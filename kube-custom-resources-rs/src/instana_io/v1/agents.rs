// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/instana/instana-agent-operator/instana.io/v1/agents.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// InstanaAgentSpec defines the desired state of the Instana Agent
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "instana.io", version = "v1", kind = "InstanaAgent", plural = "agents")]
#[kube(namespaced)]
#[kube(status = "InstanaAgentStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct InstanaAgentSpec {
    /// Agent deployment specific fields.
    pub agent: InstanaAgentAgent,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.clusterRoleBindingName")]
    pub agent_cluster_role_binding_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.clusterRoleName")]
    pub agent_cluster_role_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.configMapName")]
    pub agent_config_map_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.cpuLimit")]
    pub agent_cpu_limit: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.cpuReq")]
    pub agent_cpu_req: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.daemonSetName")]
    pub agent_daemon_set_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.downloadKey")]
    pub agent_download_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.endpoint.host")]
    pub agent_endpoint_host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.endpoint.port")]
    pub agent_endpoint_port: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.env")]
    pub agent_env: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.host.repository")]
    pub agent_host_repository: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.image")]
    pub agent_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.imagePullPolicy")]
    pub agent_image_pull_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.key")]
    pub agent_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.memLimit")]
    pub agent_mem_limit: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.memReq")]
    pub agent_mem_req: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.rbac.create")]
    pub agent_rbac_create: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.secretName")]
    pub agent_secret_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.serviceAccountName")]
    pub agent_service_account_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.tls.certificate")]
    pub agent_tls_certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.tls.key")]
    pub agent_tls_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.tls.secretName")]
    pub agent_tls_secret_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agent.zone.name")]
    pub agent_zone_name: Option<String>,
    /// Name of the cluster, that will be assigned to this cluster in Instana. Either specifying the 'cluster.name' or 'zone.name'
    /// is mandatory.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<InstanaAgentCluster>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cluster.name")]
    pub cluster_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "config.files")]
    pub config_files: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub k8s_sensor: Option<InstanaAgentK8sSensor>,
    /// Allows for installment of the Kubernetes Sensor as separate pod. Which allows for better tailored resource settings
    /// (mainly memory) both for the Agent pods and the Kubernetes Sensor pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kubernetes: Option<InstanaAgentKubernetes>,
    /// Set to `True` to indicate the Operator is being deployed in a OpenShift cluster. Provides a hint so that RBAC etc is
    /// configured correctly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub openshift: Option<bool>,
    /// Enables the OpenTelemetry gRPC endpoint on the Agent. If true, it will also apply `service.create: true`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opentelemetry: Option<InstanaAgentOpentelemetry>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "opentelemetry.enabled")]
    pub opentelemetry_enabled: Option<bool>,
    /// Specifying the PinnedChartVersion allows for 'pinning' the Helm Chart used by the Operator for installing the Agent
    /// DaemonSet. Normally the Operator will always install and update to the latest Helm Chart version.
    /// The Operator will check and make sure no 'unsupported' Chart versions can be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pinnedChartVersion")]
    pub pinned_chart_version: Option<String>,
    /// Specify a PodSecurityPolicy for the Instana Agent Pods. If enabled requires `rbac.create: true`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podSecurityPolicy")]
    pub pod_security_policy: Option<InstanaAgentPodSecurityPolicy>,
    /// Enables the Prometheus endpoint on the Agent. If true, it will also apply `service.create: true`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prometheus: Option<InstanaAgentPrometheus>,
    /// Specifies whether RBAC resources should be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbac: Option<InstanaAgentRbac>,
    /// Specifies whether to create the instana-agent `Service` to expose within the cluster. The Service can then be used e.g.
    /// for the Prometheus remote-write, OpenTelemetry GRCP endpoint and other APIs.
    /// Note: Requires Kubernetes 1.17+, as it uses topologyKeys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<InstanaAgentService>,
    /// Specifies whether a ServiceAccount should be created (default `true`), and possibly the name to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<InstanaAgentServiceAccount>,
    /// Name of the zone in which the host(s) will be displayed on the map. Optional, but then 'cluster.name' must be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<InstanaAgentZone>,
}

/// Agent deployment specific fields.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgent {
    /// These are additional backends the Instana agent will report to besides
    /// the one configured via the `agent.endpointHost`, `agent.endpointPort` and `agent.key` setting.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalBackends")]
    pub additional_backends: Option<Vec<InstanaAgentAgentAdditionalBackends>>,
    /// Custom agent charts url.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub charts_url: Option<String>,
    /// Mount in a ConfigMap with Agent configuration. Alternative to the `configuration_yaml` field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<InstanaAgentAgentConfiguration>,
    /// Supply Agent configuration e.g. for configuring certain Sensors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration_yaml: Option<String>,
    /// The DownloadKey, sometimes known as "sales key", that allows you to download software from Instana. It might be needed to
    /// specify this in addition to the Key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downloadKey")]
    pub download_key: Option<String>,
    /// EndpointHost is the hostname of the Instana server your agents will connect to.
    #[serde(rename = "endpointHost")]
    pub endpoint_host: String,
    /// EndpointPort is the port number (as a String) of the Instana server your agents will connect to.
    #[serde(rename = "endpointPort")]
    pub endpoint_port: String,
    /// Use the `env` field to set additional environment variables for the Instana Agent, for example:
    /// env:
    ///   INSTANA_AGENT_TAGS: dev
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<BTreeMap<String, String>>,
    /// Host sets a host path to be mounted as the Agent Maven repository (mainly for debugging or development purposes)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<InstanaAgentAgentHost>,
    /// Override the container image used for the Instana Agent pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<InstanaAgentAgentImage>,
    /// Override for the Maven repository URL when the Agent needs to connect to a locally provided Maven repository 'proxy'
    /// Alternative to `Host` for referencing a different Maven repo.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanaMvnRepoUrl")]
    pub instana_mvn_repo_url: Option<String>,
    /// Key is the secret token which your agent uses to authenticate to Instana's servers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Rather than specifying the Key and optionally the DownloadKey, you can "bring your
    /// own secret" creating it in the namespace in which you install the `instana-agent` and
    /// specify its name in the `KeysSecret` field. The secret you create must contain a field called `key` and optionally one
    /// called `downloadKey`, which contain, respectively, the values you'd otherwise set in `.agent.key` and `agent.downloadKey`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keysSecret")]
    pub keys_secret: Option<String>,
    /// ListenAddress is the IP addresses the Agent HTTP server will listen on. Normally this will just be localhost (`127.0.0.1`),
    /// the pod public IP and any container runtime bridge interfaces. Set `listenAddress: *` for making the Agent listen on all
    /// network interfaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "listenAddress")]
    pub listen_address: Option<String>,
    /// The minimum number of seconds for which a newly created Pod should be ready without any of its containers crashing, for it to be considered available
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i64>,
    /// Set agent mode, possible options are APM, INFRASTRUCTURE or AWS. KUBERNETES should not be used but instead enabled via
    /// `kubernetes.deployment.enabled: true`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// Override Agent Pod specific settings such as annotations, labels and resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pod: Option<InstanaAgentAgentPod>,
    /// proxyHost sets the INSTANA_AGENT_PROXY_HOST environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyHost")]
    pub proxy_host: Option<String>,
    /// proxyPassword sets the INSTANA_AGENT_PROXY_PASSWORD environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyPassword")]
    pub proxy_password: Option<String>,
    /// proxyPort sets the INSTANA_AGENT_PROXY_PORT environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyPort")]
    pub proxy_port: Option<String>,
    /// proxyProtocol sets the INSTANA_AGENT_PROXY_PROTOCOL environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyProtocol")]
    pub proxy_protocol: Option<String>,
    /// proxyUseDNS sets the INSTANA_AGENT_PROXY_USE_DNS environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUseDNS")]
    pub proxy_use_dns: Option<bool>,
    /// proxyUser sets the INSTANA_AGENT_PROXY_USER environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUser")]
    pub proxy_user: Option<String>,
    /// RedactKubernetesSecrets sets the INSTANA_KUBERNETES_REDACT_SECRETS environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redactKubernetesSecrets")]
    pub redact_kubernetes_secrets: Option<String>,
    /// TLS for end-to-end encryption between the Instana Agent and clients accessing the Agent.
    /// The Instana Agent does not yet allow enforcing TLS encryption, enabling makes it possible for clients to 'opt-in'.
    /// So TLS is only enabled on a connection when requested by the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<InstanaAgentAgentTls>,
    /// Control how to update the Agent DaemonSet
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<InstanaAgentAgentUpdateStrategy>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentAdditionalBackends {
    #[serde(rename = "endpointHost")]
    pub endpoint_host: String,
    #[serde(rename = "endpointPort")]
    pub endpoint_port: String,
    pub key: String,
}

/// Mount in a ConfigMap with Agent configuration. Alternative to the `configuration_yaml` field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentConfiguration {
    /// When setting this to true, the Helm chart will automatically look up the entries
    /// of the default instana-agent ConfigMap, and mount as agent configuration files
    /// under /opt/instana/agent/etc/instana all entries with keys that match the
    /// 'configuration-*.yaml' scheme
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoMountConfigEntries")]
    pub auto_mount_config_entries: Option<bool>,
}

/// Host sets a host path to be mounted as the Agent Maven repository (mainly for debugging or development purposes)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentHost {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
}

/// Override the container image used for the Instana Agent pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentImage {
    /// Digest (a.k.a. Image ID) of the agent container image. If specified, it has priority over `agent.image.tag`,
    /// which will then be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub digest: Option<String>,
    /// Name is the name of the container image of the Instana agent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// PullPolicy specifies when to pull the image container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// PullSecrets allows you to override the default pull secret that is created when `agent.image.name` starts with
    /// "containers.instana.io". Setting `agent.image.pullSecrets` prevents the creation of the default "containers-instana-io" secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullSecrets")]
    pub pull_secrets: Option<Vec<InstanaAgentAgentImagePullSecrets>>,
    /// Tag is the name of the agent container image; if `agent.image.digest` is specified, this property is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentImagePullSecrets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Override Agent Pod specific settings such as annotations, labels and resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPod {
    /// agent.pod.affinity are affinities to influence agent pod assignment.
    /// https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<InstanaAgentAgentPodAffinity>,
    /// agent.pod.annotations are additional annotations to be added to the agent pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// agent.pod.labels are additional labels to be added to the agent pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// agent.pod.priorityClassName is the name of an existing PriorityClass that should be set on the agent pods
    /// https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
    /// agent.pod.tolerations are tolerations to influence agent pod assignment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<InstanaAgentAgentPodTolerations>>,
}

/// agent.pod.affinity are affinities to influence agent pod assignment.
/// https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinity {
    /// Describes node affinity scheduling rules for the pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<InstanaAgentAgentPodAffinityNodeAffinity>,
    /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<InstanaAgentAgentPodAffinityPodAffinity>,
    /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<InstanaAgentAgentPodAffinityPodAntiAffinity>,
}

/// Describes node affinity scheduling rules for the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityNodeAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node matches the corresponding matchExpressions; the
    /// node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<InstanaAgentAgentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to an update), the system
    /// may or may not try to eventually evict the pod from its node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<InstanaAgentAgentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

/// An empty preferred scheduling term matches all objects with implicit weight 0
/// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// A node selector term, associated with the corresponding weight.
    pub preference: InstanaAgentAgentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    pub weight: i32,
}

/// A node selector term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /// A list of node selector requirements by node's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    /// A list of node selector requirements by node's fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<InstanaAgentAgentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// If the affinity requirements specified by this field are not met at
/// scheduling time, the pod will not be scheduled onto the node.
/// If the affinity requirements specified by this field cease to be met
/// at some point during pod execution (e.g. due to an update), the system
/// may or may not try to eventually evict the pod from its node.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// Required. A list of node selector terms. The terms are ORed.
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<InstanaAgentAgentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

/// A null or empty node selector term matches no objects. The requirements of
/// them are ANDed.
/// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /// A list of node selector requirements by node's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    /// A list of node selector requirements by node's fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<InstanaAgentAgentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    /// node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to a pod label update), the
    /// system may or may not try to eventually evict the pod from its node.
    /// When there are multiple elements, the lists of nodes corresponding to each
    /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// Required. A pod affinity term, associated with the corresponding weight.
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    /// weight associated with matching the corresponding podAffinityTerm,
    /// in the range 1-100.
    pub weight: i32,
}

/// Required. A pod affinity term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /// A label query over a set of resources, in this case pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    /// This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
/// This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Defines a set of pods (namely those matching the labelSelector
/// relative to the given namespace(s)) that this pod should be
/// co-located (affinity) or not co-located (anti-affinity) with,
/// where co-located is defined as running on a node whose value of
/// the label with key <topologyKey> matches that of any node on which
/// a pod of the set of pods is running
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// A label query over a set of resources, in this case pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    /// This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
/// This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the anti-affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling anti-affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    /// node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the anti-affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the anti-affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to a pod label update), the
    /// system may or may not try to eventually evict the pod from its node.
    /// When there are multiple elements, the lists of nodes corresponding to each
    /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// Required. A pod affinity term, associated with the corresponding weight.
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    /// weight associated with matching the corresponding podAffinityTerm,
    /// in the range 1-100.
    pub weight: i32,
}

/// Required. A pod affinity term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /// A label query over a set of resources, in this case pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    /// This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
/// This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Defines a set of pods (namely those matching the labelSelector
/// relative to the given namespace(s)) that this pod should be
/// co-located (affinity) or not co-located (anti-affinity) with,
/// where co-located is defined as running on a node whose value of
/// the label with key <topologyKey> matches that of any node on which
/// a pod of the set of pods is running
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// A label query over a set of resources, in this case pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    /// This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
/// This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentPodTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// TLS for end-to-end encryption between the Instana Agent and clients accessing the Agent.
/// The Instana Agent does not yet allow enforcing TLS encryption, enabling makes it possible for clients to 'opt-in'.
/// So TLS is only enabled on a connection when requested by the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentTls {
    /// certificate (together with key) is the alternative to an existing Secret. Must be base64 encoded.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// key (together with certificate) is the alternative to an existing Secret. Must be base64 encoded.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// secretName is the name of the secret that has the relevant files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Control how to update the Agent DaemonSet
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentUpdateStrategy {
    /// Rolling update config params. Present only if type = "RollingUpdate".
    /// ---
    /// TODO: Update this to follow our convention for oneOf, whatever we decide it
    /// to be. Same as Deployment `strategy.rollingUpdate`.
    /// See https://github.com/kubernetes/kubernetes/issues/35345
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<InstanaAgentAgentUpdateStrategyRollingUpdate>,
    /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Rolling update config params. Present only if type = "RollingUpdate".
/// ---
/// TODO: Update this to follow our convention for oneOf, whatever we decide it
/// to be. Same as Deployment `strategy.rollingUpdate`.
/// See https://github.com/kubernetes/kubernetes/issues/35345
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentAgentUpdateStrategyRollingUpdate {
    /// The maximum number of nodes with an existing available DaemonSet pod that
    /// can have an updated DaemonSet pod during during an update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up to a minimum of 1.
    /// Default value is 0.
    /// Example: when this is set to 30%, at most 30% of the total number of nodes
    /// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
    /// can have their a new pod created before the old pod is marked as deleted.
    /// The update starts by launching new pods on 30% of nodes. Once an updated
    /// pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
    /// on that node is marked deleted. If the old pod becomes unavailable for any
    /// reason (Ready transitions to false, is evicted, or is drained) an updated
    /// pod is immediatedly created on that node without considering surge limits.
    /// Allowing surge implies the possibility that the resources consumed by the
    /// daemonset on any given node can double if the readiness check fails, and
    /// so resource intensive daemonsets should take into account that they may
    /// cause evictions during disruption.
    /// This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// The maximum number of DaemonSet pods that can be unavailable during the
    /// update. Value can be an absolute number (ex: 5) or a percentage of total
    /// number of DaemonSet pods at the start of the update (ex: 10%). Absolute
    /// number is calculated from percentage by rounding up.
    /// This cannot be 0 if MaxSurge is 0
    /// Default value is 1.
    /// Example: when this is set to 30%, at most 30% of the total number of nodes
    /// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
    /// can have their pods stopped for an update at any given time. The update
    /// starts by stopping at most 30% of those DaemonSet pods and then brings
    /// up new DaemonSet pods in their place. Once the new pods are available,
    /// it then proceeds onto other DaemonSet pods, thus ensuring that at least
    /// 70% of original number of DaemonSet pods are available at all times during
    /// the update.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// Name of the cluster, that will be assigned to this cluster in Instana. Either specifying the 'cluster.name' or 'zone.name'
/// is mandatory.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentCluster {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentK8sSensor {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<InstanaAgentK8sSensorDeployment>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<InstanaAgentK8sSensorImage>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentK8sSensorDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The minimum number of seconds for which a newly created Pod should be ready without any of its containers crashing, for it to be considered available
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i64>,
    /// Override pod resource requirements for the Kubernetes Sensor pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pod: Option<InstanaAgentK8sSensorDeploymentPod>,
    /// Specify the number of replicas for the Kubernetes Sensor.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i64>,
}

/// Override pod resource requirements for the Kubernetes Sensor pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentK8sSensorDeploymentPod {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentK8sSensorImage {
    /// Digest (a.k.a. Image ID) of the agent container image. If specified, it has priority over `agent.image.tag`,
    /// which will then be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub digest: Option<String>,
    /// Name is the name of the container image of the Instana agent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// PullPolicy specifies when to pull the image container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// PullSecrets allows you to override the default pull secret that is created when `agent.image.name` starts with
    /// "containers.instana.io". Setting `agent.image.pullSecrets` prevents the creation of the default "containers-instana-io" secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullSecrets")]
    pub pull_secrets: Option<Vec<InstanaAgentK8sSensorImagePullSecrets>>,
    /// Tag is the name of the agent container image; if `agent.image.digest` is specified, this property is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentK8sSensorImagePullSecrets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Allows for installment of the Kubernetes Sensor as separate pod. Which allows for better tailored resource settings
/// (mainly memory) both for the Agent pods and the Kubernetes Sensor pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentKubernetes {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<InstanaAgentKubernetesDeployment>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentKubernetesDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The minimum number of seconds for which a newly created Pod should be ready without any of its containers crashing, for it to be considered available
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i64>,
    /// Override pod resource requirements for the Kubernetes Sensor pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pod: Option<InstanaAgentKubernetesDeploymentPod>,
    /// Specify the number of replicas for the Kubernetes Sensor.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i64>,
}

/// Override pod resource requirements for the Kubernetes Sensor pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentKubernetesDeploymentPod {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// Enables the OpenTelemetry gRPC endpoint on the Agent. If true, it will also apply `service.create: true`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentOpentelemetry {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<InstanaAgentOpentelemetryGrpc>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<InstanaAgentOpentelemetryHttp>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentOpentelemetryGrpc {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentOpentelemetryHttp {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Specify a PodSecurityPolicy for the Instana Agent Pods. If enabled requires `rbac.create: true`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentPodSecurityPolicy {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Enables the Prometheus endpoint on the Agent. If true, it will also apply `service.create: true`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentPrometheus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteWrite")]
    pub remote_write: Option<InstanaAgentPrometheusRemoteWrite>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentPrometheusRemoteWrite {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Specifies whether RBAC resources should be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentRbac {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create: Option<bool>,
}

/// Specifies whether to create the instana-agent `Service` to expose within the cluster. The Service can then be used e.g.
/// for the Prometheus remote-write, OpenTelemetry GRCP endpoint and other APIs.
/// Note: Requires Kubernetes 1.17+, as it uses topologyKeys.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create: Option<bool>,
}

/// Specifies whether a ServiceAccount should be created (default `true`), and possibly the name to use.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentServiceAccount {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Name of the zone in which the host(s) will be displayed on the map. Optional, but then 'cluster.name' must be specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentZone {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// InstanaAgentStatus defines the observed state of InstanaAgent
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentStatus {
    /// ResourceInfo holds Name and UID to given object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configmap: Option<InstanaAgentStatusConfigmap>,
    /// ResourceInfo holds Name and UID to given object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub daemonset: Option<InstanaAgentStatusDaemonset>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastUpdate")]
    pub last_update: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "leadingAgentPod")]
    pub leading_agent_pod: Option<BTreeMap<String, InstanaAgentStatusLeadingAgentPod>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oldVersionsUpdated")]
    pub old_versions_updated: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// AgentOperatorState type representing the running state of the Agent Operator itself.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// ResourceInfo holds Name and UID to given object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentStatusConfigmap {
    pub name: String,
    pub uid: String,
}

/// ResourceInfo holds Name and UID to given object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentStatusDaemonset {
    pub name: String,
    pub uid: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct InstanaAgentStatusLeadingAgentPod {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

