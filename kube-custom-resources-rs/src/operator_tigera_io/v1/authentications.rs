// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/tigera/operator/operator.tigera.io/v1/authentications.yaml --derive=PartialEq
// kopium version: 0.17.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;

/// AuthenticationSpec defines the desired state of Authentication
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "operator.tigera.io", version = "v1", kind = "Authentication", plural = "authentications")]
#[kube(status = "AuthenticationStatus")]
#[kube(schema = "disabled")]
pub struct AuthenticationSpec {
    /// If specified, GroupsPrefix is prepended to each group obtained from the identity provider. Note that Kibana does not support a groups prefix, so this prefix is removed from Kubernetes Groups when translating log access ClusterRoleBindings into Elastic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupsPrefix")]
    pub groups_prefix: Option<String>,
    /// LDAP contains the configuration needed to setup LDAP authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap: Option<AuthenticationLdap>,
    /// ManagerDomain is the domain name of the Manager
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managerDomain")]
    pub manager_domain: Option<String>,
    /// OIDC contains the configuration needed to setup OIDC authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oidc: Option<AuthenticationOidc>,
    /// Openshift contains the configuration needed to setup Openshift OAuth authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub openshift: Option<AuthenticationOpenshift>,
    /// If specified, UsernamePrefix is prepended to each user obtained from the identity provider. Note that Kibana does not support a user prefix, so this prefix is removed from Kubernetes User when translating log access ClusterRoleBindings into Elastic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernamePrefix")]
    pub username_prefix: Option<String>,
}

/// LDAP contains the configuration needed to setup LDAP authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthenticationLdap {
    /// Group search configuration to find the groups that a user is in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupSearch")]
    pub group_search: Option<AuthenticationLdapGroupSearch>,
    /// The host and port of the LDAP server. Example: ad.example.com:636
    pub host: String,
    /// StartTLS whether to enable the startTLS feature for establishing TLS on an existing LDAP session. If true, the ldap:// protocol is used and then issues a StartTLS command, otherwise, connections will use the ldaps:// protocol.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTLS")]
    pub start_tls: Option<bool>,
    /// User entry search configuration to match the credentials with a user.
    #[serde(rename = "userSearch")]
    pub user_search: AuthenticationLdapUserSearch,
}

/// Group search configuration to find the groups that a user is in.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthenticationLdapGroupSearch {
    /// BaseDN to start the search from. For example "cn=groups,dc=example,dc=com"
    #[serde(rename = "baseDN")]
    pub base_dn: String,
    /// Optional filter to apply when searching the directory. For example "(objectClass=posixGroup)"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// The attribute of the group that represents its name. This attribute can be used to apply RBAC to a user group.
    #[serde(rename = "nameAttribute")]
    pub name_attribute: String,
    /// Following list contains field pairs that are used to match a user to a group. It adds an additional requirement to the filter that an attribute in the group must match the user's attribute value.
    #[serde(rename = "userMatchers")]
    pub user_matchers: Vec<AuthenticationLdapGroupSearchUserMatchers>,
}

/// UserMatch when the value of a UserAttribute and a GroupAttribute match, a user belongs to the group.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthenticationLdapGroupSearchUserMatchers {
    /// The attribute of a group that links it to a user.
    #[serde(rename = "groupAttribute")]
    pub group_attribute: String,
    /// The attribute of a user that links it to a group.
    #[serde(rename = "userAttribute")]
    pub user_attribute: String,
}

/// User entry search configuration to match the credentials with a user.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthenticationLdapUserSearch {
    /// BaseDN to start the search from. For example "cn=users,dc=example,dc=com"
    #[serde(rename = "baseDN")]
    pub base_dn: String,
    /// Optional filter to apply when searching the directory. For example "(objectClass=person)"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// A mapping of the attribute that is used as the username. This attribute can be used to apply RBAC to a user. Default: uid
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameAttribute")]
    pub name_attribute: Option<String>,
}

/// OIDC contains the configuration needed to setup OIDC authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthenticationOidc {
    /// Some providers do not include the claim "email_verified" when there is no verification in the user enrollment process or if they are acting as a proxy for another identity provider. By default those tokens are deemed invalid. To skip this check, set the value to "InsecureSkip". Default: Verify
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailVerification")]
    pub email_verification: Option<AuthenticationOidcEmailVerification>,
    /// GroupsClaim specifies which claim to use from the OIDC provider as the group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupsClaim")]
    pub groups_claim: Option<String>,
    /// Deprecated. Please use Authentication.Spec.GroupsPrefix instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupsPrefix")]
    pub groups_prefix: Option<String>,
    /// IssuerURL is the URL to the OIDC provider.
    #[serde(rename = "issuerURL")]
    pub issuer_url: String,
    /// PromptTypes is an optional list of string values that specifies whether the identity provider prompts the end user for re-authentication and consent. See the RFC for more information on prompt types: https://openid.net/specs/openid-connect-core-1_0.html. Default: "Consent"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "promptTypes")]
    pub prompt_types: Option<Vec<String>>,
    /// RequestedScopes is a list of scopes to request from the OIDC provider. If not provided, the following scopes are requested: ["openid", "email", "profile", "groups", "offline_access"].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestedScopes")]
    pub requested_scopes: Option<Vec<String>>,
    /// Default: "Dex"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthenticationOidcType>,
    /// UsernameClaim specifies which claim to use from the OIDC provider as the username.
    #[serde(rename = "usernameClaim")]
    pub username_claim: String,
    /// Deprecated. Please use Authentication.Spec.UsernamePrefix instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernamePrefix")]
    pub username_prefix: Option<String>,
}

/// OIDC contains the configuration needed to setup OIDC authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthenticationOidcEmailVerification {
    Verify,
    InsecureSkip,
}

/// OIDC contains the configuration needed to setup OIDC authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthenticationOidcType {
    Dex,
    Tigera,
}

/// Openshift contains the configuration needed to setup Openshift OAuth authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthenticationOpenshift {
    /// IssuerURL is the URL to the Openshift OAuth provider. Ex.: https://api.my-ocp-domain.com:6443
    #[serde(rename = "issuerURL")]
    pub issuer_url: String,
}

/// AuthenticationStatus defines the observed state of Authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthenticationStatus {
    /// Conditions represents the latest observed set of conditions for the component. A component may be one or more of Ready, Progressing, Degraded or other customer types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// State provides user-readable status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

