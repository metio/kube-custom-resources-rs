// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename ./crd-catalog/fluxcd/flagger/flagger.app/v1beta1/canaries.yaml
// kopium version: 0.16.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// CanarySpec defines the desired state of a Canary.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(group = "flagger.app", version = "v1beta1", kind = "Canary", plural = "canaries")]
#[kube(namespaced)]
#[kube(status = "CanaryStatus")]
#[kube(schema = "disabled")]
pub struct CanarySpec {
    /// Canary analysis for this canary
    pub analysis: CanaryAnalysis,
    /// Scaler selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoscalerRef")]
    pub autoscaler_ref: Option<CanaryAutoscalerRef>,
    /// Ingress selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressRef")]
    pub ingress_ref: Option<CanaryIngressRef>,
    /// Prometheus URL
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsServer")]
    pub metrics_server: Option<String>,
    /// Deployment progress deadline
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "progressDeadlineSeconds")]
    pub progress_deadline_seconds: Option<f64>,
    /// Traffic managent provider
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    /// Revert mutated resources to original spec on deletion
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "revertOnDeletion")]
    pub revert_on_deletion: Option<bool>,
    /// APISIX route selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRef")]
    pub route_ref: Option<CanaryRouteRef>,
    /// Kubernetes Service spec
    pub service: CanaryService,
    /// Skip analysis and promote canary
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipAnalysis")]
    pub skip_analysis: Option<bool>,
    /// Suspend Canary disabling/pausing all canary runs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suspend: Option<bool>,
    /// Target selector
    #[serde(rename = "targetRef")]
    pub target_ref: CanaryTargetRef,
    /// Gloo Upstream selector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upstreamRef")]
    pub upstream_ref: Option<CanaryUpstreamRef>,
}

/// Canary analysis for this canary
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysis {
    /// Alert list for this canary analysis
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alerts: Option<Vec<CanaryAnalysisAlerts>>,
    /// Percentage of pods that need to be available to consider canary as ready
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canaryReadyThreshold")]
    pub canary_ready_threshold: Option<f64>,
    /// Schedule interval for this canary
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Number of checks to run for A/B Testing and Blue/Green
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iterations: Option<f64>,
    /// A/B testing match conditions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<Vec<CanaryAnalysisMatch>>,
    /// Max traffic weight routed to canary
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWeight")]
    pub max_weight: Option<f64>,
    /// Metric check list for this canary
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<Vec<CanaryAnalysisMetrics>>,
    /// Mirror traffic to canary
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<bool>,
    /// Weight of traffic to be mirrored
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mirrorWeight")]
    pub mirror_weight: Option<f64>,
    /// Percentage of pods that need to be available to consider primary as ready
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryReadyThreshold")]
    pub primary_ready_threshold: Option<f64>,
    /// SessionAffinity represents the session affinity settings for a canary run.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionAffinity")]
    pub session_affinity: Option<CanaryAnalysisSessionAffinity>,
    /// Incremental traffic step weight for the analysis phase
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepWeight")]
    pub step_weight: Option<f64>,
    /// Incremental traffic step weight for the promotion phase
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepWeightPromotion")]
    pub step_weight_promotion: Option<f64>,
    /// Incremental traffic step weights for the analysis phase
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepWeights")]
    pub step_weights: Option<Vec<f64>>,
    /// Max number of failed checks before rollback
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub threshold: Option<f64>,
    /// Webhook list for this canary
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webhooks: Option<Vec<CanaryAnalysisWebhooks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisAlerts {
    /// Name of the this alert
    pub name: String,
    /// Alert provider reference
    #[serde(rename = "providerRef")]
    pub provider_ref: CanaryAnalysisAlertsProviderRef,
    /// Severity level can be info, warn, error (default info)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<CanaryAnalysisAlertsSeverity>,
}

/// Alert provider reference
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisAlertsProviderRef {
    /// Name of the alert provider
    pub name: String,
    /// Namespace of the alert provider
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryAnalysisAlertsSeverity {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "warn")]
    Warn,
    #[serde(rename = "error")]
    Error,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisMatch {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, CanaryAnalysisMatchHeaders>>,
    /// Query parameters for matching.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<BTreeMap<String, CanaryAnalysisMatchQueryParams>>,
    /// Applicable only when the 'mesh' gateway is included in the service.gateways list
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisMatchHeaders {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suffix: Option<String>,
}

/// Query parameters for matching.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisMatchQueryParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisMetrics {
    /// Interval of the query
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Name of the metric
    pub name: String,
    /// Prometheus query
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query: Option<String>,
    /// Metric template reference
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateRef")]
    pub template_ref: Option<CanaryAnalysisMetricsTemplateRef>,
    /// Additional variables to be used in the metrics query (key-value pairs)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateVariables")]
    pub template_variables: Option<BTreeMap<String, String>>,
    /// Max value accepted for this metric
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub threshold: Option<f64>,
    /// Range accepted for this metric
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "thresholdRange")]
    pub threshold_range: Option<CanaryAnalysisMetricsThresholdRange>,
}

/// Metric template reference
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisMetricsTemplateRef {
    /// Name of this metric template
    pub name: String,
    /// Namespace of this metric template
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Range accepted for this metric
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisMetricsThresholdRange {
    /// Max value accepted for this metric
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max: Option<f64>,
    /// Min value accepted for this metric
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub min: Option<f64>,
}

/// SessionAffinity represents the session affinity settings for a canary run.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisSessionAffinity {
    /// CookieName is the key that will be used for the session affinity cookie.
    #[serde(rename = "cookieName")]
    pub cookie_name: String,
    /// MaxAge indicates the number of seconds until the session affinity cookie will expire.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    pub max_age: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAnalysisWebhooks {
    /// Metadata (key-value pairs) for this webhook
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, String>>,
    /// Mute all alerts for the webhook
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "muteAlert")]
    pub mute_alert: Option<bool>,
    /// Name of the webhook
    pub name: String,
    /// Request timeout for this webhook
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
    /// Type of the webhook pre, post or during rollout
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<CanaryAnalysisWebhooksType>,
    /// URL address of this webhook
    pub url: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryAnalysisWebhooksType {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "confirm-rollout")]
    ConfirmRollout,
    #[serde(rename = "pre-rollout")]
    PreRollout,
    #[serde(rename = "rollout")]
    Rollout,
    #[serde(rename = "confirm-promotion")]
    ConfirmPromotion,
    #[serde(rename = "post-rollout")]
    PostRollout,
    #[serde(rename = "event")]
    Event,
    #[serde(rename = "rollback")]
    Rollback,
    #[serde(rename = "confirm-traffic-increase")]
    ConfirmTrafficIncrease,
}

/// Scaler selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAutoscalerRef {
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    pub kind: CanaryAutoscalerRefKind,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryScalerQueries")]
    pub primary_scaler_queries: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryScalerReplicas")]
    pub primary_scaler_replicas: Option<CanaryAutoscalerRefPrimaryScalerReplicas>,
}

/// Scaler selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryAutoscalerRefKind {
    HorizontalPodAutoscaler,
    ScaledObject,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryAutoscalerRefPrimaryScalerReplicas {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxReplicas")]
    pub max_replicas: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReplicas")]
    pub min_replicas: Option<f64>,
}

/// Ingress selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryIngressRef {
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    pub kind: CanaryIngressRefKind,
    pub name: String,
}

/// Ingress selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryIngressRefKind {
    Ingress,
}

/// APISIX route selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryRouteRef {
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    pub kind: CanaryRouteRefKind,
    pub name: String,
}

/// APISIX route selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryRouteRefKind {
    ApisixRoute,
}

/// Kubernetes Service spec
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryService {
    /// Metadata to add to the apex service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub apex: Option<CanaryServiceApex>,
    /// Application protocol of the port
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appProtocol")]
    pub app_protocol: Option<String>,
    /// AppMesh backend array
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backends: Option<Vec<String>>,
    /// Metadata to add to the canary service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub canary: Option<CanaryServiceCanary>,
    /// Istio Cross-Origin Resource Sharing policy (CORS)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    pub cors_policy: Option<CanaryServiceCorsPolicy>,
    /// enable behaving as a delegate VirtualService
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delegation: Option<bool>,
    /// The list of parent Gateways for a HTTPRoute
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayRefs")]
    pub gateway_refs: Option<Vec<CanaryServiceGatewayRefs>>,
    /// The list of Istio gateway for this virtual service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateways: Option<Vec<String>>,
    /// Headers operations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<CanaryServiceHeaders>,
    /// The list of host names for this service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    /// URI match conditions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<Vec<CanaryServiceMatch>>,
    /// AppMesh mesh name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "meshName")]
    pub mesh_name: Option<String>,
    /// Mirror defines a schema for a filter that mirrors requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<Vec<CanaryServiceMirror>>,
    /// Kubernetes service name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Container port number
    pub port: f64,
    /// Enable port dicovery
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portDiscovery")]
    pub port_discovery: Option<bool>,
    /// Container port name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portName")]
    pub port_name: Option<String>,
    /// Metadata to add to the primary service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub primary: Option<CanaryServicePrimary>,
    /// Retry policy for HTTP requests
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retries: Option<CanaryServiceRetries>,
    /// Rewrite HTTP URIs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rewrite: Option<CanaryServiceRewrite>,
    /// Container target port name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPort")]
    pub target_port: Option<IntOrString>,
    /// HTTP or gRPC request timeout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
    /// Istio traffic policy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trafficPolicy")]
    pub traffic_policy: Option<CanaryServiceTrafficPolicy>,
}

/// Metadata to add to the apex service
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceApex {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Metadata to add to the canary service
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceCanary {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Istio Cross-Origin Resource Sharing policy (CORS)
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceCorsPolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    pub allow_credentials: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    pub allow_headers: Option<Vec<String>>,
    /// List of HTTP methods allowed to access the resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    pub allow_methods: Option<Vec<String>>,
    /// The list of origins that are allowed to perform CORS requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigin")]
    pub allow_origin: Option<Vec<String>>,
    /// String patterns that match allowed origins
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    pub allow_origins: Option<Vec<CanaryServiceCorsPolicyAllowOrigins>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    pub expose_headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    pub max_age: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceCorsPolicyAllowOrigins {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceGatewayRefs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sectionName")]
    pub section_name: Option<String>,
}

/// Headers operations
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceHeaders {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<CanaryServiceHeadersRequest>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<CanaryServiceHeadersResponse>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceHeadersRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceHeadersResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMatch {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authority: Option<CanaryServiceMatchAuthority>,
    /// Names of gateways where the rule should be applied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateways: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, CanaryServiceMatchHeaders>>,
    /// Flag to specify whether the URI matching should be case-insensitive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreUriCase")]
    pub ignore_uri_case: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<CanaryServiceMatchMethod>,
    /// The name assigned to a match.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specifies the ports on the host that is being addressed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// Query parameters for matching.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<BTreeMap<String, CanaryServiceMatchQueryParams>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<CanaryServiceMatchScheme>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<BTreeMap<String, String>>,
    /// Source namespace constraining the applicability of a rule to workloads in that namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceNamespace")]
    pub source_namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<CanaryServiceMatchUri>,
    /// withoutHeader has the same syntax with the header, but has opposite meaning.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withoutHeaders")]
    pub without_headers: Option<BTreeMap<String, CanaryServiceMatchWithoutHeaders>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMatchAuthority {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMatchHeaders {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMatchMethod {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

/// Query parameters for matching.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMatchQueryParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMatchScheme {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMatchUri {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

/// withoutHeader has the same syntax with the header, but has opposite meaning.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMatchWithoutHeaders {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMirror {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendRef")]
    pub backend_ref: Option<CanaryServiceMirrorBackendRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceMirrorBackendRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

/// Metadata to add to the primary service
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServicePrimary {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Retry policy for HTTP requests
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceRetries {
    /// Number of retries for a given request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attempts: Option<i32>,
    /// Timeout per retry attempt for a given request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    pub per_try_timeout: Option<String>,
    /// Specifies the conditions under which retry takes place
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryOn")]
    pub retry_on: Option<String>,
}

/// Rewrite HTTP URIs
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceRewrite {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authority: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

/// Istio traffic policy
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPool")]
    pub connection_pool: Option<CanaryServiceTrafficPolicyConnectionPool>,
    /// Settings controlling the load balancer algorithms.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<CanaryServiceTrafficPolicyLoadBalancer>,
    /// Settings controlling eviction of unhealthy hosts from the load balancing pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<CanaryServiceTrafficPolicyOutlierDetection>,
    /// Istio TLS related settings for connections to the upstream service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<CanaryServiceTrafficPolicyTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyConnectionPool {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<CanaryServiceTrafficPolicyConnectionPoolHttp>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyConnectionPoolHttp {
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "h2UpgradePolicy")]
    pub h2_upgrade_policy: Option<CanaryServiceTrafficPolicyConnectionPoolHttpH2UpgradePolicy>,
    /// Maximum number of pending HTTP requests to a destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http1MaxPendingRequests")]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of requests to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http2MaxRequests")]
    pub http2_max_requests: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// Maximum number of requests per connection to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryServiceTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consistentHash")]
    pub consistent_hash: Option<CanaryServiceTrafficPolicyLoadBalancerConsistentHash>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localityLbSetting")]
    pub locality_lb_setting: Option<CanaryServiceTrafficPolicyLoadBalancerLocalityLbSetting>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<CanaryServiceTrafficPolicyLoadBalancerSimple>,
    /// Represents the warmup duration of Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "warmupDurationSecs")]
    pub warmup_duration_secs: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyLoadBalancerConsistentHash {
    /// Hash based on HTTP cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpCookie")]
    pub http_cookie: Option<CanaryServiceTrafficPolicyLoadBalancerConsistentHashHttpCookie>,
    /// Hash based on a specific HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaderName")]
    pub http_header_name: Option<String>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpQueryParameterName")]
    pub http_query_parameter_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
    /// Hash based on the source IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSourceIp")]
    pub use_source_ip: Option<bool>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyLoadBalancerConsistentHashHttpCookie {
    /// Name of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyLoadBalancerLocalityLbSetting {
    /// Optional: only one of distribute or failover can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<CanaryServiceTrafficPolicyLoadBalancerLocalityLbSettingDistribute>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Optional: only failover or distribute can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<CanaryServiceTrafficPolicyLoadBalancerLocalityLbSettingFailover>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyLoadBalancerLocalityLbSettingFailover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryServiceTrafficPolicyLoadBalancerSimple {
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
    #[serde(rename = "LEAST_REQUEST")]
    LeastRequest,
}

/// Settings controlling eviction of unhealthy hosts from the load balancing pool.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyOutlierDetection {
    /// Minimum ejection duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutive5xxErrors")]
    pub consecutive5xx_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveErrors")]
    pub consecutive_errors: Option<i32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveGatewayErrors")]
    pub consecutive_gateway_errors: Option<i32>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthPercent")]
    pub min_health_percent: Option<i32>,
}

/// Istio TLS related settings for connections to the upstream service
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryServiceTrafficPolicyTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificates")]
    pub ca_certificates: Option<String>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<CanaryServiceTrafficPolicyTlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<String>>,
}

/// Istio TLS related settings for connections to the upstream service
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryServiceTrafficPolicyTlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

/// Target selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryTargetRef {
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    pub kind: CanaryTargetRefKind,
    pub name: String,
}

/// Target selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryTargetRefKind {
    DaemonSet,
    Deployment,
    Service,
}

/// Gloo Upstream selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryUpstreamRef {
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    pub kind: CanaryUpstreamRefKind,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Gloo Upstream selector
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryUpstreamRefKind {
    Upstream,
}

/// CanaryStatus defines the observed state of a canary.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryStatus {
    /// Traffic weight routed to canary
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canaryWeight")]
    pub canary_weight: Option<f64>,
    /// Status conditions of this canary
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<CanaryStatusConditions>>,
    /// Failed check count of the current canary analysis
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failedChecks")]
    pub failed_checks: Option<f64>,
    /// Iteration count of the current canary analysis
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iterations: Option<f64>,
    /// LastAppliedSpec of this canary
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedSpec")]
    pub last_applied_spec: Option<String>,
    /// LastPromotedSpec of this canary
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastPromotedSpec")]
    pub last_promoted_spec: Option<String>,
    /// LastTransitionTime of this canary
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    /// Analysis phase of this canary
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<CanaryStatusPhase>,
    /// Session affinity cookie of the previous canary run
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "previousSessionAffinityCookie")]
    pub previous_session_affinity_cookie: Option<String>,
    /// Session affinity cookie of the current canary run
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionAffinityCookie")]
    pub session_affinity_cookie: Option<String>,
    /// TrackedConfig of this canary
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trackedConfigs")]
    pub tracked_configs: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanaryStatusConditions {
    /// LastTransitionTime of this condition
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    /// LastUpdateTime of this condition
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastUpdateTime")]
    pub last_update_time: Option<String>,
    /// Message associated with this condition
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Reason for the current status of this condition
    pub reason: String,
    /// Status of this condition
    pub status: String,
    /// Type of this condition
    #[serde(rename = "type")]
    pub r#type: String,
}

/// CanaryStatus defines the observed state of a canary.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CanaryStatusPhase {
    #[serde(rename = "")]
    KopiumEmpty,
    Initializing,
    Initialized,
    Waiting,
    Progressing,
    WaitingPromotion,
    Promoting,
    Finalising,
    Succeeded,
    Failed,
    Terminating,
    Terminated,
}

