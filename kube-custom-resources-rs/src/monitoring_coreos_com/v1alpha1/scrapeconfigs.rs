// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/prometheus-operator/prometheus-operator/monitoring.coreos.com/v1alpha1/scrapeconfigs.fixed --derive=PartialEq
// kopium version: 0.16.5

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// ScrapeConfigSpec is a specification of the desired configuration for a scrape configuration.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "monitoring.coreos.com", version = "v1alpha1", kind = "ScrapeConfig", plural = "scrapeconfigs")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
pub struct ScrapeConfigSpec {
    /// Authorization header to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigAuthorization>,
    /// AzureSDConfigs defines a list of Azure service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureSDConfigs")]
    pub azure_sd_configs: Option<Vec<ScrapeConfigAzureSdConfigs>>,
    /// BasicAuth information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigBasicAuth>,
    /// ConsulSDConfigs defines a list of Consul service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consulSDConfigs")]
    pub consul_sd_configs: Option<Vec<ScrapeConfigConsulSdConfigs>>,
    /// DigitalOceanSDConfigs defines a list of DigitalOcean service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "digitalOceanSDConfigs")]
    pub digital_ocean_sd_configs: Option<Vec<ScrapeConfigDigitalOceanSdConfigs>>,
    /// DNSSDConfigs defines a list of DNS service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsSDConfigs")]
    pub dns_sd_configs: Option<Vec<ScrapeConfigDnsSdConfigs>>,
    /// EC2SDConfigs defines a list of EC2 service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ec2SDConfigs")]
    pub ec2_sd_configs: Option<Vec<ScrapeConfigEc2SdConfigs>>,
    /// When false, Prometheus will request uncompressed response from the scraped target. 
    ///  It requires Prometheus >= v2.49.0. 
    ///  If unset, Prometheus uses true by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCompression")]
    pub enable_compression: Option<bool>,
    /// FileSDConfigs defines a list of file service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSDConfigs")]
    pub file_sd_configs: Option<Vec<ScrapeConfigFileSdConfigs>>,
    /// GCESDConfigs defines a list of GCE service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gceSDConfigs")]
    pub gce_sd_configs: Option<Vec<ScrapeConfigGceSdConfigs>>,
    /// HonorLabels chooses the metric's labels on collisions with target labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorLabels")]
    pub honor_labels: Option<bool>,
    /// HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorTimestamps")]
    pub honor_timestamps: Option<bool>,
    /// HTTPSDConfigs defines a list of HTTP service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSDConfigs")]
    pub http_sd_configs: Option<Vec<ScrapeConfigHttpSdConfigs>>,
    /// Per-scrape limit on the number of targets dropped by relabeling that will be kept in memory. 0 means no limit. 
    ///  It requires Prometheus >= v2.47.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepDroppedTargets")]
    pub keep_dropped_targets: Option<i64>,
    /// KubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSDConfigs")]
    pub kubernetes_sd_configs: Option<Vec<ScrapeConfigKubernetesSdConfigs>>,
    /// Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelLimit")]
    pub label_limit: Option<i64>,
    /// Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelNameLengthLimit")]
    pub label_name_length_limit: Option<i64>,
    /// Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelValueLengthLimit")]
    pub label_value_length_limit: Option<i64>,
    /// MetricRelabelConfigs to apply to samples before ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelings")]
    pub metric_relabelings: Option<Vec<ScrapeConfigMetricRelabelings>>,
    /// MetricsPath HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g. /metrics).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsPath")]
    pub metrics_path: Option<String>,
    /// `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// OpenStackSDConfigs defines a list of OpenStack service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openstackSDConfigs")]
    pub openstack_sd_configs: Option<Vec<ScrapeConfigOpenstackSdConfigs>>,
    /// Optional HTTP URL parameters
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, String>>,
    /// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, ScrapeConfigProxyConnectHeader>>,
    /// Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). If unset, Prometheus uses its default value. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// `proxyURL` defines the HTTP proxy server to use. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// RelabelConfigs defines how to rewrite the target's labels before scraping. Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields. The original scrape job's name is available via the `__tmp_prometheus_job_name` label. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relabelings: Option<Vec<ScrapeConfigRelabelings>>,
    /// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// Configures the protocol scheme used for requests. If empty, Prometheus uses HTTP by default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ScrapeConfigScheme>,
    /// The scrape class to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeClass")]
    pub scrape_class: Option<String>,
    /// ScrapeInterval is the interval between consecutive scrapes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeInterval")]
    pub scrape_interval: Option<String>,
    /// The protocols to negotiate during a scrape. It tells clients the protocols supported by Prometheus in order of preference (from most to least preferred). 
    ///  If unset, Prometheus uses its default value. 
    ///  It requires Prometheus >= v2.49.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeProtocols")]
    pub scrape_protocols: Option<Vec<String>>,
    /// ScrapeTimeout is the number of seconds to wait until a scrape request times out.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// StaticConfigs defines a list of static targets with a common label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticConfigs")]
    pub static_configs: Option<Vec<ScrapeConfigStaticConfigs>>,
    /// TargetLimit defines a limit on the number of scraped targets that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLimit")]
    pub target_limit: Option<i64>,
    /// TLS configuration to use on every scrape request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigTlsConfig>,
    /// TrackTimestampsStaleness whether Prometheus tracks staleness of the metrics that have an explicit timestamp present in scraped data. Has no effect if `honorTimestamps` is false. It requires Prometheus >= v2.48.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trackTimestampsStaleness")]
    pub track_timestamps_staleness: Option<bool>,
}

/// Authorization header to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive. 
    ///  "Basic" is not a supported value. 
    ///  Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// AzureSDConfig allow retrieving scrape targets from Azure VMs. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#azure_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigAzureSdConfigs {
    /// # The authentication method, either OAuth or ManagedIdentity. See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authenticationMethod")]
    pub authentication_method: Option<ScrapeConfigAzureSdConfigsAuthenticationMethod>,
    /// Optional client ID. Only required with the OAuth authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    /// Optional client secret. Only required with the OAuth authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientSecret")]
    pub client_secret: Option<ScrapeConfigAzureSdConfigsClientSecret>,
    /// The Azure environment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environment: Option<String>,
    /// The port to scrape metrics from. If using the public IP address, this must instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// Optional resource group name. Limits discovery to this resource group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceGroup")]
    pub resource_group: Option<String>,
    /// The subscription ID. Always required.
    #[serde(rename = "subscriptionID")]
    pub subscription_id: String,
    /// Optional tenant ID. Only required with the OAuth authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantID")]
    pub tenant_id: Option<String>,
}

/// AzureSDConfig allow retrieving scrape targets from Azure VMs. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#azure_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigAzureSdConfigsAuthenticationMethod {
    OAuth,
    ManagedIdentity,
}

/// Optional client secret. Only required with the OAuth authentication method.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigBasicAuth {
    /// `password` specifies a key of a Secret containing the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigBasicAuthPassword>,
    /// `username` specifies a key of a Secret containing the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigBasicAuthUsername>,
}

/// `password` specifies a key of a Secret containing the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `username` specifies a key of a Secret containing the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConsulSDConfig defines a Consul service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigs {
    /// Allow stale Consul results (see https://www.consul.io/api/features/consistency.html). Will reduce load on Consul. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStale")]
    pub allow_stale: Option<bool>,
    /// Authorization header configuration to authenticate against the Consul Server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigConsulSdConfigsAuthorization>,
    /// BasicAuth information to authenticate against the Consul Server. More info: https://prometheus.io/docs/operating/configuration/#endpoints
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigConsulSdConfigsBasicAuth>,
    /// Consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datacenter: Option<String>,
    /// Whether to enable HTTP2. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// Configure whether HTTP requests follow HTTP 3xx redirects. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// Namespaces are only supported in Consul Enterprise.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// Node metadata key/value pairs to filter nodes for a given service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeMeta")]
    pub node_meta: Option<BTreeMap<String, String>>,
    /// Optional OAuth 2.0 configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigConsulSdConfigsOauth2>,
    /// Admin Partitions are only supported in Consul Enterprise.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, ScrapeConfigConsulSdConfigsProxyConnectHeader>>,
    /// Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). If unset, Prometheus uses its default value. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// `proxyURL` defines the HTTP proxy server to use. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// The time after which the provided names are refreshed. On large setup it might be a good idea to increase this value because the catalog will change all the time. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// HTTP Scheme default "http"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ScrapeConfigConsulSdConfigsScheme>,
    /// A valid string consisting of a hostname or IP followed by an optional port number.
    pub server: String,
    /// A list of services for which targets are retrieved. If omitted, all services are scraped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<String>>,
    /// The string by which Consul tags are joined into the tag label. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSeparator")]
    pub tag_separator: Option<String>,
    /// An optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// TLS Config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigConsulSdConfigsTlsConfig>,
    /// Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenRef")]
    pub token_ref: Option<ScrapeConfigConsulSdConfigsTokenRef>,
}

/// Authorization header configuration to authenticate against the Consul Server.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigConsulSdConfigsAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive. 
    ///  "Basic" is not a supported value. 
    ///  Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to authenticate against the Consul Server. More info: https://prometheus.io/docs/operating/configuration/#endpoints
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsBasicAuth {
    /// `password` specifies a key of a Secret containing the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigConsulSdConfigsBasicAuthPassword>,
    /// `username` specifies a key of a Secret containing the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigConsulSdConfigsBasicAuthUsername>,
}

/// `password` specifies a key of a Secret containing the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `username` specifies a key of a Secret containing the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional OAuth 2.0 configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2 {
    /// `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigConsulSdConfigsOauth2ClientId,
    /// `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigConsulSdConfigsOauth2ClientSecret,
    /// `endpointParams` configures the HTTP parameters to append to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// `scopes` defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// `tokenURL` configures the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
///  It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConsulSDConfig defines a Consul service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigConsulSdConfigsScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// TLS Config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigConsulSdConfigsTlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigConsulSdConfigsTlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigConsulSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTokenRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// DigitalOceanSDConfig allow retrieving scrape targets from DigitalOcean's Droplets API. This service discovery uses the public IPv4 address by default, by that can be changed with relabeling See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#digitalocean_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigs {
    /// Authorization header configuration to authenticate against the DigitalOcean API. Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigDigitalOceanSdConfigsAuthorization>,
    /// Whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// Configure whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// Optional OAuth 2.0 configuration. Cannot be set at the same time as `authorization`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigDigitalOceanSdConfigsOauth2>,
    /// The port to scrape metrics from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, ScrapeConfigDigitalOceanSdConfigsProxyConnectHeader>>,
    /// Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). If unset, Prometheus uses its default value. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// `proxyURL` defines the HTTP proxy server to use. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// Refresh interval to re-read the instance list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// TLS configuration applying to the target HTTP endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfig>,
}

/// Authorization header configuration to authenticate against the DigitalOcean API. Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigDigitalOceanSdConfigsAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive. 
    ///  "Basic" is not a supported value. 
    ///  Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional OAuth 2.0 configuration. Cannot be set at the same time as `authorization`.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2 {
    /// `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigDigitalOceanSdConfigsOauth2ClientId,
    /// `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigDigitalOceanSdConfigsOauth2ClientSecret,
    /// `endpointParams` configures the HTTP parameters to append to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// `scopes` defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// `tokenURL` configures the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDigitalOceanSdConfigsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDigitalOceanSdConfigsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
///  It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from /etc/resolv.conf. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDnsSdConfigs {
    /// A list of DNS domain names to be queried.
    pub names: Vec<String>,
    /// The port number used if the query type is not SRV Ignored for SRV records
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// RefreshInterval configures the time after which the provided names are refreshed. If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// The type of DNS query to perform. One of SRV, A, AAAA, MX or NS. If not set, Prometheus uses its default value. 
    ///  When set to NS, It requires Prometheus >= 2.49.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ScrapeConfigDnsSdConfigsType>,
}

/// DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from /etc/resolv.conf. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDnsSdConfigsType {
    #[serde(rename = "SRV")]
    Srv,
    A,
    #[serde(rename = "AAAA")]
    Aaaa,
    #[serde(rename = "MX")]
    Mx,
    #[serde(rename = "NS")]
    Ns,
}

/// EC2SDConfig allow retrieving scrape targets from AWS EC2 instances. The private IP address is used by default, but may be changed to the public IP address with relabeling. The IAM credentials used must have the ec2:DescribeInstances permission to discover scrape targets See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ec2_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigEc2SdConfigs {
    /// AccessKey is the AWS API key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessKey")]
    pub access_key: Option<ScrapeConfigEc2SdConfigsAccessKey>,
    /// Filters can be used optionally to filter the instance list by other criteria. Available filter criteria can be found here: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html Filter API documentation: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filters: Option<Vec<ScrapeConfigEc2SdConfigsFilters>>,
    /// The port to scrape metrics from. If using the public IP address, this must instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// The AWS region
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// AWS Role ARN, an alternative to using AWS API keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleARN")]
    pub role_arn: Option<String>,
    /// SecretKey is the AWS API secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKey")]
    pub secret_key: Option<ScrapeConfigEc2SdConfigsSecretKey>,
}

/// AccessKey is the AWS API key.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsAccessKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EC2Filter is the configuration for filtering EC2 instances.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsFilters {
    pub name: String,
    pub values: Vec<String>,
}

/// SecretKey is the AWS API secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsSecretKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// FileSDConfig defines a Prometheus file service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigFileSdConfigs {
    /// List of files to be used for file discovery. Recommendation: use absolute paths. While relative paths work, the prometheus-operator project makes no guarantees about the working directory where the configuration file is stored. Files must be mounted using Prometheus.ConfigMaps or Prometheus.Secrets.
    pub files: Vec<String>,
    /// RefreshInterval configures the refresh interval at which Prometheus will reload the content of the files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
}

/// GCESDConfig configures scrape targets from GCP GCE instances. The private IP address is used by default, but may be changed to the public IP address with relabeling. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#gce_sd_config 
///  The GCE service discovery will load the Google Cloud credentials from the file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable. See https://cloud.google.com/kubernetes-engine/docs/tutorials/authenticating-to-cloud-platform 
///  A pre-requisite for using GCESDConfig is that a Secret containing valid Google Cloud credentials is mounted into the Prometheus or PrometheusAgent pod via the `.spec.secrets` field and that the GOOGLE_APPLICATION_CREDENTIALS environment variable is set to /etc/prometheus/secrets/<secret-name>/<credentials-filename.json>.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigGceSdConfigs {
    /// Filter can be used optionally to filter the instance list by other criteria Syntax of this filter is described in the filter query parameter section: https://cloud.google.com/compute/docs/reference/latest/instances/list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// The port to scrape metrics from. If using the public IP address, this must instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// The Google Cloud Project ID
    pub project: String,
    /// RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// The tag separator is used to separate the tags on concatenation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSeparator")]
    pub tag_separator: Option<String>,
    /// The zone of the scrape targets. If you need multiple zones use multiple GCESDConfigs.
    pub zone: String,
}

/// HTTPSDConfig defines a prometheus HTTP service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#http_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigs {
    /// Authorization header configuration to authenticate against the target HTTP endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigHttpSdConfigsAuthorization>,
    /// BasicAuth information to authenticate against the target HTTP endpoint. More info: https://prometheus.io/docs/operating/configuration/#endpoints
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigHttpSdConfigsBasicAuth>,
    /// `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, ScrapeConfigHttpSdConfigsProxyConnectHeader>>,
    /// Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). If unset, Prometheus uses its default value. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// `proxyURL` defines the HTTP proxy server to use. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// RefreshInterval configures the refresh interval at which Prometheus will re-query the endpoint to update the target list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// TLS configuration applying to the target HTTP endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigHttpSdConfigsTlsConfig>,
    /// URL from which the targets are fetched.
    pub url: String,
}

/// Authorization header configuration to authenticate against the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigHttpSdConfigsAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive. 
    ///  "Basic" is not a supported value. 
    ///  Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to authenticate against the target HTTP endpoint. More info: https://prometheus.io/docs/operating/configuration/#endpoints
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsBasicAuth {
    /// `password` specifies a key of a Secret containing the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigHttpSdConfigsBasicAuthPassword>,
    /// `username` specifies a key of a Secret containing the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigHttpSdConfigsBasicAuthUsername>,
}

/// `password` specifies a key of a Secret containing the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `username` specifies a key of a Secret containing the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
///  It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigHttpSdConfigsTlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigHttpSdConfigsTlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigHttpSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHttpSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHttpSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHttpSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHttpSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigs {
    /// The API server address consisting of a hostname or IP address followed by an optional port number. If left empty, Prometheus is assumed to run inside of the cluster. It will discover API servers automatically and use the pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServer")]
    pub api_server: Option<String>,
    /// Optional metadata to attach to discovered targets. It requires Prometheus >= v2.35.0 for `pod` role and Prometheus >= v2.37.0 for `endpoints` and `endpointslice` roles.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachMetadata")]
    pub attach_metadata: Option<ScrapeConfigKubernetesSdConfigsAttachMetadata>,
    /// Authorization header to use on every scrape request. Cannot be set at the same time as `basicAuth`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigKubernetesSdConfigsAuthorization>,
    /// BasicAuth information to use on every scrape request. Cannot be set at the same time as `authorization`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigKubernetesSdConfigsBasicAuth>,
    /// Whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// Configure whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// Optional namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<ScrapeConfigKubernetesSdConfigsNamespaces>,
    /// `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// Optional OAuth 2.0 configuration. Cannot be set at the same time as `authorization`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigKubernetesSdConfigsOauth2>,
    /// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, ScrapeConfigKubernetesSdConfigsProxyConnectHeader>>,
    /// Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). If unset, Prometheus uses its default value. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// `proxyURL` defines the HTTP proxy server to use. 
    ///  It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// Role of the Kubernetes entities that should be discovered.
    pub role: ScrapeConfigKubernetesSdConfigsRole,
    /// Selector to select objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selectors: Option<Vec<ScrapeConfigKubernetesSdConfigsSelectors>>,
    /// TLS configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigKubernetesSdConfigsTlsConfig>,
}

/// Optional metadata to attach to discovered targets. It requires Prometheus >= v2.35.0 for `pod` role and Prometheus >= v2.37.0 for `endpoints` and `endpointslice` roles.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsAttachMetadata {
    /// Attaches node metadata to discovered targets. When set to true, Prometheus must have the `get` permission on the `Nodes` objects. Only valid for Pod, Endpoint and Endpointslice roles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<bool>,
}

/// Authorization header to use on every scrape request. Cannot be set at the same time as `basicAuth`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigKubernetesSdConfigsAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive. 
    ///  "Basic" is not a supported value. 
    ///  Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to use on every scrape request. Cannot be set at the same time as `authorization`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsBasicAuth {
    /// `password` specifies a key of a Secret containing the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigKubernetesSdConfigsBasicAuthPassword>,
    /// `username` specifies a key of a Secret containing the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigKubernetesSdConfigsBasicAuthUsername>,
}

/// `password` specifies a key of a Secret containing the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `username` specifies a key of a Secret containing the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsNamespaces {
    /// List of namespaces where to watch for resources. If empty and `ownNamespace` isn't true, Prometheus watches for resources in all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// Includes the namespace in which the Prometheus pod exists to the list of watched namesapces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownNamespace")]
    pub own_namespace: Option<bool>,
}

/// Optional OAuth 2.0 configuration. Cannot be set at the same time as `authorization`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2 {
    /// `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigKubernetesSdConfigsOauth2ClientId,
    /// `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigKubernetesSdConfigsOauth2ClientSecret,
    /// `endpointParams` configures the HTTP parameters to append to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// `scopes` defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// `tokenURL` configures the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKubernetesSdConfigsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKubernetesSdConfigsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
///  It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsRole {
    Node,
    Service,
    Pod,
    Endpoints,
    EndpointSlice,
    Ingress,
}

/// K8SSelectorConfig is Kubernetes Selector Config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsSelectors {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// Role is role of the service in Kubernetes.
    pub role: ScrapeConfigKubernetesSdConfigsSelectorsRole,
}

/// K8SSelectorConfig is Kubernetes Selector Config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsSelectorsRole {
    Node,
    Service,
    Pod,
    Endpoints,
    EndpointSlice,
    Ingress,
}

/// TLS configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigKubernetesSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples. 
///  More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigMetricRelabelings {
    /// Action to perform based on the regex matching. 
    ///  `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0. 
    ///  Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<ScrapeConfigMetricRelabelingsAction>,
    /// Modulus to take of the hash of the source label values. 
    ///  Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a Replace action is performed if the regular expression matches. 
    ///  Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator is the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting string is written in a replacement. 
    ///  It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions. 
    ///  Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples. 
///  More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigMetricRelabelingsAction {
    Replace,
    Keep,
    Drop,
    HashMod,
    LabelMap,
    LabelDrop,
    LabelKeep,
    Lowercase,
    Uppercase,
    KeepEqual,
    DropEqual,
}

/// OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#openstack_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigs {
    /// Whether the service discovery should list all instances for all projects. It is only relevant for the 'instance' role and usually requires admin permissions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allTenants")]
    pub all_tenants: Option<bool>,
    /// ApplicationCredentialID
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationCredentialId")]
    pub application_credential_id: Option<String>,
    /// The ApplicationCredentialID or ApplicationCredentialName fields are required if using an application credential to authenticate. Some providers allow you to create an application credential to authenticate rather than a password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationCredentialName")]
    pub application_credential_name: Option<String>,
    /// The applicationCredentialSecret field is required if using an application credential to authenticate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationCredentialSecret")]
    pub application_credential_secret: Option<ScrapeConfigOpenstackSdConfigsApplicationCredentialSecret>,
    /// Availability of the endpoint to connect to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub availability: Option<ScrapeConfigOpenstackSdConfigsAvailability>,
    /// DomainID
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainID")]
    pub domain_id: Option<String>,
    /// At most one of domainId and domainName must be provided if using username with Identity V3. Otherwise, either are optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    pub domain_name: Option<String>,
    /// IdentityEndpoint specifies the HTTP endpoint that is required to work with the Identity API of the appropriate version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityEndpoint")]
    pub identity_endpoint: Option<String>,
    /// Password for the Identity V2 and V3 APIs. Consult with your provider's control panel to discover your account's preferred method of authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigOpenstackSdConfigsPassword>,
    /// The port to scrape metrics from. If using the public IP address, this must instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// ProjectID
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectID")]
    pub project_id: Option<String>,
    /// The ProjectId and ProjectName fields are optional for the Identity V2 API. Some providers allow you to specify a ProjectName instead of the ProjectId. Some require both. Your provider's authentication policies will determine how these fields influence authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectName")]
    pub project_name: Option<String>,
    /// Refresh interval to re-read the instance list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// The OpenStack Region.
    pub region: String,
    /// The OpenStack role of entities that should be discovered.
    pub role: ScrapeConfigOpenstackSdConfigsRole,
    /// TLS configuration applying to the target HTTP endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigOpenstackSdConfigsTlsConfig>,
    /// UserID
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub userid: Option<String>,
    /// Username is required if using Identity V2 API. Consult with your provider's control panel to discover your account's username. In Identity V3, either userid or a combination of username and domainId or domainName are needed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// The applicationCredentialSecret field is required if using an application credential to authenticate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsApplicationCredentialSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#openstack_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigOpenstackSdConfigsAvailability {
    Public,
    Admin,
    Internal,
}

/// Password for the Identity V2 and V3 APIs. Consult with your provider's control panel to discover your account's preferred method of authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#openstack_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigOpenstackSdConfigsRole {
    Instance,
    Hypervisor,
}

/// TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigOpenstackSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. 
///  It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples. 
///  More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigRelabelings {
    /// Action to perform based on the regex matching. 
    ///  `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0. 
    ///  Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<ScrapeConfigRelabelingsAction>,
    /// Modulus to take of the hash of the source label values. 
    ///  Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a Replace action is performed if the regular expression matches. 
    ///  Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator is the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting string is written in a replacement. 
    ///  It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions. 
    ///  Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples. 
///  More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigRelabelingsAction {
    Replace,
    Keep,
    Drop,
    HashMod,
    LabelMap,
    LabelDrop,
    LabelKeep,
    Lowercase,
    Uppercase,
    KeepEqual,
    DropEqual,
}

/// ScrapeConfigSpec is a specification of the desired configuration for a scrape configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// StaticConfig defines a Prometheus static configuration. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigStaticConfigs {
    /// Labels assigned to all metrics scraped from the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// List of targets for this static configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigTlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigTlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

