// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/istio/istio/networking.istio.io/v1/destinationrules.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "networking.istio.io", version = "v1", kind = "DestinationRule", plural = "destinationrules")]
#[kube(namespaced)]
#[kube(status = "DestinationRuleStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct DestinationRuleSpec {
    /// A list of namespaces to which this destination rule is exported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exportTo")]
    pub export_to: Option<Vec<String>>,
    /// The name of a service from the service registry.
    pub host: String,
    /// One or more named sets that represent individual versions of a service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subsets: Option<Vec<DestinationRuleSubsets>>,
    /// Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trafficPolicy")]
    pub traffic_policy: Option<DestinationRuleTrafficPolicy>,
    /// Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadSelector")]
    pub workload_selector: Option<DestinationRuleWorkloadSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsets {
    /// Labels apply a filter over the endpoints of a service in the service registry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name of the subset.
    pub name: String,
    /// Traffic policies that apply to this subset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trafficPolicy")]
    pub traffic_policy: Option<DestinationRuleSubsetsTrafficPolicy>,
}

/// Traffic policies that apply to this subset.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPool")]
    pub connection_pool: Option<DestinationRuleSubsetsTrafficPolicyConnectionPool>,
    /// Settings controlling the load balancer algorithms.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancer>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<DestinationRuleSubsetsTrafficPolicyOutlierDetection>,
    /// Traffic policies specific to individual ports.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portLevelSettings")]
    pub port_level_settings: Option<Vec<DestinationRuleSubsetsTrafficPolicyPortLevelSettings>>,
    /// The upstream PROXY protocol settings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyProtocol")]
    pub proxy_protocol: Option<DestinationRuleSubsetsTrafficPolicyProxyProtocol>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<DestinationRuleSubsetsTrafficPolicyTls>,
    /// Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tunnel: Option<DestinationRuleSubsetsTrafficPolicyTunnel>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyConnectionPool {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<DestinationRuleSubsetsTrafficPolicyConnectionPoolHttp>,
    /// Settings common to both HTTP and TCP upstream connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<DestinationRuleSubsetsTrafficPolicyConnectionPoolTcp>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyConnectionPoolHttp {
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    /// 
    /// Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "h2UpgradePolicy")]
    pub h2_upgrade_policy: Option<DestinationRuleSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy>,
    /// Maximum number of requests that will be queued while waiting for a ready connection pool connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http1MaxPendingRequests")]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of active requests to a destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http2MaxRequests")]
    pub http2_max_requests: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConcurrentStreams")]
    pub max_concurrent_streams: Option<i32>,
    /// Maximum number of requests per connection to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    /// Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// If set to true, client protocol will be preserved while initiating connection to backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useClientProtocol")]
    pub use_client_protocol: Option<bool>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings common to both HTTP and TCP upstream connections.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyConnectionPoolTcp {
    /// TCP connection timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// The idle timeout for TCP connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// The maximum duration of a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionDuration")]
    pub max_connection_duration: Option<String>,
    /// Maximum number of HTTP1 /TCP connections to a destination host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpKeepalive")]
    pub tcp_keepalive: Option<DestinationRuleSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive>,
}

/// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
    /// The time duration between keep-alive probes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Maximum number of keepalive probes to send without response before deciding the connection is dead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<i64>,
    /// The time duration a connection needs to be idle before keep-alive probes start being sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consistentHash")]
    pub consistent_hash: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHash>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localityLbSetting")]
    pub locality_lb_setting: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSetting>,
    /// 
    /// 
    /// Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerSimple>,
    /// Represents the warmup duration of Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "warmupDurationSecs")]
    pub warmup_duration_secs: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHash {
    /// Hash based on HTTP cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpCookie")]
    pub http_cookie: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie>,
    /// Hash based on a specific HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaderName")]
    pub http_header_name: Option<String>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpQueryParameterName")]
    pub http_query_parameter_name: Option<String>,
    /// The Maglev load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maglev: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev>,
    /// Deprecated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
    /// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ringHash")]
    pub ring_hash: Option<DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash>,
    /// Hash based on the source IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSourceIp")]
    pub use_source_ip: Option<bool>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie {
    /// Name of the cookie.
    pub name: String,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

/// The Maglev load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev {
    /// The table size for Maglev hashing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableSize")]
    pub table_size: Option<i64>,
}

/// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash {
    /// The minimum number of virtual nodes to use for the hash ring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSetting {
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover>>,
    /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverPriority")]
    pub failover_priority: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleSubsetsTrafficPolicyLoadBalancerSimple {
    #[serde(rename = "UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_REQUEST")]
    LeastRequest,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyOutlierDetection {
    /// Minimum ejection duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutive5xxErrors")]
    pub consecutive5xx_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveErrors")]
    pub consecutive_errors: Option<i32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveGatewayErrors")]
    pub consecutive_gateway_errors: Option<i64>,
    /// The number of consecutive locally originated failures before ejection occurs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveLocalOriginFailures")]
    pub consecutive_local_origin_failures: Option<i64>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    /// Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthPercent")]
    pub min_health_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external errors.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalLocalOriginErrors")]
    pub split_external_local_origin_errors: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettings {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPool")]
    pub connection_pool: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPool>,
    /// Settings controlling the load balancer algorithms.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancer>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsOutlierDetection>,
    /// Specifies the number of a port on the destination service on which this policy is being applied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsPort>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp>,
    /// Settings common to both HTTP and TCP upstream connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    /// 
    /// Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "h2UpgradePolicy")]
    pub h2_upgrade_policy: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy>,
    /// Maximum number of requests that will be queued while waiting for a ready connection pool connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http1MaxPendingRequests")]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of active requests to a destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http2MaxRequests")]
    pub http2_max_requests: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConcurrentStreams")]
    pub max_concurrent_streams: Option<i32>,
    /// Maximum number of requests per connection to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    /// Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// If set to true, client protocol will be preserved while initiating connection to backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useClientProtocol")]
    pub use_client_protocol: Option<bool>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings common to both HTTP and TCP upstream connections.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
    /// TCP connection timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// The idle timeout for TCP connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// The maximum duration of a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionDuration")]
    pub max_connection_duration: Option<String>,
    /// Maximum number of HTTP1 /TCP connections to a destination host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpKeepalive")]
    pub tcp_keepalive: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive>,
}

/// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
    /// The time duration between keep-alive probes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Maximum number of keepalive probes to send without response before deciding the connection is dead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<i64>,
    /// The time duration a connection needs to be idle before keep-alive probes start being sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consistentHash")]
    pub consistent_hash: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localityLbSetting")]
    pub locality_lb_setting: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting>,
    /// 
    /// 
    /// Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple>,
    /// Represents the warmup duration of Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "warmupDurationSecs")]
    pub warmup_duration_secs: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
    /// Hash based on HTTP cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpCookie")]
    pub http_cookie: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie>,
    /// Hash based on a specific HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaderName")]
    pub http_header_name: Option<String>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpQueryParameterName")]
    pub http_query_parameter_name: Option<String>,
    /// The Maglev load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maglev: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev>,
    /// Deprecated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
    /// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ringHash")]
    pub ring_hash: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash>,
    /// Hash based on the source IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSourceIp")]
    pub use_source_ip: Option<bool>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
    /// Name of the cookie.
    pub name: String,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

/// The Maglev load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
    /// The table size for Maglev hashing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableSize")]
    pub table_size: Option<i64>,
}

/// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
    /// The minimum number of virtual nodes to use for the hash ring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover>>,
    /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverPriority")]
    pub failover_priority: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple {
    #[serde(rename = "UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_REQUEST")]
    LeastRequest,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
    /// Minimum ejection duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutive5xxErrors")]
    pub consecutive5xx_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveErrors")]
    pub consecutive_errors: Option<i32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveGatewayErrors")]
    pub consecutive_gateway_errors: Option<i64>,
    /// The number of consecutive locally originated failures before ejection occurs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveLocalOriginFailures")]
    pub consecutive_local_origin_failures: Option<i64>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    /// Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthPercent")]
    pub min_health_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external errors.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalLocalOriginErrors")]
    pub split_external_local_origin_errors: Option<bool>,
}

/// Specifies the number of a port on the destination service on which this policy is being applied.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsPort {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i64>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyPortLevelSettingsTls {
    /// OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificates")]
    pub ca_certificates: Option<String>,
    /// OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCrl")]
    pub ca_crl: Option<String>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    /// The name of the secret that holds the TLS certs for the client including the CA certificates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialName")]
    pub credential_name: Option<String>,
    /// `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Indicates whether connections to this port should be secured using TLS.
    /// 
    /// Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<DestinationRuleSubsetsTrafficPolicyPortLevelSettingsTlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    /// A list of alternate names to verify the subject identity in the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<String>>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleSubsetsTrafficPolicyPortLevelSettingsTlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

/// The upstream PROXY protocol settings.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyProxyProtocol {
    /// The PROXY protocol version to use.
    /// 
    /// Valid Options: V1, V2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<DestinationRuleSubsetsTrafficPolicyProxyProtocolVersion>,
}

/// The upstream PROXY protocol settings.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleSubsetsTrafficPolicyProxyProtocolVersion {
    V1,
    V2,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyTls {
    /// OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificates")]
    pub ca_certificates: Option<String>,
    /// OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCrl")]
    pub ca_crl: Option<String>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    /// The name of the secret that holds the TLS certs for the client including the CA certificates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialName")]
    pub credential_name: Option<String>,
    /// `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Indicates whether connections to this port should be secured using TLS.
    /// 
    /// Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<DestinationRuleSubsetsTrafficPolicyTlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    /// A list of alternate names to verify the subject identity in the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<String>>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleSubsetsTrafficPolicyTlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

/// Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleSubsetsTrafficPolicyTunnel {
    /// Specifies which protocol to use for tunneling the downstream connection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    /// Specifies a host to which the downstream connection is tunneled.
    #[serde(rename = "targetHost")]
    pub target_host: String,
    /// Specifies a port to which the downstream connection is tunneled.
    #[serde(rename = "targetPort")]
    pub target_port: i64,
}

/// Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPool")]
    pub connection_pool: Option<DestinationRuleTrafficPolicyConnectionPool>,
    /// Settings controlling the load balancer algorithms.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<DestinationRuleTrafficPolicyLoadBalancer>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<DestinationRuleTrafficPolicyOutlierDetection>,
    /// Traffic policies specific to individual ports.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portLevelSettings")]
    pub port_level_settings: Option<Vec<DestinationRuleTrafficPolicyPortLevelSettings>>,
    /// The upstream PROXY protocol settings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyProtocol")]
    pub proxy_protocol: Option<DestinationRuleTrafficPolicyProxyProtocol>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<DestinationRuleTrafficPolicyTls>,
    /// Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tunnel: Option<DestinationRuleTrafficPolicyTunnel>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyConnectionPool {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<DestinationRuleTrafficPolicyConnectionPoolHttp>,
    /// Settings common to both HTTP and TCP upstream connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<DestinationRuleTrafficPolicyConnectionPoolTcp>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyConnectionPoolHttp {
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    /// 
    /// Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "h2UpgradePolicy")]
    pub h2_upgrade_policy: Option<DestinationRuleTrafficPolicyConnectionPoolHttpH2UpgradePolicy>,
    /// Maximum number of requests that will be queued while waiting for a ready connection pool connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http1MaxPendingRequests")]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of active requests to a destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http2MaxRequests")]
    pub http2_max_requests: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConcurrentStreams")]
    pub max_concurrent_streams: Option<i32>,
    /// Maximum number of requests per connection to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    /// Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// If set to true, client protocol will be preserved while initiating connection to backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useClientProtocol")]
    pub use_client_protocol: Option<bool>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings common to both HTTP and TCP upstream connections.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyConnectionPoolTcp {
    /// TCP connection timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// The idle timeout for TCP connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// The maximum duration of a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionDuration")]
    pub max_connection_duration: Option<String>,
    /// Maximum number of HTTP1 /TCP connections to a destination host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpKeepalive")]
    pub tcp_keepalive: Option<DestinationRuleTrafficPolicyConnectionPoolTcpTcpKeepalive>,
}

/// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyConnectionPoolTcpTcpKeepalive {
    /// The time duration between keep-alive probes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Maximum number of keepalive probes to send without response before deciding the connection is dead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<i64>,
    /// The time duration a connection needs to be idle before keep-alive probes start being sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consistentHash")]
    pub consistent_hash: Option<DestinationRuleTrafficPolicyLoadBalancerConsistentHash>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localityLbSetting")]
    pub locality_lb_setting: Option<DestinationRuleTrafficPolicyLoadBalancerLocalityLbSetting>,
    /// 
    /// 
    /// Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<DestinationRuleTrafficPolicyLoadBalancerSimple>,
    /// Represents the warmup duration of Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "warmupDurationSecs")]
    pub warmup_duration_secs: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyLoadBalancerConsistentHash {
    /// Hash based on HTTP cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpCookie")]
    pub http_cookie: Option<DestinationRuleTrafficPolicyLoadBalancerConsistentHashHttpCookie>,
    /// Hash based on a specific HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaderName")]
    pub http_header_name: Option<String>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpQueryParameterName")]
    pub http_query_parameter_name: Option<String>,
    /// The Maglev load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maglev: Option<DestinationRuleTrafficPolicyLoadBalancerConsistentHashMaglev>,
    /// Deprecated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
    /// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ringHash")]
    pub ring_hash: Option<DestinationRuleTrafficPolicyLoadBalancerConsistentHashRingHash>,
    /// Hash based on the source IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSourceIp")]
    pub use_source_ip: Option<bool>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyLoadBalancerConsistentHashHttpCookie {
    /// Name of the cookie.
    pub name: String,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

/// The Maglev load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyLoadBalancerConsistentHashMaglev {
    /// The table size for Maglev hashing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableSize")]
    pub table_size: Option<i64>,
}

/// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyLoadBalancerConsistentHashRingHash {
    /// The minimum number of virtual nodes to use for the hash ring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyLoadBalancerLocalityLbSetting {
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<DestinationRuleTrafficPolicyLoadBalancerLocalityLbSettingDistribute>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<DestinationRuleTrafficPolicyLoadBalancerLocalityLbSettingFailover>>,
    /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverPriority")]
    pub failover_priority: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyLoadBalancerLocalityLbSettingFailover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleTrafficPolicyLoadBalancerSimple {
    #[serde(rename = "UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_REQUEST")]
    LeastRequest,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyOutlierDetection {
    /// Minimum ejection duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutive5xxErrors")]
    pub consecutive5xx_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveErrors")]
    pub consecutive_errors: Option<i32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveGatewayErrors")]
    pub consecutive_gateway_errors: Option<i64>,
    /// The number of consecutive locally originated failures before ejection occurs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveLocalOriginFailures")]
    pub consecutive_local_origin_failures: Option<i64>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    /// Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthPercent")]
    pub min_health_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external errors.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalLocalOriginErrors")]
    pub split_external_local_origin_errors: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettings {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPool")]
    pub connection_pool: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPool>,
    /// Settings controlling the load balancer algorithms.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancer>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<DestinationRuleTrafficPolicyPortLevelSettingsOutlierDetection>,
    /// Specifies the number of a port on the destination service on which this policy is being applied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<DestinationRuleTrafficPolicyPortLevelSettingsPort>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<DestinationRuleTrafficPolicyPortLevelSettingsTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsConnectionPool {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolHttp>,
    /// Settings common to both HTTP and TCP upstream connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolTcp>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolHttp {
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    /// 
    /// Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "h2UpgradePolicy")]
    pub h2_upgrade_policy: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy>,
    /// Maximum number of requests that will be queued while waiting for a ready connection pool connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http1MaxPendingRequests")]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of active requests to a destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http2MaxRequests")]
    pub http2_max_requests: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConcurrentStreams")]
    pub max_concurrent_streams: Option<i32>,
    /// Maximum number of requests per connection to a backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    /// Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// If set to true, client protocol will be preserved while initiating connection to backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useClientProtocol")]
    pub use_client_protocol: Option<bool>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings common to both HTTP and TCP upstream connections.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolTcp {
    /// TCP connection timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// The idle timeout for TCP connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<String>,
    /// The maximum duration of a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionDuration")]
    pub max_connection_duration: Option<String>,
    /// Maximum number of HTTP1 /TCP connections to a destination host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpKeepalive")]
    pub tcp_keepalive: Option<DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive>,
}

/// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
    /// The time duration between keep-alive probes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Maximum number of keepalive probes to send without response before deciding the connection is dead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<i64>,
    /// The time duration a connection needs to be idle before keep-alive probes start being sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consistentHash")]
    pub consistent_hash: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localityLbSetting")]
    pub locality_lb_setting: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting>,
    /// 
    /// 
    /// Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerSimple>,
    /// Represents the warmup duration of Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "warmupDurationSecs")]
    pub warmup_duration_secs: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
    /// Hash based on HTTP cookie.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpCookie")]
    pub http_cookie: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie>,
    /// Hash based on a specific HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaderName")]
    pub http_header_name: Option<String>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpQueryParameterName")]
    pub http_query_parameter_name: Option<String>,
    /// The Maglev load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maglev: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev>,
    /// Deprecated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
    /// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ringHash")]
    pub ring_hash: Option<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash>,
    /// Hash based on the source IP address.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSourceIp")]
    pub use_source_ip: Option<bool>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
    /// Name of the cookie.
    pub name: String,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

/// The Maglev load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
    /// The table size for Maglev hashing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableSize")]
    pub table_size: Option<i64>,
}

/// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
    /// The minimum number of virtual nodes to use for the hash ring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumRingSize")]
    pub minimum_ring_size: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover>>,
    /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failoverPriority")]
    pub failover_priority: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleTrafficPolicyPortLevelSettingsLoadBalancerSimple {
    #[serde(rename = "UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_REQUEST")]
    LeastRequest,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsOutlierDetection {
    /// Minimum ejection duration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutive5xxErrors")]
    pub consecutive5xx_errors: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveErrors")]
    pub consecutive_errors: Option<i32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveGatewayErrors")]
    pub consecutive_gateway_errors: Option<i64>,
    /// The number of consecutive locally originated failures before ejection occurs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consecutiveLocalOriginFailures")]
    pub consecutive_local_origin_failures: Option<i64>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    /// Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthPercent")]
    pub min_health_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external errors.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalLocalOriginErrors")]
    pub split_external_local_origin_errors: Option<bool>,
}

/// Specifies the number of a port on the destination service on which this policy is being applied.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsPort {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i64>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyPortLevelSettingsTls {
    /// OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificates")]
    pub ca_certificates: Option<String>,
    /// OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCrl")]
    pub ca_crl: Option<String>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    /// The name of the secret that holds the TLS certs for the client including the CA certificates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialName")]
    pub credential_name: Option<String>,
    /// `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Indicates whether connections to this port should be secured using TLS.
    /// 
    /// Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<DestinationRuleTrafficPolicyPortLevelSettingsTlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    /// A list of alternate names to verify the subject identity in the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<String>>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleTrafficPolicyPortLevelSettingsTlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

/// The upstream PROXY protocol settings.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyProxyProtocol {
    /// The PROXY protocol version to use.
    /// 
    /// Valid Options: V1, V2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<DestinationRuleTrafficPolicyProxyProtocolVersion>,
}

/// The upstream PROXY protocol settings.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleTrafficPolicyProxyProtocolVersion {
    V1,
    V2,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyTls {
    /// OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificates")]
    pub ca_certificates: Option<String>,
    /// OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCrl")]
    pub ca_crl: Option<String>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<String>,
    /// The name of the secret that holds the TLS certs for the client including the CA certificates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialName")]
    pub credential_name: Option<String>,
    /// `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Indicates whether connections to this port should be secured using TLS.
    /// 
    /// Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<DestinationRuleTrafficPolicyTlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    /// A list of alternate names to verify the subject identity in the certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectAltNames")]
    pub subject_alt_names: Option<Vec<String>>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleTrafficPolicyTlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

/// Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleTrafficPolicyTunnel {
    /// Specifies which protocol to use for tunneling the downstream connection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    /// Specifies a host to which the downstream connection is tunneled.
    #[serde(rename = "targetHost")]
    pub target_host: String,
    /// Specifies a port to which the downstream connection is tunneled.
    #[serde(rename = "targetPort")]
    pub target_port: i64,
}

/// Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleWorkloadSelector {
    /// One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleStatus {
    /// Current service state of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// Resource Generation to which the Reconciled Condition refers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<IntOrString>,
    /// Includes any errors or warnings detected by Istio's analyzers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validationMessages")]
    pub validation_messages: Option<Vec<DestinationRuleStatusValidationMessages>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleStatusValidationMessages {
    /// A url pointing to the Istio documentation for this specific error type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "documentationUrl")]
    pub documentation_url: Option<String>,
    /// Represents how severe a message is.
    /// 
    /// Valid Options: UNKNOWN, ERROR, WARNING, INFO
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<DestinationRuleStatusValidationMessagesLevel>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<DestinationRuleStatusValidationMessagesType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DestinationRuleStatusValidationMessagesLevel {
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "ERROR")]
    Error,
    #[serde(rename = "WARNING")]
    Warning,
    #[serde(rename = "INFO")]
    Info,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DestinationRuleStatusValidationMessagesType {
    /// A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message type.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// A human-readable name for the message type.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

