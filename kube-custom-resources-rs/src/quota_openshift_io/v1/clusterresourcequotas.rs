// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/openshift/api/quota.openshift.io/v1/clusterresourcequotas.yaml --derive=Default --derive=PartialEq
// kopium version: 0.17.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// Spec defines the desired quota
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "quota.openshift.io", version = "v1", kind = "ClusterResourceQuota", plural = "clusterresourcequotas")]
#[kube(status = "ClusterResourceQuotaStatus")]
#[kube(schema = "disabled")]
pub struct ClusterResourceQuotaSpec {
    /// Quota defines the desired quota
    pub quota: ClusterResourceQuotaQuota,
    /// Selector is the selector used to match projects. It should only select active projects on the scale of dozens (though it can select many more less active projects).  These projects will contend on object creation through this resource.
    pub selector: ClusterResourceQuotaSelector,
}

/// Quota defines the desired quota
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaQuota {
    /// hard is the set of desired hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hard: Option<BTreeMap<String, IntOrString>>,
    /// scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota but expressed using ScopeSelectorOperator in combination with possible values. For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scopeSelector")]
    pub scope_selector: Option<ClusterResourceQuotaQuotaScopeSelector>,
    /// A collection of filters that must match each object tracked by a quota. If not specified, the quota matches all objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
}

/// scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota but expressed using ScopeSelectorOperator in combination with possible values. For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaQuotaScopeSelector {
    /// A list of scope selector requirements by scope of the resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterResourceQuotaQuotaScopeSelectorMatchExpressions>>,
}

/// A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator that relates the scope name and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaQuotaScopeSelectorMatchExpressions {
    /// Represents a scope's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist.
    pub operator: String,
    /// The name of the scope that the selector applies to.
    #[serde(rename = "scopeName")]
    pub scope_name: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Selector is the selector used to match projects. It should only select active projects on the scale of dozens (though it can select many more less active projects).  These projects will contend on object creation through this resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaSelector {
    /// AnnotationSelector is used to select projects by annotation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// LabelSelector is used to select projects by label.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<ClusterResourceQuotaSelectorLabels>,
}

/// LabelSelector is used to select projects by label.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaSelectorLabels {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterResourceQuotaSelectorLabelsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaSelectorLabelsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Status defines the actual enforced quota and its current usage
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaStatus {
    /// Namespaces slices the usage by project.  This division allows for quick resolution of deletion reconciliation inside of a single project without requiring a recalculation across all projects.  This can be used to pull the deltas for a given project.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<ClusterResourceQuotaStatusNamespaces>>,
    /// Total defines the actual enforced quota and its current usage across all projects
    pub total: ClusterResourceQuotaStatusTotal,
}

/// ResourceQuotaStatusByNamespace gives status for a particular project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaStatusNamespaces {
    /// Namespace the project this status applies to
    pub namespace: String,
    /// Status indicates how many resources have been consumed by this project
    pub status: ClusterResourceQuotaStatusNamespacesStatus,
}

/// Status indicates how many resources have been consumed by this project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaStatusNamespacesStatus {
    /// Hard is the set of enforced hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hard: Option<BTreeMap<String, IntOrString>>,
    /// Used is the current observed total usage of the resource in the namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub used: Option<BTreeMap<String, IntOrString>>,
}

/// Total defines the actual enforced quota and its current usage across all projects
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterResourceQuotaStatusTotal {
    /// Hard is the set of enforced hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hard: Option<BTreeMap<String, IntOrString>>,
    /// Used is the current observed total usage of the resource in the namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub used: Option<BTreeMap<String, IntOrString>>,
}

