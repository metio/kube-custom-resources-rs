// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/redhat-cop/namespace-configuration-operator/redhatcop.redhat.io/v1alpha1/userconfigs.yaml --derive=PartialEq
// kopium version: 0.16.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "redhatcop.redhat.io", version = "v1alpha1", kind = "UserConfig", plural = "userconfigs")]
#[kube(status = "UserConfigStatus")]
#[kube(schema = "disabled")]
pub struct UserConfigSpec {
    /// AnnotationSelector selects Users by annotation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "annotationSelector")]
    pub annotation_selector: Option<UserConfigAnnotationSelector>,
    /// IdentityExtraSelector allows you to specify a selector for the extra fields of the User's identities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityExtraFieldSelector")]
    pub identity_extra_field_selector: Option<UserConfigIdentityExtraFieldSelector>,
    /// LabelSelector selects Users by label.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<UserConfigLabelSelector>,
    /// ProviderName allows you to specify an identity provider. If a user logged in with that provider it is selected. This condition is in OR with IdentityExtraSelector
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerName")]
    pub provider_name: Option<String>,
    /// Templates these are the templates of the resources to be created when a selected user is created/updated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<Vec<UserConfigTemplates>>,
}

/// AnnotationSelector selects Users by annotation.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigAnnotationSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<UserConfigAnnotationSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigAnnotationSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// IdentityExtraSelector allows you to specify a selector for the extra fields of the User's identities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigIdentityExtraFieldSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<UserConfigIdentityExtraFieldSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigIdentityExtraFieldSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// LabelSelector selects Users by label.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<UserConfigLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigTemplates {
    /// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludedPaths")]
    pub excluded_paths: Option<Vec<String>>,
    /// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
    #[serde(rename = "objectTemplate")]
    pub object_template: String,
}

/// UserConfigStatus defines the observed state of UserConfig
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigStatus {
    /// ReconcileStatus this is the general status of the main reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<UserConfigStatusConditions>>,
    /// LockedResourceStatuses contains the reconcile status for each of the managed resources
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lockedPatchStatuses")]
    pub locked_patch_statuses: Option<BTreeMap<String, UserConfigStatusLockedPatchStatuses>>,
    /// LockedResourceStatuses contains the reconcile status for each of the managed resources
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lockedResourceStatuses")]
    pub locked_resource_statuses: Option<BTreeMap<String, UserConfigStatusLockedResourceStatuses>>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///      // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: UserConfigStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///      // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum UserConfigStatusConditionsStatus {
    True,
    False,
    Unknown,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///      // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigStatusLockedPatchStatuses {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: UserConfigStatusLockedPatchStatusesStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///      // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum UserConfigStatusLockedPatchStatusesStatus {
    True,
    False,
    Unknown,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///      // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct UserConfigStatusLockedResourceStatuses {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: UserConfigStatusLockedResourceStatusesStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///      // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum UserConfigStatusLockedResourceStatusesStatus {
    True,
    False,
    Unknown,
}

