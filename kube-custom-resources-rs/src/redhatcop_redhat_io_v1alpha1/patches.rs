// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename ./crd-catalog/redhat-cop/patch-operator/redhatcop.redhat.io/v1alpha1/patches.yaml
// kopium version: 0.16.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// PatchSpec defines the desired state of Patch
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(group = "redhatcop.redhat.io", version = "v1alpha1", kind = "Patch", plural = "patches")]
#[kube(namespaced)]
#[kube(status = "PatchStatus")]
#[kube(schema = "disabled")]
pub struct PatchSpec {
    /// Patches is a list of patches that should be enforced at runtime.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patches: Option<BTreeMap<String, PatchPatches>>,
    /// ServiceAccountRef is the service account to be used to run the controllers associated with this configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    pub service_account_ref: Option<PatchServiceAccountRef>,
}

/// Patches is a list of patches that should be enforced at runtime.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchPatches {
    /// PatchTemplate is a go template that will be resolved using the SourceObjectRefs as parameters. The result must be a valid patch based on the pacth type and the target object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchTemplate")]
    pub patch_template: Option<String>,
    /// PatchType is the type of patch to be applied, one of "application/json-patch+json"'"application/merge-patch+json","application/strategic-merge-patch+json","application/apply-patch+yaml" default:="application/strategic-merge-patch+json"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchType")]
    pub patch_type: Option<PatchPatchesPatchType>,
    /// SourceObjectRefs is an arrays of refereces to source objects that will be used as input for the template processing. These refernces must resolve to single instance. The resolution rule is as follows (+ present, - absent): the King and APIVersion field are mandatory -Namespace +Name: resolves to cluster-level object <Name>. If Kind is namespaced, this results in an error. -Namespace -Name: results in an error Name manespaces Namespace are evaluated as golang templates with the input of the template being the target object. When selecting multiple target, this allows for having specific source objects for each target. ResourceVersion and UID are always ignored If FieldPath is specified, the restuned object is calculated from the path, so for example if FieldPath=.spec, the only the spec portion of the object is returned. The target object is always added as element zero of the array of the SourceObjectRefs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceObjectRefs")]
    pub source_object_refs: Option<Vec<PatchPatchesSourceObjectRefs>>,
    /// TargetObjectRef is a reference to the object to which the pacth should be applied. the King and APIVersion field are mandatory the Name and Namespace field have the following meaning (+ present, - absent) -Namespace +Name: apply the patch to the cluster-level object <Name>. If Kind is namespaced, this results in an error. -Namespace -Name: if the kind is namespaced apply the patch to all of the objects in all of the namespaces. If the kind is not namespaced, apply the patch to all of the cluster level objects. The lable selector can be used to further filter the selected objects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetObjectRef")]
    pub target_object_ref: Option<PatchPatchesTargetObjectRef>,
}

/// Patches is a list of patches that should be enforced at runtime.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PatchPatchesPatchType {
    #[serde(rename = "application/json-patch+json")]
    ApplicationJsonPatchJson,
    #[serde(rename = "application/merge-patch+json")]
    ApplicationMergePatchJson,
    #[serde(rename = "application/strategic-merge-patch+json")]
    ApplicationStrategicMergePatchJson,
    #[serde(rename = "application/apply-patch+yaml")]
    ApplicationApplyPatchYaml,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchPatchesSourceObjectRefs {
    /// API version of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// TargetObjectRef is a reference to the object to which the pacth should be applied. the King and APIVersion field are mandatory the Name and Namespace field have the following meaning (+ present, - absent) -Namespace +Name: apply the patch to the cluster-level object <Name>. If Kind is namespaced, this results in an error. -Namespace -Name: if the kind is namespaced apply the patch to all of the objects in all of the namespaces. If the kind is not namespaced, apply the patch to all of the cluster level objects. The lable selector can be used to further filter the selected objects.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchPatchesTargetObjectRef {
    /// AnnotationSelector selects objects by label
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "annotationSelector")]
    pub annotation_selector: Option<PatchPatchesTargetObjectRefAnnotationSelector>,
    /// API version of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// LabelSelector selects objects by label
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PatchPatchesTargetObjectRefLabelSelector>,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// AnnotationSelector selects objects by label
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchPatchesTargetObjectRefAnnotationSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PatchPatchesTargetObjectRefAnnotationSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchPatchesTargetObjectRefAnnotationSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// LabelSelector selects objects by label
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchPatchesTargetObjectRefLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PatchPatchesTargetObjectRefLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchPatchesTargetObjectRefLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ServiceAccountRef is the service account to be used to run the controllers associated with this configuration
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchServiceAccountRef {
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// PatchStatus defines the observed state of Patch
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchStatus {
    /// ReconcileStatus this is the general status of the main reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<PatchStatusConditions>>,
    /// PatchStatuses contains the reconcile status for each of the managed patch
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchStatuses")]
    pub patch_statuses: Option<BTreeMap<String, PatchStatusPatchStatuses>>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PatchStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: PatchStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PatchStatusConditionsStatus {
    True,
    False,
    Unknown,
}

