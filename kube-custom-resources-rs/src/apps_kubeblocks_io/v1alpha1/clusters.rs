// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/apecloud/kubeblocks/apps.kubeblocks.io/v1alpha1/clusters.yaml --derive=PartialEq
// kopium version: 0.16.2

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// ClusterSpec defines the desired state of Cluster.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "apps.kubeblocks.io", version = "v1alpha1", kind = "Cluster", plural = "clusters")]
#[kube(namespaced)]
#[kube(status = "ClusterStatus")]
#[kube(schema = "disabled")]
pub struct ClusterSpec {
    /// affinity is a group of affinity scheduling rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<ClusterAffinity>,
    /// availabilityPolicy describes the availability policy, including zone, node, and none.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityPolicy")]
    pub availability_policy: Option<ClusterAvailabilityPolicy>,
    /// cluster backup configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backup: Option<ClusterBackup>,
    /// Cluster referencing ClusterDefinition name. This is an immutable attribute. If ClusterDefRef is not specified, ComponentDef must be specified for each Component in ComponentSpecs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDefinitionRef")]
    pub cluster_definition_ref: Option<String>,
    /// Cluster referencing ClusterVersion name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterVersionRef")]
    pub cluster_version_ref: Option<String>,
    /// List of componentSpecs you want to replace in ClusterDefinition and ClusterVersion. It will replace the field in ClusterDefinition's and ClusterVersion's component if type is matching.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentSpecs")]
    pub component_specs: Option<Vec<ClusterComponentSpecs>>,
    /// monitor specifies the configuration of monitor
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monitor: Option<ClusterMonitor>,
    /// network specifies the configuration of network
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<ClusterNetwork>,
    /// replicas specifies the replicas of the first componentSpec, if the replicas of the first componentSpec is specified, this value will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// resources specifies the resources of the first componentSpec, if the resources of the first componentSpec is specified, this value will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ClusterResources>,
    /// services defines the services to access a cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<ClusterServices>>,
    /// storage specifies the storage of the first componentSpec, if the storage of the first componentSpec is specified, this value will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<ClusterStorage>,
    /// tenancy describes how pods are distributed across node. SharedNode means multiple pods may share the same node. DedicatedNode means each pod runs on their own dedicated node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenancy: Option<ClusterTenancy>,
    /// Cluster termination policy. Valid values are DoNotTerminate, Halt, Delete, WipeOut. DoNotTerminate will block delete operation. Halt will delete workload resources such as statefulset, deployment workloads but keep PVCs. Delete is based on Halt and deletes PVCs. WipeOut is based on Delete and wipe out all volume snapshots and snapshot data from backup storage location.
    #[serde(rename = "terminationPolicy")]
    pub termination_policy: ClusterTerminationPolicy,
    /// tolerations are attached to tolerate any taint that matches the triple `key,value,effect` using the matching operator `operator`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<ClusterTolerations>>,
}

/// affinity is a group of affinity scheduling rules.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterAffinity {
    /// nodeLabels describes that pods must be scheduled to the nodes with the specified node labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLabels")]
    pub node_labels: Option<BTreeMap<String, String>>,
    /// podAntiAffinity describes the anti-affinity level of pods within a component. Preferred means try spread pods by `TopologyKeys`. Required means must spread pods by `TopologyKeys`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<ClusterAffinityPodAntiAffinity>,
    /// tenancy describes how pods are distributed across node. SharedNode means multiple pods may share the same node. DedicatedNode means each pod runs on their own dedicated node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenancy: Option<ClusterAffinityTenancy>,
    /// topologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. It's used as the topology domain for pod anti-affinity and pod spread constraint. Some well-known label keys, such as "kubernetes.io/hostname" and "topology.kubernetes.io/zone" are often used as TopologyKey, as well as any other custom label key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologyKeys")]
    pub topology_keys: Option<Vec<String>>,
}

/// affinity is a group of affinity scheduling rules.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterAffinityPodAntiAffinity {
    Preferred,
    Required,
}

/// affinity is a group of affinity scheduling rules.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterAffinityTenancy {
    SharedNode,
    DedicatedNode,
}

/// ClusterSpec defines the desired state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterAvailabilityPolicy {
    #[serde(rename = "zone")]
    Zone,
    #[serde(rename = "node")]
    Node,
    #[serde(rename = "none")]
    None,
}

/// cluster backup configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterBackup {
    /// the cron expression for schedule, the timezone is in UTC. see https://en.wikipedia.org/wiki/Cron.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cronExpression")]
    pub cron_expression: Option<String>,
    /// enabled defines whether to enable automated backup.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// backup method name to use, that is defined in backupPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// pitrEnabled defines whether to enable point-in-time recovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pitrEnabled")]
    pub pitr_enabled: Option<bool>,
    /// repoName is the name of the backupRepo, if not set, will use the default backupRepo.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    pub repo_name: Option<String>,
    /// retentionPeriod determines a duration up to which the backup should be kept. controller will remove all backups that are older than the RetentionPeriod. For example, RetentionPeriod of `30d` will keep only the backups of last 30 days. Sample duration format: - years: 	2y - months: 	6mo - days: 		30d - hours: 	12h - minutes: 	30m You can also combine the above durations. For example: 30d12h30m
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionPeriod")]
    pub retention_period: Option<String>,
    /// startingDeadlineMinutes defines the deadline in minutes for starting the backup job if it misses scheduled time for any reason.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startingDeadlineMinutes")]
    pub starting_deadline_minutes: Option<i64>,
}

/// ClusterComponentSpec defines the cluster component spec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecs {
    /// affinity describes affinities specified by users.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<ClusterComponentSpecsAffinity>,
    /// classDefRef references the class defined in ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classDefRef")]
    pub class_def_ref: Option<ClusterComponentSpecsClassDefRef>,
    /// componentDef references the name of the ComponentDefinition. If both componentDefRef and componentDef are provided, the componentDef will take precedence over componentDefRef.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentDef")]
    pub component_def: Option<String>,
    /// componentDefRef references componentDef defined in ClusterDefinition spec. Need to comply with IANA Service Naming rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentDefRef")]
    pub component_def_ref: Option<String>,
    /// enabledLogs indicates which log file takes effect in the database cluster. element is the log type which is defined in cluster definition logConfig.name, and will set relative variables about this log type in database kernel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enabledLogs")]
    pub enabled_logs: Option<Vec<String>>,
    /// Instances defines the list of instance to be deleted priorly If the RsmTransformPolicy is specified as ToPod,the list of instances will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<Vec<String>>,
    /// issuer defines provider context for TLS certs. required when TLS enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issuer: Option<ClusterComponentSpecsIssuer>,
    /// monitor is a switch to enable monitoring and is set as false by default. KubeBlocks provides an extension mechanism to support component level monitoring, which will scrape metrics auto or manually from servers in component and export metrics to Time Series Database.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monitor: Option<bool>,
    /// name defines cluster's component name, this name is also part of Service DNS name, so this name will comply with IANA Service Naming rule.
    pub name: String,
    /// noCreatePDB defines the PodDisruptionBudget creation behavior and is set to true if creation of PodDisruptionBudget for this component is not needed. It defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noCreatePDB")]
    pub no_create_pdb: Option<bool>,
    /// Nodes defines the list of nodes that pods can schedule If the RsmTransformPolicy is specified as ToPod,the list of nodes will be used. If the list of nodes is empty, no specific node will be assigned. However, if the list of node is filled, all pods will be evenly scheduled across the nodes in the list.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nodes: Option<Vec<String>>,
    /// Component replicas.
    pub replicas: i32,
    /// Resources requests and limits of workload.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ClusterComponentSpecsResources>,
    /// RsmTransformPolicy defines the policy generate sts using rsm. ToSts: rsm transforms to statefulSet ToPod: rsm transforms to pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rsmTransformPolicy")]
    pub rsm_transform_policy: Option<ClusterComponentSpecsRsmTransformPolicy>,
    /// serviceAccountName is the name of the ServiceAccount that running component depends on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountName")]
    pub service_account_name: Option<String>,
    /// serviceRefs define service references for the current component. Based on the referenced services, they can be categorized into two types: Service provided by external sources: These services are provided by external sources and are not managed by KubeBlocks. They can be Kubernetes-based or non-Kubernetes services. For external services, you need to provide an additional ServiceDescriptor object to establish the service binding. Service provided by other KubeBlocks clusters: These services are provided by other KubeBlocks clusters. You can bind to these services by specifying the name of the hosting cluster. Each type of service reference requires specific configurations and bindings to establish the connection and interaction with the respective services. It should be noted that the ServiceRef has cluster-level semantic consistency, meaning that within the same Cluster, service references with the same ServiceRef.Name are considered to be the same service. It is only allowed to bind to the same Cluster or ServiceDescriptor.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRefs")]
    pub service_refs: Option<Vec<ClusterComponentSpecsServiceRefs>>,
    /// Services expose endpoints that can be accessed by clients.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<ClusterComponentSpecsServices>>,
    /// switchPolicy defines the strategy for switchover and failover when workloadType is Replication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "switchPolicy")]
    pub switch_policy: Option<ClusterComponentSpecsSwitchPolicy>,
    /// Enables or disables TLS certs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<bool>,
    /// Component tolerations will override ClusterSpec.Tolerations if specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<ClusterComponentSpecsTolerations>>,
    /// updateStrategy defines the update strategy for the component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<ClusterComponentSpecsUpdateStrategy>,
    /// userResourceRefs defines the user-defined volumes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userResourceRefs")]
    pub user_resource_refs: Option<ClusterComponentSpecsUserResourceRefs>,
    /// volumeClaimTemplates information for statefulset.spec.volumeClaimTemplates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Option<Vec<ClusterComponentSpecsVolumeClaimTemplates>>,
}

/// affinity describes affinities specified by users.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsAffinity {
    /// nodeLabels describes that pods must be scheduled to the nodes with the specified node labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeLabels")]
    pub node_labels: Option<BTreeMap<String, String>>,
    /// podAntiAffinity describes the anti-affinity level of pods within a component. Preferred means try spread pods by `TopologyKeys`. Required means must spread pods by `TopologyKeys`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<ClusterComponentSpecsAffinityPodAntiAffinity>,
    /// tenancy describes how pods are distributed across node. SharedNode means multiple pods may share the same node. DedicatedNode means each pod runs on their own dedicated node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenancy: Option<ClusterComponentSpecsAffinityTenancy>,
    /// topologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. It's used as the topology domain for pod anti-affinity and pod spread constraint. Some well-known label keys, such as "kubernetes.io/hostname" and "topology.kubernetes.io/zone" are often used as TopologyKey, as well as any other custom label key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologyKeys")]
    pub topology_keys: Option<Vec<String>>,
}

/// affinity describes affinities specified by users.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterComponentSpecsAffinityPodAntiAffinity {
    Preferred,
    Required,
}

/// affinity describes affinities specified by users.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterComponentSpecsAffinityTenancy {
    SharedNode,
    DedicatedNode,
}

/// classDefRef references the class defined in ComponentClassDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsClassDefRef {
    /// Class refers to the name of the class that is defined in the ComponentClassDefinition.
    pub class: String,
    /// Name refers to the name of the ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// issuer defines provider context for TLS certs. required when TLS enabled
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsIssuer {
    /// Name of issuer. Options supported: - KubeBlocks - Certificates signed by KubeBlocks Operator. - UserProvided - User provided own CA-signed certificates.
    pub name: ClusterComponentSpecsIssuerName,
    /// secretRef. TLS certs Secret reference required when from is UserProvided
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterComponentSpecsIssuerSecretRef>,
}

/// issuer defines provider context for TLS certs. required when TLS enabled
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterComponentSpecsIssuerName {
    KubeBlocks,
    UserProvided,
}

/// secretRef. TLS certs Secret reference required when from is UserProvided
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsIssuerSecretRef {
    /// CA cert key in Secret
    pub ca: String,
    /// Cert key in Secret
    pub cert: String,
    /// Key of TLS private key in Secret
    pub key: String,
    /// Name of the Secret
    pub name: String,
}

/// Resources requests and limits of workload.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ClusterComponentSpecsResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// ClusterComponentSpec defines the cluster component spec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterComponentSpecsRsmTransformPolicy {
    ToPod,
    ToSts,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsServiceRefs {
    /// When referencing a service provided by other KubeBlocks cluster, you need to provide the name of the Cluster being referenced. By default, when other KubeBlocks Cluster are referenced, the ClusterDefinition.spec.connectionCredential secret corresponding to the referenced Cluster will be used to bind to the current component. Currently, if a KubeBlocks cluster is to be referenced, the connection credential secret should include and correspond to the following fields: endpoint, port, username, and password. Under this referencing approach, the ServiceKind and ServiceVersion of service reference declaration defined in the ClusterDefinition will not be validated. If both Cluster and ServiceDescriptor are specified, the Cluster takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<String>,
    /// name of the service reference declaration. references the serviceRefDeclaration name defined in clusterDefinition.componentDefs[*].serviceRefDeclarations[*].name
    pub name: String,
    /// namespace defines the namespace of the referenced Cluster or the namespace of the referenced ServiceDescriptor object. If not set, the referenced Cluster and ServiceDescriptor will be searched in the namespace of the current cluster by default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// serviceDescriptor defines the service descriptor of the service provided by external sources. When referencing a service provided by external sources, you need to provide the ServiceDescriptor object name to establish the service binding. And serviceDescriptor is the name of the ServiceDescriptor object, furthermore, the ServiceDescriptor.spec.serviceKind and ServiceDescriptor.spec.serviceVersion should match clusterDefinition.componentDefs[*].serviceRefDeclarations[*].serviceRefDeclarationSpecs[*].serviceKind and the regular expression defines in clusterDefinition.componentDefs[*].serviceRefDeclarations[*].serviceRefDeclarationSpecs[*].serviceVersion. If both Cluster and ServiceDescriptor are specified, the Cluster takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDescriptor")]
    pub service_descriptor: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsServices {
    /// If ServiceType is LoadBalancer, cloud provider related parameters can be put here More info: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Service name
    pub name: String,
    /// serviceType determines how the Service is exposed. Valid options are ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, they are determined by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<ClusterComponentSpecsServicesServiceType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterComponentSpecsServicesServiceType {
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    NodePort,
    LoadBalancer,
}

/// switchPolicy defines the strategy for switchover and failover when workloadType is Replication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsSwitchPolicy {
    /// clusterSwitchPolicy defines type of the switchPolicy when workloadType is Replication. MaximumAvailability: [WIP] when the primary is active, do switch if the synchronization delay = 0 in the user-defined lagProbe data delay detection logic, otherwise do not switch. The primary is down, switch immediately. It will be available in future versions. MaximumDataProtection: [WIP] when the primary is active, do switch if synchronization delay = 0 in the user-defined lagProbe data lag detection logic, otherwise do not switch. If the primary is down, if it can be judged that the primary and secondary data are consistent, then do the switch, otherwise do not switch. It will be available in future versions. Noop: KubeBlocks will not perform high-availability switching on components. Users need to implement HA by themselves or integrate open source HA solution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ClusterComponentSpecsSwitchPolicyType>,
}

/// switchPolicy defines the strategy for switchover and failover when workloadType is Replication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterComponentSpecsSwitchPolicyType {
    Noop,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// ClusterComponentSpec defines the cluster component spec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterComponentSpecsUpdateStrategy {
    Serial,
    BestEffortParallel,
    Parallel,
}

/// userResourceRefs defines the user-defined volumes.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsUserResourceRefs {
    /// configMapRefs defines the user-defined configmaps.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRefs")]
    pub config_map_refs: Option<Vec<ClusterComponentSpecsUserResourceRefsConfigMapRefs>>,
    /// secretRefs defines the user-defined secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRefs")]
    pub secret_refs: Option<Vec<ClusterComponentSpecsUserResourceRefsSecretRefs>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsUserResourceRefsConfigMapRefs {
    /// asVolumeFrom defines the list of containers where volumeMounts will be injected into.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "asVolumeFrom")]
    pub as_volume_from: Option<Vec<String>>,
    /// configMap defines the configmap volume source.
    #[serde(rename = "configMap")]
    pub config_map: ClusterComponentSpecsUserResourceRefsConfigMapRefsConfigMap,
    /// mountPath is the path at which to mount the volume.
    #[serde(rename = "mountPoint")]
    pub mount_point: String,
    /// name is the name of the referenced the Configmap/Secret object.
    pub name: String,
    /// subPath is a relative file path within the volume to mount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
}

/// configMap defines the configmap volume source.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsUserResourceRefsConfigMapRefsConfigMap {
    /// defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ClusterComponentSpecsUserResourceRefsConfigMapRefsConfigMapItems>>,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsUserResourceRefsConfigMapRefsConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsUserResourceRefsSecretRefs {
    /// asVolumeFrom defines the list of containers where volumeMounts will be injected into.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "asVolumeFrom")]
    pub as_volume_from: Option<Vec<String>>,
    /// mountPath is the path at which to mount the volume.
    #[serde(rename = "mountPoint")]
    pub mount_point: String,
    /// name is the name of the referenced the Configmap/Secret object.
    pub name: String,
    /// secret defines the secret volume source.
    pub secret: ClusterComponentSpecsUserResourceRefsSecretRefsSecret,
    /// subPath is a relative file path within the volume to mount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
}

/// secret defines the secret volume source.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsUserResourceRefsSecretRefsSecret {
    /// defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ClusterComponentSpecsUserResourceRefsSecretRefsSecretItems>>,
    /// optional field specify whether the Secret or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsUserResourceRefsSecretRefsSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsVolumeClaimTemplates {
    /// Reference `ClusterDefinition.spec.componentDefs.containers.volumeMounts.name`.
    pub name: String,
    /// spec defines the desired characteristics of a volume requested by a pod author.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ClusterComponentSpecsVolumeClaimTemplatesSpec>,
}

/// spec defines the desired characteristics of a volume requested by a pod author.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsVolumeClaimTemplatesSpec {
    /// accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ClusterComponentSpecsVolumeClaimTemplatesSpecResources>,
    /// storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
}

/// resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsVolumeClaimTemplatesSpecResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ClusterComponentSpecsVolumeClaimTemplatesSpecResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterComponentSpecsVolumeClaimTemplatesSpecResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// monitor specifies the configuration of monitor
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterMonitor {
    /// monitoringInterval specifies interval of monitoring, no monitor if set to 0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringInterval")]
    pub monitoring_interval: Option<IntOrString>,
}

/// network specifies the configuration of network
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterNetwork {
    /// hostNetworkAccessible specifies whether host network is accessible. It defaults to false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetworkAccessible")]
    pub host_network_accessible: Option<bool>,
    /// publiclyAccessible specifies whether it is publicly accessible. It defaults to false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publiclyAccessible")]
    pub publicly_accessible: Option<bool>,
}

/// resources specifies the resources of the first componentSpec, if the resources of the first componentSpec is specified, this value will be ignored.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterResources {
    /// cpu resource needed, more info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<IntOrString>,
    /// memory resource needed, more info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterServices {
    /// If ServiceType is LoadBalancer, cloud provider related parameters can be put here More info: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// ComponentSelector extends the ServiceSpec.Selector by allowing you to specify a component as selectors for the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentSelector")]
    pub component_selector: Option<String>,
    /// Name defines the name of the service. otherwise, it indicates the name of the service. Others can refer to this service by its name. (e.g., connection credential) Cannot be updated.
    pub name: String,
    /// RoleSelector extends the ServiceSpec.Selector by allowing you to specify defined role as selector for the service. if GeneratePodOrdinalService sets to true, RoleSelector will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleSelector")]
    pub role_selector: Option<String>,
    /// ServiceName defines the name of the underlying service object. If not specified, the default service name with different patterns will be used: - <CLUSTER_NAME>: for cluster-level services - <CLUSTER_NAME>-<COMPONENT_NAME>: for component-level services Only one default service name is allowed. Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
    /// Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ClusterServicesSpec>,
}

/// Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterServicesSpec {
    /// allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocateLoadBalancerNodePorts")]
    pub allocate_load_balancer_node_ports: Option<bool>,
    /// clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIP")]
    pub cluster_ip: Option<String>,
    /// ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address.  Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. 
    ///  This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIPs")]
    pub cluster_i_ps: Option<Vec<String>>,
    /// externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIPs")]
    pub external_i_ps: Option<Vec<String>>,
    /// externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalName")]
    pub external_name: Option<String>,
    /// externalTrafficPolicy describes how nodes distribute service traffic they receive on one of the Service's "externally-facing" addresses (NodePorts, ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure the service in a way that assumes that external load balancers will take care of balancing the service traffic between nodes, and so each node will deliver traffic only to the node-local endpoints of the service, without masquerading the client source IP. (Traffic mistakenly sent to a node with no endpoints will be dropped.) The default value, "Cluster", uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features). Note that traffic sent to an External IP or LoadBalancer IP from within the cluster will always get "Cluster" semantics, but clients sending to a NodePort from within the cluster may need to take traffic policy into account when picking a node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalTrafficPolicy")]
    pub external_traffic_policy: Option<String>,
    /// healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type). This field cannot be updated once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckNodePort")]
    pub health_check_node_port: Option<i32>,
    /// InternalTrafficPolicy describes how nodes distribute service traffic they receive on the ClusterIP. If set to "Local", the proxy will assume that pods only want to talk to endpoints of the service on the same node as the pod, dropping the traffic if there are no local endpoints. The default value, "Cluster", uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalTrafficPolicy")]
    pub internal_traffic_policy: Option<String>,
    /// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are "IPv4" and "IPv6".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to "headless" services. This field will be wiped when updating a Service to type ExternalName. 
    ///  This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipFamilies")]
    pub ip_families: Option<Vec<String>>,
    /// IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipFamilyPolicy")]
    pub ip_family_policy: Option<String>,
    /// loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerClass")]
    pub load_balancer_class: Option<String>,
    /// Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations. Using it is non-portable and it may not support dual-stack. Users are encouraged to use implementation-specific annotations when available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerIP")]
    pub load_balancer_ip: Option<String>,
    /// If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerSourceRanges")]
    pub load_balancer_source_ranges: Option<Vec<String>>,
    /// The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ClusterServicesSpecPorts>>,
    /// publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishNotReadyAddresses")]
    pub publish_not_ready_addresses: Option<bool>,
    /// Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionAffinity")]
    pub session_affinity: Option<String>,
    /// sessionAffinityConfig contains the configurations of session affinity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionAffinityConfig")]
    pub session_affinity_config: Option<ClusterServicesSpecSessionAffinityConfig>,
    /// type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// ServicePort contains information on service's port.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterServicesSpecPorts {
    /// The application protocol for this port. This is used as a hint for implementations to offer richer behavior for protocols that they understand. This field follows standard Kubernetes label syntax. Valid values are either: 
    ///  * Un-prefixed protocol names - reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). 
    ///  * Kubernetes-defined prefixed names: * 'kubernetes.io/h2c' - HTTP/2 over cleartext as described in https://www.rfc-editor.org/rfc/rfc7540 * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455 * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455 
    ///  * Other protocols should use implementation-defined prefixed names such as mycompany.com/my-custom-protocol.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appProtocol")]
    pub app_protocol: Option<String>,
    /// The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i32>,
    /// The port that will be exposed by this service.
    pub port: i32,
    /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    /// Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPort")]
    pub target_port: Option<IntOrString>,
}

/// sessionAffinityConfig contains the configurations of session affinity.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterServicesSpecSessionAffinityConfig {
    /// clientIP contains the configurations of Client IP based session affinity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientIP")]
    pub client_ip: Option<ClusterServicesSpecSessionAffinityConfigClientIp>,
}

/// clientIP contains the configurations of Client IP based session affinity.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterServicesSpecSessionAffinityConfigClientIp {
    /// timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// storage specifies the storage of the first componentSpec, if the storage of the first componentSpec is specified, this value will be ignored.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterStorage {
    /// storage size needed, more info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<IntOrString>,
}

/// ClusterSpec defines the desired state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterTenancy {
    SharedNode,
    DedicatedNode,
}

/// ClusterSpec defines the desired state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterTerminationPolicy {
    DoNotTerminate,
    Halt,
    Delete,
    WipeOut,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// ClusterStatus defines the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterStatus {
    /// clusterDefGeneration represents the generation number of ClusterDefinition referenced.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDefGeneration")]
    pub cluster_def_generation: Option<i64>,
    /// components record the current status information of all components of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<BTreeMap<String, ClusterStatusComponents>>,
    /// Describe current state of cluster API Resource, like warning.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<ClusterStatusConditions>>,
    /// message describes cluster details message in current phase.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// observedGeneration is the most recent generation observed for this Cluster. It corresponds to the Cluster's generation, which is updated on mutation by the API Server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// phase describes the phase of the Cluster, the detail information of the phases are as following: Creating: all components are in `Creating` phase. Running: all components are in `Running` phase, means the cluster is working well. Updating: all components are in `Creating`, `Running` or `Updating` phase, and at least one component is in `Creating` or `Updating` phase, means the cluster is doing an update. Stopping: at least one component is in `Stopping` phase, means the cluster is in a stop progress. Stopped: all components are in 'Stopped` phase, means the cluster has stopped and didn't provide any function anymore. Failed: all components are in `Failed` phase, means the cluster is unavailable. Abnormal: some components are in `Failed` or `Abnormal` phase, means the cluster in a fragile state. troubleshoot need to be done. Deleting: the cluster is being deleted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<ClusterStatusPhase>,
}

/// components record the current status information of all components of the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterStatusComponents {
    /// members' status.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "membersStatus")]
    pub members_status: Option<Vec<ClusterStatusComponentsMembersStatus>>,
    /// message records the component details message in current phase. Keys are podName or deployName or statefulSetName. The format is `ObjectKind/Name`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<BTreeMap<String, String>>,
    /// phase describes the phase of the component and the detail information of the phases are as following: Creating: `Creating` is a special `Updating` with previous phase `empty`(means "") or `Creating`. Running: component replicas > 0 and all pod specs are latest with a Running state. Updating: component replicas > 0 and has no failed pods. the component is being updated. Abnormal: component replicas > 0 but having some failed pods. the component basically works but in a fragile state. Failed: component replicas > 0 but having some failed pods. the component doesn't work anymore. Stopping: component replicas = 0 and has terminating pods. Stopped: component replicas = 0 and all pods have been deleted. Deleting: the component is being deleted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<ClusterStatusComponentsPhase>,
    /// podsReady checks if all pods of the component are ready.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podsReady")]
    pub pods_ready: Option<bool>,
    /// podsReadyTime what time point of all component pods are ready, this time is the ready time of the last component pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podsReadyTime")]
    pub pods_ready_time: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterStatusComponentsMembersStatus {
    /// PodName pod name.
    #[serde(rename = "podName")]
    pub pod_name: String,
    /// Is it required for rsm to have at least one primary pod to be ready.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readyWithoutPrimary")]
    pub ready_without_primary: Option<bool>,
    pub role: ClusterStatusComponentsMembersStatusRole,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterStatusComponentsMembersStatusRole {
    /// AccessMode, what service this member capable.
    #[serde(rename = "accessMode")]
    pub access_mode: ClusterStatusComponentsMembersStatusRoleAccessMode,
    /// CanVote, whether this member has voting rights
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "canVote")]
    pub can_vote: Option<bool>,
    /// IsLeader, whether this member is the leader
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isLeader")]
    pub is_leader: Option<bool>,
    /// Name, role name.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterStatusComponentsMembersStatusRoleAccessMode {
    None,
    Readonly,
    ReadWrite,
}

/// components record the current status information of all components of the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterStatusComponentsPhase {
    Creating,
    Running,
    Updating,
    Stopping,
    Stopped,
    Deleting,
    Failed,
    Abnormal,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: ClusterStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterStatusConditionsStatus {
    True,
    False,
    Unknown,
}

/// ClusterStatus defines the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterStatusPhase {
    Creating,
    Running,
    Updating,
    Stopping,
    Stopped,
    Deleting,
    Failed,
    Abnormal,
}

