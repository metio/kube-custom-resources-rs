// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/apecloud/kubeblocks/apps.kubeblocks.io/v1alpha1/opsrequests.yaml --derive=PartialEq
// kopium version: 0.16.2

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// OpsRequestSpec defines the desired state of OpsRequest
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "apps.kubeblocks.io", version = "v1alpha1", kind = "OpsRequest", plural = "opsrequests")]
#[kube(namespaced)]
#[kube(status = "OpsRequestStatus")]
#[kube(schema = "disabled")]
pub struct OpsRequestSpec {
    /// backupSpec defines how to backup the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupSpec")]
    pub backup_spec: Option<OpsRequestBackupSpec>,
    /// cancel defines the action to cancel the Pending/Creating/Running opsRequest, supported types: [VerticalScaling, HorizontalScaling]. once cancel is set to true, this opsRequest will be canceled and modifying this property again will not take effect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cancel: Option<bool>,
    /// clusterRef references cluster object.
    #[serde(rename = "clusterRef")]
    pub cluster_ref: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customSpec")]
    pub custom_spec: Option<OpsRequestCustomSpec>,
    /// expose defines services the component needs to expose.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expose: Option<Vec<OpsRequestExpose>>,
    /// horizontalScaling defines what component need to horizontal scale the specified replicas.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "horizontalScaling")]
    pub horizontal_scaling: Option<Vec<OpsRequestHorizontalScaling>>,
    /// reconfigure defines the variables that need to input when updating configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconfigure: Option<OpsRequestReconfigure>,
    /// reconfigure defines the variables that need to input when updating configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconfigures: Option<Vec<OpsRequestReconfigures>>,
    /// restart the specified components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restart: Option<Vec<OpsRequestRestart>>,
    /// cluster RestoreFrom backup or point in time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreFrom")]
    pub restore_from: Option<OpsRequestRestoreFrom>,
    /// restoreSpec defines how to restore the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreSpec")]
    pub restore_spec: Option<OpsRequestRestoreSpec>,
    /// scriptSpec defines the script to be executed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scriptSpec")]
    pub script_spec: Option<OpsRequestScriptSpec>,
    /// switchover the specified components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub switchover: Option<Vec<OpsRequestSwitchover>>,
    /// ttlSecondsAfterSucceed OpsRequest will be deleted after TTLSecondsAfterSucceed second when OpsRequest.status.phase is Succeed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ttlSecondsAfterSucceed")]
    pub ttl_seconds_after_succeed: Option<i32>,
    /// ttlSecondsBeforeAbort OpsRequest will wait at most TTLSecondsBeforeAbort seconds for start-conditions to be met. If not specified, the default value is 0, which means that the start-conditions must be met immediately.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ttlSecondsBeforeAbort")]
    pub ttl_seconds_before_abort: Option<i32>,
    /// type defines the operation type.
    #[serde(rename = "type")]
    pub r#type: OpsRequestType,
    /// upgrade specifies the cluster version by specifying clusterVersionRef.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub upgrade: Option<OpsRequestUpgrade>,
    /// verticalScaling defines what component need to vertical scale the specified compute resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verticalScaling")]
    pub vertical_scaling: Option<Vec<OpsRequestVerticalScaling>>,
    /// volumeExpansion defines what component and volumeClaimTemplate need to expand the specified storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeExpansion")]
    pub volume_expansion: Option<Vec<OpsRequestVolumeExpansion>>,
}

/// backupSpec defines how to backup the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestBackupSpec {
    /// Backup method name that is defined in backupPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupMethod")]
    pub backup_method: Option<String>,
    /// backupName is the name of the backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupName")]
    pub backup_name: Option<String>,
    /// Which backupPolicy is applied to perform this backup
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupPolicyName")]
    pub backup_policy_name: Option<String>,
    /// deletionPolicy determines whether the backup contents stored in backup repository should be deleted when the backup custom resource is deleted. Supported values are "Retain" and "Delete". "Retain" means that the backup content and its physical snapshot on backup repository are kept. "Delete" means that the backup content and its physical snapshot on backup repository are deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<OpsRequestBackupSpecDeletionPolicy>,
    /// if backupType is incremental, parentBackupName is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parentBackupName")]
    pub parent_backup_name: Option<String>,
    /// retentionPeriod determines a duration up to which the backup should be kept. Controller will remove all backups that are older than the RetentionPeriod. For example, RetentionPeriod of `30d` will keep only the backups of last 30 days. Sample duration format: - years: 	2y - months: 	6mo - days: 		30d - hours: 	12h - minutes: 	30m You can also combine the above durations. For example: 30d12h30m. If not set, the backup will be kept forever.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionPeriod")]
    pub retention_period: Option<String>,
}

/// backupSpec defines how to backup the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestBackupSpecDeletionPolicy {
    Delete,
    Retain,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestCustomSpec {
    /// cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// reference a opsDefinition
    #[serde(rename = "opsDefinitionRef")]
    pub ops_definition_ref: String,
    /// the input for this operation declared in the opsDefinition.spec.parametersSchema. will create corresponding jobs for each array element. if the param type is array, the format must be "v1,v2,v3".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<Vec<BTreeMap<String, String>>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestExpose {
    /// componentName cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// Setting the list of services to be exposed.
    pub services: Vec<OpsRequestExposeServices>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestExposeServices {
    /// If ServiceType is LoadBalancer, cloud provider related parameters can be put here More info: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Service name
    pub name: String,
    /// serviceType determines how the Service is exposed. Valid options are ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, they are determined by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<OpsRequestExposeServicesServiceType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestExposeServicesServiceType {
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    NodePort,
    LoadBalancer,
}

/// HorizontalScaling defines the variables of horizontal scaling operation
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestHorizontalScaling {
    /// componentName cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// Instances defines the name of instance that rsm scale down priorly. If the RsmTransformPolicy is specified as ToPod and expected replicas is less than current replicas, the list of Instances will be used. current replicas - expected replicas > len(Instances): Scale down from the list of Instances priorly, the others will select from NodeAssignment. current replicas - expected replicas < len(Instances): Scale down from the list of Instances. current replicas - expected replicas < len(Instances): Scale down from a part of Instances.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<Vec<String>>,
    /// Nodes defines the list of nodes that pods can schedule when scale up If the RsmTransformPolicy is specified as ToPod and expected replicas is more than current replicas,the list of Nodes will be used. If the list of Nodes is empty, no specific node will be assigned. However, if the list of Nodes is filled, all pods will be evenly scheduled across the Nodes in the list when scale up.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nodes: Option<Vec<String>>,
    /// replicas for the workloads.
    pub replicas: i32,
}

/// reconfigure defines the variables that need to input when updating configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigure {
    /// componentName cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// configurations defines which components perform the operation.
    pub configurations: Vec<OpsRequestReconfigureConfigurations>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigureConfigurations {
    /// keys is used to set the parameters to be updated.
    pub keys: Vec<OpsRequestReconfigureConfigurationsKeys>,
    /// name is a config template name.
    pub name: String,
    /// policy defines the upgrade policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<OpsRequestReconfigureConfigurationsPolicy>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigureConfigurationsKeys {
    /// fileContent indicates the configuration file content. update whole file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileContent")]
    pub file_content: Option<String>,
    /// key indicates the key name of ConfigMap.
    pub key: String,
    /// Setting the list of parameters for a single configuration file. update specified the parameters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Vec<OpsRequestReconfigureConfigurationsKeysParameters>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigureConfigurationsKeysParameters {
    /// key is name of the parameter to be updated.
    pub key: String,
    /// parameter values to be updated. if set nil, the parameter defined by the key field will be deleted from the configuration file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestReconfigureConfigurationsPolicy {
    #[serde(rename = "simple")]
    Simple,
    #[serde(rename = "parallel")]
    Parallel,
    #[serde(rename = "rolling")]
    Rolling,
    #[serde(rename = "autoReload")]
    AutoReload,
    #[serde(rename = "operatorSyncUpdate")]
    OperatorSyncUpdate,
}

/// Reconfigure defines the variables that need to input when updating configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigures {
    /// componentName cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// configurations defines which components perform the operation.
    pub configurations: Vec<OpsRequestReconfiguresConfigurations>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfiguresConfigurations {
    /// keys is used to set the parameters to be updated.
    pub keys: Vec<OpsRequestReconfiguresConfigurationsKeys>,
    /// name is a config template name.
    pub name: String,
    /// policy defines the upgrade policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<OpsRequestReconfiguresConfigurationsPolicy>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfiguresConfigurationsKeys {
    /// fileContent indicates the configuration file content. update whole file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileContent")]
    pub file_content: Option<String>,
    /// key indicates the key name of ConfigMap.
    pub key: String,
    /// Setting the list of parameters for a single configuration file. update specified the parameters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Vec<OpsRequestReconfiguresConfigurationsKeysParameters>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfiguresConfigurationsKeysParameters {
    /// key is name of the parameter to be updated.
    pub key: String,
    /// parameter values to be updated. if set nil, the parameter defined by the key field will be deleted from the configuration file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestReconfiguresConfigurationsPolicy {
    #[serde(rename = "simple")]
    Simple,
    #[serde(rename = "parallel")]
    Parallel,
    #[serde(rename = "rolling")]
    Rolling,
    #[serde(rename = "autoReload")]
    AutoReload,
    #[serde(rename = "operatorSyncUpdate")]
    OperatorSyncUpdate,
}

/// ComponentOps defines the common variables of component scope operations.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestart {
    /// componentName cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
}

/// cluster RestoreFrom backup or point in time
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFrom {
    /// use the backup name and component name for restore, support for multiple components' recovery.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backup: Option<Vec<OpsRequestRestoreFromBackup>>,
    /// specified the point in time to recovery
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pointInTime")]
    pub point_in_time: Option<OpsRequestRestoreFromPointInTime>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFromBackup {
    /// specify a reference backup to restore
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ref")]
    pub r#ref: Option<OpsRequestRestoreFromBackupRef>,
}

/// specify a reference backup to restore
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFromBackupRef {
    /// specified the name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// specified the namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// specified the point in time to recovery
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFromPointInTime {
    /// specify a reference source cluster to restore
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ref")]
    pub r#ref: Option<OpsRequestRestoreFromPointInTimeRef>,
    /// specify the time point to restore, with UTC as the time zone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// specify a reference source cluster to restore
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFromPointInTimeRef {
    /// specified the name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// specified the namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// restoreSpec defines how to restore the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreSpec {
    /// backupName is the name of the backup.
    #[serde(rename = "backupName")]
    pub backup_name: String,
    /// effectiveCommonComponentDef describes this backup will be restored for all components which refer to common ComponentDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveCommonComponentDef")]
    pub effective_common_component_def: Option<bool>,
    /// restoreTime point in time to restore
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreTimeStr")]
    pub restore_time_str: Option<String>,
    /// the volume claim restore policy, support values: [Serial, Parallel]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeRestorePolicy")]
    pub volume_restore_policy: Option<OpsRequestRestoreSpecVolumeRestorePolicy>,
}

/// restoreSpec defines how to restore the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestRestoreSpecVolumeRestorePolicy {
    Serial,
    Parallel,
}

/// scriptSpec defines the script to be executed.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpec {
    /// componentName cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// exec command with image, by default use the image of kubeblocks-datascript.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// script defines the script to be executed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub script: Option<Vec<String>>,
    /// scriptFrom defines the script to be executed from configMap or secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scriptFrom")]
    pub script_from: Option<OpsRequestScriptSpecScriptFrom>,
    /// secret defines the secret to be used to execute the script. If not specified, the default cluster root credential secret will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<OpsRequestScriptSpecSecret>,
    /// KubeBlocks, by default, will execute the script on the primary pod, with role=leader. There are some exceptions, such as Redis, which does not synchronize accounts info between primary and secondary. In this case, we need to execute the script on all pods, matching the selector. selector indicates the components on which the script is executed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<OpsRequestScriptSpecSelector>,
}

/// scriptFrom defines the script to be executed from configMap or secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecScriptFrom {
    /// configMapRef defines the configMap to be executed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<Vec<OpsRequestScriptSpecScriptFromConfigMapRef>>,
    /// secretRef defines the secret to be executed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<Vec<OpsRequestScriptSpecScriptFromSecretRef>>,
}

/// Selects a key from a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecScriptFromConfigMapRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecScriptFromSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the secret to be used to execute the script. If not specified, the default cluster root credential secret will be used.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecSecret {
    /// name is the name of the secret.
    pub name: String,
    /// passwordKey field is used to specify the password of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordKey")]
    pub password_key: Option<String>,
    /// usernameKey field is used to specify the username of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernameKey")]
    pub username_key: Option<String>,
}

/// KubeBlocks, by default, will execute the script on the primary pod, with role=leader. There are some exceptions, such as Redis, which does not synchronize accounts info between primary and secondary. In this case, we need to execute the script on all pods, matching the selector. selector indicates the components on which the script is executed.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<OpsRequestScriptSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestSwitchover {
    /// componentName cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// instanceName is used to specify the candidate primary or leader instanceName for switchover. If instanceName is set to "*", it means that no specific primary or leader is specified for the switchover, and the switchoverAction defined in clusterDefinition.componentDefs[x].switchoverSpec.withoutCandidate will be executed, It is required that clusterDefinition.componentDefs[x].switchoverSpec.withoutCandidate is not empty. If instanceName is set to a valid instanceName other than "*", it means that a specific candidate primary or leader is specified for the switchover. the value of instanceName can be obtained using `kbcli cluster list-instances`, any other value is invalid. In this case, the `switchoverAction` defined in clusterDefinition.componentDefs[x].switchoverSpec.withCandidate will be executed, and it is required that clusterDefinition.componentDefs[x].switchoverSpec.withCandidate is not empty.
    #[serde(rename = "instanceName")]
    pub instance_name: String,
}

/// OpsRequestSpec defines the desired state of OpsRequest
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestType {
    Upgrade,
    VerticalScaling,
    VolumeExpansion,
    HorizontalScaling,
    Restart,
    Reconfiguring,
    Start,
    Stop,
    Expose,
    Switchover,
    DataScript,
    Backup,
    Restore,
    Custom,
}

/// upgrade specifies the cluster version by specifying clusterVersionRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestUpgrade {
    /// clusterVersionRef references ClusterVersion name.
    #[serde(rename = "clusterVersionRef")]
    pub cluster_version_ref: String,
}

/// VerticalScaling defines the variables that need to input when scaling compute resources.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVerticalScaling {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<OpsRequestVerticalScalingClaims>>,
    /// classDefRef reference class defined in ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classDefRef")]
    pub class_def_ref: Option<OpsRequestVerticalScalingClassDefRef>,
    /// componentName cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVerticalScalingClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// classDefRef reference class defined in ComponentClassDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVerticalScalingClassDefRef {
    /// Class refers to the name of the class that is defined in the ComponentClassDefinition.
    pub class: String,
    /// Name refers to the name of the ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// VolumeExpansion defines the variables of volume expansion operation.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVolumeExpansion {
    /// componentName cluster component name.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// volumeClaimTemplates specifies the storage size and volumeClaimTemplate name.
    #[serde(rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Vec<OpsRequestVolumeExpansionVolumeClaimTemplates>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVolumeExpansionVolumeClaimTemplates {
    /// name references volumeClaimTemplate name from cluster components.
    pub name: String,
    /// Request storage size.
    pub storage: IntOrString,
}

/// OpsRequestStatus defines the observed state of OpsRequest
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatus {
    /// CancelTimestamp defines cancel time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cancelTimestamp")]
    pub cancel_timestamp: Option<String>,
    /// ClusterGeneration records the cluster generation after handling the opsRequest action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterGeneration")]
    pub cluster_generation: Option<i64>,
    /// completionTimestamp defines the OpsRequest completion time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "completionTimestamp")]
    pub completion_timestamp: Option<String>,
    /// components defines the recorded the status information of changed components for operation request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<BTreeMap<String, OpsRequestStatusComponents>>,
    /// conditions describes opsRequest detail status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<OpsRequestStatusConditions>>,
    /// lastConfiguration records the last configuration before this operation take effected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastConfiguration")]
    pub last_configuration: Option<OpsRequestStatusLastConfiguration>,
    /// phase describes OpsRequest phase.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<OpsRequestStatusPhase>,
    pub progress: String,
    /// reconfiguringStatus defines the status information of reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconfiguringStatus")]
    pub reconfiguring_status: Option<OpsRequestStatusReconfiguringStatus>,
    /// reconfiguringStatus defines the status information of reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconfiguringStatusAsComponent")]
    pub reconfiguring_status_as_component: Option<BTreeMap<String, OpsRequestStatusReconfiguringStatusAsComponent>>,
    /// startTimestamp The time when the OpsRequest started processing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTimestamp")]
    pub start_timestamp: Option<String>,
}

/// components defines the recorded the status information of changed components for operation request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusComponents {
    /// lastFailedTime is the last time the component phase transitioned to Failed or Abnormal.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastFailedTime")]
    pub last_failed_time: Option<String>,
    /// message is a human-readable message indicating details about this operation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// phase describes the component phase, reference Cluster.status.component.phase.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<OpsRequestStatusComponentsPhase>,
    /// progressDetails describes the progress details of the component for this operation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "progressDetails")]
    pub progress_details: Option<Vec<OpsRequestStatusComponentsProgressDetails>>,
    /// reason describes the reason for the component phase.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// workloadType references workload type of component in ClusterDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadType")]
    pub workload_type: Option<OpsRequestStatusComponentsWorkloadType>,
}

/// components defines the recorded the status information of changed components for operation request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusComponentsPhase {
    Creating,
    Running,
    Updating,
    Stopping,
    Stopped,
    Deleting,
    Failed,
    Abnormal,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusComponentsProgressDetails {
    /// endTime is the completion time of object processing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// group describes which group the current object belongs to. if the objects of a component belong to the same group, we can ignore it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// message is a human readable message indicating details about the object condition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// objectKey is the unique key of the object.
    #[serde(rename = "objectKey")]
    pub object_key: String,
    /// startTime is the start time of object processing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// status describes the state of processing the object.
    pub status: OpsRequestStatusComponentsProgressDetailsStatus,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusComponentsProgressDetailsStatus {
    Processing,
    Pending,
    Failed,
    Succeed,
}

/// components defines the recorded the status information of changed components for operation request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusComponentsWorkloadType {
    Stateless,
    Stateful,
    Consensus,
    Replication,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: OpsRequestStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusConditionsStatus {
    True,
    False,
    Unknown,
}

/// lastConfiguration records the last configuration before this operation take effected.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfiguration {
    /// clusterVersionRef references ClusterVersion name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterVersionRef")]
    pub cluster_version_ref: Option<String>,
    /// components records last configuration of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<BTreeMap<String, OpsRequestStatusLastConfigurationComponents>>,
}

/// components records last configuration of the component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponents {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<OpsRequestStatusLastConfigurationComponentsClaims>>,
    /// classDefRef reference class defined in ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classDefRef")]
    pub class_def_ref: Option<OpsRequestStatusLastConfigurationComponentsClassDefRef>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// replicas are the last replicas of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
    /// services records the last services of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<OpsRequestStatusLastConfigurationComponentsServices>>,
    /// targetResources records the affecting target resources information for the component. resource key is in list of [pods].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetResources")]
    pub target_resources: Option<BTreeMap<String, String>>,
    /// volumeClaimTemplates records the last volumeClaimTemplates of the component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Option<Vec<OpsRequestStatusLastConfigurationComponentsVolumeClaimTemplates>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponentsClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// classDefRef reference class defined in ComponentClassDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponentsClassDefRef {
    /// Class refers to the name of the class that is defined in the ComponentClassDefinition.
    pub class: String,
    /// Name refers to the name of the ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponentsServices {
    /// If ServiceType is LoadBalancer, cloud provider related parameters can be put here More info: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Service name
    pub name: String,
    /// serviceType determines how the Service is exposed. Valid options are ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, they are determined by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<OpsRequestStatusLastConfigurationComponentsServicesServiceType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusLastConfigurationComponentsServicesServiceType {
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    NodePort,
    LoadBalancer,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponentsVolumeClaimTemplates {
    /// name references volumeClaimTemplate name from cluster components.
    pub name: String,
    /// Request storage size.
    pub storage: IntOrString,
}

/// OpsRequestStatus defines the observed state of OpsRequest
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusPhase {
    Pending,
    Creating,
    Running,
    Cancelling,
    Cancelled,
    Failed,
    Succeed,
}

/// reconfiguringStatus defines the status information of reconfiguring.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatus {
    /// conditions describes reconfiguring detail status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<OpsRequestStatusReconfiguringStatusConditions>>,
    /// configurationStatus describes the status of the component reconfiguring.
    #[serde(rename = "configurationStatus")]
    pub configuration_status: Vec<OpsRequestStatusReconfiguringStatusConfigurationStatus>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: OpsRequestStatusReconfiguringStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusReconfiguringStatusConditionsStatus {
    True,
    False,
    Unknown,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusConfigurationStatus {
    /// expectedCount describes the number of expected reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectedCount")]
    pub expected_count: Option<i32>,
    /// LastAppliedConfiguration describes the last configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedConfiguration")]
    pub last_applied_configuration: Option<BTreeMap<String, String>>,
    /// lastStatus describes the last status for the reconfiguring controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastStatus")]
    pub last_status: Option<String>,
    /// message describes the details about this operation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// name is a config template name.
    pub name: String,
    /// status describes the current state of the reconfiguring state machine.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// succeedCount describes the number of successful reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "succeedCount")]
    pub succeed_count: Option<i32>,
    /// updatePolicy describes the policy of reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    pub update_policy: Option<OpsRequestStatusReconfiguringStatusConfigurationStatusUpdatePolicy>,
    /// updatedParameters describes the updated parameters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedParameters")]
    pub updated_parameters: Option<OpsRequestStatusReconfiguringStatusConfigurationStatusUpdatedParameters>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusReconfiguringStatusConfigurationStatusUpdatePolicy {
    #[serde(rename = "simple")]
    Simple,
    #[serde(rename = "parallel")]
    Parallel,
    #[serde(rename = "rolling")]
    Rolling,
    #[serde(rename = "autoReload")]
    AutoReload,
    #[serde(rename = "operatorSyncUpdate")]
    OperatorSyncUpdate,
}

/// updatedParameters describes the updated parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusConfigurationStatusUpdatedParameters {
    /// addedKeys describes the key added.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addedKeys")]
    pub added_keys: Option<BTreeMap<String, String>>,
    /// deletedKeys describes the key deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletedKeys")]
    pub deleted_keys: Option<BTreeMap<String, String>>,
    /// updatedKeys describes the key updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedKeys")]
    pub updated_keys: Option<BTreeMap<String, String>>,
}

/// reconfiguringStatus defines the status information of reconfiguring.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusAsComponent {
    /// conditions describes reconfiguring detail status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<OpsRequestStatusReconfiguringStatusAsComponentConditions>>,
    /// configurationStatus describes the status of the component reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configurationStatus")]
    pub configuration_status: Option<Vec<OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatus>>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusAsComponentConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: OpsRequestStatusReconfiguringStatusAsComponentConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusReconfiguringStatusAsComponentConditionsStatus {
    True,
    False,
    Unknown,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatus {
    /// expectedCount describes the number of expected reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectedCount")]
    pub expected_count: Option<i32>,
    /// LastAppliedConfiguration describes the last configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedConfiguration")]
    pub last_applied_configuration: Option<BTreeMap<String, String>>,
    /// lastStatus describes the last status for the reconfiguring controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastStatus")]
    pub last_status: Option<String>,
    /// message describes the details about this operation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// name is a config template name.
    pub name: String,
    /// status describes the current state of the reconfiguring state machine.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// succeedCount describes the number of successful reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "succeedCount")]
    pub succeed_count: Option<i32>,
    /// updatePolicy describes the policy of reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    pub update_policy: Option<OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatusUpdatePolicy>,
    /// updatedParameters describes the updated parameters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedParameters")]
    pub updated_parameters: Option<OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatusUpdatedParameters>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatusUpdatePolicy {
    #[serde(rename = "simple")]
    Simple,
    #[serde(rename = "parallel")]
    Parallel,
    #[serde(rename = "rolling")]
    Rolling,
    #[serde(rename = "autoReload")]
    AutoReload,
    #[serde(rename = "operatorSyncUpdate")]
    OperatorSyncUpdate,
}

/// updatedParameters describes the updated parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatusUpdatedParameters {
    /// addedKeys describes the key added.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addedKeys")]
    pub added_keys: Option<BTreeMap<String, String>>,
    /// deletedKeys describes the key deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletedKeys")]
    pub deleted_keys: Option<BTreeMap<String, String>>,
    /// updatedKeys describes the key updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedKeys")]
    pub updated_keys: Option<BTreeMap<String, String>>,
}

