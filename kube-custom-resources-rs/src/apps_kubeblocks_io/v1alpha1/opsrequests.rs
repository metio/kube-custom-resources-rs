// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/apecloud/kubeblocks/apps.kubeblocks.io/v1alpha1/opsrequests.yaml --derive=PartialEq
// kopium version: 0.17.0

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;

/// OpsRequestSpec defines the desired state of OpsRequest
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "apps.kubeblocks.io", version = "v1alpha1", kind = "OpsRequest", plural = "opsrequests")]
#[kube(namespaced)]
#[kube(status = "OpsRequestStatus")]
#[kube(schema = "disabled")]
pub struct OpsRequestSpec {
    /// Defines how to backup the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupSpec")]
    pub backup_spec: Option<OpsRequestBackupSpec>,
    /// Defines the action to cancel the `Pending/Creating/Running` opsRequest, supported types: `VerticalScaling/HorizontalScaling`. Once set to true, this opsRequest will be canceled and modifying this property again will not take effect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cancel: Option<bool>,
    /// References the cluster object.
    #[serde(rename = "clusterRef")]
    pub cluster_ref: String,
    /// Specifies a custom operation as defined by OpsDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customSpec")]
    pub custom_spec: Option<OpsRequestCustomSpec>,
    /// Defines services the component needs to expose.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expose: Option<Vec<OpsRequestExpose>>,
    /// Defines what component need to horizontal scale the specified replicas.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "horizontalScaling")]
    pub horizontal_scaling: Option<Vec<OpsRequestHorizontalScaling>>,
    /// Deprecated: replace by reconfigures. Defines the variables that need to input when updating configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconfigure: Option<OpsRequestReconfigure>,
    /// Defines the variables that need to input when updating configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconfigures: Option<Vec<OpsRequestReconfigures>>,
    /// Restarts the specified components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restart: Option<Vec<OpsRequestRestart>>,
    /// Cluster RestoreFrom backup or point in time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreFrom")]
    pub restore_from: Option<OpsRequestRestoreFrom>,
    /// Defines how to restore the cluster. Note that this restore operation will roll back cluster services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreSpec")]
    pub restore_spec: Option<OpsRequestRestoreSpec>,
    /// Defines the script to be executed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scriptSpec")]
    pub script_spec: Option<OpsRequestScriptSpec>,
    /// Switches over the specified components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub switchover: Option<Vec<OpsRequestSwitchover>>,
    /// OpsRequest will be deleted after TTLSecondsAfterSucceed second when OpsRequest.status.phase is Succeed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ttlSecondsAfterSucceed")]
    pub ttl_seconds_after_succeed: Option<i32>,
    /// OpsRequest will wait at most TTLSecondsBeforeAbort seconds for start-conditions to be met. If not specified, the default value is 0, which means that the start-conditions must be met immediately.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ttlSecondsBeforeAbort")]
    pub ttl_seconds_before_abort: Option<i32>,
    /// Defines the operation type.
    #[serde(rename = "type")]
    pub r#type: OpsRequestType,
    /// Specifies the cluster version by specifying clusterVersionRef.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub upgrade: Option<OpsRequestUpgrade>,
    /// Note: Quantity struct can not do immutable check by CEL. Defines what component need to vertical scale the specified compute resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verticalScaling")]
    pub vertical_scaling: Option<Vec<OpsRequestVerticalScaling>>,
    /// Note: Quantity struct can not do immutable check by CEL. Defines what component and volumeClaimTemplate need to expand the specified storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeExpansion")]
    pub volume_expansion: Option<Vec<OpsRequestVolumeExpansion>>,
}

/// Defines how to backup the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestBackupSpec {
    /// Defines the backup method that is defined in backupPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupMethod")]
    pub backup_method: Option<String>,
    /// Specifies the name of the backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupName")]
    pub backup_name: Option<String>,
    /// Indicates the backupPolicy applied to perform this backup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backupPolicyName")]
    pub backup_policy_name: Option<String>,
    /// Determines whether the backup contents stored in backup repository should be deleted when the backup custom resource is deleted. Supported values are `Retain` and `Delete`. - `Retain` means that the backup content and its physical snapshot on backup repository are kept. - `Delete` means that the backup content and its physical snapshot on backup repository are deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletionPolicy")]
    pub deletion_policy: Option<OpsRequestBackupSpecDeletionPolicy>,
    /// If backupType is incremental, parentBackupName is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parentBackupName")]
    pub parent_backup_name: Option<String>,
    /// Determines a duration up to which the backup should be kept. Controller will remove all backups that are older than the RetentionPeriod. For example, RetentionPeriod of `30d` will keep only the backups of last 30 days. Sample duration format: 
    ///  - years: 2y - months: 6mo - days: 30d - hours: 12h - minutes: 30m 
    ///  You can also combine the above durations. For example: 30d12h30m. If not set, the backup will be kept forever.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionPeriod")]
    pub retention_period: Option<String>,
}

/// Defines how to backup the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestBackupSpecDeletionPolicy {
    Delete,
    Retain,
}

/// Specifies a custom operation as defined by OpsDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestCustomSpec {
    /// Defines which components need to perform the actions defined by this OpsDefinition. At least one component is required. The components are identified by their name and can be merged or retained.
    pub components: Vec<OpsRequestCustomSpecComponents>,
    /// Is a reference to an OpsDefinition.
    #[serde(rename = "opsDefinitionRef")]
    pub ops_definition_ref: String,
    /// Defines the execution concurrency. By default, all incoming Components will be executed simultaneously. The value can be an absolute number (e.g., 5) or a percentage of desired components (e.g., 10%). The absolute number is calculated from the percentage by rounding up. For instance, if the percentage value is 10% and the components length is 1, the calculated number will be rounded up to 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallelism: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountName")]
    pub service_account_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestCustomSpecComponents {
    /// Specifies the unique identifier of the cluster component
    pub name: String,
    /// Represents the parameters for this operation as declared in the opsDefinition.spec.parametersSchema.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Vec<OpsRequestCustomSpecComponentsParameters>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestCustomSpecComponentsParameters {
    /// Specifies the identifier of the parameter as defined in the OpsDefinition.
    pub name: String,
    /// Holds the data associated with the parameter. If the parameter type is an array, the format should be "v1,v2,v3".
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestExpose {
    /// Specifies the name of the cluster component.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// A list of services that are to be exposed or removed. If componentNamem is not specified, each `OpsService` in the list must specify ports and selectors.
    pub services: Vec<OpsRequestExposeServices>,
    /// Controls the expose operation. If set to Enable, the corresponding service will be exposed. Conversely, if set to Disable, the service will be removed.
    pub switch: OpsRequestExposeSwitch,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestExposeServices {
    /// Contains cloud provider related parameters if ServiceType is LoadBalancer. More info: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Specifies the name of the service. This name is used by others to refer to this service (e.g., connection credential). Note: This field cannot be updated.
    pub name: String,
    /// Lists the ports that are exposed by this service. If not provided, the default Services Ports defined in the ClusterDefinition or ComponentDefinition that are neither of NodePort nor LoadBalancer service type will be used. If there is no corresponding Service defined in the ClusterDefinition or ComponentDefinition, the expose operation will fail. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<OpsRequestExposeServicesPorts>>,
    /// Allows you to specify a defined role as a selector for the service, extending the ServiceSpec.Selector.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleSelector")]
    pub role_selector: Option<String>,
    /// Routes service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. This only applies to types ClusterIP, NodePort, and LoadBalancer and is ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// Determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. - `ClusterIP` allocates a cluster-internal IP address for load-balancing to endpoints. - `NodePort` builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. - `LoadBalancer` builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<String>,
}

/// ServicePort contains information on service's port.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestExposeServicesPorts {
    /// The application protocol for this port. This is used as a hint for implementations to offer richer behavior for protocols that they understand. This field follows standard Kubernetes label syntax. Valid values are either: 
    ///  * Un-prefixed protocol names - reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). 
    ///  * Kubernetes-defined prefixed names: * 'kubernetes.io/h2c' - HTTP/2 over cleartext as described in https://www.rfc-editor.org/rfc/rfc7540 * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455 * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455 
    ///  * Other protocols should use implementation-defined prefixed names such as mycompany.com/my-custom-protocol.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appProtocol")]
    pub app_protocol: Option<String>,
    /// The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i32>,
    /// The port that will be exposed by this service.
    pub port: i32,
    /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    /// Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPort")]
    pub target_port: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestExposeSwitch {
    Enable,
    Disable,
}

/// HorizontalScaling defines the variables of horizontal scaling operation
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestHorizontalScaling {
    /// Specifies the name of the cluster component.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// Defines the names of instances that the rsm should prioritize for scale-down operations. If the RsmTransformPolicy is set to ToPod and the expected number of replicas is less than the current number, the list of Instances will be used. 
    ///  - `current replicas - expected replicas > len(Instances)`: Scale down from the list of Instances priorly, the others will select from NodeAssignment. - `current replicas - expected replicas < len(Instances)`: Scale down from the list of Instances. - `current replicas - expected replicas < len(Instances)`: Scale down from a part of Instances.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<Vec<String>>,
    /// Defines the list of nodes where pods can be scheduled during a scale-up operation. If the RsmTransformPolicy is set to ToPod and the expected number of replicas is greater than the current number, the list of Nodes will be used. If the list of Nodes is empty, pods will not be assigned to any specific node. However, if the list of Nodes is populated, pods will be evenly distributed across the nodes in the list during scale-up.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nodes: Option<Vec<String>>,
    /// Specifies the number of replicas for the workloads.
    pub replicas: i32,
}

/// Deprecated: replace by reconfigures. Defines the variables that need to input when updating configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigure {
    /// Specifies the name of the cluster component.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// Specifies the components that will perform the operation.
    pub configurations: Vec<OpsRequestReconfigureConfigurations>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigureConfigurations {
    /// Sets the parameters to be updated. It should contain at least one item. The keys are merged and retained during patch operations.
    pub keys: Vec<OpsRequestReconfigureConfigurationsKeys>,
    /// Specifies the name of the configuration template.
    pub name: String,
    /// Defines the upgrade policy for the configuration. This field is optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<OpsRequestReconfigureConfigurationsPolicy>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigureConfigurationsKeys {
    /// Represents the content of the configuration file. This field is used to update the entire content of the file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileContent")]
    pub file_content: Option<String>,
    /// Represents the unique identifier for the ConfigMap.
    pub key: String,
    /// Defines a list of key-value pairs for a single configuration file. These parameters are used to update the specified configuration settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Vec<OpsRequestReconfigureConfigurationsKeysParameters>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigureConfigurationsKeysParameters {
    /// Represents the name of the parameter that is to be updated.
    pub key: String,
    /// Represents the parameter values that are to be updated. If set to nil, the parameter defined by the Key field will be removed from the configuration file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestReconfigureConfigurationsPolicy {
    #[serde(rename = "simple")]
    Simple,
    #[serde(rename = "parallel")]
    Parallel,
    #[serde(rename = "rolling")]
    Rolling,
    #[serde(rename = "autoReload")]
    AutoReload,
    #[serde(rename = "operatorSyncUpdate")]
    OperatorSyncUpdate,
    #[serde(rename = "dynamicReloadBeginRestart")]
    DynamicReloadBeginRestart,
}

/// Reconfigure represents the variables required for updating a configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfigures {
    /// Specifies the name of the cluster component.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// Specifies the components that will perform the operation.
    pub configurations: Vec<OpsRequestReconfiguresConfigurations>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfiguresConfigurations {
    /// Sets the parameters to be updated. It should contain at least one item. The keys are merged and retained during patch operations.
    pub keys: Vec<OpsRequestReconfiguresConfigurationsKeys>,
    /// Specifies the name of the configuration template.
    pub name: String,
    /// Defines the upgrade policy for the configuration. This field is optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<OpsRequestReconfiguresConfigurationsPolicy>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfiguresConfigurationsKeys {
    /// Represents the content of the configuration file. This field is used to update the entire content of the file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileContent")]
    pub file_content: Option<String>,
    /// Represents the unique identifier for the ConfigMap.
    pub key: String,
    /// Defines a list of key-value pairs for a single configuration file. These parameters are used to update the specified configuration settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Vec<OpsRequestReconfiguresConfigurationsKeysParameters>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestReconfiguresConfigurationsKeysParameters {
    /// Represents the name of the parameter that is to be updated.
    pub key: String,
    /// Represents the parameter values that are to be updated. If set to nil, the parameter defined by the Key field will be removed from the configuration file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestReconfiguresConfigurationsPolicy {
    #[serde(rename = "simple")]
    Simple,
    #[serde(rename = "parallel")]
    Parallel,
    #[serde(rename = "rolling")]
    Rolling,
    #[serde(rename = "autoReload")]
    AutoReload,
    #[serde(rename = "operatorSyncUpdate")]
    OperatorSyncUpdate,
    #[serde(rename = "dynamicReloadBeginRestart")]
    DynamicReloadBeginRestart,
}

/// ComponentOps represents the common variables required for operations within the scope of a component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestart {
    /// Specifies the name of the cluster component.
    #[serde(rename = "componentName")]
    pub component_name: String,
}

/// Cluster RestoreFrom backup or point in time.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFrom {
    /// Refers to the backup name and component name used for restoration. Supports recovery of multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backup: Option<Vec<OpsRequestRestoreFromBackup>>,
    /// Refers to the specific point in time for recovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pointInTime")]
    pub point_in_time: Option<OpsRequestRestoreFromPointInTime>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFromBackup {
    /// Refers to a reference backup that needs to be restored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ref")]
    pub r#ref: Option<OpsRequestRestoreFromBackupRef>,
}

/// Refers to a reference backup that needs to be restored.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFromBackupRef {
    /// Refers to the specific name of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Refers to the specific namespace of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Refers to the specific point in time for recovery.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFromPointInTime {
    /// Refers to a reference source cluster that needs to be restored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ref")]
    pub r#ref: Option<OpsRequestRestoreFromPointInTimeRef>,
    /// Refers to the specific time point for restoration, with UTC as the time zone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Refers to a reference source cluster that needs to be restored.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreFromPointInTimeRef {
    /// Refers to the specific name of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Refers to the specific namespace of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Defines how to restore the cluster. Note that this restore operation will roll back cluster services.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestRestoreSpec {
    /// Specifies the name of the backup.
    #[serde(rename = "backupName")]
    pub backup_name: String,
    /// Indicates if this backup will be restored for all components which refer to common ComponentDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "effectiveCommonComponentDef")]
    pub effective_common_component_def: Option<bool>,
    /// Defines the point in time to restore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restoreTimeStr")]
    pub restore_time_str: Option<String>,
    /// Specifies the volume claim restore policy, support values: [Serial, Parallel]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeRestorePolicy")]
    pub volume_restore_policy: Option<OpsRequestRestoreSpecVolumeRestorePolicy>,
}

/// Defines how to restore the cluster. Note that this restore operation will roll back cluster services.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestRestoreSpecVolumeRestorePolicy {
    Serial,
    Parallel,
}

/// Defines the script to be executed.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpec {
    /// Specifies the name of the cluster component.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// Specifies the image to be used for the exec command. By default, the image of kubeblocks-datascript is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Defines the script to be executed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub script: Option<Vec<String>>,
    /// Defines the script to be executed from a configMap or secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scriptFrom")]
    pub script_from: Option<OpsRequestScriptSpecScriptFrom>,
    /// Defines the secret to be used to execute the script. If not specified, the default cluster root credential secret is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<OpsRequestScriptSpecSecret>,
    /// By default, KubeBlocks will execute the script on the primary pod with role=leader. Exceptions exist, such as Redis, which does not synchronize account information between primary and secondary. In such cases, the script needs to be executed on all pods matching the selector. Indicates the components on which the script is executed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<OpsRequestScriptSpecSelector>,
}

/// Defines the script to be executed from a configMap or secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecScriptFrom {
    /// Specifies the configMap that is to be executed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<Vec<OpsRequestScriptSpecScriptFromConfigMapRef>>,
    /// Specifies the secret that is to be executed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<Vec<OpsRequestScriptSpecScriptFromSecretRef>>,
}

/// Selects a key from a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecScriptFromConfigMapRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecScriptFromSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the secret to be used to execute the script. If not specified, the default cluster root credential secret is used.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecSecret {
    /// Specifies the name of the secret.
    pub name: String,
    /// Used to specify the password part of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordKey")]
    pub password_key: Option<String>,
    /// Used to specify the username part of the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernameKey")]
    pub username_key: Option<String>,
}

/// By default, KubeBlocks will execute the script on the primary pod with role=leader. Exceptions exist, such as Redis, which does not synchronize account information between primary and secondary. In such cases, the script needs to be executed on all pods matching the selector. Indicates the components on which the script is executed.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<OpsRequestScriptSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestScriptSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestSwitchover {
    /// Specifies the name of the cluster component.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// Utilized to designate the candidate primary or leader instance for the switchover process. If assigned "*", it signifies that no specific primary or leader is designated for the switchover, and the switchoverAction defined in `clusterDefinition.componentDefs[x].switchoverSpec.withoutCandidate` will be executed. 
    ///  It is mandatory that `clusterDefinition.componentDefs[x].switchoverSpec.withoutCandidate` is not left blank. 
    ///  If assigned a valid instance name other than "*", it signifies that a specific candidate primary or leader is designated for the switchover. The value can be retrieved using `kbcli cluster list-instances`, any other value is considered invalid. 
    ///  In this scenario, the `switchoverAction` defined in clusterDefinition.componentDefs[x].switchoverSpec.withCandidate will be executed, and it is mandatory that clusterDefinition.componentDefs[x].switchoverSpec.withCandidate is not left blank.
    #[serde(rename = "instanceName")]
    pub instance_name: String,
}

/// OpsRequestSpec defines the desired state of OpsRequest
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestType {
    Upgrade,
    VerticalScaling,
    VolumeExpansion,
    HorizontalScaling,
    Restart,
    Reconfiguring,
    Start,
    Stop,
    Expose,
    Switchover,
    DataScript,
    Backup,
    Restore,
    Custom,
}

/// Specifies the cluster version by specifying clusterVersionRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestUpgrade {
    /// A reference to the name of the ClusterVersion.
    #[serde(rename = "clusterVersionRef")]
    pub cluster_version_ref: String,
}

/// VerticalScaling defines the parameters required for scaling compute resources.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVerticalScaling {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<OpsRequestVerticalScalingClaims>>,
    /// A reference to a class defined in ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classDefRef")]
    pub class_def_ref: Option<OpsRequestVerticalScalingClassDefRef>,
    /// Specifies the name of the cluster component.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVerticalScalingClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// A reference to a class defined in ComponentClassDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVerticalScalingClassDefRef {
    /// Defines the name of the class that is defined in the ComponentClassDefinition.
    pub class: String,
    /// Specifies the name of the ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// VolumeExpansion encapsulates the parameters required for a volume expansion operation.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVolumeExpansion {
    /// Specifies the name of the cluster component.
    #[serde(rename = "componentName")]
    pub component_name: String,
    /// volumeClaimTemplates specifies the storage size and volumeClaimTemplate name.
    #[serde(rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Vec<OpsRequestVolumeExpansionVolumeClaimTemplates>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestVolumeExpansionVolumeClaimTemplates {
    /// A reference to the volumeClaimTemplate name from the cluster components.
    pub name: String,
    /// Specifies the requested storage size for the volume.
    pub storage: IntOrString,
}

/// OpsRequestStatus represents the observed state of an OpsRequest.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatus {
    /// Defines the time when the OpsRequest was cancelled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cancelTimestamp")]
    pub cancel_timestamp: Option<String>,
    /// Specifies the cluster generation after the OpsRequest action has been handled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterGeneration")]
    pub cluster_generation: Option<i64>,
    /// Specifies the time when the OpsRequest was completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "completionTimestamp")]
    pub completion_timestamp: Option<String>,
    /// Records the status information of components changed due to the operation request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<BTreeMap<String, OpsRequestStatusComponents>>,
    /// Describes the detailed status of the OpsRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// A collection of additional key-value pairs that provide supplementary information for the opsRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extras: Option<Vec<BTreeMap<String, String>>>,
    /// Records the last configuration before this operation took effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastConfiguration")]
    pub last_configuration: Option<OpsRequestStatusLastConfiguration>,
    /// Defines the phase of the OpsRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<OpsRequestStatusPhase>,
    /// Represents the progress of the OpsRequest.
    pub progress: String,
    /// Deprecated: Replaced by ReconfiguringStatusAsComponent. Defines the status information of reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconfiguringStatus")]
    pub reconfiguring_status: Option<OpsRequestStatusReconfiguringStatus>,
    /// Represents the status information of reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconfiguringStatusAsComponent")]
    pub reconfiguring_status_as_component: Option<BTreeMap<String, OpsRequestStatusReconfiguringStatusAsComponent>>,
    /// Indicates the time when the OpsRequest started processing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTimestamp")]
    pub start_timestamp: Option<String>,
}

/// Records the status information of components changed due to the operation request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusComponents {
    /// Indicates the last time the component phase transitioned to Failed or Abnormal.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastFailedTime")]
    pub last_failed_time: Option<String>,
    /// Provides a human-readable message indicating details about this operation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Describes the component phase, referencing Cluster.status.component.phase.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<OpsRequestStatusComponentsPhase>,
    /// Specifies the outcome of the preConditions check for the opsRequest. This result is crucial for determining the next steps in the operation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCheck")]
    pub pre_check: Option<OpsRequestStatusComponentsPreCheck>,
    /// Describes the progress details of the component for this operation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "progressDetails")]
    pub progress_details: Option<Vec<OpsRequestStatusComponentsProgressDetails>>,
    /// Describes the reason for the component phase.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// References the workload type of component in ClusterDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadType")]
    pub workload_type: Option<OpsRequestStatusComponentsWorkloadType>,
}

/// Records the status information of components changed due to the operation request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusComponentsPhase {
    Creating,
    Running,
    Updating,
    Stopping,
    Stopped,
    Deleting,
    Failed,
    Abnormal,
}

/// Specifies the outcome of the preConditions check for the opsRequest. This result is crucial for determining the next steps in the operation.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusComponentsPreCheck {
    /// Provides additional details about the preCheck operation in a human-readable format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Indicates whether the preCheck operation was successful or not.
    pub pass: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusComponentsProgressDetails {
    /// Refer to the action name of the OpsDefinition.spec.actions[*].name. either objectKey or actionName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "actionName")]
    pub action_name: Option<String>,
    /// Records the tasks associated with an action. such as Jobs/Pods that executes action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "actionTasks")]
    pub action_tasks: Option<Vec<OpsRequestStatusComponentsProgressDetailsActionTasks>>,
    /// Represents the completion time of object processing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Specifies the group to which the current object belongs. If the objects of a component belong to the same group, they can be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// Provides a human-readable message detailing the condition of the object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Represents the unique key of the object. either objectKey or actionName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectKey")]
    pub object_key: Option<String>,
    /// Represents the start time of object processing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// Indicates the state of processing the object.
    pub status: OpsRequestStatusComponentsProgressDetailsStatus,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusComponentsProgressDetailsActionTasks {
    /// Defines the namespace where the task workload is deployed.
    pub namespace: String,
    /// Specifies the name of the task workload.
    #[serde(rename = "objectKey")]
    pub object_key: String,
    /// The number of retry attempts for this task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retries: Option<i32>,
    /// Indicates the current status of the task.
    pub status: OpsRequestStatusComponentsProgressDetailsActionTasksStatus,
    /// The name of the target pod for the task.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodName")]
    pub target_pod_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusComponentsProgressDetailsActionTasksStatus {
    Processing,
    Failed,
    Succeed,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusComponentsProgressDetailsStatus {
    Processing,
    Pending,
    Failed,
    Succeed,
}

/// Records the status information of components changed due to the operation request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusComponentsWorkloadType {
    Stateless,
    Stateful,
    Consensus,
    Replication,
}

/// Records the last configuration before this operation took effect.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfiguration {
    /// Specifies the reference to the ClusterVersion name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterVersionRef")]
    pub cluster_version_ref: Option<String>,
    /// Records the last configuration of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<BTreeMap<String, OpsRequestStatusLastConfigurationComponents>>,
}

/// Records the last configuration of the component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponents {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<OpsRequestStatusLastConfigurationComponentsClaims>>,
    /// References a class defined in ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classDefRef")]
    pub class_def_ref: Option<OpsRequestStatusLastConfigurationComponentsClassDefRef>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Represents the last replicas of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
    /// Records the last services of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<OpsRequestStatusLastConfigurationComponentsServices>>,
    /// Records the information about the target resources affected by the component. The resource key is in the list of [pods].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetResources")]
    pub target_resources: Option<BTreeMap<String, String>>,
    /// Records the last volumeClaimTemplates of the component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Option<Vec<OpsRequestStatusLastConfigurationComponentsVolumeClaimTemplates>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponentsClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// References a class defined in ComponentClassDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponentsClassDefRef {
    /// Defines the name of the class that is defined in the ComponentClassDefinition.
    pub class: String,
    /// Specifies the name of the ComponentClassDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponentsServices {
    /// If ServiceType is LoadBalancer, cloud provider related parameters can be put here. More info: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// The name of the service.
    pub name: String,
    /// Determines how the Service is exposed. Valid options are ClusterIP, NodePort, and LoadBalancer. 
    ///  - `ClusterIP` allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, they are determined by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. - `NodePort` builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. - `LoadBalancer` builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. 
    ///  More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<OpsRequestStatusLastConfigurationComponentsServicesServiceType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusLastConfigurationComponentsServicesServiceType {
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    NodePort,
    LoadBalancer,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusLastConfigurationComponentsVolumeClaimTemplates {
    /// A reference to the volumeClaimTemplate name from the cluster components.
    pub name: String,
    /// Specifies the requested storage size for the volume.
    pub storage: IntOrString,
}

/// OpsRequestStatus represents the observed state of an OpsRequest.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusPhase {
    Pending,
    Creating,
    Running,
    Cancelling,
    Cancelled,
    Failed,
    Succeed,
}

/// Deprecated: Replaced by ReconfiguringStatusAsComponent. Defines the status information of reconfiguring.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatus {
    /// Describes the reconfiguring detail status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// Describes the status of the component reconfiguring.
    #[serde(rename = "configurationStatus")]
    pub configuration_status: Vec<OpsRequestStatusReconfiguringStatusConfigurationStatus>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusConfigurationStatus {
    /// Specifies the number of expected reconfigurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectedCount")]
    pub expected_count: Option<i32>,
    /// Stores the last applied configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedConfiguration")]
    pub last_applied_configuration: Option<BTreeMap<String, String>>,
    /// Records the last status of the reconfiguration controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastStatus")]
    pub last_status: Option<String>,
    /// Provides details about the operation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Specifies the name of the configuration template.
    pub name: String,
    /// Indicates the current state of the reconfiguration state machine.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// Counts the number of successful reconfigurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "succeedCount")]
    pub succeed_count: Option<i32>,
    /// Defines the policy for reconfiguration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    pub update_policy: Option<OpsRequestStatusReconfiguringStatusConfigurationStatusUpdatePolicy>,
    /// Contains the updated parameters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedParameters")]
    pub updated_parameters: Option<OpsRequestStatusReconfiguringStatusConfigurationStatusUpdatedParameters>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusReconfiguringStatusConfigurationStatusUpdatePolicy {
    #[serde(rename = "simple")]
    Simple,
    #[serde(rename = "parallel")]
    Parallel,
    #[serde(rename = "rolling")]
    Rolling,
    #[serde(rename = "autoReload")]
    AutoReload,
    #[serde(rename = "operatorSyncUpdate")]
    OperatorSyncUpdate,
    #[serde(rename = "dynamicReloadBeginRestart")]
    DynamicReloadBeginRestart,
}

/// Contains the updated parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusConfigurationStatusUpdatedParameters {
    /// Lists the keys that have been added.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addedKeys")]
    pub added_keys: Option<BTreeMap<String, String>>,
    /// Lists the keys that have been deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletedKeys")]
    pub deleted_keys: Option<BTreeMap<String, String>>,
    /// Lists the keys that have been updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedKeys")]
    pub updated_keys: Option<BTreeMap<String, String>>,
}

/// Represents the status information of reconfiguring.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusAsComponent {
    /// Describes the reconfiguring detail status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// Describes the status of the component reconfiguring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configurationStatus")]
    pub configuration_status: Option<Vec<OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatus>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatus {
    /// Specifies the number of expected reconfigurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectedCount")]
    pub expected_count: Option<i32>,
    /// Stores the last applied configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedConfiguration")]
    pub last_applied_configuration: Option<BTreeMap<String, String>>,
    /// Records the last status of the reconfiguration controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastStatus")]
    pub last_status: Option<String>,
    /// Provides details about the operation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Specifies the name of the configuration template.
    pub name: String,
    /// Indicates the current state of the reconfiguration state machine.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// Counts the number of successful reconfigurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "succeedCount")]
    pub succeed_count: Option<i32>,
    /// Defines the policy for reconfiguration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePolicy")]
    pub update_policy: Option<OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatusUpdatePolicy>,
    /// Contains the updated parameters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedParameters")]
    pub updated_parameters: Option<OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatusUpdatedParameters>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatusUpdatePolicy {
    #[serde(rename = "simple")]
    Simple,
    #[serde(rename = "parallel")]
    Parallel,
    #[serde(rename = "rolling")]
    Rolling,
    #[serde(rename = "autoReload")]
    AutoReload,
    #[serde(rename = "operatorSyncUpdate")]
    OperatorSyncUpdate,
    #[serde(rename = "dynamicReloadBeginRestart")]
    DynamicReloadBeginRestart,
}

/// Contains the updated parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OpsRequestStatusReconfiguringStatusAsComponentConfigurationStatusUpdatedParameters {
    /// Lists the keys that have been added.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addedKeys")]
    pub added_keys: Option<BTreeMap<String, String>>,
    /// Lists the keys that have been deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletedKeys")]
    pub deleted_keys: Option<BTreeMap<String, String>>,
    /// Lists the keys that have been updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedKeys")]
    pub updated_keys: Option<BTreeMap<String, String>>,
}

