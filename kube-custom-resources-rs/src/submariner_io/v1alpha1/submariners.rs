// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/submariner-io/submariner-operator/submariner.io/v1alpha1/submariners.yaml --derive=Default --derive=PartialEq
// kopium version: 0.17.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;

/// SubmarinerSpec defines the desired state of Submariner.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "submariner.io", version = "v1alpha1", kind = "Submariner", plural = "submariners")]
#[kube(namespaced)]
#[kube(status = "SubmarinerStatus")]
#[kube(schema = "disabled")]
pub struct SubmarinerSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "airGappedDeployment")]
    pub air_gapped_deployment: Option<bool>,
    /// Type of broker (must be "k8s").
    pub broker: String,
    /// The broker API URL.
    #[serde(rename = "brokerK8sApiServer")]
    pub broker_k8s_api_server: String,
    /// The broker API Token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerK8sApiServerToken")]
    pub broker_k8s_api_server_token: Option<String>,
    /// The broker certificate authority.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerK8sCA")]
    pub broker_k8s_ca: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerK8sInsecure")]
    pub broker_k8s_insecure: Option<bool>,
    /// The Broker namespace.
    #[serde(rename = "brokerK8sRemoteNamespace")]
    pub broker_k8s_remote_namespace: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerK8sSecret")]
    pub broker_k8s_secret: Option<String>,
    /// Cable driver implementation - any of [libreswan, wireguard, vxlan].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cableDriver")]
    pub cable_driver: Option<String>,
    /// Enable logging IPsec debugging information.
    #[serde(rename = "ceIPSecDebug")]
    pub ce_ip_sec_debug: bool,
    /// Force UDP encapsulation for IPsec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecForceUDPEncaps")]
    pub ce_ip_sec_force_udp_encaps: Option<bool>,
    /// The IPsec IKE port (500 usually).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecIKEPort")]
    pub ce_ip_sec_ike_port: Option<i64>,
    /// The IPsec NAT traversal port (4500 usually).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecNATTPort")]
    pub ce_ip_sec_natt_port: Option<i64>,
    /// The IPsec Pre-Shared Key which must be identical in all route agents across the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecPSK")]
    pub ce_ip_sec_psk: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecPSKSecret")]
    pub ce_ip_sec_psk_secret: Option<String>,
    /// Enable this cluster as a preferred server for data-plane connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecPreferredServer")]
    pub ce_ip_sec_preferred_server: Option<bool>,
    /// The cluster CIDR.
    #[serde(rename = "clusterCIDR")]
    pub cluster_cidr: String,
    /// The cluster ID used to identify the tunnels.
    #[serde(rename = "clusterID")]
    pub cluster_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "colorCodes")]
    pub color_codes: Option<String>,
    /// The gateway connection health check.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionHealthCheck")]
    pub connection_health_check: Option<SubmarinerConnectionHealthCheck>,
    /// Name of the custom CoreDNS configmap to configure forwarding to Lighthouse. It should be in <namespace>/<name> format where <namespace> is optional and defaults to kube-system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreDNSCustomConfig")]
    pub core_dns_custom_config: Option<SubmarinerCoreDnsCustomConfig>,
    /// List of domains to use for multi-cluster service discovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customDomains")]
    pub custom_domains: Option<Vec<String>>,
    /// Enable operator debugging.
    pub debug: bool,
    /// The Global CIDR super-net range for allocating GlobalCIDRs to each cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalCIDR")]
    pub global_cidr: Option<String>,
    /// Halt on certificate error (so the pod gets restarted).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "haltOnCertificateError")]
    pub halt_on_certificate_error: Option<bool>,
    /// Override component images.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageOverrides")]
    pub image_overrides: Option<BTreeMap<String, String>>,
    /// Enable automatic Load Balancer in front of the gateways.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerEnabled")]
    pub load_balancer_enabled: Option<bool>,
    /// The namespace in which to deploy the submariner operator.
    pub namespace: String,
    /// Enable NAT between clusters.
    #[serde(rename = "natEnabled")]
    pub nat_enabled: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// The image repository.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    /// The service CIDR.
    #[serde(rename = "serviceCIDR")]
    pub service_cidr: String,
    /// Enable support for Service Discovery (Lighthouse).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDiscoveryEnabled")]
    pub service_discovery_enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<SubmarinerTolerations>>,
    /// The image tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// The gateway connection health check.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerConnectionHealthCheck {
    /// Enable the connection health check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The interval at which health check pings are sent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSeconds")]
    pub interval_seconds: Option<i64>,
    /// The maximum number of packets lost at which the health checker will mark the connection as down.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPacketLossCount")]
    pub max_packet_loss_count: Option<i64>,
}

/// Name of the custom CoreDNS configmap to configure forwarding to Lighthouse. It should be in <namespace>/<name> format where <namespace> is optional and defaults to kube-system.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerCoreDnsCustomConfig {
    /// Name of the custom CoreDNS configmap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapName")]
    pub config_map_name: Option<String>,
    /// Namespace of the custom CoreDNS configmap.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// SubmarinerStatus defines the observed state of Submariner.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "airGappedDeployment")]
    pub air_gapped_deployment: Option<bool>,
    /// The current cluster CIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterCIDR")]
    pub cluster_cidr: Option<String>,
    /// The current cluster ID.
    #[serde(rename = "clusterID")]
    pub cluster_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "colorCodes")]
    pub color_codes: Option<String>,
    /// Information about the deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentInfo")]
    pub deployment_info: Option<SubmarinerStatusDeploymentInfo>,
    /// The status of the gateway DaemonSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayDaemonSetStatus")]
    pub gateway_daemon_set_status: Option<SubmarinerStatusGatewayDaemonSetStatus>,
    /// Status of the gateways in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateways: Option<Vec<SubmarinerStatusGateways>>,
    /// The current global CIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalCIDR")]
    pub global_cidr: Option<String>,
    /// The status of the Globalnet DaemonSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalnetDaemonSetStatus")]
    pub globalnet_daemon_set_status: Option<SubmarinerStatusGlobalnetDaemonSetStatus>,
    /// The status of the load balancer DaemonSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerStatus")]
    pub load_balancer_status: Option<SubmarinerStatusLoadBalancerStatus>,
    /// The current NAT status.
    #[serde(rename = "natEnabled")]
    pub nat_enabled: bool,
    /// The current network plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPlugin")]
    pub network_plugin: Option<String>,
    /// The status of the route agent DaemonSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAgentDaemonSetStatus")]
    pub route_agent_daemon_set_status: Option<SubmarinerStatusRouteAgentDaemonSetStatus>,
    /// The current service CIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceCIDR")]
    pub service_cidr: Option<String>,
    /// The image version in use by the various Submariner DaemonSets and Deployments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Information about the deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusDeploymentInfo {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudProvider")]
    pub cloud_provider: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesType")]
    pub kubernetes_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesTypeVersion")]
    pub kubernetes_type_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesVersion")]
    pub kubernetes_version: Option<String>,
}

/// The status of the gateway DaemonSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastResourceVersion")]
    pub last_resource_version: Option<String>,
    #[serde(rename = "mismatchedContainerImages")]
    pub mismatched_container_images: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonReadyContainerStates")]
    pub non_ready_container_states: Option<Vec<SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStates>>,
    /// DaemonSetStatus represents the current status of a daemon set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<SubmarinerStatusGatewayDaemonSetStatusStatus>,
}

/// ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStates {
    /// Details about a running container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub running: Option<SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesRunning>,
    /// Details about a terminated container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub terminated: Option<SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesTerminated>,
    /// Details about a waiting container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub waiting: Option<SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesWaiting>,
}

/// Details about a running container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesRunning {
    /// Time at which the container was last (re-)started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a terminated container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesTerminated {
    /// Container's ID in the format '<type>://<container_id>'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerID")]
    pub container_id: Option<String>,
    /// Exit status from the last termination of the container
    #[serde(rename = "exitCode")]
    pub exit_code: i32,
    /// Time at which the container last terminated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finishedAt")]
    pub finished_at: Option<String>,
    /// Message regarding the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// Signal from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<i32>,
    /// Time at which previous execution of the container started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a waiting container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesWaiting {
    /// Message regarding why the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// DaemonSetStatus represents the current status of a daemon set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusStatus {
    /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collisionCount")]
    pub collision_count: Option<i32>,
    /// Represents the latest available observations of a DaemonSet's current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "currentNumberScheduled")]
    pub current_number_scheduled: i32,
    /// The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "desiredNumberScheduled")]
    pub desired_number_scheduled: i32,
    /// The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberAvailable")]
    pub number_available: Option<i32>,
    /// The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "numberMisscheduled")]
    pub number_misscheduled: i32,
    /// numberReady is the number of nodes that should be running the daemon pod and have one or more of the daemon pod running with a Ready Condition.
    #[serde(rename = "numberReady")]
    pub number_ready: i32,
    /// The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberUnavailable")]
    pub number_unavailable: Option<i32>,
    /// The most recent generation observed by the daemon set controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// The total number of nodes that are running updated daemon pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedNumberScheduled")]
    pub updated_number_scheduled: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGateways {
    pub connections: Vec<SubmarinerStatusGatewaysConnections>,
    #[serde(rename = "haStatus")]
    pub ha_status: String,
    #[serde(rename = "localEndpoint")]
    pub local_endpoint: SubmarinerStatusGatewaysLocalEndpoint,
    #[serde(rename = "statusFailure")]
    pub status_failure: String,
    pub version: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewaysConnections {
    pub endpoint: SubmarinerStatusGatewaysConnectionsEndpoint,
    /// LatencySpec describes the round trip time information for a packet between the gateway pods of two clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "latencyRTT")]
    pub latency_rtt: Option<SubmarinerStatusGatewaysConnectionsLatencyRtt>,
    pub status: String,
    #[serde(rename = "statusMessage")]
    pub status_message: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usingIP")]
    pub using_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usingNAT")]
    pub using_nat: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewaysConnectionsEndpoint {
    pub backend: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backend_config: Option<BTreeMap<String, String>>,
    pub cable_name: String,
    pub cluster_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIP")]
    pub health_check_ip: Option<String>,
    pub hostname: String,
    pub nat_enabled: bool,
    pub private_ip: String,
    pub public_ip: String,
    pub subnets: Vec<String>,
}

/// LatencySpec describes the round trip time information for a packet between the gateway pods of two clusters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewaysConnectionsLatencyRtt {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub average: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub min: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdDev")]
    pub std_dev: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewaysLocalEndpoint {
    pub backend: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backend_config: Option<BTreeMap<String, String>>,
    pub cable_name: String,
    pub cluster_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIP")]
    pub health_check_ip: Option<String>,
    pub hostname: String,
    pub nat_enabled: bool,
    pub private_ip: String,
    pub public_ip: String,
    pub subnets: Vec<String>,
}

/// The status of the Globalnet DaemonSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastResourceVersion")]
    pub last_resource_version: Option<String>,
    #[serde(rename = "mismatchedContainerImages")]
    pub mismatched_container_images: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonReadyContainerStates")]
    pub non_ready_container_states: Option<Vec<SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStates>>,
    /// DaemonSetStatus represents the current status of a daemon set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<SubmarinerStatusGlobalnetDaemonSetStatusStatus>,
}

/// ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStates {
    /// Details about a running container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub running: Option<SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesRunning>,
    /// Details about a terminated container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub terminated: Option<SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesTerminated>,
    /// Details about a waiting container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub waiting: Option<SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesWaiting>,
}

/// Details about a running container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesRunning {
    /// Time at which the container was last (re-)started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a terminated container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesTerminated {
    /// Container's ID in the format '<type>://<container_id>'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerID")]
    pub container_id: Option<String>,
    /// Exit status from the last termination of the container
    #[serde(rename = "exitCode")]
    pub exit_code: i32,
    /// Time at which the container last terminated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finishedAt")]
    pub finished_at: Option<String>,
    /// Message regarding the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// Signal from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<i32>,
    /// Time at which previous execution of the container started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a waiting container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesWaiting {
    /// Message regarding why the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// DaemonSetStatus represents the current status of a daemon set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusStatus {
    /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collisionCount")]
    pub collision_count: Option<i32>,
    /// Represents the latest available observations of a DaemonSet's current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "currentNumberScheduled")]
    pub current_number_scheduled: i32,
    /// The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "desiredNumberScheduled")]
    pub desired_number_scheduled: i32,
    /// The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberAvailable")]
    pub number_available: Option<i32>,
    /// The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "numberMisscheduled")]
    pub number_misscheduled: i32,
    /// numberReady is the number of nodes that should be running the daemon pod and have one or more of the daemon pod running with a Ready Condition.
    #[serde(rename = "numberReady")]
    pub number_ready: i32,
    /// The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberUnavailable")]
    pub number_unavailable: Option<i32>,
    /// The most recent generation observed by the daemon set controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// The total number of nodes that are running updated daemon pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedNumberScheduled")]
    pub updated_number_scheduled: Option<i32>,
}

/// The status of the load balancer DaemonSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusLoadBalancerStatus {
    /// LoadBalancerStatus represents the status of a load-balancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<SubmarinerStatusLoadBalancerStatusStatus>,
}

/// LoadBalancerStatus represents the status of a load-balancer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusLoadBalancerStatusStatus {
    /// Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<Vec<SubmarinerStatusLoadBalancerStatusStatusIngress>>,
}

/// LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusLoadBalancerStatusStatusIngress {
    /// Hostname is set for load-balancer ingress points that are DNS based (typically AWS load-balancers)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack load-balancers)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
    /// Ports is a list of records of service ports If used, every port defined in the service should have an entry in it
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<SubmarinerStatusLoadBalancerStatusStatusIngressPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusLoadBalancerStatusStatusIngressPorts {
    /// Error is to record the problem with the service port The format of the error shall comply with the following rules: - built-in error values shall be specified in this file and those shall use CamelCase names - cloud provider specific error values must have names that comply with the format foo.example.com/CamelCase. --- The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    /// Port is the port number of the service port of which status is recorded here
    pub port: i32,
    /// Protocol is the protocol of the service port of which status is recorded here The supported values are: "TCP", "UDP", "SCTP"
    pub protocol: String,
}

/// The status of the route agent DaemonSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastResourceVersion")]
    pub last_resource_version: Option<String>,
    #[serde(rename = "mismatchedContainerImages")]
    pub mismatched_container_images: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonReadyContainerStates")]
    pub non_ready_container_states: Option<Vec<SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStates>>,
    /// DaemonSetStatus represents the current status of a daemon set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<SubmarinerStatusRouteAgentDaemonSetStatusStatus>,
}

/// ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStates {
    /// Details about a running container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub running: Option<SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesRunning>,
    /// Details about a terminated container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub terminated: Option<SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesTerminated>,
    /// Details about a waiting container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub waiting: Option<SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesWaiting>,
}

/// Details about a running container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesRunning {
    /// Time at which the container was last (re-)started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a terminated container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesTerminated {
    /// Container's ID in the format '<type>://<container_id>'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerID")]
    pub container_id: Option<String>,
    /// Exit status from the last termination of the container
    #[serde(rename = "exitCode")]
    pub exit_code: i32,
    /// Time at which the container last terminated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finishedAt")]
    pub finished_at: Option<String>,
    /// Message regarding the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// Signal from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<i32>,
    /// Time at which previous execution of the container started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a waiting container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesWaiting {
    /// Message regarding why the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// DaemonSetStatus represents the current status of a daemon set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusStatus {
    /// Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collisionCount")]
    pub collision_count: Option<i32>,
    /// Represents the latest available observations of a DaemonSet's current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "currentNumberScheduled")]
    pub current_number_scheduled: i32,
    /// The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "desiredNumberScheduled")]
    pub desired_number_scheduled: i32,
    /// The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberAvailable")]
    pub number_available: Option<i32>,
    /// The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "numberMisscheduled")]
    pub number_misscheduled: i32,
    /// numberReady is the number of nodes that should be running the daemon pod and have one or more of the daemon pod running with a Ready Condition.
    #[serde(rename = "numberReady")]
    pub number_ready: i32,
    /// The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberUnavailable")]
    pub number_unavailable: Option<i32>,
    /// The most recent generation observed by the daemon set controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// The total number of nodes that are running updated daemon pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedNumberScheduled")]
    pub updated_number_scheduled: Option<i32>,
}

