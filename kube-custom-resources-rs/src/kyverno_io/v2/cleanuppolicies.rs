// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/kyverno/kyverno/kyverno.io/v2/cleanuppolicies.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// Spec declares policy behaviors.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "kyverno.io", version = "v2", kind = "CleanupPolicy", plural = "cleanuppolicies")]
#[kube(namespaced)]
#[kube(status = "CleanupPolicyStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct CleanupPolicySpec {
    /// Conditions defines the conditions used to select the resources which will be cleaned up.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<CleanupPolicyConditions>,
    /// Context defines variables and data sources that can be used during rule execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<Vec<CleanupPolicyContext>>,
    /// ExcludeResources defines when cleanuppolicy should not be applied. The exclude
    /// criteria can include resource information (e.g. kind, name, namespace, labels)
    /// and admission review request information like the name or role.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exclude: Option<CleanupPolicyExclude>,
    /// MatchResources defines when cleanuppolicy should be applied. The match
    /// criteria can include resource information (e.g. kind, name, namespace, labels)
    /// and admission review request information like the user name or role.
    /// At least one kind is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<CleanupPolicyMatch>,
    /// The schedule in Cron format
    pub schedule: String,
}

/// Conditions defines the conditions used to select the resources which will be cleaned up.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyConditions {
    /// AllConditions enable variable-based conditional rule execution. This is useful for
    /// finer control of when an rule is applied. A condition can reference object data
    /// using JMESPath notation.
    /// Here, all of the conditions need to pass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<CleanupPolicyConditionsAll>>,
    /// AnyConditions enable variable-based conditional rule execution. This is useful for
    /// finer control of when an rule is applied. A condition can reference object data
    /// using JMESPath notation.
    /// Here, at least one of the conditions need to pass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<CleanupPolicyConditionsAny>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyConditionsAll {
    /// Key is the context entry (using JMESPath) for conditional rule evaluation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<serde_json::Value>,
    /// Message is an optional display message
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Operator is the conditional operation to perform. Valid operators are:
    /// Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    /// GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    /// DurationLessThanOrEquals, DurationLessThan
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<CleanupPolicyConditionsAllOperator>,
    /// Value is the conditional value, or set of values. The values can be fixed set
    /// or can be variables declared using JMESPath.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CleanupPolicyConditionsAllOperator {
    Equals,
    NotEquals,
    AnyIn,
    AllIn,
    AnyNotIn,
    AllNotIn,
    GreaterThanOrEquals,
    GreaterThan,
    LessThanOrEquals,
    LessThan,
    DurationGreaterThanOrEquals,
    DurationGreaterThan,
    DurationLessThanOrEquals,
    DurationLessThan,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyConditionsAny {
    /// Key is the context entry (using JMESPath) for conditional rule evaluation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<serde_json::Value>,
    /// Message is an optional display message
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Operator is the conditional operation to perform. Valid operators are:
    /// Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    /// GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    /// DurationLessThanOrEquals, DurationLessThan
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<CleanupPolicyConditionsAnyOperator>,
    /// Value is the conditional value, or set of values. The values can be fixed set
    /// or can be variables declared using JMESPath.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CleanupPolicyConditionsAnyOperator {
    Equals,
    NotEquals,
    AnyIn,
    AllIn,
    AnyNotIn,
    AllNotIn,
    GreaterThanOrEquals,
    GreaterThan,
    LessThanOrEquals,
    LessThan,
    DurationGreaterThanOrEquals,
    DurationGreaterThan,
    DurationLessThanOrEquals,
    DurationLessThan,
}

/// ContextEntry adds variables and data sources to a rule Context. Either a
/// ConfigMap reference or a APILookup must be provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyContext {
    /// APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
    /// The data returned is stored in the context with the name for the context entry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiCall")]
    pub api_call: Option<CleanupPolicyContextApiCall>,
    /// ConfigMap is the ConfigMap reference.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CleanupPolicyContextConfigMap>,
    /// GlobalContextEntryReference is a reference to a cached global context entry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalReference")]
    pub global_reference: Option<CleanupPolicyContextGlobalReference>,
    /// ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
    /// details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistry")]
    pub image_registry: Option<CleanupPolicyContextImageRegistry>,
    /// Name is the variable name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Variable defines an arbitrary JMESPath context variable that can be defined inline.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variable: Option<CleanupPolicyContextVariable>,
}

/// APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
/// The data returned is stored in the context with the name for the context entry.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyContextApiCall {
    /// The data object specifies the POST data sent to the server.
    /// Only applicable when the method field is set to POST.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<Vec<CleanupPolicyContextApiCallData>>,
    /// JMESPath is an optional JSON Match Expression that can be used to
    /// transform the JSON response returned from the server. For example
    /// a JMESPath of "items | length(@)" applied to the API server response
    /// for the URLPath "/apis/apps/v1/deployments" will return the total count
    /// of deployments across all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jmesPath")]
    pub jmes_path: Option<String>,
    /// Method is the HTTP request type (GET or POST). Defaults to GET.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<CleanupPolicyContextApiCallMethod>,
    /// Service is an API call to a JSON web service.
    /// This is used for non-Kubernetes API server calls.
    /// It's mutually exclusive with the URLPath field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<CleanupPolicyContextApiCallService>,
    /// URLPath is the URL path to be used in the HTTP GET or POST request to the
    /// Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
    /// The format required is the same format used by the `kubectl get --raw` command.
    /// See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
    /// for details.
    /// It's mutually exclusive with the Service field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlPath")]
    pub url_path: Option<String>,
}

/// RequestData contains the HTTP POST data
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyContextApiCallData {
    /// Key is a unique identifier for the data value
    pub key: String,
    /// Value is the data value
    pub value: serde_json::Value,
}

/// APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
/// The data returned is stored in the context with the name for the context entry.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CleanupPolicyContextApiCallMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
}

/// Service is an API call to a JSON web service.
/// This is used for non-Kubernetes API server calls.
/// It's mutually exclusive with the URLPath field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyContextApiCallService {
    /// CABundle is a PEM encoded CA bundle which will be used to validate
    /// the server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caBundle")]
    pub ca_bundle: Option<String>,
    /// URL is the JSON web service URL. A typical form is
    /// `https://{service}.{namespace}:{port}/{path}`.
    pub url: String,
}

/// ConfigMap is the ConfigMap reference.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyContextConfigMap {
    /// Name is the ConfigMap name.
    pub name: String,
    /// Namespace is the ConfigMap namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// GlobalContextEntryReference is a reference to a cached global context entry.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyContextGlobalReference {
    /// JMESPath is an optional JSON Match Expression that can be used to
    /// transform the JSON response returned from the server. For example
    /// a JMESPath of "items | length(@)" applied to the API server response
    /// for the URLPath "/apis/apps/v1/deployments" will return the total count
    /// of deployments across all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jmesPath")]
    pub jmes_path: Option<String>,
    /// Name of the global context entry
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
/// details.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyContextImageRegistry {
    /// ImageRegistryCredentials provides credentials that will be used for authentication with registry
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistryCredentials")]
    pub image_registry_credentials: Option<CleanupPolicyContextImageRegistryImageRegistryCredentials>,
    /// JMESPath is an optional JSON Match Expression that can be used to
    /// transform the ImageData struct returned as a result of processing
    /// the image reference.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jmesPath")]
    pub jmes_path: Option<String>,
    /// Reference is image reference to a container image in the registry.
    /// Example: ghcr.io/kyverno/kyverno:latest
    pub reference: String,
}

/// ImageRegistryCredentials provides credentials that will be used for authentication with registry
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyContextImageRegistryImageRegistryCredentials {
    /// AllowInsecureRegistry allows insecure access to a registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowInsecureRegistry")]
    pub allow_insecure_registry: Option<bool>,
    /// Providers specifies a list of OCI Registry names, whose authentication providers are provided.
    /// It can be of one of these values: default,google,azure,amazon,github.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub providers: Option<Vec<String>>,
    /// Secrets specifies a list of secrets that are provided for credentials.
    /// Secrets must live in the Kyverno namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
}

/// Variable defines an arbitrary JMESPath context variable that can be defined inline.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyContextVariable {
    /// Default is an optional arbitrary JSON object that the variable may take if the JMESPath
    /// expression evaluates to nil
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    /// JMESPath is an optional JMESPath Expression that can be used to
    /// transform the variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jmesPath")]
    pub jmes_path: Option<String>,
    /// Value is any arbitrary JSON object representable in YAML or JSON form.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// ExcludeResources defines when cleanuppolicy should not be applied. The exclude
/// criteria can include resource information (e.g. kind, name, namespace, labels)
/// and admission review request information like the name or role.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExclude {
    /// All allows specifying resources which will be ANDed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<CleanupPolicyExcludeAll>>,
    /// Any allows specifying resources which will be ORed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<CleanupPolicyExcludeAny>>,
}

/// ResourceFilter allow users to "AND" or "OR" between resources
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAll {
    /// ClusterRoles is the list of cluster-wide role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRoles")]
    pub cluster_roles: Option<Vec<String>>,
    /// ResourceDescription contains information about the resource being created or modified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CleanupPolicyExcludeAllResources>,
    /// Roles is the list of namespaced role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
    /// Subjects is the list of subject names like users, user groups, and service accounts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<CleanupPolicyExcludeAllSubjects>>,
}

/// ResourceDescription contains information about the resource being created or modified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAllResources {
    /// Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
    /// and values support the wildcard characters "*" (matches zero or many characters) and
    /// "?" (matches at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Kinds is a list of resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinds: Option<Vec<String>>,
    /// Name is the name of the resource. The name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    /// NOTE: "Name" is being deprecated in favor of "Names".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Names are the names of the resources. Each name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// NamespaceSelector is a label selector for the resource namespace. Label keys and values
    /// in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
    /// and `?` (matches one character).Wildcards allows writing label selectors like
    /// ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
    /// does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CleanupPolicyExcludeAllResourcesNamespaceSelector>,
    /// Namespaces is a list of namespaces names. Each name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
    /// characters `*` (matches zero or many characters) and `?` (matches one character).
    /// Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
    /// using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CleanupPolicyExcludeAllResourcesSelector>,
}

/// NamespaceSelector is a label selector for the resource namespace. Label keys and values
/// in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
/// and `?` (matches one character).Wildcards allows writing label selectors like
/// ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
/// does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAllResourcesNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyExcludeAllResourcesNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAllResourcesNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
/// characters `*` (matches zero or many characters) and `?` (matches one character).
/// Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
/// using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAllResourcesSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyExcludeAllResourcesSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAllResourcesSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
/// or a value for non-objects such as user and group names.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAllSubjects {
    /// APIGroup holds the API group of the referenced subject.
    /// Defaults to "" for ServiceAccount subjects.
    /// Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
    /// If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    pub kind: String,
    /// Name of the object being referenced.
    pub name: String,
    /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
    /// the Authorizer should report an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ResourceFilter allow users to "AND" or "OR" between resources
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAny {
    /// ClusterRoles is the list of cluster-wide role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRoles")]
    pub cluster_roles: Option<Vec<String>>,
    /// ResourceDescription contains information about the resource being created or modified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CleanupPolicyExcludeAnyResources>,
    /// Roles is the list of namespaced role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
    /// Subjects is the list of subject names like users, user groups, and service accounts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<CleanupPolicyExcludeAnySubjects>>,
}

/// ResourceDescription contains information about the resource being created or modified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAnyResources {
    /// Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
    /// and values support the wildcard characters "*" (matches zero or many characters) and
    /// "?" (matches at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Kinds is a list of resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinds: Option<Vec<String>>,
    /// Name is the name of the resource. The name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    /// NOTE: "Name" is being deprecated in favor of "Names".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Names are the names of the resources. Each name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// NamespaceSelector is a label selector for the resource namespace. Label keys and values
    /// in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
    /// and `?` (matches one character).Wildcards allows writing label selectors like
    /// ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
    /// does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CleanupPolicyExcludeAnyResourcesNamespaceSelector>,
    /// Namespaces is a list of namespaces names. Each name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
    /// characters `*` (matches zero or many characters) and `?` (matches one character).
    /// Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
    /// using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CleanupPolicyExcludeAnyResourcesSelector>,
}

/// NamespaceSelector is a label selector for the resource namespace. Label keys and values
/// in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
/// and `?` (matches one character).Wildcards allows writing label selectors like
/// ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
/// does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAnyResourcesNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyExcludeAnyResourcesNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAnyResourcesNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
/// characters `*` (matches zero or many characters) and `?` (matches one character).
/// Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
/// using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAnyResourcesSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyExcludeAnyResourcesSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAnyResourcesSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
/// or a value for non-objects such as user and group names.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyExcludeAnySubjects {
    /// APIGroup holds the API group of the referenced subject.
    /// Defaults to "" for ServiceAccount subjects.
    /// Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
    /// If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    pub kind: String,
    /// Name of the object being referenced.
    pub name: String,
    /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
    /// the Authorizer should report an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// MatchResources defines when cleanuppolicy should be applied. The match
/// criteria can include resource information (e.g. kind, name, namespace, labels)
/// and admission review request information like the user name or role.
/// At least one kind is required.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatch {
    /// All allows specifying resources which will be ANDed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<CleanupPolicyMatchAll>>,
    /// Any allows specifying resources which will be ORed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<CleanupPolicyMatchAny>>,
}

/// ResourceFilter allow users to "AND" or "OR" between resources
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAll {
    /// ClusterRoles is the list of cluster-wide role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRoles")]
    pub cluster_roles: Option<Vec<String>>,
    /// ResourceDescription contains information about the resource being created or modified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CleanupPolicyMatchAllResources>,
    /// Roles is the list of namespaced role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
    /// Subjects is the list of subject names like users, user groups, and service accounts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<CleanupPolicyMatchAllSubjects>>,
}

/// ResourceDescription contains information about the resource being created or modified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAllResources {
    /// Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
    /// and values support the wildcard characters "*" (matches zero or many characters) and
    /// "?" (matches at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Kinds is a list of resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinds: Option<Vec<String>>,
    /// Name is the name of the resource. The name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    /// NOTE: "Name" is being deprecated in favor of "Names".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Names are the names of the resources. Each name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// NamespaceSelector is a label selector for the resource namespace. Label keys and values
    /// in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
    /// and `?` (matches one character).Wildcards allows writing label selectors like
    /// ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
    /// does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CleanupPolicyMatchAllResourcesNamespaceSelector>,
    /// Namespaces is a list of namespaces names. Each name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
    /// characters `*` (matches zero or many characters) and `?` (matches one character).
    /// Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
    /// using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CleanupPolicyMatchAllResourcesSelector>,
}

/// NamespaceSelector is a label selector for the resource namespace. Label keys and values
/// in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
/// and `?` (matches one character).Wildcards allows writing label selectors like
/// ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
/// does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAllResourcesNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyMatchAllResourcesNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAllResourcesNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
/// characters `*` (matches zero or many characters) and `?` (matches one character).
/// Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
/// using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAllResourcesSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyMatchAllResourcesSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAllResourcesSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
/// or a value for non-objects such as user and group names.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAllSubjects {
    /// APIGroup holds the API group of the referenced subject.
    /// Defaults to "" for ServiceAccount subjects.
    /// Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
    /// If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    pub kind: String,
    /// Name of the object being referenced.
    pub name: String,
    /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
    /// the Authorizer should report an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ResourceFilter allow users to "AND" or "OR" between resources
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAny {
    /// ClusterRoles is the list of cluster-wide role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRoles")]
    pub cluster_roles: Option<Vec<String>>,
    /// ResourceDescription contains information about the resource being created or modified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CleanupPolicyMatchAnyResources>,
    /// Roles is the list of namespaced role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
    /// Subjects is the list of subject names like users, user groups, and service accounts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<CleanupPolicyMatchAnySubjects>>,
}

/// ResourceDescription contains information about the resource being created or modified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAnyResources {
    /// Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
    /// and values support the wildcard characters "*" (matches zero or many characters) and
    /// "?" (matches at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Kinds is a list of resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinds: Option<Vec<String>>,
    /// Name is the name of the resource. The name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    /// NOTE: "Name" is being deprecated in favor of "Names".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Names are the names of the resources. Each name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// NamespaceSelector is a label selector for the resource namespace. Label keys and values
    /// in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
    /// and `?` (matches one character).Wildcards allows writing label selectors like
    /// ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
    /// does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CleanupPolicyMatchAnyResourcesNamespaceSelector>,
    /// Namespaces is a list of namespaces names. Each name supports wildcard characters
    /// "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
    /// characters `*` (matches zero or many characters) and `?` (matches one character).
    /// Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
    /// using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CleanupPolicyMatchAnyResourcesSelector>,
}

/// NamespaceSelector is a label selector for the resource namespace. Label keys and values
/// in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
/// and `?` (matches one character).Wildcards allows writing label selectors like
/// ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
/// does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAnyResourcesNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyMatchAnyResourcesNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAnyResourcesNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
/// characters `*` (matches zero or many characters) and `?` (matches one character).
/// Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
/// using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAnyResourcesSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyMatchAnyResourcesSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAnyResourcesSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
/// or a value for non-objects such as user and group names.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyMatchAnySubjects {
    /// APIGroup holds the API group of the referenced subject.
    /// Defaults to "" for ServiceAccount subjects.
    /// Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
    /// If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    pub kind: String,
    /// Name of the object being referenced.
    pub name: String,
    /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
    /// the Authorizer should report an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Status contains policy runtime data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CleanupPolicyStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastExecutionTime")]
    pub last_execution_time: Option<String>,
}

