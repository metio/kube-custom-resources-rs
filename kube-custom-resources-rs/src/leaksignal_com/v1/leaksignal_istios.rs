// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/leaksignal/leaksignal-operator/leaksignal.com/v1/leaksignal-istios.yaml --derive=Default --derive=PartialEq
// kopium version: 0.19.0

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "leaksignal.com", version = "v1", kind = "LeaksignalIstio", plural = "leaksignal-istios")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct LeaksignalIstioSpec {
    /// API Key from the LeakSignal Command dashboard. Alternatively, the deployment name from LeakAgent.
    #[serde(rename = "apiKey")]
    pub api_key: String,
    /// Location of CA bundle in istio-proxy. Default is `/etc/ssl/certs/ca-certificates.crt` which is suitable for Istio. OpenShift Service Mesh requires `/etc/ssl/certs/ca-bundle.crt`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caBundle")]
    pub ca_bundle: Option<String>,
    /// If `true` (default), then L4 streams are also scanned by LeakSignal Proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableStreaming")]
    pub enable_streaming: Option<bool>,
    /// If `true` (default), if LeakSignal Proxy has a failure, then all traffic is routed around it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOpen")]
    pub fail_open: Option<bool>,
    /// Whether to use Google GRPC or Envoy GRPC for WASM deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grpcMode")]
    pub grpc_mode: Option<LeaksignalIstioGrpcMode>,
    /// If set, use an alternate name for created EnvoyFilter objects, to allow multiple LeaksignalIstio objects in one namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "istioName")]
    pub istio_name: Option<String>,
    /// If `true` (not default), istio-proxy containers are updated to a corresponding image with support for dynamic plugins, and the native LeakSignal Proxy module is installed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub native: Option<bool>,
    /// Alternative memory limit for Istio sidecars running native modules. Useful to mitigate a surge of memory usage when loading the proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nativeProxyMemoryLimit")]
    pub native_proxy_memory_limit: Option<String>,
    /// Default is `leaksignal/istio-proxy`. If no tag is specified, it is inferred from the existing proxy image on each given pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nativeRepo")]
    pub native_repo: Option<String>,
    /// Hash of the downloaded bundle for LeakSignal Proxy. Will depend on your version and deployment mechanism (nginx, envoy, WASM).
    #[serde(rename = "proxyHash")]
    pub proxy_hash: String,
    /// Prefix of binary to pull. Defaults to `s3/leakproxy`. For LeakAgent deployments, use `proxy`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyPrefix")]
    pub proxy_prefix: Option<String>,
    /// Format `https?://domain(:port)?/`. Defaults to being based on `upstreamLocation`, `upstreamPort`, `tls`, and `proxyPrefix`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyPullLocation")]
    pub proxy_pull_location: Option<String>,
    /// Version string for LeakSignal Proxy deployment.
    #[serde(rename = "proxyVersion")]
    pub proxy_version: String,
    /// Detects pods that should have leaksignal deployed, but dont, and restarts them.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshPodsOnStale")]
    pub refresh_pods_on_stale: Option<bool>,
    /// For WASM mode, redeploys all pods with Istio sidecars affected by a LeakSignal Proxy upgrade. This provides more consistent behavior. Default is `true`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshPodsOnUpdate")]
    pub refresh_pods_on_update: Option<bool>,
    /// If `true` (default), TLS/HTTPS is used for telemetry upload and downloading LeakSignal Proxy. LeakAgent is usually `false`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<bool>,
    /// Hostname of upstream location to send metrics to. Default is `ingestion.app.leaksignal.com`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upstreamLocation")]
    pub upstream_location: Option<String>,
    /// Port of upstream ingestion. Defaults to 80/443 depending on `tls`. Recommended 8121 for LeakAgent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upstreamPort")]
    pub upstream_port: Option<i64>,
    /// Pod selector for workloads.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadSelector")]
    pub workload_selector: Option<LeaksignalIstioWorkloadSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum LeaksignalIstioGrpcMode {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "envoy")]
    Envoy,
}

/// Pod selector for workloads.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct LeaksignalIstioWorkloadSelector {
    /// Labels to match any pod before deploying LeakSignal.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

