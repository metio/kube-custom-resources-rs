// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive PartialEq --docs --filename ./crd-catalog/prometheus-operator/prometheus-operator/monitoring.coreos.com/v1alpha1/scrapeconfigs.yaml
// kopium version: 0.16.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// ScrapeConfigSpec is a specification of the desired configuration for a scrape configuration.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "monitoring.coreos.com", version = "v1alpha1", kind = "ScrapeConfig", plural = "scrapeconfigs")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
pub struct ScrapeConfigSpec {
    /// Authorization header to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigAuthorization>,
    /// BasicAuth information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigBasicAuth>,
    /// ConsulSDConfigs defines a list of Consul service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consulSDConfigs")]
    pub consul_sd_configs: Option<Vec<ScrapeConfigConsulSdConfigs>>,
    /// DNSSDConfigs defines a list of DNS service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsSDConfigs")]
    pub dns_sd_configs: Option<Vec<ScrapeConfigDnsSdConfigs>>,
    /// EC2SDConfigs defines a list of EC2 service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ec2SDConfigs")]
    pub ec2_sd_configs: Option<Vec<ScrapeConfigEc2SdConfigs>>,
    /// FileSDConfigs defines a list of file service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSDConfigs")]
    pub file_sd_configs: Option<Vec<ScrapeConfigFileSdConfigs>>,
    /// HonorLabels chooses the metric's labels on collisions with target labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorLabels")]
    pub honor_labels: Option<bool>,
    /// HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorTimestamps")]
    pub honor_timestamps: Option<bool>,
    /// HTTPSDConfigs defines a list of HTTP service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSDConfigs")]
    pub http_sd_configs: Option<Vec<ScrapeConfigHttpSdConfigs>>,
    /// Per-scrape limit on the number of targets dropped by relabeling that will be kept in memory. 0 means no limit. 
    ///  It requires Prometheus >= v2.47.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepDroppedTargets")]
    pub keep_dropped_targets: Option<i64>,
    /// KubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSDConfigs")]
    pub kubernetes_sd_configs: Option<Vec<ScrapeConfigKubernetesSdConfigs>>,
    /// Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelLimit")]
    pub label_limit: Option<i64>,
    /// Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelNameLengthLimit")]
    pub label_name_length_limit: Option<i64>,
    /// Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelValueLengthLimit")]
    pub label_value_length_limit: Option<i64>,
    /// MetricRelabelConfigs to apply to samples before ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelings")]
    pub metric_relabelings: Option<Vec<ScrapeConfigMetricRelabelings>>,
    /// MetricsPath HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g. /metrics).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsPath")]
    pub metrics_path: Option<String>,
    /// Optional HTTP URL parameters
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, String>>,
    /// RelabelConfigs defines how to rewrite the target's labels before scraping. Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields. The original scrape job's name is available via the `__tmp_prometheus_job_name` label. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relabelings: Option<Vec<ScrapeConfigRelabelings>>,
    /// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// Configures the protocol scheme used for requests. If empty, Prometheus uses HTTP by default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ScrapeConfigScheme>,
    /// ScrapeInterval is the interval between consecutive scrapes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeInterval")]
    pub scrape_interval: Option<String>,
    /// ScrapeTimeout is the number of seconds to wait until a scrape request times out.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// StaticConfigs defines a list of static targets with a common label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticConfigs")]
    pub static_configs: Option<Vec<ScrapeConfigStaticConfigs>>,
    /// TargetLimit defines a limit on the number of scraped targets that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLimit")]
    pub target_limit: Option<i64>,
    /// TLS configuration to use on every scrape request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigTlsConfig>,
}

/// Authorization header to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive. 
    ///  "Basic" is not a supported value. 
    ///  Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigBasicAuth {
    /// The secret in the service monitor namespace that contains the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigBasicAuthPassword>,
    /// The secret in the service monitor namespace that contains the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigBasicAuthUsername>,
}

/// The secret in the service monitor namespace that contains the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service monitor namespace that contains the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConsulSDConfig defines a Consul service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigs {
    /// Allow stale Consul results (see https://www.consul.io/api/features/consistency.html). Will reduce load on Consul. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_stale: Option<bool>,
    /// Authorization header configuration to authenticate against the Consul Server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigConsulSdConfigsAuthorization>,
    /// BasicAuth information to authenticate against the Consul Server. More info: https://prometheus.io/docs/operating/configuration/#endpoints
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigConsulSdConfigsBasicAuth>,
    /// Consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datacenter: Option<String>,
    /// Whether to enable HTTP2. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable_http2: Option<bool>,
    /// Configure whether HTTP requests follow HTTP 3xx redirects. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub follow_redirects: Option<bool>,
    /// Namespaces are only supported in Consul Enterprise.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub no_proxy: Option<String>,
    /// Node metadata key/value pairs to filter nodes for a given service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_meta: Option<BTreeMap<String, String>>,
    /// Optional OAuth 2.0 configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigConsulSdConfigsOauth2>,
    /// Admin Partitions are only supported in Consul Enterprise.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// Specifies headers to send to proxies during CONNECT requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_connect_header: Option<BTreeMap<String, ScrapeConfigConsulSdConfigsProxyConnectHeader>>,
    /// Use proxy URL indicated by environment variables (HTTP_PROXY, https_proxy, HTTPs_PROXY, https_proxy, and no_proxy) If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_from_environment: Option<bool>,
    /// Optional proxy URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_url: Option<String>,
    /// The time after which the provided names are refreshed. On large setup it might be a good idea to increase this value because the catalog will change all the time. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub refresh_interval: Option<String>,
    /// HTTP Scheme default "http"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ScrapeConfigConsulSdConfigsScheme>,
    /// A valid string consisting of a hostname or IP followed by an optional port number.
    pub server: String,
    /// A list of services for which targets are retrieved. If omitted, all services are scraped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<String>>,
    /// The string by which Consul tags are joined into the tag label. If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag_separator: Option<String>,
    /// An optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// TLS Config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigConsulSdConfigsTlsConfig>,
    /// Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenRef")]
    pub token_ref: Option<ScrapeConfigConsulSdConfigsTokenRef>,
}

/// Authorization header configuration to authenticate against the Consul Server.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigConsulSdConfigsAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive. 
    ///  "Basic" is not a supported value. 
    ///  Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to authenticate against the Consul Server. More info: https://prometheus.io/docs/operating/configuration/#endpoints
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsBasicAuth {
    /// The secret in the service monitor namespace that contains the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigConsulSdConfigsBasicAuthPassword>,
    /// The secret in the service monitor namespace that contains the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigConsulSdConfigsBasicAuthUsername>,
}

/// The secret in the service monitor namespace that contains the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service monitor namespace that contains the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional OAuth 2.0 configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2 {
    /// The secret or configmap containing the OAuth2 client id
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigConsulSdConfigsOauth2ClientId,
    /// The secret containing the OAuth2 client secret
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigConsulSdConfigsOauth2ClientSecret,
    /// Parameters to append to the token URL
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// OAuth2 scopes used for the token request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// The URL to fetch the token from
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// The secret or configmap containing the OAuth2 client id
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret containing the OAuth2 client secret
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Specifies headers to send to proxies during CONNECT requests.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConsulSDConfig defines a Consul service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigConsulSdConfigsScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// TLS Config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigConsulSdConfigsTlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigConsulSdConfigsTlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigConsulSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTokenRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from /etc/resolv.conf. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDnsSdConfigs {
    /// A list of DNS domain names to be queried.
    pub names: Vec<String>,
    /// The port number used if the query type is not SRV Ignored for SRV records
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// RefreshInterval configures the time after which the provided names are refreshed. If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// The type of DNS query to perform. One of SRV, A, AAAA or MX. If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ScrapeConfigDnsSdConfigsType>,
}

/// DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from /etc/resolv.conf. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDnsSdConfigsType {
    #[serde(rename = "SRV")]
    Srv,
    A,
    #[serde(rename = "AAAA")]
    Aaaa,
    #[serde(rename = "MX")]
    Mx,
}

/// EC2SDConfig allow retrieving scrape targets from AWS EC2 instances. The private IP address is used by default, but may be changed to the public IP address with relabeling. The IAM credentials used must have the ec2:DescribeInstances permission to discover scrape targets See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ec2_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigEc2SdConfigs {
    /// AccessKey is the AWS API key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessKey")]
    pub access_key: Option<ScrapeConfigEc2SdConfigsAccessKey>,
    /// Filters can be used optionally to filter the instance list by other criteria. Available filter criteria can be found here: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html Filter API documentation: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filters: Option<Vec<ScrapeConfigEc2SdConfigsFilters>>,
    /// The port to scrape metrics from. If using the public IP address, this must instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// The AWS region
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// AWS Role ARN, an alternative to using AWS API keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleARN")]
    pub role_arn: Option<String>,
    /// SecretKey is the AWS API secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKey")]
    pub secret_key: Option<ScrapeConfigEc2SdConfigsSecretKey>,
}

/// AccessKey is the AWS API key.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsAccessKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EC2Filter is the configuration for filtering EC2 instances.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsFilters {
    pub name: String,
    pub values: Vec<String>,
}

/// SecretKey is the AWS API secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsSecretKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// FileSDConfig defines a Prometheus file service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigFileSdConfigs {
    /// List of files to be used for file discovery. Recommendation: use absolute paths. While relative paths work, the prometheus-operator project makes no guarantees about the working directory where the configuration file is stored. Files must be mounted using Prometheus.ConfigMaps or Prometheus.Secrets.
    pub files: Vec<String>,
    /// RefreshInterval configures the refresh interval at which Prometheus will reload the content of the files.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
}

/// HTTPSDConfig defines a prometheus HTTP service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#http_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigs {
    /// Authorization header configuration to authenticate against the target HTTP endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigHttpSdConfigsAuthorization>,
    /// BasicAuth information to authenticate against the target HTTP endpoint. More info: https://prometheus.io/docs/operating/configuration/#endpoints
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigHttpSdConfigsBasicAuth>,
    /// RefreshInterval configures the refresh interval at which Prometheus will re-query the endpoint to update the target list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// TLS configuration applying to the target HTTP endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigHttpSdConfigsTlsConfig>,
    /// URL from which the targets are fetched.
    pub url: String,
}

/// Authorization header configuration to authenticate against the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigHttpSdConfigsAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive. 
    ///  "Basic" is not a supported value. 
    ///  Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to authenticate against the target HTTP endpoint. More info: https://prometheus.io/docs/operating/configuration/#endpoints
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsBasicAuth {
    /// The secret in the service monitor namespace that contains the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigHttpSdConfigsBasicAuthPassword>,
    /// The secret in the service monitor namespace that contains the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigHttpSdConfigsBasicAuthUsername>,
}

/// The secret in the service monitor namespace that contains the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service monitor namespace that contains the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigHttpSdConfigsTlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigHttpSdConfigsTlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigHttpSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHttpSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHttpSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHttpSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHttpSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigs {
    /// Role of the Kubernetes entities that should be discovered.
    pub role: ScrapeConfigKubernetesSdConfigsRole,
    /// Selector to select objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selectors: Option<Vec<ScrapeConfigKubernetesSdConfigsSelectors>>,
}

/// KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsRole {
    Node,
}

/// K8SSelectorConfig is Kubernetes Selector Config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsSelectors {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// K8SRole is role of the service in Kubernetes. Currently the only supported role is "Node".
    pub role: ScrapeConfigKubernetesSdConfigsSelectorsRole,
}

/// K8SSelectorConfig is Kubernetes Selector Config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsSelectorsRole {
    Node,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples. 
///  More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigMetricRelabelings {
    /// Action to perform based on the regex matching. 
    ///  `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0. 
    ///  Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<ScrapeConfigMetricRelabelingsAction>,
    /// Modulus to take of the hash of the source label values. 
    ///  Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a Replace action is performed if the regular expression matches. 
    ///  Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator is the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting string is written in a replacement. 
    ///  It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions. 
    ///  Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples. 
///  More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigMetricRelabelingsAction {
    Replace,
    Keep,
    Drop,
    HashMod,
    LabelMap,
    LabelDrop,
    LabelKeep,
    Lowercase,
    Uppercase,
    KeepEqual,
    DropEqual,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples. 
///  More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigRelabelings {
    /// Action to perform based on the regex matching. 
    ///  `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0. 
    ///  Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<ScrapeConfigRelabelingsAction>,
    /// Modulus to take of the hash of the source label values. 
    ///  Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a Replace action is performed if the regular expression matches. 
    ///  Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator is the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting string is written in a replacement. 
    ///  It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions. 
    ///  Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples. 
///  More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigRelabelingsAction {
    Replace,
    Keep,
    Drop,
    HashMod,
    LabelMap,
    LabelDrop,
    LabelKeep,
    Lowercase,
    Uppercase,
    KeepEqual,
    DropEqual,
}

/// ScrapeConfigSpec is a specification of the desired configuration for a scrape configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// StaticConfig defines a Prometheus static configuration. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigStaticConfigs {
    /// Labels assigned to all metrics scraped from the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// List of targets for this static configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigTlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigTlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

