// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/DopplerHQ/kubernetes-operator/secrets.doppler.com/v1alpha1/dopplersecrets.yaml --derive=PartialEq
// kopium version: 0.16.5

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// DopplerSecretSpec defines the desired state of DopplerSecret
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "secrets.doppler.com", version = "v1alpha1", kind = "DopplerSecret", plural = "dopplersecrets")]
#[kube(namespaced)]
#[kube(status = "DopplerSecretStatus")]
#[kube(schema = "disabled")]
pub struct DopplerSecretSpec {
    /// The Doppler config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<String>,
    /// Format enables the downloading of secrets as a file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<DopplerSecretFormat>,
    /// The Doppler API host
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The Kubernetes secret where the operator will store and sync the fetched secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedSecret")]
    pub managed_secret: Option<DopplerSecretManagedSecret>,
    /// The environment variable compatible secrets name transformer to apply
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameTransformer")]
    pub name_transformer: Option<DopplerSecretNameTransformer>,
    /// A list of processors to transform the data during ingestion
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub processors: Option<BTreeMap<String, DopplerSecretProcessors>>,
    /// The Doppler project
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// The number of seconds to wait between resyncs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resyncSeconds")]
    pub resync_seconds: Option<i64>,
    /// A list of secrets to sync from the config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
    /// The Kubernetes secret containing the Doppler service token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecret")]
    pub token_secret: Option<DopplerSecretTokenSecret>,
    /// Whether or not to verify TLS
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verifyTLS")]
    pub verify_tls: Option<bool>,
}

/// DopplerSecretSpec defines the desired state of DopplerSecret
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DopplerSecretFormat {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "dotnet-json")]
    DotnetJson,
    #[serde(rename = "env")]
    Env,
    #[serde(rename = "yaml")]
    Yaml,
    #[serde(rename = "docker")]
    Docker,
}

/// The Kubernetes secret where the operator will store and sync the fetched secrets
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DopplerSecretManagedSecret {
    /// The name of the Secret resource
    pub name: String,
    /// Namespace of the resource being referred to. Ignored if not cluster scoped
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The secret type of the managed secret
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<DopplerSecretManagedSecretType>,
}

/// The Kubernetes secret where the operator will store and sync the fetched secrets
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DopplerSecretManagedSecretType {
    Opaque,
    #[serde(rename = "kubernetes.io/tls")]
    KubernetesIoTls,
    #[serde(rename = "kubernetes.io/service-account-token")]
    KubernetesIoServiceAccountToken,
    #[serde(rename = "kubernetes.io/dockercfg")]
    KubernetesIoDockercfg,
    #[serde(rename = "kubernetes.io/dockerconfigjson")]
    KubernetesIoDockerconfigjson,
    #[serde(rename = "kubernetes.io/basic-auth")]
    KubernetesIoBasicAuth,
    #[serde(rename = "kubernetes.io/ssh-auth")]
    KubernetesIoSshAuth,
    #[serde(rename = "bootstrap.kubernetes.io/token")]
    BootstrapKubernetesIoToken,
}

/// DopplerSecretSpec defines the desired state of DopplerSecret
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DopplerSecretNameTransformer {
    #[serde(rename = "upper-camel")]
    UpperCamel,
    #[serde(rename = "camel")]
    Camel,
    #[serde(rename = "lower-snake")]
    LowerSnake,
    #[serde(rename = "tf-var")]
    TfVar,
    #[serde(rename = "dotnet-env")]
    DotnetEnv,
    #[serde(rename = "lower-kebab")]
    LowerKebab,
}

/// A list of processors to transform the data during ingestion
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DopplerSecretProcessors {
    /// The mapped name of the field in the managed secret, defaults to the original Doppler secret name for Opaque Kubernetes secrets. If omitted for other types, the value is not copied to the managed secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "asName")]
    pub as_name: Option<String>,
    /// The type of process to be performed, either "plain" or "base64"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<DopplerSecretProcessorsType>,
}

/// A list of processors to transform the data during ingestion
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DopplerSecretProcessorsType {
    #[serde(rename = "plain")]
    Plain,
    #[serde(rename = "base64")]
    Base64,
}

/// The Kubernetes secret containing the Doppler service token
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DopplerSecretTokenSecret {
    /// The name of the Secret resource
    pub name: String,
    /// Namespace of the resource being referred to. Ignored if not cluster scoped
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// DopplerSecretStatus defines the observed state of DopplerSecret
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DopplerSecretStatus {
    pub conditions: Vec<DopplerSecretStatusConditions>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///      // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DopplerSecretStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: DopplerSecretStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///      // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DopplerSecretStatusConditionsStatus {
    True,
    False,
    Unknown,
}

