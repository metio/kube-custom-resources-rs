// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/fluent/fluent-operator/fluentbit.fluent.io/v1alpha2/clusteroutputs.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// OutputSpec defines the desired state of ClusterOutput
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "fluentbit.fluent.io", version = "v1alpha2", kind = "ClusterOutput", plural = "clusteroutputs")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClusterOutputSpec {
    /// A user friendly alias name for this output plugin.
    /// Used in metrics for distinction of each configured output.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,
    /// AzureBlob defines AzureBlob Output Configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureBlob")]
    pub azure_blob: Option<ClusterOutputAzureBlob>,
    /// AzureLogAnalytics defines AzureLogAnalytics Output Configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureLogAnalytics")]
    pub azure_log_analytics: Option<ClusterOutputAzureLogAnalytics>,
    /// CloudWatch defines CloudWatch Output Configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudWatch")]
    pub cloud_watch: Option<ClusterOutputCloudWatch>,
    /// CustomPlugin defines Custom Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customPlugin")]
    pub custom_plugin: Option<ClusterOutputCustomPlugin>,
    /// DataDog defines DataDog Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datadog: Option<ClusterOutputDatadog>,
    /// Elasticsearch defines Elasticsearch Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub es: Option<ClusterOutputEs>,
    /// File defines File Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub file: Option<ClusterOutputFile>,
    /// Firehose defines Firehose Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub firehose: Option<ClusterOutputFirehose>,
    /// Forward defines Forward Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<ClusterOutputForward>,
    /// Gelf defines GELF Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gelf: Option<ClusterOutputGelf>,
    /// HTTP defines HTTP Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ClusterOutputHttp>,
    /// InfluxDB defines InfluxDB Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "influxDB")]
    pub influx_db: Option<ClusterOutputInfluxDb>,
    /// Kafka defines Kafka Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<ClusterOutputKafka>,
    /// Kinesis defines Kinesis Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinesis: Option<ClusterOutputKinesis>,
    /// Set the plugin's logging verbosity level. Allowed values are: off, error, warn, info, debug and trace, Defaults to the SERVICE section's Log_Level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<ClusterOutputLogLevel>,
    /// Loki defines Loki Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loki: Option<ClusterOutputLoki>,
    /// A pattern to match against the tags of incoming records.
    /// It's case sensitive and support the star (*) character as a wildcard.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// A regular expression to match against the tags of incoming records.
    /// Use this option if you want to use the full regex syntax.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchRegex")]
    pub match_regex: Option<String>,
    /// Null defines Null Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub null: Option<ClusterOutputNull>,
    /// OpenSearch defines OpenSearch Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opensearch: Option<ClusterOutputOpensearch>,
    /// OpenTelemetry defines OpenTelemetry Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opentelemetry: Option<ClusterOutputOpentelemetry>,
    /// Processors defines the processors configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub processors: Option<BTreeMap<String, serde_json::Value>>,
    /// PrometheusExporter_types defines Prometheus exporter configuration to expose metrics from Fluent Bit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusExporter")]
    pub prometheus_exporter: Option<ClusterOutputPrometheusExporter>,
    /// PrometheusRemoteWrite_types defines Prometheus Remote Write configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusRemoteWrite")]
    pub prometheus_remote_write: Option<ClusterOutputPrometheusRemoteWrite>,
    /// RetryLimit represents configuration for the scheduler which can be set independently on each output section.
    /// This option allows to disable retries or impose a limit to try N times and then discard the data after reaching that limit.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry_limit: Option<String>,
    /// S3 defines S3 Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<ClusterOutputS3>,
    /// Splunk defines Splunk Output Configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub splunk: Option<ClusterOutputSplunk>,
    /// Stackdriver defines Stackdriver Output Configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stackdriver: Option<ClusterOutputStackdriver>,
    /// Stdout defines Stdout Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ClusterOutputStdout>,
    /// Syslog defines Syslog Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub syslog: Option<ClusterOutputSyslog>,
    /// TCP defines TCP Output configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<ClusterOutputTcp>,
}

/// AzureBlob defines AzureBlob Output Configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureBlob {
    /// Azure Storage account name
    #[serde(rename = "accountName")]
    pub account_name: String,
    /// Creates container if ContainerName is not set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoCreateContainer")]
    pub auto_create_container: Option<ClusterOutputAzureBlobAutoCreateContainer>,
    /// Specify the desired blob type. Must be `appendblob` or `blockblob`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blobType")]
    pub blob_type: Option<ClusterOutputAzureBlobBlobType>,
    /// Name of the container that will contain the blobs
    #[serde(rename = "containerName")]
    pub container_name: String,
    /// Optional toggle to use an Azure emulator
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emulatorMode")]
    pub emulator_mode: Option<ClusterOutputAzureBlobEmulatorMode>,
    /// HTTP Service of the endpoint (if using EmulatorMode)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputAzureBlobNetworking>,
    /// Optional path to store the blobs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Specify the Azure Storage Shared Key to authenticate against the storage account
    #[serde(rename = "sharedKey")]
    pub shared_key: ClusterOutputAzureBlobSharedKey,
    /// Enable/Disable TLS Encryption. Azure services require TLS to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputAzureBlobTls>,
}

/// AzureBlob defines AzureBlob Output Configuration
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputAzureBlobAutoCreateContainer {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// AzureBlob defines AzureBlob Output Configuration
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputAzureBlobBlobType {
    #[serde(rename = "appendblob")]
    Appendblob,
    #[serde(rename = "blockblob")]
    Blockblob,
}

/// AzureBlob defines AzureBlob Output Configuration
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputAzureBlobEmulatorMode {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureBlobNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputAzureBlobNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputAzureBlobNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputAzureBlobNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputAzureBlobNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputAzureBlobNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputAzureBlobNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Specify the Azure Storage Shared Key to authenticate against the storage account
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureBlobSharedKey {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputAzureBlobSharedKeyValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureBlobSharedKeyValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputAzureBlobSharedKeyValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureBlobSharedKeyValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Enable/Disable TLS Encryption. Azure services require TLS to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureBlobTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputAzureBlobTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Enable/Disable TLS Encryption. Azure services require TLS to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputAzureBlobTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureBlobTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputAzureBlobTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureBlobTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputAzureBlobTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureBlobTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// AzureLogAnalytics defines AzureLogAnalytics Output Configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureLogAnalytics {
    /// Customer ID or Workspace ID
    #[serde(rename = "customerID")]
    pub customer_id: ClusterOutputAzureLogAnalyticsCustomerId,
    /// Name of the event type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logType")]
    pub log_type: Option<String>,
    /// Specify the primary or the secondary client authentication key
    #[serde(rename = "sharedKey")]
    pub shared_key: ClusterOutputAzureLogAnalyticsSharedKey,
    /// If set, overrides the timeKey value with the `time-generated-field` HTTP header value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeGenerated")]
    pub time_generated: Option<bool>,
    /// Specify the name of the key where the timestamp is stored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
}

/// Customer ID or Workspace ID
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureLogAnalyticsCustomerId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputAzureLogAnalyticsCustomerIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureLogAnalyticsCustomerIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputAzureLogAnalyticsCustomerIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureLogAnalyticsCustomerIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Specify the primary or the secondary client authentication key
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureLogAnalyticsSharedKey {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputAzureLogAnalyticsSharedKeyValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureLogAnalyticsSharedKeyValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputAzureLogAnalyticsSharedKeyValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputAzureLogAnalyticsSharedKeyValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// CloudWatch defines CloudWatch Output Configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputCloudWatch {
    /// Automatically create the log group. Defaults to False.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoCreateGroup")]
    pub auto_create_group: Option<bool>,
    /// Automatically retry failed requests to CloudWatch once. Defaults to True.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRetryRequests")]
    pub auto_retry_requests: Option<bool>,
    /// Custom endpoint for CloudWatch logs API
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Specify an external ID for the STS API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalID")]
    pub external_id: Option<String>,
    /// Optional parameter to tell CloudWatch the format of the data
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    pub log_format: Option<String>,
    /// Name of Cloudwatch Log Group to send log records to
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupName")]
    pub log_group_name: Option<String>,
    /// Template for Log Group name, overrides LogGroupName if set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupTemplate")]
    pub log_group_template: Option<String>,
    /// If set, only the value of the key will be sent to CloudWatch
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logKey")]
    pub log_key: Option<String>,
    /// Number of days logs are retained for
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logRetentionDays")]
    pub log_retention_days: Option<i32>,
    /// The name of the CloudWatch Log Stream to send log records to
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamName")]
    pub log_stream_name: Option<String>,
    /// Prefix for the Log Stream name. Not compatible with LogStreamName setting
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamPrefix")]
    pub log_stream_prefix: Option<String>,
    /// Template for Log Stream name. Overrides LogStreamPrefix and LogStreamName if set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamTemplate")]
    pub log_stream_template: Option<String>,
    /// Optional lists of lists for dimension keys to be added to all metrics. Use comma separated strings
    /// for one list of dimensions and semicolon separated strings for list of lists dimensions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricDimensions")]
    pub metric_dimensions: Option<String>,
    /// Optional string to represent the CloudWatch namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricNamespace")]
    pub metric_namespace: Option<String>,
    /// AWS Region
    pub region: String,
    /// Role ARN to use for cross-account access
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Specify a custom STS endpoint for the AWS STS API
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stsEndpoint")]
    pub sts_endpoint: Option<String>,
}

/// CloudWatch defines CloudWatch Output Configuration
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputCloudWatchLogRetentionDays {
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "5")]
    r#_5,
    #[serde(rename = "7")]
    r#_7,
    #[serde(rename = "14")]
    r#_14,
    #[serde(rename = "30")]
    r#_30,
    #[serde(rename = "60")]
    r#_60,
    #[serde(rename = "90")]
    r#_90,
    #[serde(rename = "120")]
    r#_120,
    #[serde(rename = "150")]
    r#_150,
    #[serde(rename = "180")]
    r#_180,
    #[serde(rename = "365")]
    r#_365,
    #[serde(rename = "400")]
    r#_400,
    #[serde(rename = "545")]
    r#_545,
    #[serde(rename = "731")]
    r#_731,
    #[serde(rename = "1827")]
    r#_1827,
    #[serde(rename = "3653")]
    r#_3653,
}

/// CustomPlugin defines Custom Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputCustomPlugin {
    /// Config holds any unsupported plugins classic configurations,
    /// if ConfigFileFormat is set to yaml, this filed will be ignored
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<String>,
    /// YamlConfig holds the unsupported plugins yaml configurations, it only works when the ConfigFileFormat is yaml
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "yamlConfig")]
    pub yaml_config: Option<BTreeMap<String, serde_json::Value>>,
}

/// DataDog defines DataDog Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputDatadog {
    /// Your Datadog API key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub apikey: Option<ClusterOutputDatadogApikey>,
    /// Compress  the payload in GZIP format.
    /// Datadog supports and recommends setting this to gzip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<String>,
    /// By default, the plugin searches for the key 'log' and remap the value to the key 'message'. If the property is set, the plugin will search the property name key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dd_message_key: Option<String>,
    /// The human readable name for your service generating the logs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dd_service: Option<String>,
    /// A human readable name for the underlying technology of your service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dd_source: Option<String>,
    /// The tags you want to assign to your logs in Datadog.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dd_tags: Option<String>,
    /// Host is the Datadog server where you are sending your logs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// If enabled, a tag is appended to output. The key name is used tag_key property.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub include_tag_key: Option<bool>,
    /// Date key name for output.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json_date_key: Option<String>,
    /// To activate the remapping, specify configuration flag provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    /// Specify an HTTP Proxy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<String>,
    /// The key name of tag. If include_tag_key is false, This property is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag_key: Option<String>,
    /// TLS controls whether to use end-to-end security communications security protocol.
    /// Datadog recommends setting this to on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<bool>,
}

/// Your Datadog API key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputDatadogApikey {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputDatadogApikeyValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputDatadogApikeyValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputDatadogApikeyValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputDatadogApikeyValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Elasticsearch defines Elasticsearch Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEs {
    /// Enable AWS Sigv4 Authentication for Amazon ElasticSearch Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsAuth")]
    pub aws_auth: Option<String>,
    /// External ID for the AWS IAM Role specified with aws_role_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsExternalID")]
    pub aws_external_id: Option<String>,
    /// Specify the AWS region for Amazon ElasticSearch Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsRegion")]
    pub aws_region: Option<String>,
    /// AWS IAM Role to assume to put records to your Amazon ES cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsRoleARN")]
    pub aws_role_arn: Option<String>,
    /// Specify the custom sts endpoint to be used with STS API for Amazon ElasticSearch Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsSTSEndpoint")]
    pub aws_sts_endpoint: Option<String>,
    /// Specify the buffer size used to read the response from the Elasticsearch HTTP service.
    /// This option is useful for debugging purposes where is required to read full responses,
    /// note that response size grows depending of the number of records inserted.
    /// To set an unlimited amount of memory set this value to False,
    /// otherwise the value must be according to the Unit Size specification.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bufferSize")]
    pub buffer_size: Option<String>,
    /// Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudAuth")]
    pub cloud_auth: Option<String>,
    /// If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudID")]
    pub cloud_id: Option<String>,
    /// Set payload compression mechanism. Option available is 'gzip'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<ClusterOutputEsCompress>,
    /// Use current time for index generation instead of message record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentTimeIndex")]
    pub current_time_index: Option<bool>,
    /// When enabled, generate _id for outgoing records.
    /// This prevents duplicate records when retrying ES.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generateID")]
    pub generate_id: Option<bool>,
    /// IP address or hostname of the target Elasticsearch instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Password for user defined in HTTP_User
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPassword")]
    pub http_password: Option<ClusterOutputEsHttpPassword>,
    /// Optional username credential for Elastic X-Pack access
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<ClusterOutputEsHttpUser>,
    /// If set, _id will be the value of the key from incoming record and Generate_ID option is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idKey")]
    pub id_key: Option<String>,
    /// When enabled, it append the Tag name to the record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeTagKey")]
    pub include_tag_key: Option<bool>,
    /// Index name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// Time format (based on strftime) to generate the second part of the Index name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashDateFormat")]
    pub logstash_date_format: Option<String>,
    /// Enable Logstash format compatibility.
    /// This option takes a boolean value: True/False, On/Off
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashFormat")]
    pub logstash_format: Option<bool>,
    /// When Logstash_Format is enabled, the Index name is composed using a prefix and the date,
    /// e.g: If Logstash_Prefix is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
    /// The last string appended belongs to the date when the data is being generated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashPrefix")]
    pub logstash_prefix: Option<String>,
    /// Prefix keys with this string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashPrefixKey")]
    pub logstash_prefix_key: Option<String>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputEsNetworking>,
    /// Elasticsearch accepts new data on HTTP query path "/_bulk".
    /// But it is also possible to serve Elasticsearch behind a reverse proxy on a subpath.
    /// This option defines such path on the fluent-bit side.
    /// It simply adds a path prefix in the indexing HTTP POST URI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Newer versions of Elasticsearch allows setting up filters called pipelines.
    /// This option allows defining which pipeline the database should use.
    /// For performance reasons is strongly suggested parsing
    /// and filtering on Fluent Bit side, avoid pipelines.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pipeline: Option<String>,
    /// TCP port of the target Elasticsearch instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// When enabled, replace field name dots with underscore, required by Elasticsearch 2.0-2.3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDots")]
    pub replace_dots: Option<bool>,
    /// When enabled, mapping types is removed and Type option is ignored. Types are deprecated in APIs in v7.0. This options is for v7.0 or later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suppressTypeName")]
    pub suppress_type_name: Option<String>,
    /// When Include_Tag_Key is enabled, this property defines the key name for the tag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagKey")]
    pub tag_key: Option<String>,
    /// When Logstash_Format is enabled, each record will get a new timestamp field.
    /// The Time_Key property defines the name of that field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// When Logstash_Format is enabled, this property defines the format of the timestamp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKeyFormat")]
    pub time_key_format: Option<String>,
    /// When Logstash_Format is enabled, enabling this property sends nanosecond precision timestamps.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKeyNanos")]
    pub time_key_nanos: Option<bool>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputEsTls>,
    /// Limit the maximum number of Chunks in the filesystem for the current output logical destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalLimitSize")]
    pub total_limit_size: Option<String>,
    /// When enabled print the elasticsearch API calls to stdout when elasticsearch returns an error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "traceError")]
    pub trace_error: Option<bool>,
    /// When enabled print the elasticsearch API calls to stdout (for diag only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "traceOutput")]
    pub trace_output: Option<bool>,
    /// Type name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// Operation to use to write in bulk requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeOperation")]
    pub write_operation: Option<String>,
}

/// Elasticsearch defines Elasticsearch Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputEsCompress {
    #[serde(rename = "gzip")]
    Gzip,
}

/// Password for user defined in HTTP_User
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsHttpPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputEsHttpPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsHttpPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputEsHttpPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsHttpPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional username credential for Elastic X-Pack access
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputEsHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputEsHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputEsNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputEsNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputEsNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputEsNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputEsNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputEsNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputEsTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputEsTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputEsTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputEsTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputEsTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// File defines File Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputFile {
    /// The character to separate each pair. Applicable only if format is csv or ltsv.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delimiter: Option<String>,
    /// Set file name to store the records. If not set, the file name will be the tag associated with the records.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub file: Option<String>,
    /// The format of the file content. See also Format section. Default: out_file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<ClusterOutputFileFormat>,
    /// The character to separate each pair. Applicable only if format is ltsv.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelDelimiter")]
    pub label_delimiter: Option<String>,
    /// Absolute directory path to store files. If not set, Fluent Bit will write the files on it's own positioned directory.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The format string. Applicable only if format is template.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
}

/// File defines File Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputFileFormat {
    #[serde(rename = "out_file")]
    OutFile,
    #[serde(rename = "plain")]
    Plain,
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "ltsv")]
    Ltsv,
    #[serde(rename = "template")]
    Template,
}

/// Firehose defines Firehose Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputFirehose {
    /// Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRetryRequests")]
    pub auto_retry_requests: Option<bool>,
    /// By default, the whole log record will be sent to Kinesis. If you specify a key name(s) with this option, then only those keys and values will be sent to Kinesis. For example, if you are using the Fluentd Docker log driver, you can specify data_keys log and only the log message will be sent to Kinesis. If you specify multiple keys, they should be comma delimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataKeys")]
    pub data_keys: Option<String>,
    /// The name of the Kinesis Firehose Delivery stream that you want log records sent to.
    #[serde(rename = "deliveryStream")]
    pub delivery_stream: String,
    /// Specify a custom endpoint for the Kinesis Firehose API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose. For example, if you are using the Fluentd Docker log driver, you can specify log_key log and only the log message will be sent to Firehose.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logKey")]
    pub log_key: Option<String>,
    /// The AWS region.
    pub region: String,
    /// ARN of an IAM role to assume (for cross account access).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleARN")]
    pub role_arn: Option<String>,
    /// Specify a custom endpoint for the STS API; used to assume your custom role provided with role_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stsEndpoint")]
    pub sts_endpoint: Option<String>,
    /// Add the timestamp to the record under this key. By default, the timestamp from Fluent Bit will not be added to records sent to Kinesis.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// strftime compliant format string for the timestamp; for example, %Y-%m-%dT%H *string This option is used with time_key. You can also use %L for milliseconds and %f for microseconds. If you are using ECS FireLens, make sure you are running Amazon ECS Container Agent v1.42.0 or later, otherwise the timestamps associated with your container logs will only have second precision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKeyFormat")]
    pub time_key_format: Option<String>,
}

/// Forward defines Forward Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForward {
    /// Use this option to connect to Fluentd with a zero-length secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptySharedKey")]
    pub empty_shared_key: Option<bool>,
    /// Target host where Fluent-Bit or Fluentd are listening for Forward messages.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputForwardNetworking>,
    /// Specify the password corresponding to the username.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ClusterOutputForwardPassword>,
    /// TCP Port of the target service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Send "chunk"-option and wait for "ack" response from server.
    /// Enables at-least-once and receiving server can control rate of traffic.
    /// (Requires Fluentd v0.14.0+ server)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAckResponse")]
    pub require_ack_response: Option<bool>,
    /// Default value of the auto-generated certificate common name (CN).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfHostname")]
    pub self_hostname: Option<String>,
    /// Always send options (with "size"=count of messages)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendOptions")]
    pub send_options: Option<bool>,
    /// A key string known by the remote Fluentd used for authorization.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedKey")]
    pub shared_key: Option<String>,
    /// Overwrite the tag as we transmit. This allows the receiving pipeline start
    /// fresh, or to attribute source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
    /// Set timestamps in integer format, it enable compatibility mode for Fluentd v0.12 series.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeAsInteger")]
    pub time_as_integer: Option<bool>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputForwardTls>,
    /// Specify the username to present to a Fluentd server that enables user_auth.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ClusterOutputForwardUsername>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputForwardNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputForwardNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputForwardNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputForwardNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputForwardNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputForwardNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Specify the password corresponding to the username.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputForwardPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputForwardPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputForwardTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputForwardTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputForwardTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputForwardTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Specify the username to present to a Fluentd server that enables user_auth.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputForwardUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputForwardUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputForwardUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Gelf defines GELF Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputGelf {
    /// If transport protocol is udp, it defines if UDP packets should be compressed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<bool>,
    /// FullMessageKey is the key to use as the long message that can i.e. contain a backtrace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fullMessageKey")]
    pub full_message_key: Option<String>,
    /// IP address or hostname of the target Graylog server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// HostKey is the key which its value is used as the name of the host, source or application that sent this message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostKey")]
    pub host_key: Option<String>,
    /// LevelKey is the key to be used as the log level.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "levelKey")]
    pub level_key: Option<String>,
    /// The protocol to use (tls, tcp or udp).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<ClusterOutputGelfMode>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputGelfNetworking>,
    /// If transport protocol is udp, it sets the size of packets to be sent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "packetSize")]
    pub packet_size: Option<i32>,
    /// The port that the target Graylog server is listening on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// ShortMessageKey is the key to use as the short message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shortMessageKey")]
    pub short_message_key: Option<String>,
    /// TimestampKey is the key which its value is used as the timestamp of the message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampKey")]
    pub timestamp_key: Option<String>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputGelfTls>,
}

/// Gelf defines GELF Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputGelfMode {
    #[serde(rename = "tls")]
    Tls,
    #[serde(rename = "tcp")]
    Tcp,
    #[serde(rename = "udp")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputGelfNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputGelfNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputGelfNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputGelfNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputGelfNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputGelfNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputGelfNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputGelfTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputGelfTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputGelfTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputGelfTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputGelfTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputGelfTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputGelfTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputGelfTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// HTTP defines HTTP Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttp {
    /// Specify if duplicated headers are allowed.
    /// If a duplicated header is found, the latest key/value set is preserved.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowDuplicatedHeaders")]
    pub allow_duplicated_headers: Option<bool>,
    /// Set payload compression mechanism. Option available is 'gzip'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<String>,
    /// Specify the data format to be used in the HTTP request body, by default it uses msgpack.
    /// Other supported formats are json, json_stream and json_lines and gelf.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<ClusterOutputHttpFormat>,
    /// Specify the key to use for the full message in gelf format
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gelfFullMessageKey")]
    pub gelf_full_message_key: Option<String>,
    /// Specify the key to use for the host in gelf format
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gelfHostKey")]
    pub gelf_host_key: Option<String>,
    /// Specify the key to use for the level in gelf format
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gelfLevelKey")]
    pub gelf_level_key: Option<String>,
    /// Specify the key to use as the short message in gelf format
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gelfShortMessageKey")]
    pub gelf_short_message_key: Option<String>,
    /// Specify the key to use for timestamp in gelf format
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gelfTimestampKey")]
    pub gelf_timestamp_key: Option<String>,
    /// Specify an optional HTTP header field for the original message tag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerTag")]
    pub header_tag: Option<String>,
    /// Add a HTTP header key/value pair. Multiple headers can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, String>>,
    /// IP address or hostname of the target HTTP Server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Basic Auth Password. Requires HTTP_User to be set
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPassword")]
    pub http_password: Option<ClusterOutputHttpHttpPassword>,
    /// Basic Auth Username
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<ClusterOutputHttpHttpUser>,
    /// Specify the format of the date. Supported formats are double, epoch
    /// and iso8601 (eg: 2018-05-30T09:39:52.000681Z)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonDateFormat")]
    pub json_date_format: Option<String>,
    /// Specify the name of the time key in the output record.
    /// To disable the time key just set the value to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonDateKey")]
    pub json_date_key: Option<String>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputHttpNetworking>,
    /// TCP port of the target HTTP Server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Specify an HTTP Proxy. The expected format of this value is http://host:port.
    /// Note that https is not supported yet.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<String>,
    /// HTTP output plugin supports TTL/SSL, for more details about the properties available
    /// and general configuration, please refer to the TLS/SSL section.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputHttpTls>,
    /// Specify an optional HTTP URI for the target web server, e.g: /something
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

/// HTTP defines HTTP Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputHttpFormat {
    #[serde(rename = "msgpack")]
    Msgpack,
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "json_stream")]
    JsonStream,
    #[serde(rename = "json_lines")]
    JsonLines,
    #[serde(rename = "gelf")]
    Gelf,
}

/// Basic Auth Password. Requires HTTP_User to be set
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpHttpPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputHttpHttpPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpHttpPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputHttpHttpPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpHttpPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Basic Auth Username
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputHttpHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputHttpHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputHttpNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputHttpNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputHttpNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputHttpNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputHttpNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputHttpNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// HTTP output plugin supports TTL/SSL, for more details about the properties available
/// and general configuration, please refer to the TLS/SSL section.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputHttpTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// HTTP output plugin supports TTL/SSL, for more details about the properties available
/// and general configuration, please refer to the TLS/SSL section.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputHttpTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputHttpTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputHttpTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputHttpTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// InfluxDB defines InfluxDB Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDb {
    /// Automatically tag keys where value is string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoTags")]
    pub auto_tags: Option<bool>,
    /// InfluxDB bucket name where records will be inserted - if specified, database is ignored and v2 of API is used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// InfluxDB database name where records will be inserted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub database: Option<String>,
    /// IP address or hostname of the target InfluxDB service.
    pub host: String,
    /// Password for user defined in HTTP_User
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPassword")]
    pub http_password: Option<ClusterOutputInfluxDbHttpPassword>,
    /// Authentication token used with InfluxDB v2 - if specified, both HTTPUser and HTTPPasswd are ignored
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpToken")]
    pub http_token: Option<ClusterOutputInfluxDbHttpToken>,
    /// Optional username for HTTP Basic Authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<ClusterOutputInfluxDbHttpUser>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputInfluxDbNetworking>,
    /// InfluxDB organization name where the bucket is (v2 only)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub org: Option<String>,
    /// TCP port of the target InfluxDB service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// The name of the tag whose value is incremented for the consecutive simultaneous events.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sequenceTag")]
    pub sequence_tag: Option<String>,
    /// List of keys that needs to be tagged
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagKeys")]
    pub tag_keys: Option<Vec<String>>,
    /// Key of the string array optionally contained within each log record that contains tag keys for that record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagListKey")]
    pub tag_list_key: Option<String>,
    /// Dynamically tag keys which are in the string array at Tags_List_Key key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsListEnabled")]
    pub tags_list_enabled: Option<bool>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputInfluxDbTls>,
}

/// Password for user defined in HTTP_User
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbHttpPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputInfluxDbHttpPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbHttpPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputInfluxDbHttpPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbHttpPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Authentication token used with InfluxDB v2 - if specified, both HTTPUser and HTTPPasswd are ignored
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbHttpToken {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputInfluxDbHttpTokenValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbHttpTokenValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputInfluxDbHttpTokenValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbHttpTokenValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional username for HTTP Basic Authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputInfluxDbHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputInfluxDbHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputInfluxDbNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputInfluxDbNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputInfluxDbNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputInfluxDbNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputInfluxDbNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputInfluxDbNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputInfluxDbTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputInfluxDbTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputInfluxDbTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputInfluxDbTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputInfluxDbTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Kafka defines Kafka Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputKafka {
    /// Single of multiple list of Kafka Brokers, e.g: 192.168.1.3:9092, 192.168.1.4:9092.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub brokers: Option<String>,
    /// adds unknown topics (found in Topic_Key) to Topics. So in Topics only a default topic needs to be configured
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicTopic")]
    pub dynamic_topic: Option<bool>,
    /// Specify data format, options available: json, msgpack.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
    /// Optional key to store the message
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageKey")]
    pub message_key: Option<String>,
    /// If set, the value of Message_Key_Field in the record will indicate the message key.
    /// If not set nor found in the record, Message_Key will be used (if set).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageKeyField")]
    pub message_key_field: Option<String>,
    /// Fluent Bit queues data into rdkafka library,
    /// if for some reason the underlying library cannot flush the records the queue might fills up blocking new addition of records.
    /// The queue_full_retries option set the number of local retries to enqueue the data.
    /// The default value is 10 times, the interval between each retry is 1 second.
    /// Setting the queue_full_retries value to 0 set's an unlimited number of retries.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueFullRetries")]
    pub queue_full_retries: Option<i64>,
    /// {property} can be any librdkafka properties
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rdkafka: Option<BTreeMap<String, String>>,
    /// iso8601 or double
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampFormat")]
    pub timestamp_format: Option<String>,
    /// Set the key to store the record timestamp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampKey")]
    pub timestamp_key: Option<String>,
    /// If multiple Topics exists, the value of Topic_Key in the record will indicate the topic to use.
    /// E.g: if Topic_Key is router and the record is {"key1": 123, "router": "route_2"},
    /// Fluent Bit will use topic route_2. Note that if the value of Topic_Key is not present in Topics,
    /// then by default the first topic in the Topics list will indicate the topic to be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicKey")]
    pub topic_key: Option<String>,
    /// Single entry or list of topics separated by comma (,) that Fluent Bit will use to send messages to Kafka.
    /// If only one topic is set, that one will be used for all records.
    /// Instead if multiple topics exists, the one set in the record by Topic_Key will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topics: Option<String>,
}

/// Kinesis defines Kinesis Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputKinesis {
    /// Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. This option defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRetryRequests")]
    pub auto_retry_requests: Option<bool>,
    /// Specify a custom endpoint for the Kinesis API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Specify an external ID for the STS API, can be used with the role_arn parameter if your role requires an external ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalID")]
    pub external_id: Option<String>,
    /// By default, the whole log record will be sent to Kinesis. If you specify a key name with this option, then only the value of that key will be sent to Kinesis. For example, if you are using the Fluentd Docker log driver, you can specify log_key log and only the log message will be sent to Kinesis.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logKey")]
    pub log_key: Option<String>,
    /// The AWS region.
    pub region: String,
    /// ARN of an IAM role to assume (for cross account access).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleARN")]
    pub role_arn: Option<String>,
    /// The name of the Kinesis Streams Delivery stream that you want log records sent to.
    pub stream: String,
    /// Custom endpoint for the STS API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stsEndpoint")]
    pub sts_endpoint: Option<String>,
    /// Add the timestamp to the record under this key. By default the timestamp from Fluent Bit will not be added to records sent to Kinesis.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// strftime compliant format string for the timestamp; for example, the default is '%Y-%m-%dT%H:%M:%S'. Supports millisecond precision with '%3N' and supports nanosecond precision with '%9N' and '%L'; for example, adding '%3N' to support millisecond '%Y-%m-%dT%H:%M:%S.%3N'. This option is used with time_key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKeyFormat")]
    pub time_key_format: Option<String>,
}

/// OutputSpec defines the desired state of ClusterOutput
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputLogLevel {
    #[serde(rename = "off")]
    Off,
    #[serde(rename = "error")]
    Error,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "debug")]
    Debug,
    #[serde(rename = "trace")]
    Trace,
}

/// Loki defines Loki Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLoki {
    /// If set to true, it will add all Kubernetes labels to the Stream labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoKubernetesLabels")]
    pub auto_kubernetes_labels: Option<ClusterOutputLokiAutoKubernetesLabels>,
    /// Set bearer token authentication token value.
    /// Can be used as alterntative to HTTP basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerToken")]
    pub bearer_token: Option<ClusterOutputLokiBearerToken>,
    /// If set to true and after extracting labels only a single key remains, the log line sent to Loki will be the value of that key in line_format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropSingleKey")]
    pub drop_single_key: Option<ClusterOutputLokiDropSingleKey>,
    /// Loki hostname or IP address.
    pub host: String,
    /// Password for user defined in HTTP_User
    /// Set HTTP basic authentication password
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPassword")]
    pub http_password: Option<ClusterOutputLokiHttpPassword>,
    /// Set HTTP basic authentication user name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<ClusterOutputLokiHttpUser>,
    /// Optional list of record keys that will be placed as stream labels.
    /// This configuration property is for records key only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelKeys")]
    pub label_keys: Option<Vec<String>>,
    /// Specify the label map file path. The file defines how to extract labels from each record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelMapPath")]
    pub label_map_path: Option<String>,
    /// Stream labels for API request. It can be multiple comma separated of strings specifying  key=value pairs.
    /// In addition to fixed parameters, it also allows to add custom record keys (similar to label_keys property).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<Vec<String>>,
    /// Format to use when flattening the record to a log line. Valid values are json or key_value.
    /// If set to json,  the log line sent to Loki will be the Fluent Bit record dumped as JSON.
    /// If set to key_value, the log line will be each item in the record concatenated together (separated by a single space) in the format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lineFormat")]
    pub line_format: Option<ClusterOutputLokiLineFormat>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputLokiNetworking>,
    /// Loki TCP port
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Optional list of keys to remove.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeKeys")]
    pub remove_keys: Option<Vec<String>>,
    /// Tenant ID used by default to push logs to Loki.
    /// If omitted or empty it assumes Loki is running in single-tenant mode and no X-Scope-OrgID header is sent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantID")]
    pub tenant_id: Option<ClusterOutputLokiTenantId>,
    /// Specify the name of the key from the original record that contains the Tenant ID.
    /// The value of the key is set as X-Scope-OrgID of HTTP header. It is useful to set Tenant ID dynamically.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantIDKey")]
    pub tenant_id_key: Option<String>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputLokiTls>,
    /// Specify a custom HTTP URI. It must start with forward slash.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

/// Loki defines Loki Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputLokiAutoKubernetesLabels {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Set bearer token authentication token value.
/// Can be used as alterntative to HTTP basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiBearerToken {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputLokiBearerTokenValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiBearerTokenValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputLokiBearerTokenValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiBearerTokenValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Loki defines Loki Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputLokiDropSingleKey {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Password for user defined in HTTP_User
/// Set HTTP basic authentication password
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiHttpPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputLokiHttpPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiHttpPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputLokiHttpPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiHttpPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Set HTTP basic authentication user name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputLokiHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputLokiHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Loki defines Loki Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputLokiLineFormat {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "key_value")]
    KeyValue,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputLokiNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputLokiNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputLokiNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputLokiNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputLokiNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputLokiNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Tenant ID used by default to push logs to Loki.
/// If omitted or empty it assumes Loki is running in single-tenant mode and no X-Scope-OrgID header is sent.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiTenantId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputLokiTenantIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiTenantIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputLokiTenantIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiTenantIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputLokiTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputLokiTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputLokiTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputLokiTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputLokiTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Null defines Null Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputNull {
}

/// OpenSearch defines OpenSearch Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearch {
    /// Enables dedicated thread(s) for this output. Default value is set since version 1.8.13. For previous versions is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "Workers")]
    pub workers: Option<i32>,
    /// Enable AWS Sigv4 Authentication for Amazon OpenSearch Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsAuth")]
    pub aws_auth: Option<String>,
    /// External ID for the AWS IAM Role specified with aws_role_arn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsExternalID")]
    pub aws_external_id: Option<String>,
    /// Specify the AWS region for Amazon OpenSearch Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsRegion")]
    pub aws_region: Option<String>,
    /// AWS IAM Role to assume to put records to your Amazon cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsRoleARN")]
    pub aws_role_arn: Option<String>,
    /// Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsSTSEndpoint")]
    pub aws_sts_endpoint: Option<String>,
    /// Specify the buffer size used to read the response from the OpenSearch HTTP service.
    /// This option is useful for debugging purposes where is required to read full responses,
    /// note that response size grows depending of the number of records inserted.
    /// To set an unlimited amount of memory set this value to False,
    /// otherwise the value must be according to the Unit Size specification.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bufferSize")]
    pub buffer_size: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<ClusterOutputOpensearchCompress>,
    /// Use current time for index generation instead of message record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentTimeIndex")]
    pub current_time_index: Option<bool>,
    /// When enabled, generate _id for outgoing records.
    /// This prevents duplicate records when retrying OpenSearch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generateID")]
    pub generate_id: Option<bool>,
    /// IP address or hostname of the target OpenSearch instance, default `127.0.0.1`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Password for user defined in HTTP_User
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPassword")]
    pub http_password: Option<ClusterOutputOpensearchHttpPassword>,
    /// Optional username credential for access
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<ClusterOutputOpensearchHttpUser>,
    /// If set, _id will be the value of the key from incoming record and Generate_ID option is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idKey")]
    pub id_key: Option<String>,
    /// When enabled, it append the Tag name to the record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeTagKey")]
    pub include_tag_key: Option<bool>,
    /// Index name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// Time format (based on strftime) to generate the second part of the Index name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashDateFormat")]
    pub logstash_date_format: Option<String>,
    /// Enable Logstash format compatibility.
    /// This option takes a boolean value: True/False, On/Off
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashFormat")]
    pub logstash_format: Option<bool>,
    /// When Logstash_Format is enabled, the Index name is composed using a prefix and the date,
    /// e.g: If Logstash_Prefix is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
    /// The last string appended belongs to the date when the data is being generated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashPrefix")]
    pub logstash_prefix: Option<String>,
    /// Prefix keys with this string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashPrefixKey")]
    pub logstash_prefix_key: Option<String>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputOpensearchNetworking>,
    /// OpenSearch accepts new data on HTTP query path "/_bulk".
    /// But it is also possible to serve OpenSearch behind a reverse proxy on a subpath.
    /// This option defines such path on the fluent-bit side.
    /// It simply adds a path prefix in the indexing HTTP POST URI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// OpenSearch allows to setup filters called pipelines.
    /// This option allows to define which pipeline the database should use.
    /// For performance reasons is strongly suggested to do parsing
    /// and filtering on Fluent Bit side, avoid pipelines.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pipeline: Option<String>,
    /// TCP port of the target OpenSearch instance, default `9200`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// When enabled, replace field name dots with underscore, required by Elasticsearch 2.0-2.3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceDots")]
    pub replace_dots: Option<bool>,
    /// When enabled, mapping types is removed and Type option is ignored. Types are deprecated in APIs in v7.0. This options is for v7.0 or later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suppressTypeName")]
    pub suppress_type_name: Option<bool>,
    /// When Include_Tag_Key is enabled, this property defines the key name for the tag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagKey")]
    pub tag_key: Option<String>,
    /// When Logstash_Format is enabled, each record will get a new timestamp field.
    /// The Time_Key property defines the name of that field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// When Logstash_Format is enabled, this property defines the format of the timestamp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKeyFormat")]
    pub time_key_format: Option<String>,
    /// When Logstash_Format is enabled, enabling this property sends nanosecond precision timestamps.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKeyNanos")]
    pub time_key_nanos: Option<bool>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputOpensearchTls>,
    /// Limit the maximum number of Chunks in the filesystem for the current output logical destination.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalLimitSize")]
    pub total_limit_size: Option<String>,
    /// When enabled print the elasticsearch API calls to stdout when elasticsearch returns an error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "traceError")]
    pub trace_error: Option<bool>,
    /// When enabled print the elasticsearch API calls to stdout (for diag only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "traceOutput")]
    pub trace_output: Option<bool>,
    /// Type name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// Operation to use to write in bulk requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeOperation")]
    pub write_operation: Option<String>,
}

/// OpenSearch defines OpenSearch Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOpensearchCompress {
    #[serde(rename = "gzip")]
    Gzip,
}

/// Password for user defined in HTTP_User
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchHttpPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOpensearchHttpPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchHttpPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOpensearchHttpPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchHttpPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional username credential for access
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOpensearchHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOpensearchHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputOpensearchNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputOpensearchNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputOpensearchNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOpensearchNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOpensearchNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOpensearchNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputOpensearchTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOpensearchTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOpensearchTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOpensearchTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpensearchTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpenTelemetry defines OpenTelemetry Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetry {
    /// This allows you to add custom labels to all metrics exposed through the OpenTelemetry exporter. You may have multiple of these fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addLabel")]
    pub add_label: Option<BTreeMap<String, String>>,
    /// Add a HTTP header key/value pair. Multiple headers can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<BTreeMap<String, String>>,
    /// IP address or hostname of the target HTTP Server, default `127.0.0.1`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Password for user defined in HTTP_User
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPassword")]
    pub http_password: Option<ClusterOutputOpentelemetryHttpPassword>,
    /// Optional username credential for access
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<ClusterOutputOpentelemetryHttpUser>,
    /// Log the response payload within the Fluent Bit log.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logResponsePayload")]
    pub log_response_payload: Option<bool>,
    /// Specify an optional HTTP URI for the target web server listening for logs, e.g: /v1/logs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logsUri")]
    pub logs_uri: Option<String>,
    /// Specify an optional HTTP URI for the target web server listening for metrics, e.g: /v1/metrics
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsUri")]
    pub metrics_uri: Option<String>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputOpentelemetryNetworking>,
    /// TCP port of the target OpenSearch instance, default `80`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Specify an HTTP Proxy. The expected format of this value is http://HOST:PORT. Note that HTTPS is not currently supported.
    /// It is recommended not to set this and to configure the HTTP proxy environment variables instead as they support both HTTP and HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<String>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputOpentelemetryTls>,
    /// Specify an optional HTTP URI for the target web server listening for traces, e.g: /v1/traces
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tracesUri")]
    pub traces_uri: Option<String>,
}

/// Password for user defined in HTTP_User
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryHttpPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOpentelemetryHttpPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryHttpPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOpentelemetryHttpPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryHttpPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional username credential for access
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOpentelemetryHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOpentelemetryHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputOpentelemetryNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputOpentelemetryNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputOpentelemetryNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOpentelemetryNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOpentelemetryNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOpentelemetryNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputOpentelemetryTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOpentelemetryTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOpentelemetryTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOpentelemetryTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOpentelemetryTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// PrometheusExporter_types defines Prometheus exporter configuration to expose metrics from Fluent Bit.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusExporter {
    /// This allows you to add custom labels to all metrics exposed through the prometheus exporter. You may have multiple of these fields
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addLabels")]
    pub add_labels: Option<BTreeMap<String, String>>,
    /// IP address or hostname of the target HTTP Server, default: 0.0.0.0
    pub host: String,
    /// This is the port Fluent Bit will bind to when hosting prometheus metrics.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

/// PrometheusRemoteWrite_types defines Prometheus Remote Write configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWrite {
    /// This allows you to add custom labels to all metrics exposed through the prometheus exporter. You may have multiple of these fields
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addLabels")]
    pub add_labels: Option<BTreeMap<String, String>>,
    /// Add a HTTP header key/value pair. Multiple headers can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, String>>,
    /// IP address or hostname of the target HTTP Server, default: 127.0.0.1
    pub host: String,
    /// Basic Auth Password.
    /// Requires HTTP_user to be se
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPasswd")]
    pub http_passwd: Option<ClusterOutputPrometheusRemoteWriteHttpPasswd>,
    /// Basic Auth Username
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<ClusterOutputPrometheusRemoteWriteHttpUser>,
    /// Log the response payload within the Fluent Bit log,default: false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logResponsePayload")]
    pub log_response_payload: Option<bool>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputPrometheusRemoteWriteNetworking>,
    /// TCP port of the target HTTP Serveri, default:80
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Specify an HTTP Proxy. The expected format of this value is http://HOST:PORT.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<String>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputPrometheusRemoteWriteTls>,
    /// Specify an optional HTTP URI for the target web server, e.g: /something ,default: /
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    /// Enables dedicated thread(s) for this output. Default value is set since version 1.8.13. For previous versions is 0,default : 2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<i32>,
}

/// Basic Auth Password.
/// Requires HTTP_user to be se
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteHttpPasswd {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputPrometheusRemoteWriteHttpPasswdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteHttpPasswdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Basic Auth Username
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputPrometheusRemoteWriteHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputPrometheusRemoteWriteHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputPrometheusRemoteWriteNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputPrometheusRemoteWriteNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputPrometheusRemoteWriteNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputPrometheusRemoteWriteNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputPrometheusRemoteWriteNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputPrometheusRemoteWriteNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputPrometheusRemoteWriteTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputPrometheusRemoteWriteTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputPrometheusRemoteWriteTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// S3 defines S3 Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputS3 {
    /// Immediately retry failed requests to AWS services once.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "AutoRetryRequests")]
    pub auto_retry_requests: Option<bool>,
    /// S3 Bucket name
    #[serde(rename = "Bucket")]
    pub bucket: String,
    /// Predefined Canned ACL Policy for S3 objects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "CannedAcl")]
    pub canned_acl: Option<String>,
    /// Compression type for S3 objects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "Compression")]
    pub compression: Option<String>,
    /// A standard MIME type for the S3 object; this will be set as the Content-Type HTTP header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ContentType")]
    pub content_type: Option<String>,
    /// Custom endpoint for the S3 API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "Endpoint")]
    pub endpoint: Option<String>,
    /// Specify an external ID for the STS API, can be used with the role_arn parameter if your role requires an external ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ExternalId")]
    pub external_id: Option<String>,
    /// Specify the format of the date. Supported formats are double, epoch, iso8601 (eg: 2018-05-30T09:39:52.000681Z) and java_sql_timestamp (eg: 2018-05-30 09:39:52.000681)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "JsonDateFormat")]
    pub json_date_format: Option<String>,
    /// Specify the name of the time key in the output record. To disable the time key just set the value to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "JsonDateKey")]
    pub json_date_key: Option<String>,
    /// By default, the whole log record will be sent to S3. If you specify a key name with this option, then only the value of that key will be sent to S3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "LogKey")]
    pub log_key: Option<String>,
    /// Normally, when an upload request fails, there is a high chance for the last received chunk to be swapped with a later chunk, resulting in data shuffling. This feature prevents this shuffling by using a queue logic for uploads.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "PreserveDataOrdering")]
    pub preserve_data_ordering: Option<bool>,
    /// Option to specify an AWS Profile for credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "Profile")]
    pub profile: Option<String>,
    /// The AWS region of your S3 bucket
    #[serde(rename = "Region")]
    pub region: String,
    /// Integer value to set the maximum number of retries allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "RetryLimit")]
    pub retry_limit: Option<i32>,
    /// ARN of an IAM role to assume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "RoleArn")]
    pub role_arn: Option<String>,
    /// Format string for keys in S3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "S3KeyFormat")]
    pub s3_key_format: Option<String>,
    /// A series of characters which will be used to split the tag into 'parts' for use with the s3_key_format option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "S3KeyFormatTagDelimiters")]
    pub s3_key_format_tag_delimiters: Option<String>,
    /// Send the Content-MD5 header with PutObject and UploadPart requests, as is required when Object Lock is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "SendContentMd5")]
    pub send_content_md5: Option<bool>,
    /// Disables behavior where UUID string is automatically appended to end of S3 key name when $UUID is not provided in s3_key_format. $UUID, time formatters, $TAG, and other dynamic key formatters all work as expected while this feature is set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "StaticFilePath")]
    pub static_file_path: Option<bool>,
    /// Specify the storage class for S3 objects. If this option is not specified, objects will be stored with the default 'STANDARD' storage class.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "StorageClass")]
    pub storage_class: Option<String>,
    /// Directory to locally buffer data before sending.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "StoreDir")]
    pub store_dir: Option<String>,
    /// The size of the limitation for disk usage in S3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "StoreDirLimitSize")]
    pub store_dir_limit_size: Option<String>,
    /// Custom endpoint for the STS API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "StsEndpoint")]
    pub sts_endpoint: Option<String>,
    /// Specifies the size of files in S3. Minimum size is 1M. With use_put_object On the maximum size is 1G. With multipart upload mode, the maximum size is 50G.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "TotalFileSize")]
    pub total_file_size: Option<String>,
    /// The size of each 'part' for multipart uploads. Max: 50M
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "UploadChunkSize")]
    pub upload_chunk_size: Option<String>,
    /// Whenever this amount of time has elapsed, Fluent Bit will complete an upload and create a new file in S3. For example, set this value to 60m and you will get a new file every hour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "UploadTimeout")]
    pub upload_timeout: Option<String>,
    /// Use the S3 PutObject API, instead of the multipart upload API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "UsePutObject")]
    pub use_put_object: Option<bool>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputS3Tls>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputS3Tls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputS3TlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputS3TlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputS3TlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputS3TlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputS3TlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputS3TlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputS3TlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Splunk defines Splunk Output Configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunk {
    /// Enables dedicated thread(s) for this output. Default value `2` is set since version 1.8.13. For previous versions is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "Workers")]
    pub workers: Option<i32>,
    /// Specify X-Splunk-Request-Channel Header for the HTTP Event Collector interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
    /// Set payload compression mechanism. The only available option is gzip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<String>,
    /// Set event fields for the record. This option is an array and the format is "key_name
    /// record_accessor_pattern".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventFields")]
    pub event_fields: Option<Vec<String>>,
    /// Specify the key name that contains the host value. This option allows a record accessors pattern.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventHost")]
    pub event_host: Option<String>,
    /// The name of the index by which the event data is to be indexed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventIndex")]
    pub event_index: Option<String>,
    /// Set a record key that will populate the index field. If the key is found, it will have precedence
    /// over the value set in event_index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventIndexKey")]
    pub event_index_key: Option<String>,
    /// Specify the key name that will be used to send a single value as part of the record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventKey")]
    pub event_key: Option<String>,
    /// Set the source value to assign to the event data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventSource")]
    pub event_source: Option<String>,
    /// Set the sourcetype value to assign to the event data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventSourcetype")]
    pub event_sourcetype: Option<String>,
    /// Set a record key that will populate 'sourcetype'. If the key is found, it will have precedence
    /// over the value set in event_sourcetype.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventSourcetypeKey")]
    pub event_sourcetype_key: Option<String>,
    /// IP address or hostname of the target OpenSearch instance, default `127.0.0.1`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Buffer size used to receive Splunk HTTP responses: Default `2M`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpBufferSize")]
    pub http_buffer_size: Option<String>,
    /// If the HTTP server response code is 400 (bad request) and this flag is enabled, it will print the full HTTP request
    /// and response to the stdout interface. This feature is available for debugging purposes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpDebugBadRequest")]
    pub http_debug_bad_request: Option<bool>,
    /// Password for user defined in HTTP_User
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPassword")]
    pub http_password: Option<ClusterOutputSplunkHttpPassword>,
    /// Optional username credential for access
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<ClusterOutputSplunkHttpUser>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputSplunkNetworking>,
    /// TCP port of the target Splunk instance, default `8088`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// When enabled, the record keys and values are set in the top level of the map instead of under the event key. Refer to
    /// the Sending Raw Events section from the docs more details to make this option work properly.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splunkSendRaw")]
    pub splunk_send_raw: Option<bool>,
    /// Specify the Authentication Token for the HTTP Event Collector interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splunkToken")]
    pub splunk_token: Option<ClusterOutputSplunkSplunkToken>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputSplunkTls>,
}

/// Password for user defined in HTTP_User
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkHttpPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputSplunkHttpPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkHttpPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputSplunkHttpPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkHttpPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional username credential for access
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputSplunkHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputSplunkHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputSplunkNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputSplunkNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputSplunkNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputSplunkNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputSplunkNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputSplunkNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Specify the Authentication Token for the HTTP Event Collector interface.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkSplunkToken {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputSplunkSplunkTokenValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkSplunkTokenValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputSplunkSplunkTokenValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkSplunkTokenValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputSplunkTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputSplunkTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputSplunkTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputSplunkTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSplunkTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Stackdriver defines Stackdriver Output Configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputStackdriver {
    /// Rewrite the trace field to be formatted for use with GCP Cloud Trace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoformatStackdriverTrace")]
    pub autoformat_stackdriver_trace: Option<bool>,
    /// A custom regex to extract fields from the local_resource_id of the logs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customK8sRegex")]
    pub custom_k8s_regex: Option<String>,
    /// The GCP Project that should receive the logs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exportToProjectID")]
    pub export_to_project_id: Option<String>,
    /// Path to GCP Credentials JSON file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "googleServiceCredentials")]
    pub google_service_credentials: Option<String>,
    /// Identifier for a grouping of tasks. Required if Resource is generic_task
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub job: Option<String>,
    /// Location of the cluster that contains the pods/nodes. Required if Resource is k8s_container, k8s_node, or k8s_pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sClusterLocation")]
    pub k8s_cluster_location: Option<String>,
    /// Name of the cluster that the pod is running in. Required if Resource is k8s_container, k8s_node, or k8s_pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sClusterName")]
    pub k8s_cluster_name: Option<String>,
    /// Optional list of comma separated of strings for key/value pairs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<Vec<String>>,
    /// Used by Stackdriver to find related labels and extract them to LogEntry Labels
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelsKey")]
    pub labels_key: Option<String>,
    /// GCP/AWS region to store data. Required if Resource is generic_node or generic_task
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// The value of this field is set as the logName field in Stackdriver
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logNameKey")]
    pub log_name_key: Option<String>,
    /// Metadata Server Prefix
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataServer")]
    pub metadata_server: Option<String>,
    /// Namespace identifier. Required if Resource is generic_node or generic_task
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Node identifier within the namespace. Required if Resource is generic_node or generic_task
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeID")]
    pub node_id: Option<String>,
    /// Set resource types of data
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
    /// Optional list of comma seperated strings. Setting these fields overrides the Stackdriver monitored resource API values
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    pub resource_labels: Option<Vec<String>>,
    /// Email associated with the service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountEmail")]
    pub service_account_email: Option<ClusterOutputStackdriverServiceAccountEmail>,
    /// Private Key associated with the service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountSecret")]
    pub service_account_secret: Option<ClusterOutputStackdriverServiceAccountSecret>,
    /// Specify the key that contains the severity information for the logs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "severityKey")]
    pub severity_key: Option<String>,
    /// Used to validate the tags of logs that when the Resource is k8s_container, k8s_node, or k8s_pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagPrefix")]
    pub tag_prefix: Option<String>,
    /// Identifier for a task within a namespace. Required if Resource is generic_task
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskID")]
    pub task_id: Option<String>,
    /// Number of dedicated threads for the Stackdriver Output Plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<i32>,
}

/// Email associated with the service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputStackdriverServiceAccountEmail {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputStackdriverServiceAccountEmailValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputStackdriverServiceAccountEmailValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputStackdriverServiceAccountEmailValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputStackdriverServiceAccountEmailValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Private Key associated with the service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputStackdriverServiceAccountSecret {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputStackdriverServiceAccountSecretValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputStackdriverServiceAccountSecretValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputStackdriverServiceAccountSecretValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputStackdriverServiceAccountSecretValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Stdout defines Stdout Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputStdout {
    /// Specify the data format to be printed. Supported formats are msgpack json, json_lines and json_stream.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<ClusterOutputStdoutFormat>,
    /// Specify the format of the date. Supported formats are double,  iso8601 (eg: 2018-05-30T09:39:52.000681Z) and epoch.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonDateFormat")]
    pub json_date_format: Option<ClusterOutputStdoutJsonDateFormat>,
    /// Specify the name of the date field in output.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonDateKey")]
    pub json_date_key: Option<String>,
}

/// Stdout defines Stdout Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputStdoutFormat {
    #[serde(rename = "msgpack")]
    Msgpack,
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "json_lines")]
    JsonLines,
    #[serde(rename = "json_stream")]
    JsonStream,
}

/// Stdout defines Stdout Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputStdoutJsonDateFormat {
    #[serde(rename = "double")]
    Double,
    #[serde(rename = "iso8601")]
    Iso8601,
    #[serde(rename = "epoch")]
    Epoch,
}

/// Syslog defines Syslog Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSyslog {
    /// Host domain or IP address of the remote Syslog server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Mode of the desired transport type, the available options are tcp, tls and udp.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputSyslogNetworking>,
    /// TCP or UDP port of the remote Syslog server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Key name from the original record that contains the application name that generated the message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogAppnameKey")]
    pub syslog_appname_key: Option<String>,
    /// Key from the original record that contains the Syslog facility number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogFacilityKey")]
    pub syslog_facility_key: Option<String>,
    /// Syslog protocol format to use, the available options are rfc3164 and rfc5424.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogFormat")]
    pub syslog_format: Option<String>,
    /// Key name from the original record that contains the hostname that generated the message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogHostnameKey")]
    pub syslog_hostname_key: Option<String>,
    /// Maximum size allowed per message, in bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogMaxSize")]
    pub syslog_max_size: Option<i32>,
    /// Key name from the original record that contains the Message ID associated to the message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogMessageIDKey")]
    pub syslog_message_id_key: Option<String>,
    /// Key key name that contains the message to deliver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogMessageKey")]
    pub syslog_message_key: Option<String>,
    /// Key name from the original record that contains the Process ID that generated the message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogProcessIDKey")]
    pub syslog_process_id_key: Option<String>,
    /// Key name from the original record that contains the Structured Data (SD) content.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogSDKey")]
    pub syslog_sd_key: Option<String>,
    /// Key from the original record that contains the Syslog severity number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogSeverityKey")]
    pub syslog_severity_key: Option<String>,
    /// Syslog output plugin supports TTL/SSL, for more details about the properties available
    /// and general configuration, please refer to the TLS/SSL section.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputSyslogTls>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSyslogNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputSyslogNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputSyslogNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputSyslogNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputSyslogNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputSyslogNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputSyslogNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Syslog output plugin supports TTL/SSL, for more details about the properties available
/// and general configuration, please refer to the TLS/SSL section.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSyslogTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputSyslogTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Syslog output plugin supports TTL/SSL, for more details about the properties available
/// and general configuration, please refer to the TLS/SSL section.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputSyslogTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSyslogTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputSyslogTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSyslogTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputSyslogTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputSyslogTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TCP defines TCP Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputTcp {
    /// Specify the data format to be printed. Supported formats are msgpack json, json_lines and json_stream.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<ClusterOutputTcpFormat>,
    /// Target host where Fluent-Bit or Fluentd are listening for Forward messages.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Specify the format of the date. Supported formats are double, epoch
    /// and iso8601 (eg: 2018-05-30T09:39:52.000681Z)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonDateFormat")]
    pub json_date_format: Option<ClusterOutputTcpJsonDateFormat>,
    /// TSpecify the name of the time key in the output record.
    /// To disable the time key just set the value to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonDateKey")]
    pub json_date_key: Option<String>,
    /// Include fluentbit networking options for this output-plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<ClusterOutputTcpNetworking>,
    /// TCP Port of the target service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterOutputTcpTls>,
}

/// TCP defines TCP Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputTcpFormat {
    #[serde(rename = "msgpack")]
    Msgpack,
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "json_lines")]
    JsonLines,
    #[serde(rename = "json_stream")]
    JsonStream,
}

/// TCP defines TCP Output configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputTcpJsonDateFormat {
    #[serde(rename = "double")]
    Double,
    #[serde(rename = "epoch")]
    Epoch,
    #[serde(rename = "iso8601")]
    Iso8601,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputTcpNetworking {
    /// Select the primary DNS connection type (TCP or UDP).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSMode")]
    pub dns_mode: Option<ClusterOutputTcpNetworkingDnsMode>,
    /// Prioritize IPv4 DNS results when trying to establish a connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSPreferIPv4")]
    pub dns_prefer_i_pv4: Option<bool>,
    /// Select the primary DNS resolver type (LEGACY or ASYNC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "DNSResolver")]
    pub dns_resolver: Option<ClusterOutputTcpNetworkingDnsResolver>,
    /// Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<i32>,
    /// On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeoutLogError")]
    pub connect_timeout_log_error: Option<bool>,
    /// Enable or disable connection keepalive support. Accepts a boolean value: on / off.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<ClusterOutputTcpNetworkingKeepalive>,
    /// Set maximum time expressed in seconds for an idle keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveIdleTimeout")]
    pub keepalive_idle_timeout: Option<i32>,
    /// Set maximum number of times a keepalive connection can be used before it is retired.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveMaxRecycle")]
    pub keepalive_max_recycle: Option<i32>,
    /// Set maximum number of TCP connections that can be established per worker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxWorkerConnections")]
    pub max_worker_connections: Option<i32>,
    /// Specify network address to bind for data traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddress")]
    pub source_address: Option<String>,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputTcpNetworkingDnsMode {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputTcpNetworkingDnsResolver {
    #[serde(rename = "LEGACY")]
    Legacy,
    #[serde(rename = "ASYNC")]
    Async,
}

/// Include fluentbit networking options for this output-plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputTcpNetworkingKeepalive {
    #[serde(rename = "on")]
    On,
    #[serde(rename = "off")]
    Off,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputTcpTls {
    /// Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Absolute path to scan for certificate files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    /// Absolute path to Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crtFile")]
    pub crt_file: Option<String>,
    /// Set TLS debug verbosity level.
    /// It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<i32>,
    /// Absolute path to private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Optional password for tls.key_file file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyPassword")]
    pub key_password: Option<ClusterOutputTcpTlsKeyPassword>,
    /// Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Hostname to be used for TLS SNI extension
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vhost: Option<String>,
}

/// Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputTcpTlsDebug {
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
    #[serde(rename = "4")]
    r#_4,
}

/// Optional password for tls.key_file file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputTcpTlsKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputTcpTlsKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputTcpTlsKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputTcpTlsKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputTcpTlsKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

