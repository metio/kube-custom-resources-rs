// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/karmada-io/karmada/work.karmada.io/v1alpha2/resourcebindings.yaml --derive=PartialEq
// kopium version: 0.18.0

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;

/// Spec represents the desired behavior.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "work.karmada.io", version = "v1alpha2", kind = "ResourceBinding", plural = "resourcebindings")]
#[kube(namespaced)]
#[kube(status = "ResourceBindingStatus")]
#[kube(schema = "disabled")]
pub struct ResourceBindingSpec {
    /// Clusters represents target member clusters where the resource to be deployed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clusters: Option<Vec<ResourceBindingClusters>>,
    /// ConflictResolution declares how potential conflict should be handled when a resource that is being propagated already exists in the target cluster. 
    ///  It defaults to "Abort" which means stop propagating to avoid unexpected overwrites. The "Overwrite" might be useful when migrating legacy cluster resources to Karmada, in which case conflict is predictable and can be instructed to Karmada take over the resource by overwriting.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conflictResolution")]
    pub conflict_resolution: Option<ResourceBindingConflictResolution>,
    /// Failover indicates how Karmada migrates applications in case of failures. It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<ResourceBindingFailover>,
    /// GracefulEvictionTasks holds the eviction tasks that are expected to perform the eviction in a graceful way. The intended workflow is: 1. Once the controller(such as 'taint-manager') decided to evict the resource that is referenced by current ResourceBinding or ClusterResourceBinding from a target cluster, it removes(or scale down the replicas) the target from Clusters(.spec.Clusters) and builds a graceful eviction task. 2. The scheduler may perform a re-scheduler and probably select a substitute cluster to take over the evicting workload(resource). 3. The graceful eviction controller takes care of the graceful eviction tasks and performs the final removal after the workload(resource) is available on the substitute cluster or exceed the grace termination period(defaults to 10 minutes).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gracefulEvictionTasks")]
    pub graceful_eviction_tasks: Option<Vec<ResourceBindingGracefulEvictionTasks>>,
    /// Placement represents the rule for select clusters to propagate resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub placement: Option<ResourceBindingPlacement>,
    /// PropagateDeps tells if relevant resources should be propagated automatically. It is inherited from PropagationPolicy or ClusterPropagationPolicy. default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "propagateDeps")]
    pub propagate_deps: Option<bool>,
    /// ReplicaRequirements represents the requirements required by each replica.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaRequirements")]
    pub replica_requirements: Option<ResourceBindingReplicaRequirements>,
    /// Replicas represents the replica number of the referencing resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// RequiredBy represents the list of Bindings that depend on the referencing resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredBy")]
    pub required_by: Option<Vec<ResourceBindingRequiredBy>>,
    /// Resource represents the Kubernetes resource to be propagated.
    pub resource: ResourceBindingResource,
    /// SchedulerName represents which scheduler to proceed the scheduling. It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
}

/// TargetCluster represents the identifier of a member cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingClusters {
    /// Name of target cluster.
    pub name: String,
    /// Replicas in target cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
}

/// Spec represents the desired behavior.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ResourceBindingConflictResolution {
    Abort,
    Overwrite,
}

/// Failover indicates how Karmada migrates applications in case of failures. It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingFailover {
    /// Application indicates failover behaviors in case of application failure. If this value is nil, failover is disabled. If set, the PropagateDeps should be true so that the dependencies could be migrated along with the application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub application: Option<ResourceBindingFailoverApplication>,
}

/// Application indicates failover behaviors in case of application failure. If this value is nil, failover is disabled. If set, the PropagateDeps should be true so that the dependencies could be migrated along with the application.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingFailoverApplication {
    /// DecisionConditions indicates the decision conditions of performing the failover process. Only when all conditions are met can the failover process be performed. Currently, DecisionConditions includes several conditions: - TolerationSeconds (optional)
    #[serde(rename = "decisionConditions")]
    pub decision_conditions: ResourceBindingFailoverApplicationDecisionConditions,
    /// GracePeriodSeconds is the maximum waiting duration in seconds before application on the migrated cluster should be deleted. Required only when PurgeMode is "Graciously" and defaults to 600s. If the application on the new cluster cannot reach a Healthy state, Karmada will delete the application after GracePeriodSeconds is reached. Value must be positive integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gracePeriodSeconds")]
    pub grace_period_seconds: Option<i32>,
    /// PurgeMode represents how to deal with the legacy applications on the cluster from which the application is migrated. Valid options are "Immediately", "Graciously" and "Never". Defaults to "Graciously".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "purgeMode")]
    pub purge_mode: Option<String>,
}

/// DecisionConditions indicates the decision conditions of performing the failover process. Only when all conditions are met can the failover process be performed. Currently, DecisionConditions includes several conditions: - TolerationSeconds (optional)
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingFailoverApplicationDecisionConditions {
    /// TolerationSeconds represents the period of time Karmada should wait after reaching the desired state before performing failover process. If not specified, Karmada will immediately perform failover process. Defaults to 300s.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i32>,
}

/// GracefulEvictionTask represents a graceful eviction task.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingGracefulEvictionTasks {
    /// CreationTimestamp is a timestamp representing the server time when this object was created. Clients should not set this value to avoid the time inconsistency issue. It is represented in RFC3339 form(like '2021-04-25T10:02:10Z') and is in UTC. 
    ///  Populated by the system. Read-only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationTimestamp")]
    pub creation_timestamp: Option<String>,
    /// FromCluster which cluster the eviction perform from.
    #[serde(rename = "fromCluster")]
    pub from_cluster: String,
    /// GracePeriodSeconds is the maximum waiting duration in seconds before the item should be deleted. If the application on the new cluster cannot reach a Healthy state, Karmada will delete the item after GracePeriodSeconds is reached. Value must be positive integer. It can not co-exist with SuppressDeletion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gracePeriodSeconds")]
    pub grace_period_seconds: Option<i32>,
    /// Message is a human-readable message indicating details about the eviction. This may be an empty string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Producer indicates the controller who triggered the eviction.
    pub producer: String,
    /// Reason contains a programmatic identifier indicating the reason for the eviction. Producers may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// Replicas indicates the number of replicas should be evicted. Should be ignored for resource type that doesn't have replica.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// SuppressDeletion represents the grace period will be persistent until the tools or human intervention stops it. It can not co-exist with GracePeriodSeconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suppressDeletion")]
    pub suppress_deletion: Option<bool>,
}

/// Placement represents the rule for select clusters to propagate resources.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacement {
    /// ClusterAffinities represents scheduling restrictions to multiple cluster groups that indicated by ClusterAffinityTerm. 
    ///  The scheduler will evaluate these groups one by one in the order they appear in the spec, the group that does not satisfy scheduling restrictions will be ignored which means all clusters in this group will not be selected unless it also belongs to the next group(a cluster could belong to multiple groups). 
    ///  If none of the groups satisfy the scheduling restrictions, then scheduling fails, which means no cluster will be selected. 
    ///  Note: 1. ClusterAffinities can not co-exist with ClusterAffinity. 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster can be scheduling candidates. 
    ///  Potential use case 1: The private clusters in the local data center could be the main group, and the managed clusters provided by cluster providers could be the secondary group. So that the Karmada scheduler would prefer to schedule workloads to the main group and the second group will only be considered in case of the main group does not satisfy restrictions(like, lack of resources). 
    ///  Potential use case 2: For the disaster recovery scenario, the clusters could be organized to primary and backup groups, the workloads would be scheduled to primary clusters firstly, and when primary cluster fails(like data center power off), Karmada scheduler could migrate workloads to the backup clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterAffinities")]
    pub cluster_affinities: Option<Vec<ResourceBindingPlacementClusterAffinities>>,
    /// ClusterAffinity represents scheduling restrictions to a certain set of clusters. Note: 1. ClusterAffinity can not co-exist with ClusterAffinities. 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster can be scheduling candidates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterAffinity")]
    pub cluster_affinity: Option<ResourceBindingPlacementClusterAffinity>,
    /// ClusterTolerations represents the tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTolerations")]
    pub cluster_tolerations: Option<Vec<ResourceBindingPlacementClusterTolerations>>,
    /// ReplicaScheduling represents the scheduling policy on dealing with the number of replicas when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaScheduling")]
    pub replica_scheduling: Option<ResourceBindingPlacementReplicaScheduling>,
    /// SpreadConstraints represents a list of the scheduling constraints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spreadConstraints")]
    pub spread_constraints: Option<Vec<ResourceBindingPlacementSpreadConstraints>>,
}

/// ClusterAffinityTerm selects a set of cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinities {
    /// AffinityName is the name of the cluster group.
    #[serde(rename = "affinityName")]
    pub affinity_name: String,
    /// ClusterNames is the list of clusters to be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterNames")]
    pub cluster_names: Option<Vec<String>>,
    /// ExcludedClusters is the list of clusters to be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exclude: Option<Vec<String>>,
    /// FieldSelector is a filter to select member clusters by fields. The key(field) of the match expression should be 'provider', 'region', or 'zone', and the operator of the match expression should be 'In' or 'NotIn'. If non-nil and non-empty, only the clusters match this filter will be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldSelector")]
    pub field_selector: Option<ResourceBindingPlacementClusterAffinitiesFieldSelector>,
    /// LabelSelector is a filter to select member clusters by labels. If non-nil and non-empty, only the clusters match this filter will be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ResourceBindingPlacementClusterAffinitiesLabelSelector>,
}

/// FieldSelector is a filter to select member clusters by fields. The key(field) of the match expression should be 'provider', 'region', or 'zone', and the operator of the match expression should be 'In' or 'NotIn'. If non-nil and non-empty, only the clusters match this filter will be selected.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinitiesFieldSelector {
    /// A list of field selector requirements.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ResourceBindingPlacementClusterAffinitiesFieldSelectorMatchExpressions>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinitiesFieldSelectorMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// LabelSelector is a filter to select member clusters by labels. If non-nil and non-empty, only the clusters match this filter will be selected.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinitiesLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ResourceBindingPlacementClusterAffinitiesLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinitiesLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ClusterAffinity represents scheduling restrictions to a certain set of clusters. Note: 1. ClusterAffinity can not co-exist with ClusterAffinities. 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster can be scheduling candidates.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinity {
    /// ClusterNames is the list of clusters to be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterNames")]
    pub cluster_names: Option<Vec<String>>,
    /// ExcludedClusters is the list of clusters to be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exclude: Option<Vec<String>>,
    /// FieldSelector is a filter to select member clusters by fields. The key(field) of the match expression should be 'provider', 'region', or 'zone', and the operator of the match expression should be 'In' or 'NotIn'. If non-nil and non-empty, only the clusters match this filter will be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldSelector")]
    pub field_selector: Option<ResourceBindingPlacementClusterAffinityFieldSelector>,
    /// LabelSelector is a filter to select member clusters by labels. If non-nil and non-empty, only the clusters match this filter will be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ResourceBindingPlacementClusterAffinityLabelSelector>,
}

/// FieldSelector is a filter to select member clusters by fields. The key(field) of the match expression should be 'provider', 'region', or 'zone', and the operator of the match expression should be 'In' or 'NotIn'. If non-nil and non-empty, only the clusters match this filter will be selected.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinityFieldSelector {
    /// A list of field selector requirements.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ResourceBindingPlacementClusterAffinityFieldSelectorMatchExpressions>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinityFieldSelectorMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// LabelSelector is a filter to select member clusters by labels. If non-nil and non-empty, only the clusters match this filter will be selected.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinityLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ResourceBindingPlacementClusterAffinityLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterAffinityLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementClusterTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// ReplicaScheduling represents the scheduling policy on dealing with the number of replicas when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementReplicaScheduling {
    /// ReplicaDivisionPreference determines how the replicas is divided when ReplicaSchedulingType is "Divided". Valid options are Aggregated and Weighted. "Aggregated" divides replicas into clusters as few as possible, while respecting clusters' resource availabilities during the division. "Weighted" divides replicas by weight according to WeightPreference.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaDivisionPreference")]
    pub replica_division_preference: Option<ResourceBindingPlacementReplicaSchedulingReplicaDivisionPreference>,
    /// ReplicaSchedulingType determines how the replicas is scheduled when karmada propagating a resource. Valid options are Duplicated and Divided. "Duplicated" duplicates the same replicas to each candidate member cluster from resource. "Divided" divides replicas into parts according to number of valid candidate member clusters, and exact replicas for each cluster are determined by ReplicaDivisionPreference.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaSchedulingType")]
    pub replica_scheduling_type: Option<ResourceBindingPlacementReplicaSchedulingReplicaSchedulingType>,
    /// WeightPreference describes weight for each cluster or for each group of cluster If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightPreference")]
    pub weight_preference: Option<ResourceBindingPlacementReplicaSchedulingWeightPreference>,
}

/// ReplicaScheduling represents the scheduling policy on dealing with the number of replicas when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ResourceBindingPlacementReplicaSchedulingReplicaDivisionPreference {
    Aggregated,
    Weighted,
}

/// ReplicaScheduling represents the scheduling policy on dealing with the number of replicas when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ResourceBindingPlacementReplicaSchedulingReplicaSchedulingType {
    Duplicated,
    Divided,
}

/// WeightPreference describes weight for each cluster or for each group of cluster If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementReplicaSchedulingWeightPreference {
    /// DynamicWeight specifies the factor to generates dynamic weight list. If specified, StaticWeightList will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicWeight")]
    pub dynamic_weight: Option<ResourceBindingPlacementReplicaSchedulingWeightPreferenceDynamicWeight>,
    /// StaticWeightList defines the static cluster weight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticWeightList")]
    pub static_weight_list: Option<Vec<ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightList>>,
}

/// WeightPreference describes weight for each cluster or for each group of cluster If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ResourceBindingPlacementReplicaSchedulingWeightPreferenceDynamicWeight {
    AvailableReplicas,
}

/// StaticClusterWeight defines the static cluster weight.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightList {
    /// TargetCluster describes the filter to select clusters.
    #[serde(rename = "targetCluster")]
    pub target_cluster: ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster,
    /// Weight expressing the preference to the cluster(s) specified by 'TargetCluster'.
    pub weight: i64,
}

/// TargetCluster describes the filter to select clusters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster {
    /// ClusterNames is the list of clusters to be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterNames")]
    pub cluster_names: Option<Vec<String>>,
    /// ExcludedClusters is the list of clusters to be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exclude: Option<Vec<String>>,
    /// FieldSelector is a filter to select member clusters by fields. The key(field) of the match expression should be 'provider', 'region', or 'zone', and the operator of the match expression should be 'In' or 'NotIn'. If non-nil and non-empty, only the clusters match this filter will be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldSelector")]
    pub field_selector: Option<ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector>,
    /// LabelSelector is a filter to select member clusters by labels. If non-nil and non-empty, only the clusters match this filter will be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector>,
}

/// FieldSelector is a filter to select member clusters by fields. The key(field) of the match expression should be 'provider', 'region', or 'zone', and the operator of the match expression should be 'In' or 'NotIn'. If non-nil and non-empty, only the clusters match this filter will be selected.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector {
    /// A list of field selector requirements.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// LabelSelector is a filter to select member clusters by labels. If non-nil and non-empty, only the clusters match this filter will be selected.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// SpreadConstraint represents the spread constraints on resources.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingPlacementSpreadConstraints {
    /// MaxGroups restricts the maximum number of cluster groups to be selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxGroups")]
    pub max_groups: Option<i64>,
    /// MinGroups restricts the minimum number of cluster groups to be selected. Defaults to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minGroups")]
    pub min_groups: Option<i64>,
    /// SpreadByField represents the fields on Karmada cluster API used for dynamically grouping member clusters into different groups. Resources will be spread among different cluster groups. Available fields for spreading are: cluster, region, zone, and provider. SpreadByField should not co-exist with SpreadByLabel. If both SpreadByField and SpreadByLabel are empty, SpreadByField will be set to "cluster" by system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spreadByField")]
    pub spread_by_field: Option<ResourceBindingPlacementSpreadConstraintsSpreadByField>,
    /// SpreadByLabel represents the label key used for grouping member clusters into different groups. Resources will be spread among different cluster groups. SpreadByLabel should not co-exist with SpreadByField.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spreadByLabel")]
    pub spread_by_label: Option<String>,
}

/// SpreadConstraint represents the spread constraints on resources.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ResourceBindingPlacementSpreadConstraintsSpreadByField {
    #[serde(rename = "cluster")]
    Cluster,
    #[serde(rename = "region")]
    Region,
    #[serde(rename = "zone")]
    Zone,
    #[serde(rename = "provider")]
    Provider,
}

/// ReplicaRequirements represents the requirements required by each replica.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingReplicaRequirements {
    /// Namespace represents the resources namespaces
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeClaim")]
    pub node_claim: Option<ResourceBindingReplicaRequirementsNodeClaim>,
    /// PriorityClassName represents the resources priorityClassName
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// ResourceRequest represents the resources required by each replica.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceRequest")]
    pub resource_request: Option<BTreeMap<String, IntOrString>>,
}

/// NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingReplicaRequirementsNodeClaim {
    /// A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms. Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution is included here because it has a hard limit on pod scheduling.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hardNodeAffinity")]
    pub hard_node_affinity: Option<ResourceBindingReplicaRequirementsNodeClaimHardNodeAffinity>,
    /// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// If specified, the pod's tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<ResourceBindingReplicaRequirementsNodeClaimTolerations>>,
}

/// A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms. Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution is included here because it has a hard limit on pod scheduling.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingReplicaRequirementsNodeClaimHardNodeAffinity {
    /// Required. A list of node selector terms. The terms are ORed.
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<ResourceBindingReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms>,
}

/// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms {
    /// A list of node selector requirements by node's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ResourceBindingReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions>>,
    /// A list of node selector requirements by node's fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<ResourceBindingReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingReplicaRequirementsNodeClaimTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// BindingSnapshot is a snapshot of a ResourceBinding or ClusterResourceBinding.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingRequiredBy {
    /// Clusters represents the scheduled result.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clusters: Option<Vec<ResourceBindingRequiredByClusters>>,
    /// Name represents the name of the Binding.
    pub name: String,
    /// Namespace represents the namespace of the Binding. It is required for ResourceBinding. If Namespace is not specified, means the referencing is ClusterResourceBinding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// TargetCluster represents the identifier of a member cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingRequiredByClusters {
    /// Name of target cluster.
    pub name: String,
    /// Replicas in target cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
}

/// Resource represents the Kubernetes resource to be propagated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingResource {
    /// APIVersion represents the API version of the referent.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// Kind represents the Kind of the referent.
    pub kind: String,
    /// Name represents the name of the referent.
    pub name: String,
    /// Namespace represents the namespace for the referent. For non-namespace scoped resources(e.g. 'ClusterRole')，do not need specify Namespace, and for namespace scoped resources, Namespace is required. If Namespace is not specified, means the resource is non-namespace scoped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// ResourceVersion represents the internal version of the referenced object, that can be used by clients to determine when object has changed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceVersion")]
    pub resource_version: Option<String>,
    /// UID of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

/// Status represents the most recently observed status of the ResourceBinding.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingStatus {
    /// AggregatedStatus represents status list of the resource running in each member cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aggregatedStatus")]
    pub aggregated_status: Option<Vec<ResourceBindingStatusAggregatedStatus>>,
    /// Conditions contain the different condition statuses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// SchedulerObservedGeneration is the generation(.metadata.generation) observed by the scheduler. If SchedulerObservedGeneration is less than the generation in metadata means the scheduler hasn't confirmed the scheduling result or hasn't done the schedule yet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerObservedGeneration")]
    pub scheduler_observed_generation: Option<i64>,
    /// SchedulerObservedAffinityName is the name of affinity term that is the basis of current scheduling.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerObservingAffinityName")]
    pub scheduler_observing_affinity_name: Option<String>,
}

/// AggregatedStatusItem represents status of the resource running in a member cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ResourceBindingStatusAggregatedStatus {
    /// Applied represents if the resource referencing by ResourceBinding or ClusterResourceBinding is successfully applied on the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub applied: Option<bool>,
    /// AppliedMessage is a human readable message indicating details about the applied status. This is usually holds the error message in case of apply failed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appliedMessage")]
    pub applied_message: Option<String>,
    /// ClusterName represents the member cluster name which the resource deployed on.
    #[serde(rename = "clusterName")]
    pub cluster_name: String,
    /// Health represents the healthy state of the current resource. There maybe different rules for different resources to achieve health status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health: Option<ResourceBindingStatusAggregatedStatusHealth>,
    /// Status reflects running status of current manifest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<BTreeMap<String, serde_json::Value>>,
}

/// AggregatedStatusItem represents status of the resource running in a member cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ResourceBindingStatusAggregatedStatusHealth {
    Healthy,
    Unhealthy,
    Unknown,
}

