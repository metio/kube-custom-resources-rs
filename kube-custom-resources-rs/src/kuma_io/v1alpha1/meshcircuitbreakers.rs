// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/kumahq/kuma/kuma.io/v1alpha1/meshcircuitbreakers.yaml --derive=Default --derive=PartialEq
// kopium version: 0.17.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// Spec is the specification of the Kuma MeshCircuitBreaker resource.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "kuma.io", version = "v1alpha1", kind = "MeshCircuitBreaker", plural = "meshcircuitbreakers")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
pub struct MeshCircuitBreakerSpec {
    /// From list makes a match between clients and corresponding configurations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<Vec<MeshCircuitBreakerFrom>>,
    /// TargetRef is a reference to the resource the policy takes an effect on.
    /// The resource could be either a real store object or virtual resource
    /// defined in place.
    #[serde(rename = "targetRef")]
    pub target_ref: MeshCircuitBreakerTargetRef,
    /// To list makes a match between the consumed services and corresponding
    /// configurations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<Vec<MeshCircuitBreakerTo>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFrom {
    /// Default is a configuration specific to the group of destinations
    /// referenced in 'targetRef'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<MeshCircuitBreakerFromDefault>,
    /// TargetRef is a reference to the resource that represents a group of
    /// destinations.
    #[serde(rename = "targetRef")]
    pub target_ref: MeshCircuitBreakerFromTargetRef,
}

/// Default is a configuration specific to the group of destinations
/// referenced in 'targetRef'
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromDefault {
    /// ConnectionLimits contains configuration of each circuit breaking limit,
    /// which when exceeded makes the circuit breaker to become open (no traffic
    /// is allowed like no current is allowed in the circuits when physical
    /// circuit breaker ir open)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionLimits")]
    pub connection_limits: Option<MeshCircuitBreakerFromDefaultConnectionLimits>,
    /// OutlierDetection contains the configuration of the process of dynamically
    /// determining whether some number of hosts in an upstream cluster are
    /// performing unlike the others and removing them from the healthy load
    /// balancing set. Performance might be along different axes such as
    /// consecutive failures, temporal success rate, temporal latency, etc.
    /// Outlier detection is a form of passive health checking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<MeshCircuitBreakerFromDefaultOutlierDetection>,
}

/// ConnectionLimits contains configuration of each circuit breaking limit,
/// which when exceeded makes the circuit breaker to become open (no traffic
/// is allowed like no current is allowed in the circuits when physical
/// circuit breaker ir open)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromDefaultConnectionLimits {
    /// The maximum number of connection pools per cluster that are concurrently
    /// supported at once. Set this for clusters which create a large number of
    /// connection pools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionPools")]
    pub max_connection_pools: Option<i32>,
    /// The maximum number of connections allowed to be made to the upstream
    /// cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// The maximum number of pending requests that are allowed to the upstream
    /// cluster. This limit is applied as a connection limit for non-HTTP
    /// traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPendingRequests")]
    pub max_pending_requests: Option<i32>,
    /// The maximum number of parallel requests that are allowed to be made
    /// to the upstream cluster. This limit does not apply to non-HTTP traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequests")]
    pub max_requests: Option<i32>,
    /// The maximum number of parallel retries that will be allowed to
    /// the upstream cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
}

/// OutlierDetection contains the configuration of the process of dynamically
/// determining whether some number of hosts in an upstream cluster are
/// performing unlike the others and removing them from the healthy load
/// balancing set. Performance might be along different axes such as
/// consecutive failures, temporal success rate, temporal latency, etc.
/// Outlier detection is a form of passive health checking.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromDefaultOutlierDetection {
    /// The base time that a host is ejected for. The real time is equal to
    /// the base time multiplied by the number of times the host has been
    /// ejected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Contains configuration for supported outlier detectors
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub detectors: Option<MeshCircuitBreakerFromDefaultOutlierDetectionDetectors>,
    /// When set to true, outlierDetection configuration won't take any effect
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// The time interval between ejection analysis sweeps. This can result in
    /// both new ejections and hosts being returned to service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// The maximum % of an upstream cluster that can be ejected due to outlier
    /// detection. Defaults to 10% but will eject at least one host regardless of
    /// the value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external
    /// errors. If set to true the following configuration parameters are taken
    /// into account: detectors.localOriginFailures.consecutive
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalAndLocalErrors")]
    pub split_external_and_local_errors: Option<bool>,
}

/// Contains configuration for supported outlier detectors
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromDefaultOutlierDetectionDetectors {
    /// Failure Percentage based outlier detection functions similarly to success
    /// rate detection, in that it relies on success rate data from each host in
    /// a cluster. However, rather than compare those values to the mean success
    /// rate of the cluster as a whole, they are compared to a flat
    /// user-configured threshold. This threshold is configured via the
    /// outlierDetection.failurePercentageThreshold field.
    /// The other configuration fields for failure percentage based detection are
    /// similar to the fields for success rate detection. As with success rate
    /// detection, detection will not be performed for a host if its request
    /// volume over the aggregation interval is less than the
    /// outlierDetection.detectors.failurePercentage.requestVolume value.
    /// Detection also will not be performed for a cluster if the number of hosts
    /// with the minimum required request volume in an interval is less than the
    /// outlierDetection.detectors.failurePercentage.minimumHosts value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failurePercentage")]
    pub failure_percentage: Option<MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsFailurePercentage>,
    /// In the default mode (outlierDetection.splitExternalLocalOriginErrors is
    /// false) this detection type takes into account a subset of 5xx errors,
    /// called "gateway errors" (502, 503 or 504 status code) and local origin
    /// failures, such as timeout, TCP reset etc.
    /// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
    /// this detection type takes into account a subset of 5xx errors, called
    /// "gateway errors" (502, 503 or 504 status code) and is supported only by
    /// the http router.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayFailures")]
    pub gateway_failures: Option<MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsGatewayFailures>,
    /// This detection type is enabled only when
    /// outlierDetection.splitExternalLocalOriginErrors is true and takes into
    /// account only locally originated errors (timeout, reset, etc).
    /// If Envoy repeatedly cannot connect to an upstream host or communication
    /// with the upstream host is repeatedly interrupted, it will be ejected.
    /// Various locally originated problems are detected: timeout, TCP reset,
    /// ICMP errors, etc. This detection type is supported by http router and
    /// tcp proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localOriginFailures")]
    pub local_origin_failures: Option<MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsLocalOriginFailures>,
    /// Success Rate based outlier detection aggregates success rate data from
    /// every host in a cluster. Then at given intervals ejects hosts based on
    /// statistical outlier detection. Success Rate outlier detection will not be
    /// calculated for a host if its request volume over the aggregation interval
    /// is less than the outlierDetection.detectors.successRate.requestVolume
    /// value.
    /// Moreover, detection will not be performed for a cluster if the number of
    /// hosts with the minimum required request volume in an interval is less
    /// than the outlierDetection.detectors.successRate.minimumHosts value.
    /// In the default configuration mode
    /// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
    /// type takes into account all types of errors: locally and externally
    /// originated.
    /// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
    /// locally originated errors and externally originated (transaction) errors
    /// are counted and treated separately.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successRate")]
    pub success_rate: Option<MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsSuccessRate>,
    /// In the default mode (outlierDetection.splitExternalAndLocalErrors is
    /// false) this detection type takes into account all generated errors:
    /// locally originated and externally originated (transaction) errors.
    /// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
    /// this detection type takes into account only externally originated
    /// (transaction) errors, ignoring locally originated errors.
    /// If an upstream host is an HTTP-server, only 5xx types of error are taken
    /// into account (see Consecutive Gateway Failure for exceptions).
    /// Properly formatted responses, even when they carry an operational error
    /// (like index not found, access denied) are not taken into account.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalFailures")]
    pub total_failures: Option<MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsTotalFailures>,
}

/// Failure Percentage based outlier detection functions similarly to success
/// rate detection, in that it relies on success rate data from each host in
/// a cluster. However, rather than compare those values to the mean success
/// rate of the cluster as a whole, they are compared to a flat
/// user-configured threshold. This threshold is configured via the
/// outlierDetection.failurePercentageThreshold field.
/// The other configuration fields for failure percentage based detection are
/// similar to the fields for success rate detection. As with success rate
/// detection, detection will not be performed for a host if its request
/// volume over the aggregation interval is less than the
/// outlierDetection.detectors.failurePercentage.requestVolume value.
/// Detection also will not be performed for a cluster if the number of hosts
/// with the minimum required request volume in an interval is less than the
/// outlierDetection.detectors.failurePercentage.minimumHosts value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsFailurePercentage {
    /// The minimum number of hosts in a cluster in order to perform failure
    /// percentage-based ejection. If the total number of hosts in the cluster is
    /// less than this value, failure percentage-based ejection will not be
    /// performed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHosts")]
    pub minimum_hosts: Option<i32>,
    /// The minimum number of total requests that must be collected in one
    /// interval (as defined by the interval duration above) to perform failure
    /// percentage-based ejection for this host. If the volume is lower than this
    /// setting, failure percentage-based ejection will not be performed for this
    /// host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestVolume")]
    pub request_volume: Option<i32>,
    /// The failure percentage to use when determining failure percentage-based
    /// outlier detection. If the failure percentage of a given host is greater
    /// than or equal to this value, it will be ejected.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub threshold: Option<i32>,
}

/// In the default mode (outlierDetection.splitExternalLocalOriginErrors is
/// false) this detection type takes into account a subset of 5xx errors,
/// called "gateway errors" (502, 503 or 504 status code) and local origin
/// failures, such as timeout, TCP reset etc.
/// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
/// this detection type takes into account a subset of 5xx errors, called
/// "gateway errors" (502, 503 or 504 status code) and is supported only by
/// the http router.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsGatewayFailures {
    /// The number of consecutive gateway failures (502, 503, 504 status codes)
    /// before a consecutive gateway failure ejection occurs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consecutive: Option<i32>,
}

/// This detection type is enabled only when
/// outlierDetection.splitExternalLocalOriginErrors is true and takes into
/// account only locally originated errors (timeout, reset, etc).
/// If Envoy repeatedly cannot connect to an upstream host or communication
/// with the upstream host is repeatedly interrupted, it will be ejected.
/// Various locally originated problems are detected: timeout, TCP reset,
/// ICMP errors, etc. This detection type is supported by http router and
/// tcp proxy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsLocalOriginFailures {
    /// The number of consecutive locally originated failures before ejection
    /// occurs. Parameter takes effect only when splitExternalAndLocalErrors
    /// is set to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consecutive: Option<i32>,
}

/// Success Rate based outlier detection aggregates success rate data from
/// every host in a cluster. Then at given intervals ejects hosts based on
/// statistical outlier detection. Success Rate outlier detection will not be
/// calculated for a host if its request volume over the aggregation interval
/// is less than the outlierDetection.detectors.successRate.requestVolume
/// value.
/// Moreover, detection will not be performed for a cluster if the number of
/// hosts with the minimum required request volume in an interval is less
/// than the outlierDetection.detectors.successRate.minimumHosts value.
/// In the default configuration mode
/// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
/// type takes into account all types of errors: locally and externally
/// originated.
/// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
/// locally originated errors and externally originated (transaction) errors
/// are counted and treated separately.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsSuccessRate {
    /// The number of hosts in a cluster that must have enough request volume to
    /// detect success rate outliers. If the number of hosts is less than this
    /// setting, outlier detection via success rate statistics is not performed
    /// for any host in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHosts")]
    pub minimum_hosts: Option<i32>,
    /// The minimum number of total requests that must be collected in one
    /// interval (as defined by the interval duration configured in
    /// outlierDetection section) to include this host in success rate based
    /// outlier detection. If the volume is lower than this setting, outlier
    /// detection via success rate statistics is not performed for that host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestVolume")]
    pub request_volume: Option<i32>,
    /// This factor is used to determine the ejection threshold for success rate
    /// outlier ejection. The ejection threshold is the difference between
    /// the mean success rate, and the product of this factor and the standard
    /// deviation of the mean success rate: mean - (standard_deviation *
    /// success_rate_standard_deviation_factor).
    /// Either int or decimal represented as string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "standardDeviationFactor")]
    pub standard_deviation_factor: Option<IntOrString>,
}

/// In the default mode (outlierDetection.splitExternalAndLocalErrors is
/// false) this detection type takes into account all generated errors:
/// locally originated and externally originated (transaction) errors.
/// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
/// this detection type takes into account only externally originated
/// (transaction) errors, ignoring locally originated errors.
/// If an upstream host is an HTTP-server, only 5xx types of error are taken
/// into account (see Consecutive Gateway Failure for exceptions).
/// Properly formatted responses, even when they carry an operational error
/// (like index not found, access denied) are not taken into account.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromDefaultOutlierDetectionDetectorsTotalFailures {
    /// The number of consecutive server-side error responses (for HTTP traffic,
    /// 5xx responses; for TCP traffic, connection failures; for Redis, failure
    /// to respond PONG; etc.) before a consecutive total failure ejection
    /// occurs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consecutive: Option<i32>,
}

/// TargetRef is a reference to the resource that represents a group of
/// destinations.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerFromTargetRef {
    /// Kind of the referenced resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<MeshCircuitBreakerFromTargetRefKind>,
    /// Mesh is reserved for future use to identify cross mesh resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mesh: Option<String>,
    /// Name of the referenced resource. Can only be used with kinds: `MeshService`,
    /// `MeshServiceSubset` and `MeshGatewayRoute`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
    /// all data plane types are targeted by the policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyTypes")]
    pub proxy_types: Option<Vec<String>>,
    /// Tags used to select a subset of proxies by tags. Can only be used with kinds
    /// `MeshSubset` and `MeshServiceSubset`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
}

/// TargetRef is a reference to the resource that represents a group of
/// destinations.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum MeshCircuitBreakerFromTargetRefKind {
    Mesh,
    MeshSubset,
    MeshGateway,
    MeshService,
    MeshServiceSubset,
    #[serde(rename = "MeshHTTPRoute")]
    MeshHttpRoute,
}

/// TargetRef is a reference to the resource the policy takes an effect on.
/// The resource could be either a real store object or virtual resource
/// defined in place.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerTargetRef {
    /// Kind of the referenced resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<MeshCircuitBreakerTargetRefKind>,
    /// Mesh is reserved for future use to identify cross mesh resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mesh: Option<String>,
    /// Name of the referenced resource. Can only be used with kinds: `MeshService`,
    /// `MeshServiceSubset` and `MeshGatewayRoute`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
    /// all data plane types are targeted by the policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyTypes")]
    pub proxy_types: Option<Vec<String>>,
    /// Tags used to select a subset of proxies by tags. Can only be used with kinds
    /// `MeshSubset` and `MeshServiceSubset`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
}

/// TargetRef is a reference to the resource the policy takes an effect on.
/// The resource could be either a real store object or virtual resource
/// defined in place.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum MeshCircuitBreakerTargetRefKind {
    Mesh,
    MeshSubset,
    MeshGateway,
    MeshService,
    MeshServiceSubset,
    #[serde(rename = "MeshHTTPRoute")]
    MeshHttpRoute,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerTo {
    /// Default is a configuration specific to the group of destinations
    /// referenced in 'targetRef'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<MeshCircuitBreakerToDefault>,
    /// TargetRef is a reference to the resource that represents a group of
    /// destinations.
    #[serde(rename = "targetRef")]
    pub target_ref: MeshCircuitBreakerToTargetRef,
}

/// Default is a configuration specific to the group of destinations
/// referenced in 'targetRef'
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToDefault {
    /// ConnectionLimits contains configuration of each circuit breaking limit,
    /// which when exceeded makes the circuit breaker to become open (no traffic
    /// is allowed like no current is allowed in the circuits when physical
    /// circuit breaker ir open)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionLimits")]
    pub connection_limits: Option<MeshCircuitBreakerToDefaultConnectionLimits>,
    /// OutlierDetection contains the configuration of the process of dynamically
    /// determining whether some number of hosts in an upstream cluster are
    /// performing unlike the others and removing them from the healthy load
    /// balancing set. Performance might be along different axes such as
    /// consecutive failures, temporal success rate, temporal latency, etc.
    /// Outlier detection is a form of passive health checking.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outlierDetection")]
    pub outlier_detection: Option<MeshCircuitBreakerToDefaultOutlierDetection>,
}

/// ConnectionLimits contains configuration of each circuit breaking limit,
/// which when exceeded makes the circuit breaker to become open (no traffic
/// is allowed like no current is allowed in the circuits when physical
/// circuit breaker ir open)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToDefaultConnectionLimits {
    /// The maximum number of connection pools per cluster that are concurrently
    /// supported at once. Set this for clusters which create a large number of
    /// connection pools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionPools")]
    pub max_connection_pools: Option<i32>,
    /// The maximum number of connections allowed to be made to the upstream
    /// cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// The maximum number of pending requests that are allowed to the upstream
    /// cluster. This limit is applied as a connection limit for non-HTTP
    /// traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPendingRequests")]
    pub max_pending_requests: Option<i32>,
    /// The maximum number of parallel requests that are allowed to be made
    /// to the upstream cluster. This limit does not apply to non-HTTP traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequests")]
    pub max_requests: Option<i32>,
    /// The maximum number of parallel retries that will be allowed to
    /// the upstream cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
}

/// OutlierDetection contains the configuration of the process of dynamically
/// determining whether some number of hosts in an upstream cluster are
/// performing unlike the others and removing them from the healthy load
/// balancing set. Performance might be along different axes such as
/// consecutive failures, temporal success rate, temporal latency, etc.
/// Outlier detection is a form of passive health checking.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToDefaultOutlierDetection {
    /// The base time that a host is ejected for. The real time is equal to
    /// the base time multiplied by the number of times the host has been
    /// ejected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseEjectionTime")]
    pub base_ejection_time: Option<String>,
    /// Contains configuration for supported outlier detectors
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub detectors: Option<MeshCircuitBreakerToDefaultOutlierDetectionDetectors>,
    /// When set to true, outlierDetection configuration won't take any effect
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// The time interval between ejection analysis sweeps. This can result in
    /// both new ejections and hosts being returned to service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// The maximum % of an upstream cluster that can be ejected due to outlier
    /// detection. Defaults to 10% but will eject at least one host regardless of
    /// the value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEjectionPercent")]
    pub max_ejection_percent: Option<i32>,
    /// Determines whether to distinguish local origin failures from external
    /// errors. If set to true the following configuration parameters are taken
    /// into account: detectors.localOriginFailures.consecutive
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "splitExternalAndLocalErrors")]
    pub split_external_and_local_errors: Option<bool>,
}

/// Contains configuration for supported outlier detectors
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToDefaultOutlierDetectionDetectors {
    /// Failure Percentage based outlier detection functions similarly to success
    /// rate detection, in that it relies on success rate data from each host in
    /// a cluster. However, rather than compare those values to the mean success
    /// rate of the cluster as a whole, they are compared to a flat
    /// user-configured threshold. This threshold is configured via the
    /// outlierDetection.failurePercentageThreshold field.
    /// The other configuration fields for failure percentage based detection are
    /// similar to the fields for success rate detection. As with success rate
    /// detection, detection will not be performed for a host if its request
    /// volume over the aggregation interval is less than the
    /// outlierDetection.detectors.failurePercentage.requestVolume value.
    /// Detection also will not be performed for a cluster if the number of hosts
    /// with the minimum required request volume in an interval is less than the
    /// outlierDetection.detectors.failurePercentage.minimumHosts value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failurePercentage")]
    pub failure_percentage: Option<MeshCircuitBreakerToDefaultOutlierDetectionDetectorsFailurePercentage>,
    /// In the default mode (outlierDetection.splitExternalLocalOriginErrors is
    /// false) this detection type takes into account a subset of 5xx errors,
    /// called "gateway errors" (502, 503 or 504 status code) and local origin
    /// failures, such as timeout, TCP reset etc.
    /// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
    /// this detection type takes into account a subset of 5xx errors, called
    /// "gateway errors" (502, 503 or 504 status code) and is supported only by
    /// the http router.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayFailures")]
    pub gateway_failures: Option<MeshCircuitBreakerToDefaultOutlierDetectionDetectorsGatewayFailures>,
    /// This detection type is enabled only when
    /// outlierDetection.splitExternalLocalOriginErrors is true and takes into
    /// account only locally originated errors (timeout, reset, etc).
    /// If Envoy repeatedly cannot connect to an upstream host or communication
    /// with the upstream host is repeatedly interrupted, it will be ejected.
    /// Various locally originated problems are detected: timeout, TCP reset,
    /// ICMP errors, etc. This detection type is supported by http router and
    /// tcp proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localOriginFailures")]
    pub local_origin_failures: Option<MeshCircuitBreakerToDefaultOutlierDetectionDetectorsLocalOriginFailures>,
    /// Success Rate based outlier detection aggregates success rate data from
    /// every host in a cluster. Then at given intervals ejects hosts based on
    /// statistical outlier detection. Success Rate outlier detection will not be
    /// calculated for a host if its request volume over the aggregation interval
    /// is less than the outlierDetection.detectors.successRate.requestVolume
    /// value.
    /// Moreover, detection will not be performed for a cluster if the number of
    /// hosts with the minimum required request volume in an interval is less
    /// than the outlierDetection.detectors.successRate.minimumHosts value.
    /// In the default configuration mode
    /// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
    /// type takes into account all types of errors: locally and externally
    /// originated.
    /// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
    /// locally originated errors and externally originated (transaction) errors
    /// are counted and treated separately.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successRate")]
    pub success_rate: Option<MeshCircuitBreakerToDefaultOutlierDetectionDetectorsSuccessRate>,
    /// In the default mode (outlierDetection.splitExternalAndLocalErrors is
    /// false) this detection type takes into account all generated errors:
    /// locally originated and externally originated (transaction) errors.
    /// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
    /// this detection type takes into account only externally originated
    /// (transaction) errors, ignoring locally originated errors.
    /// If an upstream host is an HTTP-server, only 5xx types of error are taken
    /// into account (see Consecutive Gateway Failure for exceptions).
    /// Properly formatted responses, even when they carry an operational error
    /// (like index not found, access denied) are not taken into account.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalFailures")]
    pub total_failures: Option<MeshCircuitBreakerToDefaultOutlierDetectionDetectorsTotalFailures>,
}

/// Failure Percentage based outlier detection functions similarly to success
/// rate detection, in that it relies on success rate data from each host in
/// a cluster. However, rather than compare those values to the mean success
/// rate of the cluster as a whole, they are compared to a flat
/// user-configured threshold. This threshold is configured via the
/// outlierDetection.failurePercentageThreshold field.
/// The other configuration fields for failure percentage based detection are
/// similar to the fields for success rate detection. As with success rate
/// detection, detection will not be performed for a host if its request
/// volume over the aggregation interval is less than the
/// outlierDetection.detectors.failurePercentage.requestVolume value.
/// Detection also will not be performed for a cluster if the number of hosts
/// with the minimum required request volume in an interval is less than the
/// outlierDetection.detectors.failurePercentage.minimumHosts value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToDefaultOutlierDetectionDetectorsFailurePercentage {
    /// The minimum number of hosts in a cluster in order to perform failure
    /// percentage-based ejection. If the total number of hosts in the cluster is
    /// less than this value, failure percentage-based ejection will not be
    /// performed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHosts")]
    pub minimum_hosts: Option<i32>,
    /// The minimum number of total requests that must be collected in one
    /// interval (as defined by the interval duration above) to perform failure
    /// percentage-based ejection for this host. If the volume is lower than this
    /// setting, failure percentage-based ejection will not be performed for this
    /// host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestVolume")]
    pub request_volume: Option<i32>,
    /// The failure percentage to use when determining failure percentage-based
    /// outlier detection. If the failure percentage of a given host is greater
    /// than or equal to this value, it will be ejected.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub threshold: Option<i32>,
}

/// In the default mode (outlierDetection.splitExternalLocalOriginErrors is
/// false) this detection type takes into account a subset of 5xx errors,
/// called "gateway errors" (502, 503 or 504 status code) and local origin
/// failures, such as timeout, TCP reset etc.
/// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
/// this detection type takes into account a subset of 5xx errors, called
/// "gateway errors" (502, 503 or 504 status code) and is supported only by
/// the http router.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToDefaultOutlierDetectionDetectorsGatewayFailures {
    /// The number of consecutive gateway failures (502, 503, 504 status codes)
    /// before a consecutive gateway failure ejection occurs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consecutive: Option<i32>,
}

/// This detection type is enabled only when
/// outlierDetection.splitExternalLocalOriginErrors is true and takes into
/// account only locally originated errors (timeout, reset, etc).
/// If Envoy repeatedly cannot connect to an upstream host or communication
/// with the upstream host is repeatedly interrupted, it will be ejected.
/// Various locally originated problems are detected: timeout, TCP reset,
/// ICMP errors, etc. This detection type is supported by http router and
/// tcp proxy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToDefaultOutlierDetectionDetectorsLocalOriginFailures {
    /// The number of consecutive locally originated failures before ejection
    /// occurs. Parameter takes effect only when splitExternalAndLocalErrors
    /// is set to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consecutive: Option<i32>,
}

/// Success Rate based outlier detection aggregates success rate data from
/// every host in a cluster. Then at given intervals ejects hosts based on
/// statistical outlier detection. Success Rate outlier detection will not be
/// calculated for a host if its request volume over the aggregation interval
/// is less than the outlierDetection.detectors.successRate.requestVolume
/// value.
/// Moreover, detection will not be performed for a cluster if the number of
/// hosts with the minimum required request volume in an interval is less
/// than the outlierDetection.detectors.successRate.minimumHosts value.
/// In the default configuration mode
/// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
/// type takes into account all types of errors: locally and externally
/// originated.
/// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
/// locally originated errors and externally originated (transaction) errors
/// are counted and treated separately.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToDefaultOutlierDetectionDetectorsSuccessRate {
    /// The number of hosts in a cluster that must have enough request volume to
    /// detect success rate outliers. If the number of hosts is less than this
    /// setting, outlier detection via success rate statistics is not performed
    /// for any host in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumHosts")]
    pub minimum_hosts: Option<i32>,
    /// The minimum number of total requests that must be collected in one
    /// interval (as defined by the interval duration configured in
    /// outlierDetection section) to include this host in success rate based
    /// outlier detection. If the volume is lower than this setting, outlier
    /// detection via success rate statistics is not performed for that host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestVolume")]
    pub request_volume: Option<i32>,
    /// This factor is used to determine the ejection threshold for success rate
    /// outlier ejection. The ejection threshold is the difference between
    /// the mean success rate, and the product of this factor and the standard
    /// deviation of the mean success rate: mean - (standard_deviation *
    /// success_rate_standard_deviation_factor).
    /// Either int or decimal represented as string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "standardDeviationFactor")]
    pub standard_deviation_factor: Option<IntOrString>,
}

/// In the default mode (outlierDetection.splitExternalAndLocalErrors is
/// false) this detection type takes into account all generated errors:
/// locally originated and externally originated (transaction) errors.
/// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
/// this detection type takes into account only externally originated
/// (transaction) errors, ignoring locally originated errors.
/// If an upstream host is an HTTP-server, only 5xx types of error are taken
/// into account (see Consecutive Gateway Failure for exceptions).
/// Properly formatted responses, even when they carry an operational error
/// (like index not found, access denied) are not taken into account.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToDefaultOutlierDetectionDetectorsTotalFailures {
    /// The number of consecutive server-side error responses (for HTTP traffic,
    /// 5xx responses; for TCP traffic, connection failures; for Redis, failure
    /// to respond PONG; etc.) before a consecutive total failure ejection
    /// occurs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consecutive: Option<i32>,
}

/// TargetRef is a reference to the resource that represents a group of
/// destinations.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct MeshCircuitBreakerToTargetRef {
    /// Kind of the referenced resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<MeshCircuitBreakerToTargetRefKind>,
    /// Mesh is reserved for future use to identify cross mesh resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mesh: Option<String>,
    /// Name of the referenced resource. Can only be used with kinds: `MeshService`,
    /// `MeshServiceSubset` and `MeshGatewayRoute`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
    /// all data plane types are targeted by the policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyTypes")]
    pub proxy_types: Option<Vec<String>>,
    /// Tags used to select a subset of proxies by tags. Can only be used with kinds
    /// `MeshSubset` and `MeshServiceSubset`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
}

/// TargetRef is a reference to the resource that represents a group of
/// destinations.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum MeshCircuitBreakerToTargetRefKind {
    Mesh,
    MeshSubset,
    MeshGateway,
    MeshService,
    MeshServiceSubset,
    #[serde(rename = "MeshHTTPRoute")]
    MeshHttpRoute,
}

