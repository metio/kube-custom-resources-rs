// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/Kuadrant/kuadrant-operator/kuadrant.io/v1beta3/authpolicies.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// Mutual Exclusivity Validation
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "kuadrant.io", version = "v1beta3", kind = "AuthPolicy", plural = "authpolicies")]
#[kube(namespaced)]
#[kube(status = "AuthPolicyStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct AuthPolicySpec {
    /// Defaults define explicit default values for this policy and for policies inheriting this policy.
    /// Defaults are mutually exclusive with implicit defaults defined by AuthPolicyCommonSpec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<AuthPolicyDefaults>,
    /// Overrides define explicit override values for this policy.
    /// Overrides are mutually exclusive with explicit and implicit defaults defined by AuthPolicyCommonSpec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<AuthPolicyOverrides>,
    /// Named sets of patterns that can be referred in `when` conditions and in pattern-matching authorization policy rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patterns: Option<BTreeMap<String, AuthPolicyPatterns>>,
    /// The auth rules of the policy.
    /// See Authorino's AuthConfig CRD for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<AuthPolicyRules>,
    /// TargetRef identifies an API object to apply policy to.
    #[serde(rename = "targetRef")]
    pub target_ref: AuthPolicyTargetRef,
    /// Overall conditions for the AuthPolicy to be enforced.
    /// If omitted, the AuthPolicy will be enforced at all requests to the protected routes.
    /// If present, all conditions must match for the AuthPolicy to be enforced; otherwise, the authorization service skips the AuthPolicy and returns to the auth request with status OK.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyWhen>>,
}

/// Defaults define explicit default values for this policy and for policies inheriting this policy.
/// Defaults are mutually exclusive with implicit defaults defined by AuthPolicyCommonSpec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaults {
    /// Named sets of patterns that can be referred in `when` conditions and in pattern-matching authorization policy rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patterns: Option<BTreeMap<String, AuthPolicyDefaultsPatterns>>,
    /// The auth rules of the policy.
    /// See Authorino's AuthConfig CRD for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<AuthPolicyDefaultsRules>,
    /// Overall conditions for the AuthPolicy to be enforced.
    /// If omitted, the AuthPolicy will be enforced at all requests to the protected routes.
    /// If present, all conditions must match for the AuthPolicy to be enforced; otherwise, the authorization service skips the AuthPolicy and returns to the auth request with status OK.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsWhen>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsPatterns {
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsPatternsOperator>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// The auth rules of the policy.
/// See Authorino's AuthConfig CRD for more details.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRules {
    /// Authentication configs.
    /// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthentication>>,
    /// Authorization policies.
    /// All policies MUST evaluate to "allowed = true" for the auth request be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthorization>>,
    /// Callback functions.
    /// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callbacks: Option<BTreeMap<String, AuthPolicyDefaultsRulesCallbacks>>,
    /// Metadata sources.
    /// Authorino fetches auth metadata as JSON from sources specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, AuthPolicyDefaultsRulesMetadata>>,
    /// Response items.
    /// Authorino builds custom responses to the client of the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<AuthPolicyDefaultsRulesResponse>,
}

/// Authentication configs.
/// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthentication {
    /// Anonymous access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anonymous: Option<AuthPolicyDefaultsRulesAuthenticationAnonymous>,
    /// Authentication based on API keys stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<AuthPolicyDefaultsRulesAuthenticationApiKey>,
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesAuthenticationCache>,
    /// Defines where credentials are required to be passed in the request for authentication based on this config.
    /// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyDefaultsRulesAuthenticationCredentials>,
    /// Set default property values (claims) for the resolved identity object, that are set before appending the object to
    /// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthenticationDefaults>>,
    /// Authentication based on JWT tokens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<AuthPolicyDefaultsRulesAuthenticationJwt>,
    /// Authentication by Kubernetes token review.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesTokenReview")]
    pub kubernetes_token_review: Option<AuthPolicyDefaultsRulesAuthenticationKubernetesTokenReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Authentication by OAuth2 token introspection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauth2Introspection")]
    pub oauth2_introspection: Option<AuthPolicyDefaultsRulesAuthenticationOauth2Introspection>,
    /// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
    /// before appending the object to the authorization JSON.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthenticationOverrides>>,
    /// Identity object extracted from the context.
    /// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyDefaultsRulesAuthenticationPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesAuthenticationWhen>>,
    /// Authentication based on client X.509 certificates.
    /// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x509: Option<AuthPolicyDefaultsRulesAuthenticationX509>,
}

/// Anonymous access.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationAnonymous {
}

/// Authentication based on API keys stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationApiKey {
    /// Whether Authorino should look for API key secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
    pub selector: AuthPolicyDefaultsRulesAuthenticationApiKeySelector,
}

/// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationApiKeySelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyDefaultsRulesAuthenticationApiKeySelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationApiKeySelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesAuthenticationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Defines where credentials are required to be passed in the request for authentication based on this config.
/// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyDefaultsRulesAuthenticationCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyDefaultsRulesAuthenticationCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyDefaultsRulesAuthenticationCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyDefaultsRulesAuthenticationCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentialsQueryString {
    pub name: String,
}

/// Set default property values (claims) for the resolved identity object, that are set before appending the object to
/// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationDefaults {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authentication based on JWT tokens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationJwt {
    /// URL of the issuer of the JWT.
    /// If `jwksUrl` is omitted, Authorino will append the path to the OpenID Connect Well-Known Discovery endpoint
    /// (i.e. "/.well-known/openid-configuration") to this URL, to discover the OIDC configuration where to obtain
    /// the "jkws_uri" claim from.
    /// The value must coincide with the value of  the "iss" (issuer) claim of the discovered OpenID Connect configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUrl")]
    pub issuer_url: Option<String>,
    /// Decides how long to wait before refreshing the JWKS (in seconds).
    /// If omitted, Authorino will never refresh the JWKS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Authentication by Kubernetes token review.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationKubernetesTokenReview {
    /// The list of audiences (scopes) that must be claimed in a Kubernetes authentication token supplied in the request, and reviewed by Authorino.
    /// If omitted, Authorino will review tokens expecting the host name of the requested protected service amongst the audiences.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
}

/// Authentication by OAuth2 token introspection.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationOauth2Introspection {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyDefaultsRulesAuthenticationOauth2IntrospectionCredentialsRef,
    /// The full URL of the token introspection endpoint.
    pub endpoint: String,
    /// The token type hint for the token introspection.
    /// If omitted, it defaults to "access_token".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenTypeHint")]
    pub token_type_hint: Option<String>,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationOauth2IntrospectionCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
/// before appending the object to the authorization JSON.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationOverrides {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Identity object extracted from the context.
/// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    pub selector: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyDefaultsRulesAuthenticationWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyDefaultsRulesAuthenticationWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesAuthenticationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthenticationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authentication based on client X.509 certificates.
/// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationX509 {
    /// Whether Authorino should look for TLS secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
    /// clients trying to authenticate to this service
    pub selector: AuthPolicyDefaultsRulesAuthenticationX509Selector,
}

/// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
/// clients trying to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationX509Selector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyDefaultsRulesAuthenticationX509SelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationX509SelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Authorization policies.
/// All policies MUST evaluate to "allowed = true" for the auth request be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorization {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesAuthorizationCache>,
    /// Authorization by Kubernetes SubjectAccessReview
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSubjectAccessReview")]
    pub kubernetes_subject_access_review: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Open Policy Agent (OPA) Rego policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opa: Option<AuthPolicyDefaultsRulesAuthorizationOpa>,
    /// Pattern-matching authorization rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternMatching")]
    pub pattern_matching: Option<AuthPolicyDefaultsRulesAuthorizationPatternMatching>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Authorization decision delegated to external Authzed/SpiceDB server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spicedb: Option<AuthPolicyDefaultsRulesAuthorizationSpicedb>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesAuthorizationWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesAuthorizationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authorization by Kubernetes SubjectAccessReview
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReview {
    /// Groups the user must be a member of or, if `user` is omitted, the groups to check for authorization in the Kubernetes RBAC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
    /// Use resourceAttributes to check permissions on Kubernetes resources.
    /// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceAttributes")]
    pub resource_attributes: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes>,
    /// User to check for authorization in the Kubernetes RBAC.
    /// Omit it to check for group authorization only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewUser>,
}

/// Use resourceAttributes to check permissions on Kubernetes resources.
/// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes {
    /// API group of the resource.
    /// Use '*' for all API groups.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup>,
    /// Resource name
    /// Omit it to check for authorization on all resources of the specified kind.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName>,
    /// Namespace where the user must have permissions on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace>,
    /// Resource kind
    /// Use '*' for all resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource>,
    /// Subresource kind
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource>,
    /// Verb to check for authorization on the resource.
    /// Use '*' for all verbs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verb: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb>,
}

/// API group of the resource.
/// Use '*' for all API groups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource name
/// Omit it to check for authorization on all resources of the specified kind.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Namespace where the user must have permissions on the resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource kind
/// Use '*' for all resource kinds.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Subresource kind
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Verb to check for authorization on the resource.
/// Use '*' for all verbs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// User to check for authorization in the Kubernetes RBAC.
/// Omit it to check for group authorization only.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewUser {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Open Policy Agent (OPA) Rego policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpa {
    /// Returns the value of all Rego rules in the virtual document. Values can be read in subsequent evaluators/phases of the Auth Pipeline.
    /// Otherwise, only the default `allow` rule will be exposed.
    /// Returning all Rego rules can affect performance of OPA policies during reconciliation (policy precompile) and at runtime.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allValues")]
    pub all_values: Option<bool>,
    /// Settings for fetching the OPA policy from an external registry.
    /// Use it alternatively to 'rego'.
    /// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
    /// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalPolicy")]
    pub external_policy: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicy>,
    /// Authorization policy as a Rego language document.
    /// The Rego document must include the "allow" condition, set by Authorino to "false" by default (i.e. requests are unauthorized unless changed).
    /// The Rego document must NOT include the "package" declaration in line 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rego: Option<String>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicy {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicySharedSecretRef>,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON.
    /// E.g. https://ext-auth-server.io/metadata?p={request.path}
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicySharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Pattern-matching authorization rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationPatternMatching {
    pub patterns: Vec<AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatterns>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatterns {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatternsAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatternsAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatternsOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorization decision delegated to external Authzed/SpiceDB server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedb {
    /// Hostname and port number to the GRPC interface of the SpiceDB server (e.g. spicedb:50051).
    pub endpoint: String,
    /// Insecure HTTP connection (i.e. disables TLS verification)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// The name of the permission (or relation) on which to execute the check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbPermission>,
    /// The resource on which to check the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbResource>,
    /// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbSharedSecretRef>,
    /// The subject that will be checked for the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbSubject>,
}

/// The name of the permission (or relation) on which to execute the check.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbPermission {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// The resource on which to check the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbResource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbResourceKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbResourceName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbResourceKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbResourceName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// The subject that will be checked for the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbSubject {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbSubjectKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbSubjectName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbSubjectKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbSubjectName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyDefaultsRulesAuthorizationWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyDefaultsRulesAuthorizationWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesAuthorizationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Callback functions.
/// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacks {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesCallbacksCache>,
    /// Settings of the external HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyDefaultsRulesCallbacksHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesCallbacksWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesCallbacksCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesCallbacksHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyDefaultsRulesCallbacksHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyDefaultsRulesCallbacksHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesCallbacksHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesCallbacksHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyDefaultsRulesCallbacksHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyDefaultsRulesCallbacksHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON.
    /// E.g. https://ext-auth-server.io/metadata?p={request.path}
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyDefaultsRulesCallbacksHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyDefaultsRulesCallbacksWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyDefaultsRulesCallbacksWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesCallbacksWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Metadata sources.
/// Authorino fetches auth metadata as JSON from sources specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesMetadataCache>,
    /// External source of auth metadata via HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyDefaultsRulesMetadataHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// User-Managed Access (UMA) source of resource data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uma: Option<AuthPolicyDefaultsRulesMetadataUma>,
    /// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userInfo")]
    pub user_info: Option<AuthPolicyDefaultsRulesMetadataUserInfo>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesMetadataWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesMetadataHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyDefaultsRulesMetadataHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyDefaultsRulesMetadataHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyDefaultsRulesMetadataHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesMetadataHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesMetadataHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyDefaultsRulesMetadataHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyDefaultsRulesMetadataHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON.
    /// E.g. https://ext-auth-server.io/metadata?p={request.path}
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyDefaultsRulesMetadataHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyDefaultsRulesMetadataHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyDefaultsRulesMetadataHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyDefaultsRulesMetadataHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyDefaultsRulesMetadataHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// User-Managed Access (UMA) source of resource data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataUma {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyDefaultsRulesMetadataUmaCredentialsRef,
    /// The endpoint of the UMA server.
    /// The value must coincide with the "issuer" claim of the UMA config discovered from the well-known uma configuration endpoint.
    pub endpoint: String,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataUmaCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataUserInfo {
    /// The name of an OIDC-enabled JWT authentication config whose OpenID Connect configuration discovered includes the OIDC "userinfo_endpoint" claim.
    #[serde(rename = "identitySource")]
    pub identity_source: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyDefaultsRulesMetadataWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyDefaultsRulesMetadataWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Response items.
/// Authorino builds custom responses to the client of the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponse {
    /// Response items to be included in the auth response when the request is authenticated and authorized.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub success: Option<AuthPolicyDefaultsRulesResponseSuccess>,
    /// Customizations on the denial status attributes when the request is unauthenticated.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 401 Unauthorized
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthenticated: Option<AuthPolicyDefaultsRulesResponseUnauthenticated>,
    /// Customizations on the denial status attributes when the request is unauthorized.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 403 Forbidden
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthorized: Option<AuthPolicyDefaultsRulesResponseUnauthorized>,
}

/// Response items to be included in the auth response when the request is authenticated and authorized.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccess {
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
    /// See https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicMetadata")]
    pub dynamic_metadata: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessDynamicMetadata>>,
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessHeaders>>,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
/// See https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataJson {
    pub properties: BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeaders {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesResponseSuccessHeadersCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersJson {
    pub properties: BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessHeadersJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessHeadersWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Customizations on the denial status attributes when the request is unauthenticated.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 401 Unauthorized
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthenticated {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesResponseUnauthenticatedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseUnauthenticatedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyDefaultsRulesResponseUnauthenticatedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthenticatedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthenticatedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthenticatedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Customizations on the denial status attributes when the request is unauthorized.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 403 Forbidden
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthorized {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesResponseUnauthorizedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseUnauthorizedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyDefaultsRulesResponseUnauthorizedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthorizedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthorizedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthorizedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyDefaultsWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyDefaultsWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Overrides define explicit override values for this policy.
/// Overrides are mutually exclusive with explicit and implicit defaults defined by AuthPolicyCommonSpec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverrides {
    /// Named sets of patterns that can be referred in `when` conditions and in pattern-matching authorization policy rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patterns: Option<BTreeMap<String, AuthPolicyOverridesPatterns>>,
    /// The auth rules of the policy.
    /// See Authorino's AuthConfig CRD for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<AuthPolicyOverridesRules>,
    /// Overall conditions for the AuthPolicy to be enforced.
    /// If omitted, the AuthPolicy will be enforced at all requests to the protected routes.
    /// If present, all conditions must match for the AuthPolicy to be enforced; otherwise, the authorization service skips the AuthPolicy and returns to the auth request with status OK.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesWhen>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesPatterns {
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesPatternsOperator>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// The auth rules of the policy.
/// See Authorino's AuthConfig CRD for more details.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRules {
    /// Authentication configs.
    /// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthentication>>,
    /// Authorization policies.
    /// All policies MUST evaluate to "allowed = true" for the auth request be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthorization>>,
    /// Callback functions.
    /// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callbacks: Option<BTreeMap<String, AuthPolicyOverridesRulesCallbacks>>,
    /// Metadata sources.
    /// Authorino fetches auth metadata as JSON from sources specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, AuthPolicyOverridesRulesMetadata>>,
    /// Response items.
    /// Authorino builds custom responses to the client of the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<AuthPolicyOverridesRulesResponse>,
}

/// Authentication configs.
/// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthentication {
    /// Anonymous access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anonymous: Option<AuthPolicyOverridesRulesAuthenticationAnonymous>,
    /// Authentication based on API keys stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<AuthPolicyOverridesRulesAuthenticationApiKey>,
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesAuthenticationCache>,
    /// Defines where credentials are required to be passed in the request for authentication based on this config.
    /// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyOverridesRulesAuthenticationCredentials>,
    /// Set default property values (claims) for the resolved identity object, that are set before appending the object to
    /// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthenticationDefaults>>,
    /// Authentication based on JWT tokens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<AuthPolicyOverridesRulesAuthenticationJwt>,
    /// Authentication by Kubernetes token review.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesTokenReview")]
    pub kubernetes_token_review: Option<AuthPolicyOverridesRulesAuthenticationKubernetesTokenReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Authentication by OAuth2 token introspection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauth2Introspection")]
    pub oauth2_introspection: Option<AuthPolicyOverridesRulesAuthenticationOauth2Introspection>,
    /// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
    /// before appending the object to the authorization JSON.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthenticationOverrides>>,
    /// Identity object extracted from the context.
    /// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyOverridesRulesAuthenticationPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesAuthenticationWhen>>,
    /// Authentication based on client X.509 certificates.
    /// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x509: Option<AuthPolicyOverridesRulesAuthenticationX509>,
}

/// Anonymous access.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationAnonymous {
}

/// Authentication based on API keys stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationApiKey {
    /// Whether Authorino should look for API key secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
    pub selector: AuthPolicyOverridesRulesAuthenticationApiKeySelector,
}

/// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationApiKeySelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyOverridesRulesAuthenticationApiKeySelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationApiKeySelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesAuthenticationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Defines where credentials are required to be passed in the request for authentication based on this config.
/// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyOverridesRulesAuthenticationCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyOverridesRulesAuthenticationCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyOverridesRulesAuthenticationCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyOverridesRulesAuthenticationCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentialsQueryString {
    pub name: String,
}

/// Set default property values (claims) for the resolved identity object, that are set before appending the object to
/// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationDefaults {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authentication based on JWT tokens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationJwt {
    /// URL of the issuer of the JWT.
    /// If `jwksUrl` is omitted, Authorino will append the path to the OpenID Connect Well-Known Discovery endpoint
    /// (i.e. "/.well-known/openid-configuration") to this URL, to discover the OIDC configuration where to obtain
    /// the "jkws_uri" claim from.
    /// The value must coincide with the value of  the "iss" (issuer) claim of the discovered OpenID Connect configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUrl")]
    pub issuer_url: Option<String>,
    /// Decides how long to wait before refreshing the JWKS (in seconds).
    /// If omitted, Authorino will never refresh the JWKS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Authentication by Kubernetes token review.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationKubernetesTokenReview {
    /// The list of audiences (scopes) that must be claimed in a Kubernetes authentication token supplied in the request, and reviewed by Authorino.
    /// If omitted, Authorino will review tokens expecting the host name of the requested protected service amongst the audiences.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
}

/// Authentication by OAuth2 token introspection.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationOauth2Introspection {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef,
    /// The full URL of the token introspection endpoint.
    pub endpoint: String,
    /// The token type hint for the token introspection.
    /// If omitted, it defaults to "access_token".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenTypeHint")]
    pub token_type_hint: Option<String>,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
/// before appending the object to the authorization JSON.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationOverrides {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Identity object extracted from the context.
/// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    pub selector: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyOverridesRulesAuthenticationWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyOverridesRulesAuthenticationWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesAuthenticationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthenticationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authentication based on client X.509 certificates.
/// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationX509 {
    /// Whether Authorino should look for TLS secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
    /// clients trying to authenticate to this service
    pub selector: AuthPolicyOverridesRulesAuthenticationX509Selector,
}

/// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
/// clients trying to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationX509Selector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyOverridesRulesAuthenticationX509SelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationX509SelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Authorization policies.
/// All policies MUST evaluate to "allowed = true" for the auth request be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorization {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesAuthorizationCache>,
    /// Authorization by Kubernetes SubjectAccessReview
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSubjectAccessReview")]
    pub kubernetes_subject_access_review: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Open Policy Agent (OPA) Rego policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opa: Option<AuthPolicyOverridesRulesAuthorizationOpa>,
    /// Pattern-matching authorization rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternMatching")]
    pub pattern_matching: Option<AuthPolicyOverridesRulesAuthorizationPatternMatching>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Authorization decision delegated to external Authzed/SpiceDB server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spicedb: Option<AuthPolicyOverridesRulesAuthorizationSpicedb>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesAuthorizationWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesAuthorizationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authorization by Kubernetes SubjectAccessReview
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReview {
    /// Groups the user must be a member of or, if `user` is omitted, the groups to check for authorization in the Kubernetes RBAC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
    /// Use resourceAttributes to check permissions on Kubernetes resources.
    /// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceAttributes")]
    pub resource_attributes: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes>,
    /// User to check for authorization in the Kubernetes RBAC.
    /// Omit it to check for group authorization only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser>,
}

/// Use resourceAttributes to check permissions on Kubernetes resources.
/// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes {
    /// API group of the resource.
    /// Use '*' for all API groups.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup>,
    /// Resource name
    /// Omit it to check for authorization on all resources of the specified kind.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName>,
    /// Namespace where the user must have permissions on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace>,
    /// Resource kind
    /// Use '*' for all resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource>,
    /// Subresource kind
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource>,
    /// Verb to check for authorization on the resource.
    /// Use '*' for all verbs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verb: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb>,
}

/// API group of the resource.
/// Use '*' for all API groups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource name
/// Omit it to check for authorization on all resources of the specified kind.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Namespace where the user must have permissions on the resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource kind
/// Use '*' for all resource kinds.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Subresource kind
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Verb to check for authorization on the resource.
/// Use '*' for all verbs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// User to check for authorization in the Kubernetes RBAC.
/// Omit it to check for group authorization only.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Open Policy Agent (OPA) Rego policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpa {
    /// Returns the value of all Rego rules in the virtual document. Values can be read in subsequent evaluators/phases of the Auth Pipeline.
    /// Otherwise, only the default `allow` rule will be exposed.
    /// Returning all Rego rules can affect performance of OPA policies during reconciliation (policy precompile) and at runtime.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allValues")]
    pub all_values: Option<bool>,
    /// Settings for fetching the OPA policy from an external registry.
    /// Use it alternatively to 'rego'.
    /// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
    /// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalPolicy")]
    pub external_policy: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicy>,
    /// Authorization policy as a Rego language document.
    /// The Rego document must include the "allow" condition, set by Authorino to "false" by default (i.e. requests are unauthorized unless changed).
    /// The Rego document must NOT include the "package" declaration in line 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rego: Option<String>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicy {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef>,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON.
    /// E.g. https://ext-auth-server.io/metadata?p={request.path}
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Pattern-matching authorization rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationPatternMatching {
    pub patterns: Vec<AuthPolicyOverridesRulesAuthorizationPatternMatchingPatterns>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationPatternMatchingPatterns {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyOverridesRulesAuthorizationPatternMatchingPatternsAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyOverridesRulesAuthorizationPatternMatchingPatternsAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesAuthorizationPatternMatchingPatternsOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationPatternMatchingPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorization decision delegated to external Authzed/SpiceDB server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedb {
    /// Hostname and port number to the GRPC interface of the SpiceDB server (e.g. spicedb:50051).
    pub endpoint: String,
    /// Insecure HTTP connection (i.e. disables TLS verification)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// The name of the permission (or relation) on which to execute the check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<AuthPolicyOverridesRulesAuthorizationSpicedbPermission>,
    /// The resource on which to check the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyOverridesRulesAuthorizationSpicedbResource>,
    /// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyOverridesRulesAuthorizationSpicedbSharedSecretRef>,
    /// The subject that will be checked for the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<AuthPolicyOverridesRulesAuthorizationSpicedbSubject>,
}

/// The name of the permission (or relation) on which to execute the check.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbPermission {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// The resource on which to check the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbResource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyOverridesRulesAuthorizationSpicedbResourceKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyOverridesRulesAuthorizationSpicedbResourceName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbResourceKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbResourceName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// The subject that will be checked for the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbSubject {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyOverridesRulesAuthorizationSpicedbSubjectKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyOverridesRulesAuthorizationSpicedbSubjectName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbSubjectKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbSubjectName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyOverridesRulesAuthorizationWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyOverridesRulesAuthorizationWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesAuthorizationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Callback functions.
/// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacks {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesCallbacksCache>,
    /// Settings of the external HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyOverridesRulesCallbacksHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesCallbacksWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesCallbacksCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesCallbacksHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyOverridesRulesCallbacksHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyOverridesRulesCallbacksHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyOverridesRulesCallbacksHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesCallbacksHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesCallbacksHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyOverridesRulesCallbacksHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyOverridesRulesCallbacksHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON.
    /// E.g. https://ext-auth-server.io/metadata?p={request.path}
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyOverridesRulesCallbacksHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyOverridesRulesCallbacksHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyOverridesRulesCallbacksHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyOverridesRulesCallbacksHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyOverridesRulesCallbacksHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyOverridesRulesCallbacksWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyOverridesRulesCallbacksWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesCallbacksWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Metadata sources.
/// Authorino fetches auth metadata as JSON from sources specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesMetadataCache>,
    /// External source of auth metadata via HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyOverridesRulesMetadataHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// User-Managed Access (UMA) source of resource data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uma: Option<AuthPolicyOverridesRulesMetadataUma>,
    /// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userInfo")]
    pub user_info: Option<AuthPolicyOverridesRulesMetadataUserInfo>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesMetadataWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesMetadataHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyOverridesRulesMetadataHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyOverridesRulesMetadataHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyOverridesRulesMetadataHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesMetadataHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesMetadataHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyOverridesRulesMetadataHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyOverridesRulesMetadataHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON.
    /// E.g. https://ext-auth-server.io/metadata?p={request.path}
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyOverridesRulesMetadataHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyOverridesRulesMetadataHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyOverridesRulesMetadataHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyOverridesRulesMetadataHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyOverridesRulesMetadataHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// User-Managed Access (UMA) source of resource data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataUma {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyOverridesRulesMetadataUmaCredentialsRef,
    /// The endpoint of the UMA server.
    /// The value must coincide with the "issuer" claim of the UMA config discovered from the well-known uma configuration endpoint.
    pub endpoint: String,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataUmaCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataUserInfo {
    /// The name of an OIDC-enabled JWT authentication config whose OpenID Connect configuration discovered includes the OIDC "userinfo_endpoint" claim.
    #[serde(rename = "identitySource")]
    pub identity_source: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyOverridesRulesMetadataWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyOverridesRulesMetadataWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Response items.
/// Authorino builds custom responses to the client of the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponse {
    /// Response items to be included in the auth response when the request is authenticated and authorized.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub success: Option<AuthPolicyOverridesRulesResponseSuccess>,
    /// Customizations on the denial status attributes when the request is unauthenticated.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 401 Unauthorized
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthenticated: Option<AuthPolicyOverridesRulesResponseUnauthenticated>,
    /// Customizations on the denial status attributes when the request is unauthorized.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 403 Forbidden
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthorized: Option<AuthPolicyOverridesRulesResponseUnauthorized>,
}

/// Response items to be included in the auth response when the request is authenticated and authorized.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccess {
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
    /// See https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicMetadata")]
    pub dynamic_metadata: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessDynamicMetadata>>,
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessHeaders>>,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
/// See https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesResponseSuccessDynamicMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataJson {
    pub properties: BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessDynamicMetadataJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeaders {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesResponseSuccessHeadersCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyOverridesRulesResponseSuccessHeadersJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyOverridesRulesResponseSuccessHeadersPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesResponseSuccessHeadersWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyOverridesRulesResponseSuccessHeadersWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesResponseSuccessHeadersCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersJson {
    pub properties: BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessHeadersJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyOverridesRulesResponseSuccessHeadersWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyOverridesRulesResponseSuccessHeadersWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesResponseSuccessHeadersWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessHeadersWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessHeadersWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Customizations on the denial status attributes when the request is unauthenticated.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 401 Unauthorized
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthenticated {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesResponseUnauthenticatedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseUnauthenticatedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyOverridesRulesResponseUnauthenticatedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthenticatedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthenticatedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthenticatedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Customizations on the denial status attributes when the request is unauthorized.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 403 Forbidden
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthorized {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesResponseUnauthorizedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseUnauthorizedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyOverridesRulesResponseUnauthorizedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthorizedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthorizedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthorizedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyOverridesWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyOverridesWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyPatterns {
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyPatternsOperator>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// The auth rules of the policy.
/// See Authorino's AuthConfig CRD for more details.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRules {
    /// Authentication configs.
    /// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<BTreeMap<String, AuthPolicyRulesAuthentication>>,
    /// Authorization policies.
    /// All policies MUST evaluate to "allowed = true" for the auth request be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<BTreeMap<String, AuthPolicyRulesAuthorization>>,
    /// Callback functions.
    /// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callbacks: Option<BTreeMap<String, AuthPolicyRulesCallbacks>>,
    /// Metadata sources.
    /// Authorino fetches auth metadata as JSON from sources specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, AuthPolicyRulesMetadata>>,
    /// Response items.
    /// Authorino builds custom responses to the client of the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<AuthPolicyRulesResponse>,
}

/// Authentication configs.
/// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthentication {
    /// Anonymous access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anonymous: Option<AuthPolicyRulesAuthenticationAnonymous>,
    /// Authentication based on API keys stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<AuthPolicyRulesAuthenticationApiKey>,
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesAuthenticationCache>,
    /// Defines where credentials are required to be passed in the request for authentication based on this config.
    /// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyRulesAuthenticationCredentials>,
    /// Set default property values (claims) for the resolved identity object, that are set before appending the object to
    /// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<BTreeMap<String, AuthPolicyRulesAuthenticationDefaults>>,
    /// Authentication based on JWT tokens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<AuthPolicyRulesAuthenticationJwt>,
    /// Authentication by Kubernetes token review.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesTokenReview")]
    pub kubernetes_token_review: Option<AuthPolicyRulesAuthenticationKubernetesTokenReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Authentication by OAuth2 token introspection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauth2Introspection")]
    pub oauth2_introspection: Option<AuthPolicyRulesAuthenticationOauth2Introspection>,
    /// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
    /// before appending the object to the authorization JSON.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<BTreeMap<String, AuthPolicyRulesAuthenticationOverrides>>,
    /// Identity object extracted from the context.
    /// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyRulesAuthenticationPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesAuthenticationWhen>>,
    /// Authentication based on client X.509 certificates.
    /// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x509: Option<AuthPolicyRulesAuthenticationX509>,
}

/// Anonymous access.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationAnonymous {
}

/// Authentication based on API keys stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationApiKey {
    /// Whether Authorino should look for API key secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
    pub selector: AuthPolicyRulesAuthenticationApiKeySelector,
}

/// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationApiKeySelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyRulesAuthenticationApiKeySelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationApiKeySelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesAuthenticationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Defines where credentials are required to be passed in the request for authentication based on this config.
/// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyRulesAuthenticationCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyRulesAuthenticationCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyRulesAuthenticationCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyRulesAuthenticationCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentialsQueryString {
    pub name: String,
}

/// Set default property values (claims) for the resolved identity object, that are set before appending the object to
/// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationDefaults {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authentication based on JWT tokens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationJwt {
    /// URL of the issuer of the JWT.
    /// If `jwksUrl` is omitted, Authorino will append the path to the OpenID Connect Well-Known Discovery endpoint
    /// (i.e. "/.well-known/openid-configuration") to this URL, to discover the OIDC configuration where to obtain
    /// the "jkws_uri" claim from.
    /// The value must coincide with the value of  the "iss" (issuer) claim of the discovered OpenID Connect configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUrl")]
    pub issuer_url: Option<String>,
    /// Decides how long to wait before refreshing the JWKS (in seconds).
    /// If omitted, Authorino will never refresh the JWKS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Authentication by Kubernetes token review.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationKubernetesTokenReview {
    /// The list of audiences (scopes) that must be claimed in a Kubernetes authentication token supplied in the request, and reviewed by Authorino.
    /// If omitted, Authorino will review tokens expecting the host name of the requested protected service amongst the audiences.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
}

/// Authentication by OAuth2 token introspection.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationOauth2Introspection {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyRulesAuthenticationOauth2IntrospectionCredentialsRef,
    /// The full URL of the token introspection endpoint.
    pub endpoint: String,
    /// The token type hint for the token introspection.
    /// If omitted, it defaults to "access_token".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenTypeHint")]
    pub token_type_hint: Option<String>,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationOauth2IntrospectionCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
/// before appending the object to the authorization JSON.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationOverrides {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Identity object extracted from the context.
/// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    pub selector: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyRulesAuthenticationWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyRulesAuthenticationWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesAuthenticationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthenticationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authentication based on client X.509 certificates.
/// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationX509 {
    /// Whether Authorino should look for TLS secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
    /// clients trying to authenticate to this service
    pub selector: AuthPolicyRulesAuthenticationX509Selector,
}

/// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
/// clients trying to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationX509Selector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyRulesAuthenticationX509SelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationX509SelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Authorization policies.
/// All policies MUST evaluate to "allowed = true" for the auth request be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorization {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesAuthorizationCache>,
    /// Authorization by Kubernetes SubjectAccessReview
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSubjectAccessReview")]
    pub kubernetes_subject_access_review: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Open Policy Agent (OPA) Rego policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opa: Option<AuthPolicyRulesAuthorizationOpa>,
    /// Pattern-matching authorization rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternMatching")]
    pub pattern_matching: Option<AuthPolicyRulesAuthorizationPatternMatching>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Authorization decision delegated to external Authzed/SpiceDB server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spicedb: Option<AuthPolicyRulesAuthorizationSpicedb>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesAuthorizationWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesAuthorizationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authorization by Kubernetes SubjectAccessReview
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReview {
    /// Groups the user must be a member of or, if `user` is omitted, the groups to check for authorization in the Kubernetes RBAC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
    /// Use resourceAttributes to check permissions on Kubernetes resources.
    /// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceAttributes")]
    pub resource_attributes: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes>,
    /// User to check for authorization in the Kubernetes RBAC.
    /// Omit it to check for group authorization only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewUser>,
}

/// Use resourceAttributes to check permissions on Kubernetes resources.
/// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes {
    /// API group of the resource.
    /// Use '*' for all API groups.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup>,
    /// Resource name
    /// Omit it to check for authorization on all resources of the specified kind.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName>,
    /// Namespace where the user must have permissions on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace>,
    /// Resource kind
    /// Use '*' for all resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource>,
    /// Subresource kind
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource>,
    /// Verb to check for authorization on the resource.
    /// Use '*' for all verbs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verb: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb>,
}

/// API group of the resource.
/// Use '*' for all API groups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource name
/// Omit it to check for authorization on all resources of the specified kind.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Namespace where the user must have permissions on the resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource kind
/// Use '*' for all resource kinds.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Subresource kind
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Verb to check for authorization on the resource.
/// Use '*' for all verbs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// User to check for authorization in the Kubernetes RBAC.
/// Omit it to check for group authorization only.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewUser {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Open Policy Agent (OPA) Rego policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpa {
    /// Returns the value of all Rego rules in the virtual document. Values can be read in subsequent evaluators/phases of the Auth Pipeline.
    /// Otherwise, only the default `allow` rule will be exposed.
    /// Returning all Rego rules can affect performance of OPA policies during reconciliation (policy precompile) and at runtime.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allValues")]
    pub all_values: Option<bool>,
    /// Settings for fetching the OPA policy from an external registry.
    /// Use it alternatively to 'rego'.
    /// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
    /// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalPolicy")]
    pub external_policy: Option<AuthPolicyRulesAuthorizationOpaExternalPolicy>,
    /// Authorization policy as a Rego language document.
    /// The Rego document must include the "allow" condition, set by Authorino to "false" by default (i.e. requests are unauthorized unless changed).
    /// The Rego document must NOT include the "package" declaration in line 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rego: Option<String>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicy {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyRulesAuthorizationOpaExternalPolicyBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesAuthorizationOpaExternalPolicyHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyRulesAuthorizationOpaExternalPolicySharedSecretRef>,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON.
    /// E.g. https://ext-auth-server.io/metadata?p={request.path}
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationOpaExternalPolicyContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationOpaExternalPolicyMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicySharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Pattern-matching authorization rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationPatternMatching {
    pub patterns: Vec<AuthPolicyRulesAuthorizationPatternMatchingPatterns>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationPatternMatchingPatterns {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyRulesAuthorizationPatternMatchingPatternsAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyRulesAuthorizationPatternMatchingPatternsAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesAuthorizationPatternMatchingPatternsOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationPatternMatchingPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorization decision delegated to external Authzed/SpiceDB server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedb {
    /// Hostname and port number to the GRPC interface of the SpiceDB server (e.g. spicedb:50051).
    pub endpoint: String,
    /// Insecure HTTP connection (i.e. disables TLS verification)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// The name of the permission (or relation) on which to execute the check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<AuthPolicyRulesAuthorizationSpicedbPermission>,
    /// The resource on which to check the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyRulesAuthorizationSpicedbResource>,
    /// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyRulesAuthorizationSpicedbSharedSecretRef>,
    /// The subject that will be checked for the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<AuthPolicyRulesAuthorizationSpicedbSubject>,
}

/// The name of the permission (or relation) on which to execute the check.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbPermission {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// The resource on which to check the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbResource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyRulesAuthorizationSpicedbResourceKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyRulesAuthorizationSpicedbResourceName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbResourceKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbResourceName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// The subject that will be checked for the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbSubject {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyRulesAuthorizationSpicedbSubjectKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyRulesAuthorizationSpicedbSubjectName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbSubjectKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbSubjectName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyRulesAuthorizationWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyRulesAuthorizationWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesAuthorizationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Callback functions.
/// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacks {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesCallbacksCache>,
    /// Settings of the external HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyRulesCallbacksHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesCallbacksWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesCallbacksCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesCallbacksHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyRulesCallbacksHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyRulesCallbacksHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyRulesCallbacksHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesCallbacksHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesCallbacksHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyRulesCallbacksHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyRulesCallbacksHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON.
    /// E.g. https://ext-auth-server.io/metadata?p={request.path}
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyRulesCallbacksHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyRulesCallbacksHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyRulesCallbacksHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyRulesCallbacksHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyRulesCallbacksHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyRulesCallbacksWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyRulesCallbacksWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesCallbacksWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Metadata sources.
/// Authorino fetches auth metadata as JSON from sources specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesMetadataCache>,
    /// External source of auth metadata via HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyRulesMetadataHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// User-Managed Access (UMA) source of resource data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uma: Option<AuthPolicyRulesMetadataUma>,
    /// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userInfo")]
    pub user_info: Option<AuthPolicyRulesMetadataUserInfo>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesMetadataWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesMetadataHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyRulesMetadataHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyRulesMetadataHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyRulesMetadataHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesMetadataHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesMetadataHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyRulesMetadataHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyRulesMetadataHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON.
    /// E.g. https://ext-auth-server.io/metadata?p={request.path}
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyRulesMetadataHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyRulesMetadataHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyRulesMetadataHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyRulesMetadataHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyRulesMetadataHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// User-Managed Access (UMA) source of resource data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataUma {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyRulesMetadataUmaCredentialsRef,
    /// The endpoint of the UMA server.
    /// The value must coincide with the "issuer" claim of the UMA config discovered from the well-known uma configuration endpoint.
    pub endpoint: String,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataUmaCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataUserInfo {
    /// The name of an OIDC-enabled JWT authentication config whose OpenID Connect configuration discovered includes the OIDC "userinfo_endpoint" claim.
    #[serde(rename = "identitySource")]
    pub identity_source: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyRulesMetadataWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyRulesMetadataWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Response items.
/// Authorino builds custom responses to the client of the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponse {
    /// Response items to be included in the auth response when the request is authenticated and authorized.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub success: Option<AuthPolicyRulesResponseSuccess>,
    /// Customizations on the denial status attributes when the request is unauthenticated.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 401 Unauthorized
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthenticated: Option<AuthPolicyRulesResponseUnauthenticated>,
    /// Customizations on the denial status attributes when the request is unauthorized.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 403 Forbidden
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthorized: Option<AuthPolicyRulesResponseUnauthorized>,
}

/// Response items to be included in the auth response when the request is authenticated and authorized.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccess {
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
    /// See https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicMetadata")]
    pub dynamic_metadata: Option<BTreeMap<String, AuthPolicyRulesResponseSuccessDynamicMetadata>>,
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesResponseSuccessHeaders>>,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
/// See https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesResponseSuccessDynamicMetadataCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyRulesResponseSuccessDynamicMetadataJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyRulesResponseSuccessDynamicMetadataPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesResponseSuccessDynamicMetadataWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyRulesResponseSuccessDynamicMetadataWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesResponseSuccessDynamicMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataJson {
    pub properties: BTreeMap<String, AuthPolicyRulesResponseSuccessDynamicMetadataJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyRulesResponseSuccessDynamicMetadataWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyRulesResponseSuccessDynamicMetadataWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesResponseSuccessDynamicMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessDynamicMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyRulesResponseSuccessDynamicMetadataWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeaders {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesResponseSuccessHeadersCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyRulesResponseSuccessHeadersJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyRulesResponseSuccessHeadersPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesResponseSuccessHeadersWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyRulesResponseSuccessHeadersWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesResponseSuccessHeadersCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersJson {
    pub properties: BTreeMap<String, AuthPolicyRulesResponseSuccessHeadersJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyRulesResponseSuccessHeadersWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyRulesResponseSuccessHeadersWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesResponseSuccessHeadersWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessHeadersWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyRulesResponseSuccessHeadersWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyRulesResponseSuccessHeadersWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Customizations on the denial status attributes when the request is unauthenticated.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 401 Unauthorized
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthenticated {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesResponseUnauthenticatedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesResponseUnauthenticatedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyRulesResponseUnauthenticatedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthenticatedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthenticatedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthenticatedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Customizations on the denial status attributes when the request is unauthorized.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 403 Forbidden
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthorized {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesResponseUnauthorizedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesResponseUnauthorizedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyRulesResponseUnauthorizedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthorizedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthorizedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthorizedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// TargetRef identifies an API object to apply policy to.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyTargetRef {
    /// Group is the group of the target resource.
    pub group: String,
    /// Kind is kind of the target resource.
    pub kind: String,
    /// Name is the name of the target resource.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<AuthPolicyWhenAll>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<AuthPolicyWhenAny>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyStatus {
    /// Represents the observations of a foo's current state.
    /// Known .status.conditions.type are: "Available"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration reflects the generation of the most recently observed spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

