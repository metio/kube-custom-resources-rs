// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/Kuadrant/dns-operator/kuadrant.io/v1alpha1/dnsrecords.yaml --derive=Default --derive=PartialEq
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// DNSRecordSpec defines the desired state of DNSRecord
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "kuadrant.io", version = "v1alpha1", kind = "DNSRecord", plural = "dnsrecords")]
#[kube(namespaced)]
#[kube(status = "DNSRecordStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct DNSRecordSpec {
    /// endpoints is a list of endpoints that will be published into the dns provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<Vec<DNSRecordEndpoints>>,
    /// HealthCheckSpec configures health checks in the DNS provider.
    /// By default this health check will be applied to each unique DNS A Record for
    /// the listeners assigned to the target gateway
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<DNSRecordHealthCheck>,
    /// managedZone is a reference to a ManagedZone instance to which this record will publish its endpoints.
    #[serde(rename = "managedZone")]
    pub managed_zone: DNSRecordManagedZone,
    /// ownerID is a unique string used to identify the owner of this record.
    #[serde(rename = "ownerID")]
    pub owner_id: String,
    /// rootHost is the single root for all endpoints in a DNSRecord.
    /// it is expected all defined endpoints are children of or equal to this rootHost
    #[serde(rename = "rootHost")]
    pub root_host: String,
}

/// Endpoint is a high-level way of a connection between a service and an IP
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordEndpoints {
    /// The hostname of the DNS record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    pub dns_name: Option<String>,
    /// Labels stores labels defined for the Endpoint
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// ProviderSpecific stores provider specific config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerSpecific")]
    pub provider_specific: Option<Vec<DNSRecordEndpointsProviderSpecific>>,
    /// TTL for the record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordTTL")]
    pub record_ttl: Option<i64>,
    /// RecordType type of record, e.g. CNAME, A, AAAA, SRV, TXT etc
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordType")]
    pub record_type: Option<String>,
    /// Identifier to distinguish multiple records with the same name and type (e.g. Route53 records with routing policies other than 'simple')
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setIdentifier")]
    pub set_identifier: Option<String>,
    /// The targets the DNS record points to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// ProviderSpecificProperty holds the name and value of a configuration which is specific to individual DNS providers
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordEndpointsProviderSpecific {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HealthCheckSpec configures health checks in the DNS provider.
/// By default this health check will be applied to each unique DNS A Record for
/// the listeners assigned to the target gateway
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordHealthCheck {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// managedZone is a reference to a ManagedZone instance to which this record will publish its endpoints.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordManagedZone {
    /// `name` is the name of the managed zone.
    /// Required
    pub name: String,
}

/// DNSRecordStatus defines the observed state of DNSRecord
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordStatus {
    /// conditions are any conditions associated with the record in the managed zone.
    /// 
    /// 
    /// If publishing the record fails, the "Failed" condition will be set with a
    /// reason and message describing the cause of the failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// endpoints are the last endpoints that were successfully published by the provider
    /// 
    /// 
    /// Provides a simple mechanism to store the current provider records in order to
    /// delete any that are no longer present in DNSRecordSpec.Endpoints
    /// 
    /// 
    /// Note: This will not be required if/when we switch to using external-dns since when
    /// running with a "sync" policy it will clean up unused records automatically.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<Vec<DNSRecordStatusEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<DNSRecordStatusHealthCheck>,
    /// observedGeneration is the most recently observed generation of the
    /// DNSRecord.  When the DNSRecord is updated, the controller updates the
    /// corresponding record in each managed zone.  If an update for a
    /// particular zone fails, that failure is recorded in the status
    /// condition for the zone so that the controller can determine that it
    /// needs to retry the update for that specific zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// QueuedAt is a time when DNS record was received for the reconciliation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queuedAt")]
    pub queued_at: Option<String>,
    /// QueuedFor is a time when we expect a DNS record to be reconciled again
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queuedFor")]
    pub queued_for: Option<String>,
    /// ValidFor indicates duration since the last reconciliation we consider data in the record to be valid
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validFor")]
    pub valid_for: Option<String>,
    /// WriteCounter represent a number of consecutive write attempts on the same generation of the record.
    /// It is being reset to 0 when the generation changes or there are no changes to write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeCounter")]
    pub write_counter: Option<i64>,
}

/// Endpoint is a high-level way of a connection between a service and an IP
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordStatusEndpoints {
    /// The hostname of the DNS record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    pub dns_name: Option<String>,
    /// Labels stores labels defined for the Endpoint
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// ProviderSpecific stores provider specific config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerSpecific")]
    pub provider_specific: Option<Vec<DNSRecordStatusEndpointsProviderSpecific>>,
    /// TTL for the record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordTTL")]
    pub record_ttl: Option<i64>,
    /// RecordType type of record, e.g. CNAME, A, AAAA, SRV, TXT etc
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordType")]
    pub record_type: Option<String>,
    /// Identifier to distinguish multiple records with the same name and type (e.g. Route53 records with routing policies other than 'simple')
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setIdentifier")]
    pub set_identifier: Option<String>,
    /// The targets the DNS record points to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// ProviderSpecificProperty holds the name and value of a configuration which is specific to individual DNS providers
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordStatusEndpointsProviderSpecific {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordStatusHealthCheck {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<Vec<DNSRecordStatusHealthCheckProbes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordStatusHealthCheckProbes {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    pub host: String,
    pub id: String,
    #[serde(rename = "ipAddress")]
    pub ip_address: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synced: Option<bool>,
}

