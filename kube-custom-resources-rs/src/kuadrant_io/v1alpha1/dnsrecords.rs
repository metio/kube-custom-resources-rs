// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/Kuadrant/dns-operator/kuadrant.io/v1alpha1/dnsrecords.yaml --derive=Default --derive=PartialEq
// kopium version: 0.17.2

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;

/// DNSRecordSpec defines the desired state of DNSRecord
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "kuadrant.io", version = "v1alpha1", kind = "DNSRecord", plural = "dnsrecords")]
#[kube(namespaced)]
#[kube(status = "DNSRecordStatus")]
#[kube(schema = "disabled")]
pub struct DNSRecordSpec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<Vec<DNSRecordEndpoints>>,
    /// HealthCheckSpec configures health checks in the DNS provider. By default this health check will be applied to each unique DNS A Record for the listeners assigned to the target gateway
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<DNSRecordHealthCheck>,
    /// ManagedZoneReference holds a reference to a ManagedZone
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedZone")]
    pub managed_zone: Option<DNSRecordManagedZone>,
    /// OwnerID is a unique string used to identify all endpoints created by this kuadrant
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownerID")]
    pub owner_id: Option<String>,
    /// rootHost is the single root for all endpoints in a DNSRecord. If rootHost is set, it is expected all defined endpoints are children 	of or equal to this rootHost
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootHost")]
    pub root_host: Option<String>,
}

/// Endpoint is a high-level way of a connection between a service and an IP
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordEndpoints {
    /// The hostname of the DNS record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    pub dns_name: Option<String>,
    /// Labels stores labels defined for the Endpoint
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// ProviderSpecific stores provider specific config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerSpecific")]
    pub provider_specific: Option<Vec<DNSRecordEndpointsProviderSpecific>>,
    /// TTL for the record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordTTL")]
    pub record_ttl: Option<i64>,
    /// RecordType type of record, e.g. CNAME, A, AAAA, SRV, TXT etc
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordType")]
    pub record_type: Option<String>,
    /// Identifier to distinguish multiple records with the same name and type (e.g. Route53 records with routing policies other than 'simple')
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setIdentifier")]
    pub set_identifier: Option<String>,
    /// The targets the DNS record points to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// ProviderSpecificProperty holds the name and value of a configuration which is specific to individual DNS providers
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordEndpointsProviderSpecific {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HealthCheckSpec configures health checks in the DNS provider. By default this health check will be applied to each unique DNS A Record for the listeners assigned to the target gateway
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordHealthCheck {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// ManagedZoneReference holds a reference to a ManagedZone
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordManagedZone {
    /// `name` is the name of the managed zone. Required
    pub name: String,
}

/// DNSRecordStatus defines the observed state of DNSRecord
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordStatus {
    /// conditions are any conditions associated with the record in the managed zone. 
    ///  If publishing the record fails, the "Failed" condition will be set with a reason and message describing the cause of the failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// endpoints are the last endpoints that were successfully published by the provider 
    ///  Provides a simple mechanism to store the current provider records in order to delete any that are no longer present in DNSRecordSpec.Endpoints 
    ///  Note: This will not be required if/when we switch to using external-dns since when running with a "sync" policy it will clean up unused records automatically.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<Vec<DNSRecordStatusEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<DNSRecordStatusHealthCheck>,
    /// observedGeneration is the most recently observed generation of the DNSRecord.  When the DNSRecord is updated, the controller updates the corresponding record in each managed zone.  If an update for a particular zone fails, that failure is recorded in the status condition for the zone so that the controller can determine that it needs to retry the update for that specific zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

/// Endpoint is a high-level way of a connection between a service and an IP
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordStatusEndpoints {
    /// The hostname of the DNS record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsName")]
    pub dns_name: Option<String>,
    /// Labels stores labels defined for the Endpoint
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// ProviderSpecific stores provider specific config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerSpecific")]
    pub provider_specific: Option<Vec<DNSRecordStatusEndpointsProviderSpecific>>,
    /// TTL for the record
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordTTL")]
    pub record_ttl: Option<i64>,
    /// RecordType type of record, e.g. CNAME, A, AAAA, SRV, TXT etc
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recordType")]
    pub record_type: Option<String>,
    /// Identifier to distinguish multiple records with the same name and type (e.g. Route53 records with routing policies other than 'simple')
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setIdentifier")]
    pub set_identifier: Option<String>,
    /// The targets the DNS record points to
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// ProviderSpecificProperty holds the name and value of a configuration which is specific to individual DNS providers
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordStatusEndpointsProviderSpecific {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct DNSRecordStatusHealthCheck {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

