// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/stackabletech/listener-operator/listeners.stackable.tech/v1alpha1/listeners.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// Exposes a set of pods to the outside world.
/// 
/// Essentially a Stackable extension of a Kubernetes Service. Compared to a Service, a Listener changes three things: 1. It uses a cluster-level policy object (ListenerClass) to define how exactly the exposure works 2. It has a consistent API for reading back the exposed address(es) of the service 3. The Pod must mount a Volume referring to the Listener, which also allows ["sticky" scheduling](https://docs.stackable.tech/home/nightly/listener-operator/listener#_sticky_scheduling).
/// 
/// Learn more in the [Listener documentation](https://docs.stackable.tech/home/nightly/listener-operator/listener).
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "listeners.stackable.tech", version = "v1alpha1", kind = "Listener", plural = "listeners")]
#[kube(namespaced)]
#[kube(status = "ListenerStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ListenerSpec {
    /// The name of the [ListenerClass](https://docs.stackable.tech/home/nightly/listener-operator/listenerclass).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "className")]
    pub class_name: Option<String>,
    /// Extra labels that the Pods must match in order to be exposed. They must _also_ still have a Volume referring to the Listener.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraPodSelectorLabels")]
    pub extra_pod_selector_labels: Option<BTreeMap<String, String>>,
    /// Ports that should be exposed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ListenerPorts>>,
    /// Whether incoming traffic should also be directed to Pods that are not `Ready`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishNotReadyAddresses")]
    pub publish_not_ready_addresses: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ListenerPorts {
    /// The name of the port.
    /// 
    /// The name of each port *must* be unique within a single Listener.
    pub name: String,
    /// The port number.
    pub port: i32,
    /// The layer-4 protocol (`TCP` or `UDP`).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Informs users about how to reach the Listener.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ListenerStatus {
    /// All addresses that the Listener is currently reachable from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressAddresses")]
    pub ingress_addresses: Option<Vec<ListenerStatusIngressAddresses>>,
    /// Port mappings for accessing the Listener on each Node that the Pods are currently running on.
    /// 
    /// This is only intended for internal use by listener-operator itself. This will be left unset if using a ListenerClass that does not require Node-local access.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePorts")]
    pub node_ports: Option<BTreeMap<String, i32>>,
    /// The backing Kubernetes Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

/// One address that a Listener is accessible from.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ListenerStatusIngressAddresses {
    /// The hostname or IP address to the Listener.
    pub address: String,
    /// The type of address (`Hostname` or `IP`).
    #[serde(rename = "addressType")]
    pub address_type: ListenerStatusIngressAddressesAddressType,
    /// Port mapping table.
    pub ports: BTreeMap<String, i32>,
}

/// One address that a Listener is accessible from.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ListenerStatusIngressAddressesAddressType {
    Hostname,
    #[serde(rename = "IP")]
    Ip,
}

