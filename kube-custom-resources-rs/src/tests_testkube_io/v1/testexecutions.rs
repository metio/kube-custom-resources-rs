// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/kubeshop/testkube-operator/tests.testkube.io/v1/testexecutions.yaml --derive=PartialEq
// kopium version: 0.16.5

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// TestExecutionSpec defines the desired state of TestExecution
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "tests.testkube.io", version = "v1", kind = "TestExecution", plural = "testexecutions")]
#[kube(namespaced)]
#[kube(status = "TestExecutionStatus")]
#[kube(schema = "disabled")]
pub struct TestExecutionSpec {
    /// test execution request body
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionRequest")]
    pub execution_request: Option<TestExecutionExecutionRequest>,
    pub test: TestExecutionTest,
}

/// test execution request body
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequest {
    /// Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeDeadlineSeconds")]
    pub active_deadline_seconds: Option<i64>,
    /// additional executor binary arguments
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// usage mode for arguments
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "argsMode")]
    pub args_mode: Option<TestExecutionExecutionRequestArgsMode>,
    /// artifact request body with test artifacts
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "artifactRequest")]
    pub artifact_request: Option<TestExecutionExecutionRequestArtifactRequest>,
    /// executor binary command
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// cron job template extensions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cronJobTemplate")]
    pub cron_job_template: Option<String>,
    /// config map references
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envConfigMaps")]
    pub env_config_maps: Option<Vec<TestExecutionExecutionRequestEnvConfigMaps>>,
    /// secret references
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envSecrets")]
    pub env_secrets: Option<Vec<TestExecutionExecutionRequestEnvSecrets>>,
    /// Environment variables passed to executor. Deprecated: use Basic Variables instead
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub envs: Option<BTreeMap<String, String>>,
    /// execute post run script before scraping (prebuilt executor only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executePostRunScriptBeforeScraping")]
    pub execute_post_run_script_before_scraping: Option<bool>,
    /// test execution labels
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionLabels")]
    pub execution_labels: Option<BTreeMap<String, String>>,
    /// http proxy for executor containers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpProxy")]
    pub http_proxy: Option<String>,
    /// https proxy for executor containers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsProxy")]
    pub https_proxy: Option<String>,
    /// container executor image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// container executor image pull secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecrets")]
    pub image_pull_secrets: Option<Vec<TestExecutionExecutionRequestImagePullSecrets>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isVariablesFileUploaded")]
    pub is_variables_file_uploaded: Option<bool>,
    /// job template extensions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobTemplate")]
    pub job_template: Option<String>,
    /// test execution custom name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// test kubernetes namespace (\"testkube\" when not set)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// negative test will fail the execution if it is a success and it will succeed if it is a failure
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "negativeTest")]
    pub negative_test: Option<bool>,
    /// test execution number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i32>,
    /// script to run after test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postRunScript")]
    pub post_run_script: Option<String>,
    /// script to run before test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preRunScript")]
    pub pre_run_script: Option<String>,
    /// running context for test or test suite execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runningContext")]
    pub running_context: Option<TestExecutionExecutionRequestRunningContext>,
    /// scraper template extensions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scraperTemplate")]
    pub scraper_template: Option<String>,
    /// Execution variables passed to executor from secrets. Deprecated: use Secret Variables instead
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretEnvs")]
    pub secret_envs: Option<BTreeMap<String, String>>,
    /// pod request body
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slavePodRequest")]
    pub slave_pod_request: Option<TestExecutionExecutionRequestSlavePodRequest>,
    /// whether to start execution sync or async
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sync: Option<bool>,
    /// test secret uuid
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSecretUUID")]
    pub test_secret_uuid: Option<String>,
    /// unique test suite name (CRD Test suite name), if it's run as a part of test suite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteName")]
    pub test_suite_name: Option<String>,
    /// test suite secret uuid, if it's run as a part of test suite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteSecretUUID")]
    pub test_suite_secret_uuid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<BTreeMap<String, TestExecutionExecutionRequestVariables>>,
    /// variables file content - need to be in format for particular executor (e.g. postman envs file)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "variablesFile")]
    pub variables_file: Option<String>,
}

/// test execution request body
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestExecutionExecutionRequestArgsMode {
    #[serde(rename = "append")]
    Append,
    #[serde(rename = "override")]
    Override,
    #[serde(rename = "replace")]
    Replace,
}

/// artifact request body with test artifacts
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestArtifactRequest {
    /// artifact directories for scraping
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dirs: Option<Vec<String>>,
    /// regexp to filter scraped artifacts, single or comma separated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub masks: Option<Vec<String>>,
    /// don't use a separate folder for execution artifacts
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "omitFolderPerExecution")]
    pub omit_folder_per_execution: Option<bool>,
    /// whether to share volume between pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedBetweenPods")]
    pub shared_between_pods: Option<bool>,
    /// artifact bucket storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageBucket")]
    pub storage_bucket: Option<String>,
    /// artifact storage class name for container executor
    #[serde(rename = "storageClassName")]
    pub storage_class_name: String,
    /// artifact volume mount path for container executor
    #[serde(rename = "volumeMountPath")]
    pub volume_mount_path: String,
}

/// Reference to env resource
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestEnvConfigMaps {
    /// whether we shoud map to variables from resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mapToVariables")]
    pub map_to_variables: Option<bool>,
    /// whether we shoud mount resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mount: Option<bool>,
    /// where we shoud mount resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPath")]
    pub mount_path: Option<String>,
    /// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
    pub reference: TestExecutionExecutionRequestEnvConfigMapsReference,
}

/// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestEnvConfigMapsReference {
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Reference to env resource
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestEnvSecrets {
    /// whether we shoud map to variables from resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mapToVariables")]
    pub map_to_variables: Option<bool>,
    /// whether we shoud mount resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mount: Option<bool>,
    /// where we shoud mount resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPath")]
    pub mount_path: Option<String>,
    /// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
    pub reference: TestExecutionExecutionRequestEnvSecretsReference,
}

/// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestEnvSecretsReference {
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestImagePullSecrets {
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestRunningContext {
    /// Context value depending from its type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<String>,
    /// One of possible context types
    #[serde(rename = "type")]
    pub r#type: TestExecutionExecutionRequestRunningContextType,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestExecutionExecutionRequestRunningContextType {
    #[serde(rename = "user-cli")]
    UserCli,
    #[serde(rename = "user-ui")]
    UserUi,
    #[serde(rename = "testsuite")]
    Testsuite,
    #[serde(rename = "testtrigger")]
    Testtrigger,
    #[serde(rename = "scheduler")]
    Scheduler,
    #[serde(rename = "testexecution")]
    Testexecution,
    #[serde(rename = "testsuiteexecution")]
    Testsuiteexecution,
}

/// pod request body
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestSlavePodRequest {
    /// pod template extensions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// name of the template resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplateReference")]
    pub pod_template_reference: Option<String>,
    /// pod resources request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TestExecutionExecutionRequestSlavePodRequestResources>,
}

/// pod resources request specification
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestSlavePodRequestResources {
    /// resource request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<TestExecutionExecutionRequestSlavePodRequestResourcesLimits>,
    /// resource request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<TestExecutionExecutionRequestSlavePodRequestResourcesRequests>,
}

/// resource request specification
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestSlavePodRequestResourcesLimits {
    /// requested cpu units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    /// requested memory units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

/// resource request specification
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestSlavePodRequestResourcesRequests {
    /// requested cpu units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    /// requested memory units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestVariables {
    /// variable name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// variable type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// variable string value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// or load it from var source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<TestExecutionExecutionRequestVariablesValueFrom>,
}

/// or load it from var source
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestVariablesValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<TestExecutionExecutionRequestVariablesValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<TestExecutionExecutionRequestVariablesValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<TestExecutionExecutionRequestVariablesValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<TestExecutionExecutionRequestVariablesValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestVariablesValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestVariablesValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestVariablesValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionExecutionRequestVariablesValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionTest {
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// TestExecutionStatus defines the observed state of TestExecution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatus {
    /// test execution generation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generation: Option<i64>,
    /// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "latestExecution")]
    pub latest_execution: Option<TestExecutionStatusLatestExecution>,
}

/// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecution {
    /// additional arguments/flags passed to executor binary
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// usage mode for arguments
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args_mode: Option<TestExecutionStatusLatestExecutionArgsMode>,
    /// artifact request body with test artifacts
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "artifactRequest")]
    pub artifact_request: Option<TestExecutionStatusLatestExecutionArtifactRequest>,
    /// minio bucket name to get uploads from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// executor image command
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// shell used in container executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerShell")]
    pub container_shell: Option<String>,
    /// TestContent defines test content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content: Option<TestExecutionStatusLatestExecutionContent>,
    /// test duration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// test duration in milliseconds
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "durationMs")]
    pub duration_ms: Option<i32>,
    /// test end time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Environment variables passed to executor. Deprecated: use Basic Variables instead
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub envs: Option<BTreeMap<String, String>>,
    /// execute post run script before scraping (prebuilt executor only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executePostRunScriptBeforeScraping")]
    pub execute_post_run_script_before_scraping: Option<bool>,
    /// execution result returned from executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionResult")]
    pub execution_result: Option<TestExecutionStatusLatestExecutionExecutionResult>,
    /// execution id
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// in case the variables file is too big, it will be uploaded to storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isVariablesFileUploaded")]
    pub is_variables_file_uploaded: Option<bool>,
    /// test and execution labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// execution name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// execution number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i32>,
    /// script to run after test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postRunScript")]
    pub post_run_script: Option<String>,
    /// script to run before test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preRunScript")]
    pub pre_run_script: Option<String>,
    /// running context for test or test suite execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runningContext")]
    pub running_context: Option<TestExecutionStatusLatestExecutionRunningContext>,
    /// pod request body
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slavePodRequest")]
    pub slave_pod_request: Option<TestExecutionStatusLatestExecutionSlavePodRequest>,
    /// test start time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// unique test name (CRD Test name)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testName")]
    pub test_name: Option<String>,
    /// test namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testNamespace")]
    pub test_namespace: Option<String>,
    /// test secret uuid
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSecretUUID")]
    pub test_secret_uuid: Option<String>,
    /// unique test suite name (CRD Test suite name), if it's run as a part of test suite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteName")]
    pub test_suite_name: Option<String>,
    /// test suite secret uuid, if it's run as a part of test suite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteSecretUUID")]
    pub test_suite_secret_uuid: Option<String>,
    /// test type e.g. postman/collection
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testType")]
    pub test_type: Option<String>,
    /// list of file paths that need to be copied into the test from uploads
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uploads: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<BTreeMap<String, TestExecutionStatusLatestExecutionVariables>>,
    /// variables file content - need to be in format for particular executor (e.g. postman envs file)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "variablesFile")]
    pub variables_file: Option<String>,
}

/// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestExecutionStatusLatestExecutionArgsMode {
    #[serde(rename = "append")]
    Append,
    #[serde(rename = "override")]
    Override,
    #[serde(rename = "replace")]
    Replace,
}

/// artifact request body with test artifacts
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionArtifactRequest {
    /// artifact directories for scraping
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dirs: Option<Vec<String>>,
    /// regexp to filter scraped artifacts, single or comma separated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub masks: Option<Vec<String>>,
    /// don't use a separate folder for execution artifacts
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "omitFolderPerExecution")]
    pub omit_folder_per_execution: Option<bool>,
    /// whether to share volume between pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedBetweenPods")]
    pub shared_between_pods: Option<bool>,
    /// artifact bucket storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageBucket")]
    pub storage_bucket: Option<String>,
    /// artifact storage class name for container executor
    #[serde(rename = "storageClassName")]
    pub storage_class_name: String,
    /// artifact volume mount path for container executor
    #[serde(rename = "volumeMountPath")]
    pub volume_mount_path: String,
}

/// TestContent defines test content
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionContent {
    /// test content body
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// repository of test content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<TestExecutionStatusLatestExecutionContentRepository>,
    /// test type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<TestExecutionStatusLatestExecutionContentType>,
    /// uri of test content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

/// repository of test content
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionContentRepository {
    /// auth type for git requests
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authType")]
    pub auth_type: Option<TestExecutionStatusLatestExecutionContentRepositoryAuthType>,
    /// branch/tag name for checkout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,
    /// git auth certificate secret for private repositories
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateSecret")]
    pub certificate_secret: Option<String>,
    /// commit id (sha) for checkout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit: Option<String>,
    /// if needed we can checkout particular path (dir or file) in case of BIG/mono repositories
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Testkube internal reference for secret storage in Kubernetes secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecret")]
    pub token_secret: Option<TestExecutionStatusLatestExecutionContentRepositoryTokenSecret>,
    /// VCS repository type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// uri of content file or git directory
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    /// Testkube internal reference for secret storage in Kubernetes secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernameSecret")]
    pub username_secret: Option<TestExecutionStatusLatestExecutionContentRepositoryUsernameSecret>,
    /// if provided we checkout the whole repository and run test from this directory
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// repository of test content
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestExecutionStatusLatestExecutionContentRepositoryAuthType {
    #[serde(rename = "basic")]
    Basic,
    #[serde(rename = "header")]
    Header,
}

/// Testkube internal reference for secret storage in Kubernetes secrets
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionContentRepositoryTokenSecret {
    /// object key
    pub key: String,
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Testkube internal reference for secret storage in Kubernetes secrets
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionContentRepositoryUsernameSecret {
    /// object key
    pub key: String,
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// TestContent defines test content
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestExecutionStatusLatestExecutionContentType {
    #[serde(rename = "string")]
    String,
    #[serde(rename = "file-uri")]
    FileUri,
    #[serde(rename = "git-file")]
    GitFile,
    #[serde(rename = "git-dir")]
    GitDir,
    #[serde(rename = "git")]
    Git,
}

/// execution result returned from executor
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionExecutionResult {
    /// error message when status is error, separate to output as output can be partial in case of error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorMessage")]
    pub error_message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reports: Option<TestExecutionStatusLatestExecutionExecutionResultReports>,
    pub status: TestExecutionStatusLatestExecutionExecutionResultStatus,
    /// execution steps (for collection of requests)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<Vec<TestExecutionStatusLatestExecutionExecutionResultSteps>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionExecutionResultReports {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub junit: Option<String>,
}

/// execution result returned from executor
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestExecutionStatusLatestExecutionExecutionResultStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "passed")]
    Passed,
    #[serde(rename = "failed")]
    Failed,
    #[serde(rename = "aborted")]
    Aborted,
    #[serde(rename = "timeout")]
    Timeout,
}

/// execution result data
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionExecutionResultSteps {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "assertionResults")]
    pub assertion_results: Option<Vec<TestExecutionStatusLatestExecutionExecutionResultStepsAssertionResults>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// step name
    pub name: String,
    /// execution step status
    pub status: String,
}

/// execution result data
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionExecutionResultStepsAssertionResults {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorMessage")]
    pub error_message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionRunningContext {
    /// Context value depending from its type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<String>,
    /// One of possible context types
    #[serde(rename = "type")]
    pub r#type: TestExecutionStatusLatestExecutionRunningContextType,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestExecutionStatusLatestExecutionRunningContextType {
    #[serde(rename = "user-cli")]
    UserCli,
    #[serde(rename = "user-ui")]
    UserUi,
    #[serde(rename = "testsuite")]
    Testsuite,
    #[serde(rename = "testtrigger")]
    Testtrigger,
    #[serde(rename = "scheduler")]
    Scheduler,
    #[serde(rename = "testexecution")]
    Testexecution,
    #[serde(rename = "testsuiteexecution")]
    Testsuiteexecution,
}

/// pod request body
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionSlavePodRequest {
    /// pod template extensions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// name of the template resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplateReference")]
    pub pod_template_reference: Option<String>,
    /// pod resources request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TestExecutionStatusLatestExecutionSlavePodRequestResources>,
}

/// pod resources request specification
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionSlavePodRequestResources {
    /// resource request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<TestExecutionStatusLatestExecutionSlavePodRequestResourcesLimits>,
    /// resource request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<TestExecutionStatusLatestExecutionSlavePodRequestResourcesRequests>,
}

/// resource request specification
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionSlavePodRequestResourcesLimits {
    /// requested cpu units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    /// requested memory units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

/// resource request specification
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionSlavePodRequestResourcesRequests {
    /// requested cpu units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    /// requested memory units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionVariables {
    /// variable name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// variable type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// variable string value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// or load it from var source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<TestExecutionStatusLatestExecutionVariablesValueFrom>,
}

/// or load it from var source
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionVariablesValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<TestExecutionStatusLatestExecutionVariablesValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<TestExecutionStatusLatestExecutionVariablesValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<TestExecutionStatusLatestExecutionVariablesValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<TestExecutionStatusLatestExecutionVariablesValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionVariablesValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionVariablesValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionVariablesValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestExecutionStatusLatestExecutionVariablesValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

