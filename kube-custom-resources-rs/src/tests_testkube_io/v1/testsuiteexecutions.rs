// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/kubeshop/testkube-operator/tests.testkube.io/v1/testsuiteexecutions.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// TestSuiteExecutionSpec defines the desired state of TestSuiteExecution
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "tests.testkube.io", version = "v1", kind = "TestSuiteExecution", plural = "testsuiteexecutions")]
#[kube(namespaced)]
#[kube(status = "TestSuiteExecutionStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct TestSuiteExecutionSpec {
    /// test suite execution request body
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionRequest")]
    pub execution_request: Option<TestSuiteExecutionExecutionRequest>,
    #[serde(rename = "testSuite")]
    pub test_suite: TestSuiteExecutionTestSuite,
}

/// test suite execution request body
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionExecutionRequest {
    /// number of tests run in parallel
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "concurrencyLevel")]
    pub concurrency_level: Option<i32>,
    /// test content request body
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentRequest")]
    pub content_request: Option<TestSuiteExecutionExecutionRequestContentRequest>,
    /// cron job template extensions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cronJobTemplate")]
    pub cron_job_template: Option<String>,
    /// whether webhooks should be disabled for this execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableWebhooks")]
    pub disable_webhooks: Option<bool>,
    /// execution labels
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionLabels")]
    pub execution_labels: Option<BTreeMap<String, String>>,
    /// http proxy for executor containers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpProxy")]
    pub http_proxy: Option<String>,
    /// https proxy for executor containers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsProxy")]
    pub https_proxy: Option<String>,
    /// test suite labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// test execution custom name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// test kubernetes namespace (\"testkube\" when not set)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// test suite execution number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i32>,
    /// running context for test or test suite execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runningContext")]
    pub running_context: Option<TestSuiteExecutionExecutionRequestRunningContext>,
    /// secret uuid
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUUID")]
    pub secret_uuid: Option<String>,
    /// whether to start execution sync or async
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sync: Option<bool>,
    /// test suite execution name started the test suite execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteExecutionName")]
    pub test_suite_execution_name: Option<String>,
    /// duration in seconds the test suite may be active, until its stopped
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<BTreeMap<String, TestSuiteExecutionExecutionRequestVariables>>,
}

/// test content request body
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionExecutionRequestContentRequest {
    /// repository parameters for tests in git repositories
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<TestSuiteExecutionExecutionRequestContentRequestRepository>,
}

/// repository parameters for tests in git repositories
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionExecutionRequestContentRequestRepository {
    /// branch/tag name for checkout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,
    /// commit id (sha) for checkout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit: Option<String>,
    /// if needed we can checkout particular path (dir or file) in case of BIG/mono repositories
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// if provided we checkout the whole repository and run test from this directory
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestSuiteExecutionExecutionRequestRunningContext {
    /// Context value depending from its type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<String>,
    /// One of possible context types
    #[serde(rename = "type")]
    pub r#type: TestSuiteExecutionExecutionRequestRunningContextType,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionExecutionRequestRunningContextType {
    #[serde(rename = "user-cli")]
    UserCli,
    #[serde(rename = "user-ui")]
    UserUi,
    #[serde(rename = "testsuite")]
    Testsuite,
    #[serde(rename = "testtrigger")]
    Testtrigger,
    #[serde(rename = "scheduler")]
    Scheduler,
    #[serde(rename = "testexecution")]
    Testexecution,
    #[serde(rename = "testsuiteexecution")]
    Testsuiteexecution,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionExecutionRequestVariables {
    /// variable name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// variable type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// variable string value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// or load it from var source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<TestSuiteExecutionExecutionRequestVariablesValueFrom>,
}

/// or load it from var source
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionExecutionRequestVariablesValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<TestSuiteExecutionExecutionRequestVariablesValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<TestSuiteExecutionExecutionRequestVariablesValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<TestSuiteExecutionExecutionRequestVariablesValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<TestSuiteExecutionExecutionRequestVariablesValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionExecutionRequestVariablesValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionExecutionRequestVariablesValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionExecutionRequestVariablesValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionExecutionRequestVariablesValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionTestSuite {
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// TestSuiteExecutionStatus defines the observed state of TestSuiteExecution
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatus {
    /// test status execution generation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generation: Option<i64>,
    /// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
    /// Important: Run "make" to regenerate code after modifying this file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "latestExecution")]
    pub latest_execution: Option<TestSuiteExecutionStatusLatestExecution>,
}

/// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
/// Important: Run "make" to regenerate code after modifying this file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecution {
    /// whether webhooks should be disabled for this execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableWebhooks")]
    pub disable_webhooks: Option<bool>,
    /// test duration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// test duration in ms
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "durationMs")]
    pub duration_ms: Option<i32>,
    /// test end time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Environment variables passed to executor.
    /// Deprecated: use Basic Variables instead
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub envs: Option<BTreeMap<String, String>>,
    /// batch steps execution results
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executeStepResults")]
    pub execute_step_results: Option<Vec<TestSuiteExecutionStatusLatestExecutionExecuteStepResults>>,
    /// execution id
    pub id: String,
    /// test suite labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// execution name
    pub name: String,
    /// running context for test or test suite execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runningContext")]
    pub running_context: Option<TestSuiteExecutionStatusLatestExecutionRunningContext>,
    /// secret uuid
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretUUID")]
    pub secret_uuid: Option<String>,
    /// test start time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<TestSuiteExecutionStatusLatestExecutionStatus>,
    /// steps execution results
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stepResults")]
    pub step_results: Option<Vec<TestSuiteExecutionStatusLatestExecutionStepResults>>,
    #[serde(rename = "testSuite")]
    pub test_suite: TestSuiteExecutionStatusLatestExecutionTestSuite,
    /// test suite execution name started the test suite execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteExecutionName")]
    pub test_suite_execution_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<BTreeMap<String, TestSuiteExecutionStatusLatestExecutionVariables>>,
}

/// execution result returned from executor
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResults {
    /// step duration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// step end time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub execute: Option<Vec<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecute>>,
    /// step start time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// set of steps run in parallel
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsStep>,
}

/// execution result returned from executor
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecute {
    /// test execution
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub execution: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecution>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteStep>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteTest>,
}

/// test execution
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecution {
    /// additional arguments/flags passed to executor binary
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// usage mode for arguments
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args_mode: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionArgsMode>,
    /// artifact request body with test artifacts
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "artifactRequest")]
    pub artifact_request: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionArtifactRequest>,
    /// minio bucket name to get uploads from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// executor image command
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// shell used in container executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerShell")]
    pub container_shell: Option<String>,
    /// TestContent defines test content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContent>,
    /// whether webhooks should be disabled for this execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableWebhooks")]
    pub disable_webhooks: Option<bool>,
    /// test duration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// test duration in milliseconds
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "durationMs")]
    pub duration_ms: Option<i32>,
    /// test end time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Environment variables passed to executor.
    /// Deprecated: use Basic Variables instead
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub envs: Option<BTreeMap<String, String>>,
    /// execute post run script before scraping (prebuilt executor only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executePostRunScriptBeforeScraping")]
    pub execute_post_run_script_before_scraping: Option<bool>,
    /// namespace for test execution (Pro edition only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionNamespace")]
    pub execution_namespace: Option<String>,
    /// execution result returned from executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionResult")]
    pub execution_result: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResult>,
    /// execution id
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// in case the variables file is too big, it will be uploaded to storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isVariablesFileUploaded")]
    pub is_variables_file_uploaded: Option<bool>,
    /// test and execution labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// execution name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// execution number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i32>,
    /// script to run after test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postRunScript")]
    pub post_run_script: Option<String>,
    /// script to run before test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preRunScript")]
    pub pre_run_script: Option<String>,
    /// running context for test or test suite execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runningContext")]
    pub running_context: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionRunningContext>,
    /// pod request body
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slavePodRequest")]
    pub slave_pod_request: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionSlavePodRequest>,
    /// run scripts using source command (container executor only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceScripts")]
    pub source_scripts: Option<bool>,
    /// test start time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// test execution name started the test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testExecutionName")]
    pub test_execution_name: Option<String>,
    /// unique test name (CRD Test name)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testName")]
    pub test_name: Option<String>,
    /// test namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testNamespace")]
    pub test_namespace: Option<String>,
    /// test secret uuid
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSecretUUID")]
    pub test_secret_uuid: Option<String>,
    /// unique test suite name (CRD Test suite name), if it's run as a part of test suite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteName")]
    pub test_suite_name: Option<String>,
    /// test suite secret uuid, if it's run as a part of test suite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteSecretUUID")]
    pub test_suite_secret_uuid: Option<String>,
    /// test type e.g. postman/collection
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testType")]
    pub test_type: Option<String>,
    /// list of file paths that need to be copied into the test from uploads
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uploads: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<BTreeMap<String, TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariables>>,
    /// variables file content - need to be in format for particular executor (e.g. postman envs file)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "variablesFile")]
    pub variables_file: Option<String>,
}

/// test execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionArgsMode {
    #[serde(rename = "append")]
    Append,
    #[serde(rename = "override")]
    Override,
    #[serde(rename = "replace")]
    Replace,
}

/// artifact request body with test artifacts
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionArtifactRequest {
    /// artifact directories for scraping
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dirs: Option<Vec<String>>,
    /// regexp to filter scraped artifacts, single or comma separated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub masks: Option<Vec<String>>,
    /// don't use a separate folder for execution artifacts
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "omitFolderPerExecution")]
    pub omit_folder_per_execution: Option<bool>,
    /// whether to share volume between pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedBetweenPods")]
    pub shared_between_pods: Option<bool>,
    /// run scraper as pod sidecar container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sidecarScraper")]
    pub sidecar_scraper: Option<bool>,
    /// artifact bucket storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageBucket")]
    pub storage_bucket: Option<String>,
    /// artifact storage class name for container executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// whether to use default storage class name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDefaultStorageClassName")]
    pub use_default_storage_class_name: Option<bool>,
    /// artifact volume mount path for container executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMountPath")]
    pub volume_mount_path: Option<String>,
}

/// TestContent defines test content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContent {
    /// test content body
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// repository of test content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentRepository>,
    /// test type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentType>,
    /// uri of test content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

/// repository of test content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentRepository {
    /// auth type for git requests
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authType")]
    pub auth_type: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentRepositoryAuthType>,
    /// branch/tag name for checkout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,
    /// git auth certificate secret for private repositories
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateSecret")]
    pub certificate_secret: Option<String>,
    /// commit id (sha) for checkout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit: Option<String>,
    /// if needed we can checkout particular path (dir or file) in case of BIG/mono repositories
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Testkube internal reference for secret storage in Kubernetes secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecret")]
    pub token_secret: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentRepositoryTokenSecret>,
    /// VCS repository type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// uri of content file or git directory
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    /// Testkube internal reference for secret storage in Kubernetes secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernameSecret")]
    pub username_secret: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentRepositoryUsernameSecret>,
    /// if provided we checkout the whole repository and run test from this directory
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// repository of test content
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentRepositoryAuthType {
    #[serde(rename = "basic")]
    Basic,
    #[serde(rename = "header")]
    Header,
}

/// Testkube internal reference for secret storage in Kubernetes secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentRepositoryTokenSecret {
    /// object key
    pub key: String,
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Testkube internal reference for secret storage in Kubernetes secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentRepositoryUsernameSecret {
    /// object key
    pub key: String,
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// TestContent defines test content
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionContentType {
    #[serde(rename = "string")]
    String,
    #[serde(rename = "file-uri")]
    FileUri,
    #[serde(rename = "git-file")]
    GitFile,
    #[serde(rename = "git-dir")]
    GitDir,
    #[serde(rename = "git")]
    Git,
}

/// execution result returned from executor
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResult {
    /// error message when status is error, separate to output as output can be partial in case of error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorMessage")]
    pub error_message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reports: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResultReports>,
    pub status: TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResultStatus,
    /// execution steps (for collection of requests)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<Vec<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResultSteps>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResultReports {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub junit: Option<String>,
}

/// execution result returned from executor
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResultStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "passed")]
    Passed,
    #[serde(rename = "failed")]
    Failed,
    #[serde(rename = "aborted")]
    Aborted,
    #[serde(rename = "timeout")]
    Timeout,
}

/// execution result data
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResultSteps {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "assertionResults")]
    pub assertion_results: Option<Vec<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResultStepsAssertionResults>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// step name
    pub name: String,
    /// execution step status
    pub status: String,
}

/// execution result data
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionExecutionResultStepsAssertionResults {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorMessage")]
    pub error_message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionRunningContext {
    /// Context value depending from its type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<String>,
    /// One of possible context types
    #[serde(rename = "type")]
    pub r#type: TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionRunningContextType,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionRunningContextType {
    #[serde(rename = "user-cli")]
    UserCli,
    #[serde(rename = "user-ui")]
    UserUi,
    #[serde(rename = "testsuite")]
    Testsuite,
    #[serde(rename = "testtrigger")]
    Testtrigger,
    #[serde(rename = "scheduler")]
    Scheduler,
    #[serde(rename = "testexecution")]
    Testexecution,
    #[serde(rename = "testsuiteexecution")]
    Testsuiteexecution,
}

/// pod request body
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionSlavePodRequest {
    /// pod template extensions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// name of the template resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplateReference")]
    pub pod_template_reference: Option<String>,
    /// pod resources request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionSlavePodRequestResources>,
}

/// pod resources request specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionSlavePodRequestResources {
    /// resource request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionSlavePodRequestResourcesLimits>,
    /// resource request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionSlavePodRequestResourcesRequests>,
}

/// resource request specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionSlavePodRequestResourcesLimits {
    /// requested cpu units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    /// requested memory units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

/// resource request specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionSlavePodRequestResourcesRequests {
    /// requested cpu units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    /// requested memory units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariables {
    /// variable name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// variable type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// variable string value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// or load it from var source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFrom>,
}

/// or load it from var source
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteExecutionVariablesValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteStep {
    /// delay duration in time units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delay: Option<String>,
    /// object name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsExecuteTest {
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// set of steps run in parallel
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsStep {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub execute: Option<Vec<TestSuiteExecutionStatusLatestExecutionExecuteStepResultsStepExecute>>,
    #[serde(rename = "stopOnFailure")]
    pub stop_on_failure: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionExecuteStepResultsStepExecute {
    /// delay duration in time units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delay: Option<String>,
    /// object name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test: Option<String>,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionRunningContext {
    /// Context value depending from its type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<String>,
    /// One of possible context types
    #[serde(rename = "type")]
    pub r#type: TestSuiteExecutionStatusLatestExecutionRunningContextType,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionRunningContextType {
    #[serde(rename = "user-cli")]
    UserCli,
    #[serde(rename = "user-ui")]
    UserUi,
    #[serde(rename = "testsuite")]
    Testsuite,
    #[serde(rename = "testtrigger")]
    Testtrigger,
    #[serde(rename = "scheduler")]
    Scheduler,
    #[serde(rename = "testexecution")]
    Testexecution,
    #[serde(rename = "testsuiteexecution")]
    Testsuiteexecution,
}

/// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
/// Important: Run "make" to regenerate code after modifying this file
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "passed")]
    Passed,
    #[serde(rename = "failed")]
    Failed,
    #[serde(rename = "aborting")]
    Aborting,
    #[serde(rename = "aborted")]
    Aborted,
    #[serde(rename = "timeout")]
    Timeout,
}

/// execution result returned from executor
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResults {
    /// test execution
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub execution: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecution>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<TestSuiteExecutionStatusLatestExecutionStepResultsStep>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test: Option<TestSuiteExecutionStatusLatestExecutionStepResultsTest>,
}

/// test execution
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecution {
    /// additional arguments/flags passed to executor binary
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// usage mode for arguments
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args_mode: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionArgsMode>,
    /// artifact request body with test artifacts
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "artifactRequest")]
    pub artifact_request: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionArtifactRequest>,
    /// minio bucket name to get uploads from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// executor image command
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// shell used in container executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerShell")]
    pub container_shell: Option<String>,
    /// TestContent defines test content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContent>,
    /// whether webhooks should be disabled for this execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableWebhooks")]
    pub disable_webhooks: Option<bool>,
    /// test duration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// test duration in milliseconds
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "durationMs")]
    pub duration_ms: Option<i32>,
    /// test end time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// Environment variables passed to executor.
    /// Deprecated: use Basic Variables instead
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub envs: Option<BTreeMap<String, String>>,
    /// execute post run script before scraping (prebuilt executor only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executePostRunScriptBeforeScraping")]
    pub execute_post_run_script_before_scraping: Option<bool>,
    /// namespace for test execution (Pro edition only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionNamespace")]
    pub execution_namespace: Option<String>,
    /// execution result returned from executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "executionResult")]
    pub execution_result: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResult>,
    /// execution id
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// in case the variables file is too big, it will be uploaded to storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isVariablesFileUploaded")]
    pub is_variables_file_uploaded: Option<bool>,
    /// test and execution labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// execution name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// execution number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i32>,
    /// script to run after test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postRunScript")]
    pub post_run_script: Option<String>,
    /// script to run before test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preRunScript")]
    pub pre_run_script: Option<String>,
    /// running context for test or test suite execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runningContext")]
    pub running_context: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionRunningContext>,
    /// pod request body
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slavePodRequest")]
    pub slave_pod_request: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionSlavePodRequest>,
    /// run scripts using source command (container executor only)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceScripts")]
    pub source_scripts: Option<bool>,
    /// test start time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// test execution name started the test execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testExecutionName")]
    pub test_execution_name: Option<String>,
    /// unique test name (CRD Test name)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testName")]
    pub test_name: Option<String>,
    /// test namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testNamespace")]
    pub test_namespace: Option<String>,
    /// test secret uuid
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSecretUUID")]
    pub test_secret_uuid: Option<String>,
    /// unique test suite name (CRD Test suite name), if it's run as a part of test suite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteName")]
    pub test_suite_name: Option<String>,
    /// test suite secret uuid, if it's run as a part of test suite
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testSuiteSecretUUID")]
    pub test_suite_secret_uuid: Option<String>,
    /// test type e.g. postman/collection
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "testType")]
    pub test_type: Option<String>,
    /// list of file paths that need to be copied into the test from uploads
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uploads: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<BTreeMap<String, TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariables>>,
    /// variables file content - need to be in format for particular executor (e.g. postman envs file)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "variablesFile")]
    pub variables_file: Option<String>,
}

/// test execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionStepResultsExecutionArgsMode {
    #[serde(rename = "append")]
    Append,
    #[serde(rename = "override")]
    Override,
    #[serde(rename = "replace")]
    Replace,
}

/// artifact request body with test artifacts
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionArtifactRequest {
    /// artifact directories for scraping
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dirs: Option<Vec<String>>,
    /// regexp to filter scraped artifacts, single or comma separated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub masks: Option<Vec<String>>,
    /// don't use a separate folder for execution artifacts
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "omitFolderPerExecution")]
    pub omit_folder_per_execution: Option<bool>,
    /// whether to share volume between pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedBetweenPods")]
    pub shared_between_pods: Option<bool>,
    /// run scraper as pod sidecar container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sidecarScraper")]
    pub sidecar_scraper: Option<bool>,
    /// artifact bucket storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageBucket")]
    pub storage_bucket: Option<String>,
    /// artifact storage class name for container executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// whether to use default storage class name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDefaultStorageClassName")]
    pub use_default_storage_class_name: Option<bool>,
    /// artifact volume mount path for container executor
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMountPath")]
    pub volume_mount_path: Option<String>,
}

/// TestContent defines test content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContent {
    /// test content body
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// repository of test content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentRepository>,
    /// test type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentType>,
    /// uri of test content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
}

/// repository of test content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentRepository {
    /// auth type for git requests
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authType")]
    pub auth_type: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentRepositoryAuthType>,
    /// branch/tag name for checkout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,
    /// git auth certificate secret for private repositories
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateSecret")]
    pub certificate_secret: Option<String>,
    /// commit id (sha) for checkout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commit: Option<String>,
    /// if needed we can checkout particular path (dir or file) in case of BIG/mono repositories
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Testkube internal reference for secret storage in Kubernetes secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecret")]
    pub token_secret: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentRepositoryTokenSecret>,
    /// VCS repository type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// uri of content file or git directory
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<String>,
    /// Testkube internal reference for secret storage in Kubernetes secrets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernameSecret")]
    pub username_secret: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentRepositoryUsernameSecret>,
    /// if provided we checkout the whole repository and run test from this directory
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// repository of test content
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentRepositoryAuthType {
    #[serde(rename = "basic")]
    Basic,
    #[serde(rename = "header")]
    Header,
}

/// Testkube internal reference for secret storage in Kubernetes secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentRepositoryTokenSecret {
    /// object key
    pub key: String,
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Testkube internal reference for secret storage in Kubernetes secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentRepositoryUsernameSecret {
    /// object key
    pub key: String,
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// TestContent defines test content
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionStepResultsExecutionContentType {
    #[serde(rename = "string")]
    String,
    #[serde(rename = "file-uri")]
    FileUri,
    #[serde(rename = "git-file")]
    GitFile,
    #[serde(rename = "git-dir")]
    GitDir,
    #[serde(rename = "git")]
    Git,
}

/// execution result returned from executor
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResult {
    /// error message when status is error, separate to output as output can be partial in case of error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorMessage")]
    pub error_message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reports: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResultReports>,
    pub status: TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResultStatus,
    /// execution steps (for collection of requests)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<Vec<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResultSteps>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResultReports {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub junit: Option<String>,
}

/// execution result returned from executor
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResultStatus {
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "passed")]
    Passed,
    #[serde(rename = "failed")]
    Failed,
    #[serde(rename = "aborted")]
    Aborted,
    #[serde(rename = "timeout")]
    Timeout,
}

/// execution result data
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResultSteps {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "assertionResults")]
    pub assertion_results: Option<Vec<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResultStepsAssertionResults>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    /// step name
    pub name: String,
    /// execution step status
    pub status: String,
}

/// execution result data
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionExecutionResultStepsAssertionResults {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorMessage")]
    pub error_message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionRunningContext {
    /// Context value depending from its type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<String>,
    /// One of possible context types
    #[serde(rename = "type")]
    pub r#type: TestSuiteExecutionStatusLatestExecutionStepResultsExecutionRunningContextType,
}

/// running context for test or test suite execution
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TestSuiteExecutionStatusLatestExecutionStepResultsExecutionRunningContextType {
    #[serde(rename = "user-cli")]
    UserCli,
    #[serde(rename = "user-ui")]
    UserUi,
    #[serde(rename = "testsuite")]
    Testsuite,
    #[serde(rename = "testtrigger")]
    Testtrigger,
    #[serde(rename = "scheduler")]
    Scheduler,
    #[serde(rename = "testexecution")]
    Testexecution,
    #[serde(rename = "testsuiteexecution")]
    Testsuiteexecution,
}

/// pod request body
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionSlavePodRequest {
    /// pod template extensions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// name of the template resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplateReference")]
    pub pod_template_reference: Option<String>,
    /// pod resources request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionSlavePodRequestResources>,
}

/// pod resources request specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionSlavePodRequestResources {
    /// resource request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionSlavePodRequestResourcesLimits>,
    /// resource request specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionSlavePodRequestResourcesRequests>,
}

/// resource request specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionSlavePodRequestResourcesLimits {
    /// requested cpu units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    /// requested memory units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

/// resource request specification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionSlavePodRequestResourcesRequests {
    /// requested cpu units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    /// requested memory units
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariables {
    /// variable name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// variable type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// variable string value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// or load it from var source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFrom>,
}

/// or load it from var source
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsExecutionVariablesValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsStep {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delay: Option<TestSuiteExecutionStatusLatestExecutionStepResultsStepDelay>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub execute: Option<TestSuiteExecutionStatusLatestExecutionStepResultsStepExecute>,
    #[serde(rename = "stopTestOnFailure")]
    pub stop_test_on_failure: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsStepDelay {
    /// delay duration in milliseconds
    pub duration: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsStepExecute {
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionStepResultsTest {
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionTestSuite {
    /// object name
    pub name: String,
    /// object kubernetes namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionVariables {
    /// variable name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// variable type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// variable string value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// or load it from var source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<TestSuiteExecutionStatusLatestExecutionVariablesValueFrom>,
}

/// or load it from var source
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionVariablesValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<TestSuiteExecutionStatusLatestExecutionVariablesValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<TestSuiteExecutionStatusLatestExecutionVariablesValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<TestSuiteExecutionStatusLatestExecutionVariablesValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<TestSuiteExecutionStatusLatestExecutionVariablesValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionVariablesValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionVariablesValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionVariablesValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TestSuiteExecutionStatusLatestExecutionVariablesValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

