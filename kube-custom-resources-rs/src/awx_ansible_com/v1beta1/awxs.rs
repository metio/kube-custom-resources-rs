// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/ansible/awx-operator/awx.ansible.com/v1beta1/awxs.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "awx.ansible.com", version = "v1beta1", kind = "AWX", plural = "awxs")]
#[kube(namespaced)]
#[kube(status = "AWXStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct AWXSpec {
    /// Additional labels defined on the resource, which should be propagated to child resources
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub additional_labels: Option<Vec<String>>,
    /// The admin user email
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin_email: Option<String>,
    /// Secret where the admin password can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin_password_secret: Option<String>,
    /// Username to use for the admin account
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin_user: Option<String>,
    /// If specified, the pod's scheduling constraints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<AWXAffinity>,
    /// Common annotations for both Web and Task deployments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<String>,
    /// An optional configuration to add a prefix in the API URL path
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_urlpattern_prefix: Option<String>,
    /// apiVersion of the deployment type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    /// Should AWX instances be automatically upgraded when operator gets upgraded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auto_upgrade: Option<bool>,
    /// Secret where the broadcast websocket secret can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub broadcast_websocket_secret: Option<String>,
    /// Secret where can be found the trusted Certificate Authority Bundle
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bundle_cacert_secret: Option<String>,
    /// Path where the trusted CA bundle is available
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_trust_bundle: Option<String>,
    /// Registry path to the Execution Environment container image to use on control plane pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub control_plane_ee_image: Option<String>,
    /// Assign a preexisting priority class to the control plane pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub control_plane_priority_class: Option<String>,
    /// Whether or not to preload data upon instance creation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create_preload_data: Option<bool>,
    /// Set csrf cookie secure mode for web
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csrf_cookie_secure: Option<String>,
    /// Name of the deployment type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment_type: Option<String>,
    /// If the deployment should be done in development mode
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub development_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_extra_env: Option<String>,
    /// Specify volume mounts to be added to Execution container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_extra_volume_mounts: Option<String>,
    /// Registry path to the Execution Environment container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_images: Option<Vec<AWXEeImages>>,
    /// Secret where pull credentials for registered ees can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_pull_credentials_secret: Option<String>,
    /// Resource requirements for the ee container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ee_resource_requirements: Option<AWXEeResourceRequirements>,
    /// Extra settings to specify for AWX
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_settings: Option<Vec<AWXExtraSettings>>,
    /// Extra ConfigMaps or Secrets of settings files to specify for AWX
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_settings_files: Option<AWXExtraSettingsFiles>,
    /// Specify extra volumes to add to the application pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_volumes: Option<String>,
    /// Whether or not to remove secrets upon instance removal
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub garbage_collect_secrets: Option<bool>,
    /// HostAliases for app containers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host_aliases: Option<Vec<AWXHostAliases>>,
    /// (Deprecated) The hostname of the instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// Registry path to the application container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// The image pull policy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_pull_policy: Option<AWXImagePullPolicy>,
    /// (Deprecated) Image pull secret for app and database containers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_pull_secret: Option<String>,
    /// Image pull secrets for app and database containers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_pull_secrets: Option<Vec<String>>,
    /// Application container image version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_version: Option<String>,
    /// Annotations to add to the Ingress Controller
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_annotations: Option<String>,
    /// The Ingress API version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_api_version: Option<String>,
    /// The name of ingress class to use instead of the cluster default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_class_name: Option<String>,
    /// Special configuration for specific Ingress Controllers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_controller: Option<String>,
    /// Ingress hostnames of the instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_hosts: Option<Vec<AWXIngressHosts>>,
    /// The ingress path used to reach the deployed service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_path: Option<String>,
    /// The ingress path type for the deployed service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_path_type: Option<String>,
    /// (Deprecated) Secret where the Ingress TLS secret can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_tls_secret: Option<String>,
    /// The ingress type to use to reach the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_type: Option<AWXIngressType>,
    /// Extra commands for the init container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_extra_commands: Option<String>,
    /// Specify volume mounts to be added to the init container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_extra_volume_mounts: Option<String>,
    /// Registry path to the init container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_image: Option<String>,
    /// Init container image version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_image_version: Option<String>,
    /// Resource requirements for the init container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_container_resource_requirements: Option<AWXInitContainerResourceRequirements>,
    /// Registry path to the init projects container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub init_projects_container_image: Option<String>,
    /// Disable web container's nginx ipv6 listener
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ipv6_disabled: Option<bool>,
    /// Kind of the deployment type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Secret where can be found the LDAP trusted Certificate Authority Bundle
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap_cacert_secret: Option<String>,
    /// Secret where can be found the LDAP bind password
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap_password_secret: Option<String>,
    /// Class of LoadBalancer to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loadbalancer_class: Option<String>,
    /// Assign LoadBalancer IP address
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loadbalancer_ip: Option<String>,
    /// Port to use for the loadbalancer
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loadbalancer_port: Option<i64>,
    /// Protocol to use for the loadbalancer
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loadbalancer_protocol: Option<AWXLoadbalancerProtocol>,
    /// Metrics-Utility ConfigMap
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_configmap: Option<String>,
    /// Enable metrics utility shipping to Red Hat Hybrid Cloud Console
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_console_enabled: Option<bool>,
    /// Metrics-Utility Gather Data CronJob Schedule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_cronjob_gather_schedule: Option<String>,
    /// Metrics-Utility Report CronJob Schedule
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_cronjob_report_schedule: Option<String>,
    /// Enable metrics utility
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_enabled: Option<bool>,
    /// Metrics-Utility Image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_image: Option<String>,
    /// Metrics-Utility Image PullPolicy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_image_pull_policy: Option<String>,
    /// Metrics-Utility Image Version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_image_version: Option<String>,
    /// Metrics-Utility PVC Claim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_pvc_claim: Option<String>,
    /// Metrics-Utility PVC Claim Size
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_pvc_claim_size: Option<String>,
    /// Metrics-Utility PVC Claim Storage Class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_pvc_claim_storage_class: Option<String>,
    /// Metrics-Utility Secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_secret: Option<String>,
    /// Metrics-Utility Ship Target
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_utility_ship_target: Option<String>,
    /// Set the socket listen queue size for nginx (defaults to same as uwsgi)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nginx_listen_queue_size: Option<i64>,
    /// Set the number of connections per worker for nginx
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nginx_worker_connections: Option<i64>,
    /// Set the CPU affinity for nginx workers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nginx_worker_cpu_affinity: Option<String>,
    /// Set the number of workers for nginx
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nginx_worker_processes: Option<i64>,
    /// Configure no_log for no_log tasks
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub no_log: Option<bool>,
    /// nodeSelector for the pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_selector: Option<String>,
    /// Port to use for the nodeport
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nodeport_port: Option<i64>,
    /// Secret where the old database configuration can be found for data migration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub old_postgres_configuration_secret: Option<String>,
    /// Annotations to add to the Postgres deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_annotations: Option<String>,
    /// Secret where the database configuration can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_configuration_secret: Option<String>,
    /// Sets permissions on the /var/lib/pgdata/data for postgres container using an init container (not Openshift)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_data_volume_init: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_extra_args: Option<Vec<String>>,
    /// Specify volume mounts to be added to Postgres container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_extra_volume_mounts: Option<String>,
    /// Specify extra volumes to add to the application pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_extra_volumes: Option<String>,
    /// Registry path to the PostgreSQL container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_image: Option<String>,
    /// PostgreSQL container image version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_image_version: Option<String>,
    /// Customize the postgres init container commands (Non Openshift)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_init_container_commands: Option<String>,
    /// (Deprecated, use postgres_resource_requirements parameter) Resource requirements for the postgres init container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_init_container_resource_requirements: Option<AWXPostgresInitContainerResourceRequirements>,
    /// Specify whether or not to keep the old PVC after PostgreSQL upgrades
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keep_pvc_after_upgrade: Option<bool>,
    /// Controls whether client-side TCP keepalives are used for Postgres connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keepalives: Option<bool>,
    /// Controls the number of TCP keepalives that can be lost before the client's connection to the server is considered dead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keepalives_count: Option<i32>,
    /// Controls the number of seconds of inactivity after which TCP should send a keepalive message to the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keepalives_idle: Option<i32>,
    /// Controls the number of seconds after which a TCP keepalive message that is not acknowledged by the server should be retransmitted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_keepalives_interval: Option<i32>,
    /// Label selector used to identify postgres pod for data migration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_label_selector: Option<String>,
    /// Assign a preexisting priority class to the postgres pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_priority_class: Option<String>,
    /// Resource requirements for the PostgreSQL container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_resource_requirements: Option<AWXPostgresResourceRequirements>,
    /// Key/values that will be set under the pod-level securityContext field
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_security_context_settings: Option<BTreeMap<String, serde_json::Value>>,
    /// nodeSelector for the Postgres pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_selector: Option<String>,
    /// Storage class to use for the PostgreSQL PVC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_storage_class: Option<String>,
    /// Storage requirements for the PostgreSQL container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_storage_requirements: Option<AWXPostgresStorageRequirements>,
    /// node tolerations for the Postgres pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_tolerations: Option<String>,
    /// PersistentVolumeClaim to mount /var/lib/projects directory
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_existing_claim: Option<String>,
    /// Whether or not the /var/lib/projects directory will be persistent
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_persistence: Option<bool>,
    /// AccessMode for the /var/lib/projects PersistentVolumeClaim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_storage_access_mode: Option<String>,
    /// Storage class for the /var/lib/projects PersistentVolumeClaim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_storage_class: Option<String>,
    /// Size for the /var/lib/projects PersistentVolumeClaim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_storage_size: Option<String>,
    /// Using existing PersistentVolumeClaim
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projects_use_existing_claim: Option<AWXProjectsUseExistingClaim>,
    /// Set log level of receptor service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub receptor_log_level: Option<String>,
    /// Redis container capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis_capabilities: Option<Vec<String>>,
    /// Registry path to the redis container to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis_image: Option<String>,
    /// Redis container image version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis_image_version: Option<String>,
    /// Resource requirements for the redis container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis_resource_requirements: Option<AWXRedisResourceRequirements>,
    /// Number of instance replicas
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// The route API version to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route_api_version: Option<String>,
    /// The DNS to use to points to the instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route_host: Option<String>,
    /// Secret where the TLS related credentials are stored
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route_tls_secret: Option<String>,
    /// The secure TLS termination mechanism to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route_tls_termination_mechanism: Option<AWXRouteTlsTerminationMechanism>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_extra_env: Option<String>,
    /// Specify volume mounts to be added to the Rsyslog container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_extra_volume_mounts: Option<String>,
    /// Resource requirements for the rsyslog container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rsyslog_resource_requirements: Option<AWXRsyslogResourceRequirements>,
    /// Secret where the secret key can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_key_secret: Option<String>,
    /// Key/values that will be set under the pod-level securityContext field
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_context_settings: Option<BTreeMap<String, serde_json::Value>>,
    /// ServiceAccount annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_account_annotations: Option<String>,
    /// Annotations to add to the service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_annotations: Option<String>,
    /// Additional labels to apply to the service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_labels: Option<String>,
    /// The service type to be used on the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_type: Option<AWXServiceType>,
    /// Set session cookie secure mode for web
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_cookie_secure: Option<String>,
    /// Maintain some of the recommended `app.kubernetes.io/*` labels on the resource (self)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set_self_labels: Option<bool>,
    /// If specified, the pod's scheduling constraints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_affinity: Option<AWXTaskAffinity>,
    /// Task deployment annotations. This will override the general annotations parameter for the Task deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_annotations: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_extra_env: Option<String>,
    /// Specify volume mounts to be added to Task container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_extra_volume_mounts: Option<String>,
    /// Number of consecutive failure events to identify failure of task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_liveness_failure_threshold: Option<i32>,
    /// Initial delay before starting liveness checks on task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_liveness_initial_delay: Option<i32>,
    /// Time period in seconds between each liveness check for the task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_liveness_period: Option<i32>,
    /// Number of seconds to wait for a probe response from task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_liveness_timeout: Option<i32>,
    /// Enables operator control of replicas count for the task deployment when set to 'true'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_manage_replicas: Option<bool>,
    /// nodeSelector for the task pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_node_selector: Option<String>,
    /// If a privileged security context should be enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_privileged: Option<bool>,
    /// Number of consecutive failure events to identify failure of task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_readiness_failure_threshold: Option<i32>,
    /// Initial delay before starting readiness checks on task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_readiness_initial_delay: Option<i32>,
    /// Time period in seconds between each readiness check for the task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_readiness_period: Option<i32>,
    /// Number of seconds to wait for a probe response from task pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_readiness_timeout: Option<i32>,
    /// Number of task instance replicas
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_replicas: Option<i32>,
    /// Resource requirements for the task container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_resource_requirements: Option<AWXTaskResourceRequirements>,
    /// node tolerations for the task pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_tolerations: Option<String>,
    /// topology rule(s) for the task pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub task_topology_spread_constraints: Option<String>,
    /// Optional duration in seconds pods needs to terminate gracefully
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub termination_grace_period_seconds: Option<i32>,
    /// node tolerations for the pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<String>,
    /// topology rule(s) for the pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topology_spread_constraints: Option<String>,
    /// Set the socket listen queue size for uwsgi
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uwsgi_listen_queue_size: Option<i64>,
    /// Set the number of uwsgi processes to run in a web container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uwsgi_processes: Option<i64>,
    /// If specified, the pod's scheduling constraints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_affinity: Option<AWXWebAffinity>,
    /// Web deployment annotations. This will override the general annotations parameter for the Web deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_annotations: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_extra_env: Option<String>,
    /// Specify volume mounts to be added to the Web container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_extra_volume_mounts: Option<String>,
    /// Number of consecutive failure events to identify failure of web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_liveness_failure_threshold: Option<i32>,
    /// Initial delay before starting liveness checks on web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_liveness_initial_delay: Option<i32>,
    /// Time period in seconds between each liveness check for the web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_liveness_period: Option<i32>,
    /// Number of seconds to wait for a probe response from web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_liveness_timeout: Option<i32>,
    /// Enables operator control of replicas count for the web deployment when set to 'true'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_manage_replicas: Option<bool>,
    /// nodeSelector for the web pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_node_selector: Option<String>,
    /// Number of consecutive failure events to identify failure of web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_readiness_failure_threshold: Option<i32>,
    /// Initial delay before starting readiness checks on web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_readiness_initial_delay: Option<i32>,
    /// Time period in seconds between each readiness check for the web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_readiness_period: Option<i32>,
    /// Number of seconds to wait for a probe response from web pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_readiness_timeout: Option<i32>,
    /// Number of web instance replicas
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_replicas: Option<i32>,
    /// Resource requirements for the web container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_resource_requirements: Option<AWXWebResourceRequirements>,
    /// node tolerations for the web pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_tolerations: Option<String>,
    /// topology rule(s) for the web pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_topology_spread_constraints: Option<String>,
}

/// If specified, the pod's scheduling constraints
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<AWXAffinityNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<AWXAffinityPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<AWXAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AWXAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<AWXAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: AWXAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AWXAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<AWXAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AWXAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXEeImages {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Resource requirements for the ee container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXEeResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AWXEeResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AWXEeResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXEeResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXEeResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXExtraSettings {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub setting: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Extra ConfigMaps or Secrets of settings files to specify for AWX
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXExtraSettingsFiles {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configmaps: Option<Vec<AWXExtraSettingsFilesConfigmaps>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<AWXExtraSettingsFilesSecrets>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXExtraSettingsFilesConfigmaps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXExtraSettingsFilesSecrets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXHostAliases {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AWXImagePullPolicy {
    Always,
    #[serde(rename = "always")]
    AlwaysX,
    Never,
    #[serde(rename = "never")]
    NeverX,
    IfNotPresent,
    #[serde(rename = "ifnotpresent")]
    Ifnotpresent,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXIngressHosts {
    /// Hostname of the instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// Secret where the Ingress TLS secret can be found
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_secret: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AWXIngressType {
    #[serde(rename = "none")]
    None,
    Ingress,
    #[serde(rename = "ingress")]
    IngressX,
    Route,
    #[serde(rename = "route")]
    RouteX,
}

/// Resource requirements for the init container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXInitContainerResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AWXInitContainerResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AWXInitContainerResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXInitContainerResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXInitContainerResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AWXLoadbalancerProtocol {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

/// (Deprecated, use postgres_resource_requirements parameter) Resource requirements for the postgres init container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXPostgresInitContainerResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AWXPostgresInitContainerResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AWXPostgresInitContainerResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXPostgresInitContainerResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXPostgresInitContainerResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

/// Resource requirements for the PostgreSQL container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXPostgresResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AWXPostgresResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AWXPostgresResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXPostgresResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXPostgresResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

/// Storage requirements for the PostgreSQL container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXPostgresStorageRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AWXPostgresStorageRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AWXPostgresStorageRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXPostgresStorageRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXPostgresStorageRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AWXProjectsUseExistingClaim {
    #[serde(rename = "_Yes_")]
    Yes,
    #[serde(rename = "_No_")]
    No,
}

/// Resource requirements for the redis container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXRedisResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AWXRedisResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AWXRedisResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXRedisResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXRedisResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AWXRouteTlsTerminationMechanism {
    Edge,
    #[serde(rename = "edge")]
    EdgeX,
    Passthrough,
    #[serde(rename = "passthrough")]
    PassthroughX,
}

/// Resource requirements for the rsyslog container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXRsyslogResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AWXRsyslogResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AWXRsyslogResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXRsyslogResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXRsyslogResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AWXServiceType {
    LoadBalancer,
    #[serde(rename = "loadbalancer")]
    Loadbalancer,
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    #[serde(rename = "clusterip")]
    Clusterip,
    NodePort,
    #[serde(rename = "nodeport")]
    Nodeport,
}

/// If specified, the pod's scheduling constraints
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<AWXTaskAffinityNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<AWXTaskAffinityPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<AWXTaskAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AWXTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<AWXTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: AWXTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AWXTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<AWXTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AWXTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Resource requirements for the task container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AWXTaskResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AWXTaskResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXTaskResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

/// If specified, the pod's scheduling constraints
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<AWXWebAffinityNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<AWXWebAffinityPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<AWXWebAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AWXWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<AWXWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: AWXWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AWXWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<AWXWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<AWXWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Resource requirements for the web container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebResourceRequirements {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<AWXWebResourceRequirementsLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<AWXWebResourceRequirementsRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebResourceRequirementsLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXWebResourceRequirementsRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeral-storage")]
    pub ephemeral_storage: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXStatus {
    /// URL to access the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "URL")]
    pub url: Option<String>,
    /// Admin password secret name of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminPasswordSecret")]
    pub admin_password_secret: Option<String>,
    /// Admin user of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminUser")]
    pub admin_user: Option<String>,
    /// Broadcast websocket secret name of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "broadcastWebsocketSecret")]
    pub broadcast_websocket_secret: Option<String>,
    /// The resulting conditions when a Service Telemetry is instantiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<AWXStatusConditions>>,
    /// URL of the image used for the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// The secret used for migrating an old instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "migratedFromSecret")]
    pub migrated_from_secret: Option<String>,
    /// Postgres Configuration secret name of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postgresConfigurationSecret")]
    pub postgres_configuration_secret: Option<String>,
    /// Secret key secret name of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeySecret")]
    pub secret_key_secret: Option<String>,
    /// Status to indicate that the database has been upgraded to the version in the status
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upgradedPostgresVersion")]
    pub upgraded_postgres_version: Option<String>,
    /// Version of the deployed instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AWXStatusConditions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

