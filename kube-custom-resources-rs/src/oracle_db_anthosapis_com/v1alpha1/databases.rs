// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/GoogleCloudPlatform/elcarro-oracle-operator/oracle.db.anthosapis.com/v1alpha1/databases.yaml --derive=PartialEq
// kopium version: 0.16.5

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// DatabaseSpec defines the desired state of Database.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "oracle.db.anthosapis.com", version = "v1alpha1", kind = "Database", plural = "databases")]
#[kube(namespaced)]
#[kube(status = "DatabaseStatus")]
#[kube(schema = "disabled")]
pub struct DatabaseSpec {
    /// AdminPasswordGsmSecretRef is a reference to the secret object containing sensitive information to pass to config agent. This field is optional, and may be empty if plaintext password is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminPasswordGsmSecretRef")]
    pub admin_password_gsm_secret_ref: Option<DatabaseAdminPasswordGsmSecretRef>,
    /// AdminPassword is the password for the sys admin of the database.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admin_password: Option<String>,
    /// Name of the instance that the database belongs to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,
    /// Name of the database.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Users specifies an optional list of users to be created in this database.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<Vec<DatabaseUsers>>,
}

/// AdminPasswordGsmSecretRef is a reference to the secret object containing sensitive information to pass to config agent. This field is optional, and may be empty if plaintext password is used.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DatabaseAdminPasswordGsmSecretRef {
    /// ProjectId identifies the project where the secret resource is.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// SecretId identifies the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretId")]
    pub secret_id: Option<String>,
    /// Version is the version of the secret. If "latest" is specified, underlying the latest SecretId is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// UserSpec defines the desired state of the Database Users.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DatabaseUsers {
    /// A reference to a GSM secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gsmSecretRef")]
    pub gsm_secret_ref: Option<DatabaseUsersGsmSecretRef>,
    /// Name of the User.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Plaintext password.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// Privileges specifies an optional list of privileges to grant to the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileges: Option<Vec<String>>,
    /// A reference to a k8s secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<DatabaseUsersSecretRef>,
}

/// A reference to a GSM secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DatabaseUsersGsmSecretRef {
    /// ProjectId identifies the project where the secret resource is.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectId")]
    pub project_id: Option<String>,
    /// SecretId identifies the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretId")]
    pub secret_id: Option<String>,
    /// Version is the version of the secret. If "latest" is specified, underlying the latest SecretId is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// A reference to a k8s secret.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DatabaseUsersSecretRef {
    /// name is unique within a namespace to reference a secret resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// namespace defines the space within which the secret name must be unique.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// DatabaseStatus defines the observed state of Database.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DatabaseStatus {
    /// UserResourceVersions is a map of username to user resource version (plaintext or GSM). For GSM Resource version, use format: "projects/{ProjectId}/secrets/{SecretId}/versions/{Version}".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "UserResourceVersions")]
    pub user_resource_versions: Option<BTreeMap<String, String>>,
    /// Conditions represents the latest available observations of the Database's current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<DatabaseStatusConditions>>,
    /// IsChangeApplied indicates whether database changes have been applied
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isChangeApplied")]
    pub is_change_applied: Option<String>,
    /// ObservedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// Phase is a summary of the current state of the Database.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
    /// List of user names.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usernames: Option<Vec<String>>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DatabaseStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: DatabaseStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum DatabaseStatusConditionsStatus {
    True,
    False,
    Unknown,
}

