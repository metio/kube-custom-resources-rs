// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/GoogleCloudPlatform/elcarro-oracle-operator/oracle.db.anthosapis.com/v1alpha1/configs.yaml --derive=Default --derive=PartialEq
// kopium version: 0.17.0

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// ConfigSpec defines the desired state of Config.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "oracle.db.anthosapis.com", version = "v1alpha1", kind = "Config", plural = "configs")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
pub struct ConfigSpec {
    /// Disks slice describes at minimum two disks: data and log (archive log), and optionally a backup disk.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disks: Option<Vec<ConfigDisks>>,
    /// HostAntiAffinityNamespaces is an optional list of namespaces that need to be included in anti-affinity by hostname rule. The effect of the rule is forbidding scheduling a database pod in the current namespace on a host that already runs a database pod in any of the listed namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostAntiAffinityNamespaces")]
    pub host_anti_affinity_namespaces: Option<Vec<String>>,
    /// Service agent and other data plane agent images. This is an optional map that allows a customer to specify agent images different from those chosen/provided by the operator by default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub images: Option<BTreeMap<String, String>>,
    /// Log Levels for the various components. This is an optional map for component -> log level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<BTreeMap<String, String>>,
    /// Deployment platform. Presently supported values are: GCP (default), BareMetal, Minikube and Kind.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub platform: Option<ConfigPlatform>,
    /// Storage class to use for dynamic provisioning. This value varies depending on a platform. For GCP (the default), it is "standard-rwo".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClass")]
    pub storage_class: Option<String>,
    /// Volume Snapshot class to use for storage snapshots. This value varies from platform to platform. For GCP (the default), it is "csi-gce-pd-snapshot-class".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeSnapshotClass")]
    pub volume_snapshot_class: Option<String>,
}

/// DiskSpec defines the desired state of a disk. (the structure is deliberately designed to be flexible, as a slice, so that if we change a disk layout for different hosting platforms, the model can be also adjusted to reflect that).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ConfigDisks {
    /// AccessModes contains the desired access modes the volume should have.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// A map of string keys and values to be stored in the annotations of the PVC. These can be read and write by external tools through Kubernetes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Name of a disk.
    pub name: String,
    /// A label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ConfigDisksSelector>,
    /// Disk size. If not specified, the defaults are: DataDisk:"100Gi", LogDisk:"150Gi",BackupDisk:"100Gi"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<IntOrString>,
    /// StorageClass points to a particular CSI driver and is used for disk provisioning.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClass")]
    pub storage_class: Option<String>,
    /// VolumeName is the binding reference to the PersistentVolume tied to this disk.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// A label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ConfigDisksSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ConfigDisksSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ConfigDisksSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ConfigSpec defines the desired state of Config.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ConfigPlatform {
    #[serde(rename = "GCP")]
    Gcp,
    BareMetal,
    Minikube,
    Kind,
}

/// ConfigStatus defines the observed state of Config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ConfigStatus {
}

