// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/chaos-mesh/chaos-mesh/chaos-mesh.org/v1alpha1/physicalmachinechaos.yaml --derive=PartialEq
// kopium version: 0.16.2

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// Spec defines the behavior of a physical machine chaos experiment
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "chaos-mesh.org", version = "v1alpha1", kind = "PhysicalMachineChaos", plural = "physicalmachinechaos")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
pub struct PhysicalMachineChaosSpec {
    /// the subAction, generate automatically
    pub action: PhysicalMachineChaosAction,
    /// DEPRECATED: Use Selector instead. Only one of Address and Selector could be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clock: Option<PhysicalMachineChaosClock>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disk-fill")]
    pub disk_fill: Option<PhysicalMachineChaosDiskFill>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disk-read-payload")]
    pub disk_read_payload: Option<PhysicalMachineChaosDiskReadPayload>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disk-write-payload")]
    pub disk_write_payload: Option<PhysicalMachineChaosDiskWritePayload>,
    /// Duration represents the duration of the chaos action
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-append")]
    pub file_append: Option<PhysicalMachineChaosFileAppend>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-create")]
    pub file_create: Option<PhysicalMachineChaosFileCreate>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-delete")]
    pub file_delete: Option<PhysicalMachineChaosFileDelete>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-modify")]
    pub file_modify: Option<PhysicalMachineChaosFileModify>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-rename")]
    pub file_rename: Option<PhysicalMachineChaosFileRename>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-replace")]
    pub file_replace: Option<PhysicalMachineChaosFileReplace>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http-abort")]
    pub http_abort: Option<PhysicalMachineChaosHttpAbort>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http-config")]
    pub http_config: Option<PhysicalMachineChaosHttpConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http-delay")]
    pub http_delay: Option<PhysicalMachineChaosHttpDelay>,
    /// used for HTTP request, now only support GET
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "http-request")]
    pub http_request: Option<PhysicalMachineChaosHttpRequest>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-exception")]
    pub jvm_exception: Option<PhysicalMachineChaosJvmException>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-gc")]
    pub jvm_gc: Option<PhysicalMachineChaosJvmGc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-latency")]
    pub jvm_latency: Option<PhysicalMachineChaosJvmLatency>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-mysql")]
    pub jvm_mysql: Option<PhysicalMachineChaosJvmMysql>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-return")]
    pub jvm_return: Option<PhysicalMachineChaosJvmReturn>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-rule-data")]
    pub jvm_rule_data: Option<PhysicalMachineChaosJvmRuleData>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jvm-stress")]
    pub jvm_stress: Option<PhysicalMachineChaosJvmStress>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kafka-fill")]
    pub kafka_fill: Option<PhysicalMachineChaosKafkaFill>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kafka-flood")]
    pub kafka_flood: Option<PhysicalMachineChaosKafkaFlood>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kafka-io")]
    pub kafka_io: Option<PhysicalMachineChaosKafkaIo>,
    /// Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent
    pub mode: PhysicalMachineChaosMode,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-bandwidth")]
    pub network_bandwidth: Option<PhysicalMachineChaosNetworkBandwidth>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-corrupt")]
    pub network_corrupt: Option<PhysicalMachineChaosNetworkCorrupt>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-delay")]
    pub network_delay: Option<PhysicalMachineChaosNetworkDelay>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-dns")]
    pub network_dns: Option<PhysicalMachineChaosNetworkDns>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-down")]
    pub network_down: Option<PhysicalMachineChaosNetworkDown>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-duplicate")]
    pub network_duplicate: Option<PhysicalMachineChaosNetworkDuplicate>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-flood")]
    pub network_flood: Option<PhysicalMachineChaosNetworkFlood>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-loss")]
    pub network_loss: Option<PhysicalMachineChaosNetworkLoss>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "network-partition")]
    pub network_partition: Option<PhysicalMachineChaosNetworkPartition>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub process: Option<PhysicalMachineChaosProcess>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-cacheLimit")]
    pub redis_cache_limit: Option<PhysicalMachineChaosRedisCacheLimit>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-expiration")]
    pub redis_expiration: Option<PhysicalMachineChaosRedisExpiration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-penetration")]
    pub redis_penetration: Option<PhysicalMachineChaosRedisPenetration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-restart")]
    pub redis_restart: Option<PhysicalMachineChaosRedisRestart>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redis-stop")]
    pub redis_stop: Option<PhysicalMachineChaosRedisStop>,
    /// RemoteCluster represents the remote cluster where the chaos will be deployed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteCluster")]
    pub remote_cluster: Option<String>,
    /// Selector is used to select physical machines that are used to inject chaos action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PhysicalMachineChaosSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stress-cpu")]
    pub stress_cpu: Option<PhysicalMachineChaosStressCpu>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stress-mem")]
    pub stress_mem: Option<PhysicalMachineChaosStressMem>,
    /// the experiment ID
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user_defined: Option<PhysicalMachineChaosUserDefined>,
    /// Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of physical machines to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of physical machines the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vm: Option<PhysicalMachineChaosVm>,
}

/// Spec defines the behavior of a physical machine chaos experiment
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PhysicalMachineChaosAction {
    #[serde(rename = "stress-cpu")]
    StressCpu,
    #[serde(rename = "stress-mem")]
    StressMem,
    #[serde(rename = "disk-read-payload")]
    DiskReadPayload,
    #[serde(rename = "disk-write-payload")]
    DiskWritePayload,
    #[serde(rename = "disk-fill")]
    DiskFill,
    #[serde(rename = "network-corrupt")]
    NetworkCorrupt,
    #[serde(rename = "network-duplicate")]
    NetworkDuplicate,
    #[serde(rename = "network-loss")]
    NetworkLoss,
    #[serde(rename = "network-delay")]
    NetworkDelay,
    #[serde(rename = "network-partition")]
    NetworkPartition,
    #[serde(rename = "network-dns")]
    NetworkDns,
    #[serde(rename = "network-bandwidth")]
    NetworkBandwidth,
    #[serde(rename = "network-flood")]
    NetworkFlood,
    #[serde(rename = "network-down")]
    NetworkDown,
    #[serde(rename = "process")]
    Process,
    #[serde(rename = "jvm-exception")]
    JvmException,
    #[serde(rename = "jvm-gc")]
    JvmGc,
    #[serde(rename = "jvm-latency")]
    JvmLatency,
    #[serde(rename = "jvm-return")]
    JvmReturn,
    #[serde(rename = "jvm-stress")]
    JvmStress,
    #[serde(rename = "jvm-rule-data")]
    JvmRuleData,
    #[serde(rename = "jvm-mysql")]
    JvmMysql,
    #[serde(rename = "clock")]
    Clock,
    #[serde(rename = "redis-expiration")]
    RedisExpiration,
    #[serde(rename = "redis-penetration")]
    RedisPenetration,
    #[serde(rename = "redis-cacheLimit")]
    RedisCacheLimit,
    #[serde(rename = "redis-restart")]
    RedisRestart,
    #[serde(rename = "redis-stop")]
    RedisStop,
    #[serde(rename = "kafka-fill")]
    KafkaFill,
    #[serde(rename = "kafka-flood")]
    KafkaFlood,
    #[serde(rename = "kafka-io")]
    KafkaIo,
    #[serde(rename = "file-create")]
    FileCreate,
    #[serde(rename = "file-modify")]
    FileModify,
    #[serde(rename = "file-delete")]
    FileDelete,
    #[serde(rename = "file-rename")]
    FileRename,
    #[serde(rename = "file-append")]
    FileAppend,
    #[serde(rename = "file-replace")]
    FileReplace,
    #[serde(rename = "vm")]
    Vm,
    #[serde(rename = "user_defined")]
    UserDefined,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosClock {
    /// the identifier of the particular clock on which to act. More clock description in linux kernel can be found in man page of clock_getres, clock_gettime, clock_settime. Muti clock ids should be split with ","
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clock-ids-slice")]
    pub clock_ids_slice: Option<String>,
    /// the pid of target program.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// specifies the length of time offset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "time-offset")]
    pub time_offset: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosDiskFill {
    /// fill disk by fallocate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fill-by-fallocate")]
    pub fill_by_fallocate: Option<bool>,
    /// specifies the location to fill data in. if path not provided, payload will read/write from/into a temp file, temp file will be deleted after writing
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// specifies how many units of data will write into the file path. support unit: c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, GB=1000*1000*1000, G=1024*1024*1024 BYTES. example : 1M | 512kB
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosDiskReadPayload {
    /// specifies the location to fill data in. if path not provided, payload will read/write from/into a temp file, temp file will be deleted after writing
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// specifies the number of process work on writing, default 1, only 1-255 is valid value
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payload-process-num")]
    pub payload_process_num: Option<i64>,
    /// specifies how many units of data will write into the file path. support unit: c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, GB=1000*1000*1000, G=1024*1024*1024 BYTES. example : 1M | 512kB
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosDiskWritePayload {
    /// specifies the location to fill data in. if path not provided, payload will read/write from/into a temp file, temp file will be deleted after writing
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// specifies the number of process work on writing, default 1, only 1-255 is valid value
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payload-process-num")]
    pub payload_process_num: Option<i64>,
    /// specifies how many units of data will write into the file path. support unit: c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, GB=1000*1000*1000, G=1024*1024*1024 BYTES. example : 1M | 512kB
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosFileAppend {
    /// Count is the number of times to append the data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// Data is the data for append.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosFileCreate {
    /// DirName is the directory name to create or delete.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dir-name")]
    pub dir_name: Option<String>,
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosFileDelete {
    /// DirName is the directory name to create or delete.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dir-name")]
    pub dir_name: Option<String>,
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosFileModify {
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
    /// Privilege is the file privilege to be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privilege: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosFileRename {
    /// DestFile is the name to be renamed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dest-file")]
    pub dest_file: Option<String>,
    /// SourceFile is the name need to be renamed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-file")]
    pub source_file: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosFileReplace {
    /// DestStr is the destination string of the file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dest-string")]
    pub dest_string: Option<String>,
    /// FileName is the name of the file to be created, modified, deleted, renamed, or appended.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "file-name")]
    pub file_name: Option<String>,
    /// Line is the line number of the file to be replaced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub line: Option<i64>,
    /// OriginStr is the origin string of the file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "origin-string")]
    pub origin_string: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosHttpAbort {
    /// Code is a rule to select target by http status code in response
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// HTTP method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Match path of Uri with wildcard matches
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The TCP port that the target service listens on
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Composed with one of the port of HTTP connection, we will only attack HTTP connection with port inside proxy_ports
    pub proxy_ports: Vec<i64>,
    /// HTTP target: Request or Response
    pub target: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosHttpConfig {
    /// The config file path
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub file_path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosHttpDelay {
    /// Code is a rule to select target by http status code in response
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// Delay represents the delay of the target request/response
    pub delay: String,
    /// HTTP method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Match path of Uri with wildcard matches
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The TCP port that the target service listens on
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Composed with one of the port of HTTP connection, we will only attack HTTP connection with port inside proxy_ports
    pub proxy_ports: Vec<i64>,
    /// HTTP target: Request or Response
    pub target: String,
}

/// used for HTTP request, now only support GET
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosHttpRequest {
    /// The number of requests to send
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// Enable connection pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enable-conn-pool")]
    pub enable_conn_pool: Option<bool>,
    /// Request to send"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosJvmException {
    /// Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class: Option<String>,
    /// the exception which needs to throw for action `exception`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exception: Option<String>,
    /// the method in Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosJvmGc {
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosJvmLatency {
    /// Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class: Option<String>,
    /// the latency duration for action 'latency', unit ms
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latency: Option<i64>,
    /// the method in Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosJvmMysql {
    /// the match database default value is "", means match all database
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub database: Option<String>,
    /// The exception which needs to throw for action `exception` or the exception message needs to throw in action `mysql`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exception: Option<String>,
    /// The latency duration for action 'latency' or the latency duration in action `mysql`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latency: Option<i64>,
    /// the version of mysql-connector-java, only support 5.X.X(set to "5") and 8.X.X(set to "8") now
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mysqlConnectorVersion")]
    pub mysql_connector_version: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// the match sql type default value is "", means match all SQL type. The value can be 'select', 'insert', 'update', 'delete', 'replace'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sqlType")]
    pub sql_type: Option<String>,
    /// the match table default value is "", means match all table
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub table: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosJvmReturn {
    /// Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class: Option<String>,
    /// the method in Java class
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// the return value for action 'return'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosJvmRuleData {
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// RuleData used to save the rule file's data, will use it when recover
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rule-data")]
    pub rule_data: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosJvmStress {
    /// the CPU core number need to use, only set it when action is stress
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpu-count")]
    pub cpu_count: Option<i64>,
    /// the memory type need to locate, only set it when action is stress, the value can be 'stack' or 'heap'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mem-type")]
    pub mem_type: Option<String>,
    /// the pid of Java process which needs to attach
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i64>,
    /// the port of agent server, default 9277
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosKafkaFill {
    /// The host of kafka server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The max bytes to fill
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<i64>,
    /// The size of each message
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageSize")]
    pub message_size: Option<i64>,
    /// The password of kafka client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The port of kafka server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// The command to reload kafka config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reloadCommand")]
    pub reload_command: Option<String>,
    /// The topic to attack
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
    /// The username of kafka client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosKafkaFlood {
    /// The host of kafka server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The size of each message
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageSize")]
    pub message_size: Option<i64>,
    /// The password of kafka client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The port of kafka server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// The number of worker threads
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub threads: Option<i64>,
    /// The topic to attack
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
    /// The username of kafka client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosKafkaIo {
    /// The path of server config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configFile")]
    pub config_file: Option<String>,
    /// Make kafka cluster non-readable
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonReadable")]
    pub non_readable: Option<bool>,
    /// Make kafka cluster non-writable
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonWritable")]
    pub non_writable: Option<bool>,
    /// The topic to attack
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// Spec defines the behavior of a physical machine chaos experiment
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PhysicalMachineChaosMode {
    #[serde(rename = "one")]
    One,
    #[serde(rename = "all")]
    All,
    #[serde(rename = "fixed")]
    Fixed,
    #[serde(rename = "fixed-percent")]
    FixedPercent,
    #[serde(rename = "random-max-percent")]
    RandomMaxPercent,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosNetworkBandwidth {
    pub buffer: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    pub limit: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minburst: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peakrate: Option<i64>,
    pub rate: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosNetworkCorrupt {
    /// correlation is percentage (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub correlation: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// only impact egress traffic to these destination ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egress-port")]
    pub egress_port: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
    /// percentage of packets to corrupt (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<String>,
    /// only impact egress traffic from these source ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-port")]
    pub source_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosNetworkDelay {
    /// only the packet which match the tcp flag can be accepted, others will be dropped. only set when the IPProtocol is tcp, used for partition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accept-tcp-flags")]
    pub accept_tcp_flags: Option<String>,
    /// correlation is percentage (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub correlation: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// only impact egress traffic to these destination ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egress-port")]
    pub egress_port: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
    /// jitter time, time units: ns, us (or µs), ms, s, m, h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jitter: Option<String>,
    /// delay egress time, time units: ns, us (or µs), ms, s, m, h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub latency: Option<String>,
    /// only impact egress traffic from these source ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-port")]
    pub source_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosNetworkDns {
    /// map this host to specified IP
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dns-domain-name")]
    pub dns_domain_name: Option<String>,
    /// map specified host to this IP address
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dns-ip")]
    pub dns_ip: Option<String>,
    /// update the DNS server in /etc/resolv.conf with this value
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dns-server")]
    pub dns_server: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosNetworkDown {
    /// The network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// NIC down time, time units: ns, us (or µs), ms, s, m, h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub duration: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosNetworkDuplicate {
    /// correlation is percentage (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub correlation: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// only impact egress traffic to these destination ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egress-port")]
    pub egress_port: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
    /// percentage of packets to duplicate (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<String>,
    /// only impact egress traffic from these source ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-port")]
    pub source_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosNetworkFlood {
    /// The number of seconds to run the iperf test
    pub duration: String,
    /// Generate traffic to this IP address
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// The number of iperf parallel client threads to run
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallel: Option<i32>,
    /// Generate traffic to this port on the IP address
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// The speed of network traffic, allows bps, kbps, mbps, gbps, tbps unit. bps means bytes per second
    pub rate: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosNetworkLoss {
    /// correlation is percentage (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub correlation: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// only impact egress traffic to these destination ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egress-port")]
    pub egress_port: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
    /// percentage of packets to loss (10 is 10%)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<String>,
    /// only impact egress traffic from these source ports, use a ',' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source-port")]
    pub source_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosNetworkPartition {
    /// only the packet which match the tcp flag can be accepted, others will be dropped. only set when the IPProtocol is tcp, used for partition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accept-tcp-flags")]
    pub accept_tcp_flags: Option<String>,
    /// the network interface to impact
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// specifies the partition direction, values can be 'from', 'to'. 'from' means packets coming from the 'IPAddress' or 'Hostname' and going to your server, 'to' means packets originating from your server and going to the 'IPAddress' or 'Hostname'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub direction: Option<String>,
    /// only impact traffic to these hostnames
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-address")]
    pub ip_address: Option<String>,
    /// only impact egress traffic to these IP addresses
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ip-protocol")]
    pub ip_protocol: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosProcess {
    /// the process name or the process ID
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub process: Option<String>,
    /// the command to be run when recovering experiment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoverCmd")]
    pub recover_cmd: Option<String>,
    /// the signal number to send
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosRedisCacheLimit {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The size of `maxmemory`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cacheSize")]
    pub cache_size: Option<String>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// Specifies maxmemory as a percentage of the original value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub percent: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosRedisExpiration {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The expiration of the keys
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expiration: Option<String>,
    /// The keys to be expired
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Additional options for `expiration`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<String>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosRedisPenetration {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The number of requests to be sent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestNum")]
    pub request_num: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosRedisRestart {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The path of Sentinel conf
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conf: Option<String>,
    /// The control flag determines whether to flush config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushConfig")]
    pub flush_config: Option<bool>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The path of `redis-server` command-line tool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redisPath")]
    pub redis_path: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosRedisStop {
    /// The adress of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// The path of Sentinel conf
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conf: Option<String>,
    /// The control flag determines whether to flush config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushConfig")]
    pub flush_config: Option<bool>,
    /// The password of Redis server
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The path of `redis-server` command-line tool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redisPath")]
    pub redis_path: Option<bool>,
}

/// Selector is used to select physical machines that are used to inject chaos action.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosSelector {
    /// Map of string keys and values that can be used to select objects. A selector based on annotations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "annotationSelectors")]
    pub annotation_selectors: Option<BTreeMap<String, String>>,
    /// a slice of label selector expressions that can be used to select objects. A list of selectors based on set-based label expressions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expressionSelectors")]
    pub expression_selectors: Option<Vec<PhysicalMachineChaosSelectorExpressionSelectors>>,
    /// Map of string keys and values that can be used to select objects. A selector based on fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldSelectors")]
    pub field_selectors: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to select objects. A selector based on labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelectors")]
    pub label_selectors: Option<BTreeMap<String, String>>,
    /// Namespaces is a set of namespace to which objects belong.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// PhysicalMachines is a map of string keys and a set values that used to select physical machines. The key defines the namespace which physical machine belong, and each value is a set of physical machine names.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "physicalMachines")]
    pub physical_machines: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosSelectorExpressionSelectors {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosStressCpu {
    /// specifies P percent loading per CPU worker. 0 is effectively a sleep (no load) and 100 is full loading.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub load: Option<i64>,
    /// extend stress-ng options
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
    /// specifies N workers to apply the stressor.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosStressMem {
    /// extend stress-ng options
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
    /// specifies N bytes consumed per vm worker, default is the total available memory. One can specify the size as % of total available memory or in units of B, KB/KiB, MB/MiB, GB/GiB, TB/TiB..
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosUserDefined {
    /// The command to be executed when attack
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attackCmd")]
    pub attack_cmd: Option<String>,
    /// The command to be executed when recover
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoverCmd")]
    pub recover_cmd: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosVm {
    /// The name of the VM to be injected
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vm-name")]
    pub vm_name: Option<String>,
}

/// Most recently observed status of the chaos experiment
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosStatus {
    /// Conditions represents the current global condition of the chaos
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<PhysicalMachineChaosStatusConditions>>,
    /// Experiment records the last experiment state.
    pub experiment: PhysicalMachineChaosStatusExperiment,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosStatusConditions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    pub status: String,
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Experiment records the last experiment state.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosStatusExperiment {
    /// Records are used to track the running status
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerRecords")]
    pub container_records: Option<Vec<PhysicalMachineChaosStatusExperimentContainerRecords>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredPhase")]
    pub desired_phase: Option<PhysicalMachineChaosStatusExperimentDesiredPhase>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosStatusExperimentContainerRecords {
    /// Events are the essential details about the injections and recoveries
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub events: Option<Vec<PhysicalMachineChaosStatusExperimentContainerRecordsEvents>>,
    pub id: String,
    /// InjectedCount is a counter to record the sum of successful injections
    #[serde(rename = "injectedCount")]
    pub injected_count: i64,
    pub phase: String,
    /// RecoveredCount is a counter to record the sum of successful recoveries
    #[serde(rename = "recoveredCount")]
    pub recovered_count: i64,
    #[serde(rename = "selectorKey")]
    pub selector_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PhysicalMachineChaosStatusExperimentContainerRecordsEvents {
    /// Message is the detail message, e.g. the reason why we failed to inject the chaos
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Operation represents the operation we are doing, when we crate this event
    pub operation: String,
    /// Timestamp is time when we create this event
    pub timestamp: String,
    /// Type means the stage of this event
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Experiment records the last experiment state.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PhysicalMachineChaosStatusExperimentDesiredPhase {
    Run,
    Stop,
}

