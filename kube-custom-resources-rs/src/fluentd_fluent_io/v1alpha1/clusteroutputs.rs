// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/fluent/fluent-operator/fluentd.fluent.io/v1alpha1/clusteroutputs.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
}
use self::prelude::*;

/// ClusterOutputSpec defines the desired state of ClusterOutput
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "fluentd.fluent.io", version = "v1alpha1", kind = "ClusterOutput", plural = "clusteroutputs")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClusterOutputSpec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outputs: Option<Vec<ClusterOutputOutputs>>,
}

/// Output defines all available output plugins and their parameters
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputs {
    /// buffer section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub buffer: Option<ClusterOutputOutputsBuffer>,
    /// out_cloudwatch plugin
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudWatch")]
    pub cloud_watch: Option<ClusterOutputOutputsCloudWatch>,
    /// copy plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub copy: Option<ClusterOutputOutputsCopy>,
    /// Custom plugin type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customPlugin")]
    pub custom_plugin: Option<ClusterOutputOutputsCustomPlugin>,
    /// datadog plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datadog: Option<ClusterOutputOutputsDatadog>,
    /// out_es plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<ClusterOutputOutputsElasticsearch>,
    /// out_es datastreams plugin
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "elasticsearchDataStream")]
    pub elasticsearch_data_stream: Option<ClusterOutputOutputsElasticsearchDataStream>,
    /// format section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<ClusterOutputOutputsFormat>,
    /// out_forward plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<ClusterOutputOutputsForward>,
    /// out_http plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ClusterOutputOutputsHttp>,
    /// inject section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inject: Option<ClusterOutputOutputsInject>,
    /// out_kafka plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<ClusterOutputOutputsKafka>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// out_loki plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loki: Option<ClusterOutputOutputsLoki>,
    /// out_opensearch plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opensearch: Option<ClusterOutputOutputsOpensearch>,
    /// out_s3 plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<ClusterOutputOutputsS3>,
    /// out_stdout plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ClusterOutputOutputsStdout>,
    /// Which tag to be matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterOutputOutputsBuffer {
    /// Calculates the number of records, chunk size, during chunk resume.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "calcNumRecords")]
    pub calc_num_records: Option<String>,
    /// ChunkFormat specifies the chunk format for calc_num_records.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chunkFormat")]
    pub chunk_format: Option<ClusterOutputOutputsBufferChunkFormat>,
    /// The max number of events that each chunks can store in it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chunkLimitRecords")]
    pub chunk_limit_records: Option<String>,
    /// Buffer parameters The max size of each chunks: events will be written into chunks until the size of chunks become this size Default: 8MB (memory) / 256MB (file)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chunkLimitSize")]
    pub chunk_limit_size: Option<String>,
    /// Fluentd will decompress these compressed chunks automatically before passing them to the output plugin If gzip is set, Fluentd compresses data records before writing to buffer chunks. Default:text.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<ClusterOutputOutputsBufferCompress>,
    /// The timeout (seconds) until output plugin decides if the async write operation has failed. Default is 60s
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "delayedCommitTimeout")]
    pub delayed_commit_timeout: Option<String>,
    /// Instead of storing unrecoverable chunks in the backup directory, just discard them. This option is new in Fluentd v1.2.6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableChunkBackup")]
    pub disable_chunk_backup: Option<bool>,
    /// Flush parameters This specifies whether to flush/write all buffer chunks on shutdown or not.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushAtShutdown")]
    pub flush_at_shutdown: Option<bool>,
    /// FlushInterval defines the flush interval
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushInterval")]
    pub flush_interval: Option<String>,
    /// FlushMode defines the flush mode: lazy: flushes/writes chunks once per timekey interval: flushes/writes chunks per specified time via flush_interval immediate: flushes/writes chunks immediately after events are appended into chunks default: equals to lazy if time is specified as chunk key, interval otherwise
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushMode")]
    pub flush_mode: Option<ClusterOutputOutputsBufferFlushMode>,
    /// The number of threads to flush/write chunks in parallel
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushThreadCount")]
    pub flush_thread_count: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// If true, uses local time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// OverflowAtction defines the output plugin behave when its buffer queue is full. Default: throw_exception
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "overflowAction")]
    pub overflow_action: Option<String>,
    /// The path where buffer chunks are stored. This field would make no effect in memory buffer plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Changes the suffix of the buffer file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathSuffix")]
    pub path_suffix: Option<String>,
    /// The queue length limitation of this buffer plugin instance. Default: 0.95
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueLimitLength")]
    pub queue_limit_length: Option<String>,
    /// Limit the number of queued chunks. Default: 1 If a smaller flush_interval is set, e.g. 1s, there are lots of small queued chunks in the buffer. With file buffer, it may consume a lot of fd resources when output destination has a problem. This parameter mitigates such situations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queuedChunksLimitSize")]
    pub queued_chunks_limit_size: Option<i64>,
    /// The base number of exponential backoff for retries.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryExponentialBackoffBase")]
    pub retry_exponential_backoff_base: Option<String>,
    /// If true, plugin will ignore retry_timeout and retry_max_times options and retry flushing forever.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryForever")]
    pub retry_forever: Option<bool>,
    /// The maximum interval (seconds) for exponential backoff between retries while failing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryMaxInterval")]
    pub retry_max_interval: Option<String>,
    /// The maximum number of times to retry to flush the failed chunks. Default: none
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryMaxTimes")]
    pub retry_max_times: Option<i64>,
    /// If true, the output plugin will retry after randomized interval not to do burst retries
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryRandomize")]
    pub retry_randomize: Option<bool>,
    /// The ratio of retry_timeout to switch to use the secondary while failing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retrySecondaryThreshold")]
    pub retry_secondary_threshold: Option<String>,
    /// Retry parameters The maximum time (seconds) to retry to flush again the failed chunks, until the plugin discards the buffer chunks
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryTimeout")]
    pub retry_timeout: Option<String>,
    /// Output plugin will retry periodically with fixed intervals.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryType")]
    pub retry_type: Option<String>,
    /// Wait in seconds before the next retry to flush or constant factor of exponential backoff
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryWait")]
    pub retry_wait: Option<String>,
    /// The output plugins group events into chunks. Chunk keys, specified as the argument of <buffer> section, control how to group events into chunks. If tag is empty, which means blank Chunk Keys. Tag also supports Nested Field, combination of Chunk Keys, placeholders, etc. See https://docs.fluentd.org/configuration/buffer-section.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
    /// Process value according to the specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Uses the specified time format as a fallback in the specified order. You can parse undetermined time format by using time_format_fallbacks. This options is enabled when time_type is mixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormatFallbacks")]
    pub time_format_fallbacks: Option<String>,
    /// parses/formats value according to this type, default is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeType")]
    pub time_type: Option<ClusterOutputOutputsBufferTimeType>,
    /// Output plugin will flush chunks per specified time (enabled when time is specified in chunk keys)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timekey: Option<String>,
    /// Output plugin will write chunks after timekey_wait seconds later after timekey expiration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timekeyWait")]
    pub timekey_wait: Option<String>,
    /// Uses the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
    /// The size limitation of this buffer plugin instance Default: 512MB (memory) / 64GB (file)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalLimitSize")]
    pub total_limit_size: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(rename = "type")]
    pub r#type: ClusterOutputOutputsBufferType,
    /// If true, uses UTC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub utc: Option<bool>,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsBufferChunkFormat {
    #[serde(rename = "msgpack")]
    Msgpack,
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "auto")]
    Auto,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsBufferCompress {
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "gzip")]
    Gzip,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsBufferFlushMode {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "lazy")]
    Lazy,
    #[serde(rename = "interval")]
    Interval,
    #[serde(rename = "immediate")]
    Immediate,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsBufferTimeType {
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "unixtime")]
    Unixtime,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "mixed")]
    Mixed,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsBufferType {
    #[serde(rename = "file")]
    File,
    #[serde(rename = "memory")]
    Memory,
    #[serde(rename = "file_single")]
    FileSingle,
}

/// out_cloudwatch plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsCloudWatch {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoCreateStream")]
    pub auto_create_stream: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsEcsAuthentication")]
    pub aws_ecs_authentication: Option<bool>,
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsKeyId")]
    pub aws_key_id: Option<ClusterOutputOutputsCloudWatchAwsKeyId>,
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsSecKey")]
    pub aws_sec_key: Option<ClusterOutputOutputsCloudWatchAwsSecKey>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsDurationSeconds")]
    pub aws_sts_duration_seconds: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsEndpointUrl")]
    pub aws_sts_endpoint_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsExternalId")]
    pub aws_sts_external_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsPolicy")]
    pub aws_sts_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsRoleArn")]
    pub aws_sts_role_arn: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsSessionName")]
    pub aws_sts_session_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsUseSts")]
    pub aws_use_sts: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub concurrency: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "durationSeconds")]
    pub duration_seconds: Option<String>,
    /// Specify an AWS endpoint to send data to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpProxy")]
    pub http_proxy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeTimeKey")]
    pub include_time_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonHandler")]
    pub json_handler: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupAwsTags")]
    pub log_group_aws_tags: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupAwsTagsKey")]
    pub log_group_aws_tags_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupName")]
    pub log_group_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupNameKey")]
    pub log_group_name_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logRejectedRequest")]
    pub log_rejected_request: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamName")]
    pub log_stream_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamNameKey")]
    pub log_stream_name_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEventsPerBatch")]
    pub max_events_per_batch: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxMessageLength")]
    pub max_message_length: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageKeys")]
    pub message_keys: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putLogEventsDisableRetryLimit")]
    pub put_log_events_disable_retry_limit: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putLogEventsRetryLimit")]
    pub put_log_events_retry_limit: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putLogEventsRetryWait")]
    pub put_log_events_retry_wait: Option<String>,
    /// The AWS region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeLogGroupAwsTagsKey")]
    pub remove_log_group_aws_tags_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeLogGroupNameKey")]
    pub remove_log_group_name_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeLogStreamNameKey")]
    pub remove_log_stream_name_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeRetentionInDaysKey")]
    pub remove_retention_in_days_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionInDays")]
    pub retention_in_days: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionInDaysKey")]
    pub retention_in_days_key: Option<String>,
    /// ARN of an IAM role to assume (for cross account access).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Role Session name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleSessionName")]
    pub role_session_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslVerifyPeer")]
    pub ssl_verify_peer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTagAsGroup")]
    pub use_tag_as_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTagAsStream")]
    pub use_tag_as_stream: Option<String>,
    /// Web identity token file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webIdentityTokenFile")]
    pub web_identity_token_file: Option<String>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsCloudWatchAwsKeyId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsCloudWatchAwsKeyIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsCloudWatchAwsKeyIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsCloudWatchAwsKeyIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsCloudWatchAwsKeyIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsCloudWatchAwsSecKey {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsCloudWatchAwsSecKeyValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsCloudWatchAwsSecKeyValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsCloudWatchAwsSecKeyValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsCloudWatchAwsSecKeyValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// copy plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterOutputOutputsCopy {
    /// CopyMode defines how to pass the events to <store> plugins.
    #[serde(rename = "copyMode")]
    pub copy_mode: ClusterOutputOutputsCopyCopyMode,
}

/// copy plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsCopyCopyMode {
    #[serde(rename = "no_copy")]
    NoCopy,
    #[serde(rename = "shallow")]
    Shallow,
    #[serde(rename = "deep")]
    Deep,
    #[serde(rename = "marshal")]
    Marshal,
}

/// Custom plugin type
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsCustomPlugin {
    pub config: String,
}

/// datadog plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsDatadog {
    /// This parameter is required in order to authenticate your fluent agent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<ClusterOutputOutputsDatadogApiKey>,
    /// Set the log compression level for HTTP (1 to 9, 9 being the best ratio)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionLevel")]
    pub compression_level: Option<i32>,
    /// Used by Datadog to identify the host submitting the logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ddHostname")]
    pub dd_hostname: Option<String>,
    /// This tells Datadog what integration it is
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ddSource")]
    pub dd_source: Option<String>,
    /// Multiple value attribute. Can be used to refine the source attribute
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ddSourcecategory")]
    pub dd_sourcecategory: Option<String>,
    /// Custom tags with the following format "key1:value1, key2:value2"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ddTags")]
    pub dd_tags: Option<String>,
    /// Proxy endpoint when logs are not directly forwarded to Datadog
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// HTTP proxy, only takes effect if HTTP forwarding is enabled (use_http). Defaults to HTTP_PROXY/http_proxy env vars.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpProxy")]
    pub http_proxy: Option<String>,
    /// Automatically include the Fluentd tag in the record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeTagKey")]
    pub include_tag_key: Option<bool>,
    /// The maximum time waited between each retry in seconds
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBackoff")]
    pub max_backoff: Option<i32>,
    /// The number of retries before the output plugin stops. Set to -1 for unlimited retries
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// Disable SSL validation (useful for proxy forwarding)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noSSLValidation")]
    pub no_ssl_validation: Option<bool>,
    /// Proxy port when logs are not directly forwarded to Datadog and ssl is not used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Used by Datadog to correlate between logs, traces and metrics.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    /// Port used to send logs over a SSL encrypted connection to Datadog. If use_http is disabled, use 10516 for the US region and 443 for the EU region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslPort")]
    pub ssl_port: Option<i32>,
    /// Where to store the Fluentd tag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagKey")]
    pub tag_key: Option<String>,
    /// Name of the attribute which will contain timestamp of the log event. If nil, timestamp attribute is not added.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampKey")]
    pub timestamp_key: Option<String>,
    /// Enable log compression for HTTP
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useCompression")]
    pub use_compression: Option<bool>,
    /// Enable HTTP forwarding. If you disable it, make sure to change the port to 10514 or ssl_port to 10516
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useHTTP")]
    pub use_http: Option<bool>,
    /// Event format, if true, the event is sent in json format. Othwerwise, in plain text.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useJson")]
    pub use_json: Option<bool>,
    /// If true, the agent initializes a secure connection to Datadog. In clear TCP otherwise.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSSL")]
    pub use_ssl: Option<bool>,
}

/// This parameter is required in order to authenticate your fluent agent.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsDatadogApiKey {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsDatadogApiKeyValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsDatadogApiKeyValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsDatadogApiKeyValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsDatadogApiKeyValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_es plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearch {
    /// Optional, Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Optional, Absolute path to client Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCert")]
    pub client_cert: Option<String>,
    /// Optional, Absolute path to client private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientKey")]
    pub client_key: Option<String>,
    /// Optional, password for ClientKey file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientKeyPassword")]
    pub client_key_password: Option<ClusterOutputOutputsElasticsearchClientKeyPassword>,
    /// Authenticate towards Elastic Cloud using cloudAuth.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudAuth")]
    pub cloud_auth: Option<ClusterOutputOutputsElasticsearchCloudAuth>,
    /// Authenticate towards Elastic Cloud using CloudId. If set, cloudAuth must be set as well and host, port, user and password are ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudId")]
    pub cloud_id: Option<ClusterOutputOutputsElasticsearchCloudId>,
    /// The hostname of your Elasticsearch node (default: localhost).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Hosts defines a list of hosts if you want to connect to more than one Elasticsearch nodes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<String>,
    /// IndexName defines the placeholder syntax of Fluentd plugin API. See https://docs.fluentd.org/configuration/buffer-section.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexName")]
    pub index_name: Option<String>,
    /// If true, Fluentd uses the conventional index name format logstash-%Y.%m.%d (default: false). This option supersedes the index_name option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashFormat")]
    pub logstash_format: Option<bool>,
    /// LogstashPrefix defines the logstash prefix index name to write events when logstash_format is true (default: logstash).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashPrefix")]
    pub logstash_prefix: Option<String>,
    /// Optional, The login credentials to connect to Elasticsearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ClusterOutputOutputsElasticsearchPassword>,
    /// Path defines the REST API endpoint of Elasticsearch to post write requests (default: nil).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port number of your Elasticsearch node (default: 9200).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Specify https if your Elasticsearch endpoint supports SSL (default: http).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
    /// Optional, Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslVerify")]
    pub ssl_verify: Option<bool>,
    /// Optional, The login credentials to connect to Elasticsearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<ClusterOutputOutputsElasticsearchUser>,
}

/// Optional, password for ClientKey file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchClientKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchClientKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchClientKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchClientKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchClientKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Authenticate towards Elastic Cloud using cloudAuth.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchCloudAuth {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchCloudAuthValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchCloudAuthValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchCloudAuthValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchCloudAuthValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Authenticate towards Elastic Cloud using CloudId. If set, cloudAuth must be set as well and host, port, user and password are ignored.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchCloudId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchCloudIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchCloudIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchCloudIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchCloudIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Elasticsearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Elasticsearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_es datastreams plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStream {
    /// Optional, Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Optional, Absolute path to client Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCert")]
    pub client_cert: Option<String>,
    /// Optional, Absolute path to client private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientKey")]
    pub client_key: Option<String>,
    /// Optional, password for ClientKey file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientKeyPassword")]
    pub client_key_password: Option<ClusterOutputOutputsElasticsearchDataStreamClientKeyPassword>,
    /// Authenticate towards Elastic Cloud using cloudAuth.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudAuth")]
    pub cloud_auth: Option<ClusterOutputOutputsElasticsearchDataStreamCloudAuth>,
    /// Authenticate towards Elastic Cloud using CloudId. If set, cloudAuth must be set as well and host, port, user and password are ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudId")]
    pub cloud_id: Option<ClusterOutputOutputsElasticsearchDataStreamCloudId>,
    /// You can specify Elasticsearch data stream name by this parameter. This parameter is mandatory for elasticsearch_data_stream
    #[serde(rename = "dataStreamName")]
    pub data_stream_name: String,
    /// The hostname of your Elasticsearch node (default: localhost).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Hosts defines a list of hosts if you want to connect to more than one Elasticsearch nodes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<String>,
    /// Optional, The login credentials to connect to Elasticsearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ClusterOutputOutputsElasticsearchDataStreamPassword>,
    /// Path defines the REST API endpoint of Elasticsearch to post write requests (default: nil).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port number of your Elasticsearch node (default: 9200).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Specify https if your Elasticsearch endpoint supports SSL (default: http).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
    /// Optional, Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslVerify")]
    pub ssl_verify: Option<bool>,
    /// Optional, The login credentials to connect to Elasticsearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<ClusterOutputOutputsElasticsearchDataStreamUser>,
}

/// Optional, password for ClientKey file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamClientKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchDataStreamClientKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamClientKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchDataStreamClientKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamClientKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Authenticate towards Elastic Cloud using cloudAuth.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamCloudAuth {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchDataStreamCloudAuthValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamCloudAuthValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchDataStreamCloudAuthValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamCloudAuthValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Authenticate towards Elastic Cloud using CloudId. If set, cloudAuth must be set as well and host, port, user and password are ignored.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamCloudId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchDataStreamCloudIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamCloudIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchDataStreamCloudIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamCloudIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Elasticsearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchDataStreamPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchDataStreamPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Elasticsearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsElasticsearchDataStreamUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsElasticsearchDataStreamUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsElasticsearchDataStreamUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// format section
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsFormat {
    /// Delimiter for each field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delimiter: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// If true, uses local time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Specify newline characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub newline: Option<ClusterOutputOutputsFormatNewline>,
    /// Output tag field if true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputTag")]
    pub output_tag: Option<bool>,
    /// Output time field if true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputTime")]
    pub output_time: Option<bool>,
    /// Process value according to the specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Uses the specified time format as a fallback in the specified order. You can parse undetermined time format by using time_format_fallbacks. This options is enabled when time_type is mixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormatFallbacks")]
    pub time_format_fallbacks: Option<String>,
    /// parses/formats value according to this type, default is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeType")]
    pub time_type: Option<ClusterOutputOutputsFormatTimeType>,
    /// Uses the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ClusterOutputOutputsFormatType>,
    /// If true, uses UTC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub utc: Option<bool>,
}

/// format section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsFormatNewline {
    #[serde(rename = "lf")]
    Lf,
    #[serde(rename = "crlf")]
    Crlf,
}

/// format section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsFormatTimeType {
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "unixtime")]
    Unixtime,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "mixed")]
    Mixed,
}

/// format section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsFormatType {
    #[serde(rename = "out_file")]
    OutFile,
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "ltsv")]
    Ltsv,
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "msgpack")]
    Msgpack,
    #[serde(rename = "hash")]
    Hash,
    #[serde(rename = "single_value")]
    SingleValue,
}

/// out_forward plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForward {
    /// This option is used when require_ack_response is true. This default value is based on popular tcp_syn_retries.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResponseTimeout")]
    pub ack_response_timeout: Option<String>,
    /// The connection timeout for the socket. When the connection is timed out during the connection establishment, Errno::ETIMEDOUT error is raised.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Enable client-side DNS round robin. Uniform randomly pick an IP address to send data when a hostname has several IP addresses. heartbeat_type udp is not available with dns_round_robintrue. Use heartbeat_type tcp or heartbeat_type none.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsRoundRobin")]
    pub dns_round_robin: Option<bool>,
    /// Sets TTL to expire DNS cache in seconds. Set 0 not to use DNS Cache.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expireDnsCache")]
    pub expire_dns_cache: Option<String>,
    /// The hard timeout used to detect server failure. The default value is equal to the send_timeout parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hardTimeout")]
    pub hard_timeout: Option<String>,
    /// The interval of the heartbeat packer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "heartbeatInterval")]
    pub heartbeat_interval: Option<String>,
    /// Specifies the transport protocol for heartbeats. Set none to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "heartbeatType")]
    pub heartbeat_type: Option<ClusterOutputOutputsForwardHeartbeatType>,
    /// Ignores DNS resolution and errors at startup time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreNetworkErrorsAtStartup")]
    pub ignore_network_errors_at_startup: Option<bool>,
    /// Enables the keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<bool>,
    /// Timeout for keepalive. Default value is nil which means to keep the connection alive as long as possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveTimeout")]
    pub keepalive_timeout: Option<String>,
    /// Use the "Phi accrual failure detector" to detect server failure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phiFailureDetector")]
    pub phi_failure_detector: Option<bool>,
    /// The threshold parameter used to detect server faults.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phiThreshold")]
    pub phi_threshold: Option<i64>,
    /// The wait time before accepting a server fault recovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoverWait")]
    pub recover_wait: Option<String>,
    /// Changes the protocol to at-least-once. The plugin waits the ack from destination's in_forward plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAckResponse")]
    pub require_ack_response: Option<bool>,
    /// ServiceDiscovery defines the security section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<ClusterOutputOutputsForwardSecurity>,
    /// The timeout time when sending event logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendTimeout")]
    pub send_timeout: Option<String>,
    /// Servers defines the servers section, at least one is required
    pub servers: Vec<ClusterOutputOutputsForwardServers>,
    /// ServiceDiscovery defines the service_discovery section
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDiscovery")]
    pub service_discovery: Option<ClusterOutputOutputsForwardServiceDiscovery>,
    /// Allows self-signed certificates or not.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsAllowSelfSignedCert")]
    pub tls_allow_self_signed_cert: Option<bool>,
    /// The certificate logical store name on Windows system certstore. This parameter is for Windows only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCertLogicalStoreName")]
    pub tls_cert_logical_store_name: Option<String>,
    /// The additional CA certificate path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCertPath")]
    pub tls_cert_path: Option<String>,
    /// The certificate thumbprint for searching from Windows system certstore. This parameter is for Windows only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCertThumbprint")]
    pub tls_cert_thumbprint: Option<String>,
    /// Enables the certificate enterprise store on Windows system certstore. This parameter is for Windows only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCertUseEnterpriseStore")]
    pub tls_cert_use_enterprise_store: Option<bool>,
    /// The cipher configuration of TLS transport.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCiphers")]
    pub tls_ciphers: Option<String>,
    /// The client certificate path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientCertPath")]
    pub tls_client_cert_path: Option<String>,
    /// The TLS private key passphrase for the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientPrivateKeyPassphrase")]
    pub tls_client_private_key_passphrase: Option<String>,
    /// The client private key path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientPrivateKeyPath")]
    pub tls_client_private_key_path: Option<String>,
    /// Skips all verification of certificates or not.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsInsecureMode")]
    pub tls_insecure_mode: Option<bool>,
    /// Verifies hostname of servers and certificates or not in TLS transport.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVerifyHostname")]
    pub tls_verify_hostname: Option<bool>,
    /// The default version of TLS transport.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVersion")]
    pub tls_version: Option<ClusterOutputOutputsForwardTlsVersion>,
    /// Verify that a connection can be made with one of out_forward nodes at the time of startup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verifyConnectionAtStartup")]
    pub verify_connection_at_startup: Option<bool>,
}

/// out_forward plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsForwardHeartbeatType {
    #[serde(rename = "transport")]
    Transport,
    #[serde(rename = "tcp")]
    Tcp,
    #[serde(rename = "udp")]
    Udp,
    #[serde(rename = "none")]
    None,
}

/// ServiceDiscovery defines the security section
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardSecurity {
    /// Allows the anonymous source. <client> sections are required, if disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowAnonymousSource")]
    pub allow_anonymous_source: Option<String>,
    /// The hostname.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfHostname")]
    pub self_hostname: Option<String>,
    /// The shared key for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedKey")]
    pub shared_key: Option<String>,
    /// Defines user section directly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<ClusterOutputOutputsForwardSecurityUser>,
    /// If true, user-based authentication is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userAuth")]
    pub user_auth: Option<String>,
}

/// Defines user section directly.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardSecurityUser {
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ClusterOutputOutputsForwardSecurityUserPassword>,
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ClusterOutputOutputsForwardSecurityUserUsername>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardSecurityUserPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsForwardSecurityUserPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardSecurityUserPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsForwardSecurityUserPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardSecurityUserPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardSecurityUserUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsForwardSecurityUserUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardSecurityUserUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsForwardSecurityUserUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardSecurityUserUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Server defines the common parameters for the server plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServers {
    /// Host defines the IP address or host name of the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Name defines the name of the server. Used for logging and certificate verification in TLS transport (when the host is the address).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Password defines the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ClusterOutputOutputsForwardServersPassword>,
    /// Port defines the port number of the host. Note that both TCP packets (event stream) and UDP packets (heartbeat messages) are sent to this port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// SharedKey defines the shared key per server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedKey")]
    pub shared_key: Option<String>,
    /// Standby marks a node as the standby node for an Active-Standby model between Fluentd nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// Username defines the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ClusterOutputOutputsForwardServersUsername>,
    /// Weight defines the load balancing weight
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<String>,
}

/// Password defines the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServersPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsForwardServersPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServersPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsForwardServersPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServersPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServersUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsForwardServersUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServersUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsForwardServersUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServersUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ServiceDiscovery defines the service_discovery section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterOutputOutputsForwardServiceDiscovery {
    /// The encoding of the configuration file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confEncoding")]
    pub conf_encoding: Option<String>,
    /// DnsLookup resolves the hostname to IP address of the SRV's Target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsLookup")]
    pub dns_lookup: Option<String>,
    /// DnsServerHost defines the hostname of the DNS server to request the SRV record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsServerHost")]
    pub dns_server_host: Option<String>,
    /// The name in RFC2782.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Interval defines the interval of sending requests to DNS server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// The path of the target list. Default is '/etc/fluent/sd.yaml'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Proto without the underscore in RFC2782.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proto: Option<String>,
    /// The server section of this plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server: Option<ClusterOutputOutputsForwardServiceDiscoveryServer>,
    /// Service without the underscore in RFC2782.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(rename = "type")]
    pub r#type: ClusterOutputOutputsForwardServiceDiscoveryType,
}

/// The server section of this plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServiceDiscoveryServer {
    /// Host defines the IP address or host name of the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Name defines the name of the server. Used for logging and certificate verification in TLS transport (when the host is the address).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Password defines the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ClusterOutputOutputsForwardServiceDiscoveryServerPassword>,
    /// Port defines the port number of the host. Note that both TCP packets (event stream) and UDP packets (heartbeat messages) are sent to this port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// SharedKey defines the shared key per server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedKey")]
    pub shared_key: Option<String>,
    /// Standby marks a node as the standby node for an Active-Standby model between Fluentd nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// Username defines the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ClusterOutputOutputsForwardServiceDiscoveryServerUsername>,
    /// Weight defines the load balancing weight
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<String>,
}

/// Password defines the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServiceDiscoveryServerPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsForwardServiceDiscoveryServerPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServiceDiscoveryServerPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsForwardServiceDiscoveryServerPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServiceDiscoveryServerPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServiceDiscoveryServerUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsForwardServiceDiscoveryServerUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServiceDiscoveryServerUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsForwardServiceDiscoveryServerUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsForwardServiceDiscoveryServerUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ServiceDiscovery defines the service_discovery section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsForwardServiceDiscoveryType {
    #[serde(rename = "static")]
    Static,
    #[serde(rename = "file")]
    File,
    #[serde(rename = "srv")]
    Srv,
}

/// out_forward plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsForwardTlsVersion {
    #[serde(rename = "TLSv1_1")]
    TlSv11,
    #[serde(rename = "TLSv1_2")]
    TlSv12,
}

/// out_http plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsHttp {
    /// Auth section for this plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<ClusterOutputOutputsHttpAuth>,
    /// ContentType defines Content-Type for HTTP request. out_http automatically set Content-Type for built-in formatters when this parameter is not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<String>,
    /// Endpoint defines the endpoint for HTTP request. If you want to use HTTPS, use https prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Raise UnrecoverableError when the response code is not SUCCESS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorResponseAsUnrecoverable")]
    pub error_response_as_unrecoverable: Option<bool>,
    /// Headers defines the additional headers for HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<String>,
    /// Additional placeholder based headers for HTTP request. If you want to use tag or record field, use this parameter instead of headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headersFromPlaceholders")]
    pub headers_from_placeholders: Option<String>,
    /// HttpMethod defines the method for HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpMethod")]
    pub http_method: Option<ClusterOutputOutputsHttpHttpMethod>,
    /// JsonArray defines whether to use the array format of JSON or not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonArray")]
    pub json_array: Option<bool>,
    /// OpenTimeout defines the connection open timeout in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openTimeout")]
    pub open_timeout: Option<i64>,
    /// Proxy defines the proxy for HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<String>,
    /// ReadTimeout defines the read timeout in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readTimeout")]
    pub read_timeout: Option<i64>,
    /// The list of retryable response codes. If the response code is included in this list, out_http retries the buffer flush.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryableResponseCodes")]
    pub retryable_response_codes: Option<String>,
    /// SslTimeout defines the TLS timeout in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslTimeout")]
    pub ssl_timeout: Option<i64>,
    /// TlsCaCertPath defines the CA certificate path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCaCertPath")]
    pub tls_ca_cert_path: Option<String>,
    /// TlsCiphers defines the cipher suites configuration of TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCiphers")]
    pub tls_ciphers: Option<String>,
    /// TlsClientCertPath defines the client certificate path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientCertPath")]
    pub tls_client_cert_path: Option<String>,
    /// TlsPrivateKeyPassphrase defines the client private key passphrase for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPrivateKeyPassphrase")]
    pub tls_private_key_passphrase: Option<String>,
    /// TlsPrivateKeyPath defines the client private key path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPrivateKeyPath")]
    pub tls_private_key_path: Option<String>,
    /// TlsVerifyMode defines the verify mode of TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVerifyMode")]
    pub tls_verify_mode: Option<ClusterOutputOutputsHttpTlsVerifyMode>,
    /// TlsVersion defines the default version of TLS transport.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVersion")]
    pub tls_version: Option<ClusterOutputOutputsHttpTlsVersion>,
}

/// Auth section for this plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsHttpAuth {
    /// The method for HTTP authentication. Now only basic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<String>,
    /// The password for basic authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ClusterOutputOutputsHttpAuthPassword>,
    /// The username for basic authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ClusterOutputOutputsHttpAuthUsername>,
}

/// The password for basic authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsHttpAuthPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsHttpAuthPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsHttpAuthPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsHttpAuthPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsHttpAuthPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The username for basic authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsHttpAuthUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsHttpAuthUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsHttpAuthUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsHttpAuthUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsHttpAuthUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsHttpHttpMethod {
    #[serde(rename = "post")]
    Post,
    #[serde(rename = "put")]
    Put,
}

/// out_http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsHttpTlsVerifyMode {
    #[serde(rename = "peer")]
    Peer,
    #[serde(rename = "none")]
    None,
}

/// out_http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsHttpTlsVersion {
    #[serde(rename = "TLSv1_1")]
    TlSv11,
    #[serde(rename = "TLSv1_2")]
    TlSv12,
}

/// inject section
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsInject {
    /// Hostname value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// The field name to inject hostname
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostnameKey")]
    pub hostname_key: Option<String>,
    /// Time section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inline: Option<ClusterOutputOutputsInjectInline>,
    /// The field name to inject tag
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagKey")]
    pub tag_key: Option<String>,
    /// The field name to inject time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// The field name to inject worker_id
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerIdKey")]
    pub worker_id_key: Option<String>,
}

/// Time section
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsInjectInline {
    /// If true, uses local time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    /// Process value according to the specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Uses the specified time format as a fallback in the specified order. You can parse undetermined time format by using time_format_fallbacks. This options is enabled when time_type is mixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormatFallbacks")]
    pub time_format_fallbacks: Option<String>,
    /// parses/formats value according to this type, default is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeType")]
    pub time_type: Option<ClusterOutputOutputsInjectInlineTimeType>,
    /// Uses the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
    /// If true, uses UTC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub utc: Option<bool>,
}

/// Time section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsInjectInlineTimeType {
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "unixtime")]
    Unixtime,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "mixed")]
    Mixed,
}

/// out_kafka plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsKafka {
    /// The list of all seed brokers, with their host and port information. Default: localhost:9092
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub brokers: Option<String>,
    /// The codec the producer uses to compress messages (default: nil).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionCodec")]
    pub compression_codec: Option<ClusterOutputOutputsKafkaCompressionCodec>,
    /// The name of the default topic. (default: nil)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultTopic")]
    pub default_topic: Option<String>,
    /// The number of acks required per request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredAcks")]
    pub required_acks: Option<i64>,
    /// The field name for the target topic. If the field value is app, this plugin writes events to the app topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicKey")]
    pub topic_key: Option<String>,
    /// Set fluentd event time to Kafka's CreateTime.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useEventTime")]
    pub use_event_time: Option<bool>,
}

/// out_kafka plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsKafkaCompressionCodec {
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "snappy")]
    Snappy,
}

/// out_loki plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLoki {
    /// If a record only has 1 key, then just set the log line to the value and discard the key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropSingleKey")]
    pub drop_single_key: Option<bool>,
    /// If set to true, it will add all Kubernetes labels to the Stream labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extractKubernetesLabels")]
    pub extract_kubernetes_labels: Option<bool>,
    /// Password for user defined in HTTP_User Set HTTP basic authentication password
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPassword")]
    pub http_password: Option<ClusterOutputOutputsLokiHttpPassword>,
    /// Set HTTP basic authentication user name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<ClusterOutputOutputsLokiHttpUser>,
    /// Whether or not to include the fluentd_thread label when multiple threads are used for flushing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeThreadLabel")]
    pub include_thread_label: Option<bool>,
    /// Disable certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// Optional list of record keys that will be placed as stream labels. This configuration property is for records key only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelKeys")]
    pub label_keys: Option<Vec<String>>,
    /// Stream labels for API request. It can be multiple comma separated of strings specifying  key=value pairs. In addition to fixed parameters, it also allows to add custom record keys (similar to label_keys property).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<Vec<String>>,
    /// Format to use when flattening the record to a log line. Valid values are json or key_value. If set to json,  the log line sent to Loki will be the Fluentd record dumped as JSON. If set to key_value, the log line will be each item in the record concatenated together (separated by a single space) in the format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lineFormat")]
    pub line_format: Option<ClusterOutputOutputsLokiLineFormat>,
    /// Optional list of record keys that will be removed from stream labels. This configuration property is for records key only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeKeys")]
    pub remove_keys: Option<Vec<String>>,
    /// Tenant ID used by default to push logs to Loki. If omitted or empty it assumes Loki is running in single-tenant mode and no X-Scope-OrgID header is sent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantID")]
    pub tenant_id: Option<ClusterOutputOutputsLokiTenantId>,
    /// TlsCaCert defines the CA certificate file for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCaCertFile")]
    pub tls_ca_cert_file: Option<String>,
    /// TlsClientCert defines the client certificate file for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientCertFile")]
    pub tls_client_cert_file: Option<String>,
    /// TlsPrivateKey defines the client private key file for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPrivateKeyFile")]
    pub tls_private_key_file: Option<String>,
    /// Loki URL.
    pub url: String,
}

/// Password for user defined in HTTP_User Set HTTP basic authentication password
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLokiHttpPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsLokiHttpPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLokiHttpPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsLokiHttpPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLokiHttpPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Set HTTP basic authentication user name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLokiHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsLokiHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLokiHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsLokiHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLokiHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_loki plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsLokiLineFormat {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "key_value")]
    KeyValue,
}

/// Tenant ID used by default to push logs to Loki. If omitted or empty it assumes Loki is running in single-tenant mode and no X-Scope-OrgID header is sent.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLokiTenantId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsLokiTenantIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLokiTenantIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsLokiTenantIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsLokiTenantIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_opensearch plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsOpensearch {
    /// The hostname of your Opensearch node (default: localhost).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Hosts defines a list of hosts if you want to connect to more than one Openearch nodes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<String>,
    /// IndexName defines the placeholder syntax of Fluentd plugin API. See https://docs.fluentd.org/configuration/buffer-section.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexName")]
    pub index_name: Option<String>,
    /// If true, Fluentd uses the conventional index name format logstash-%Y.%m.%d (default: false). This option supersedes the index_name option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashFormat")]
    pub logstash_format: Option<bool>,
    /// LogstashPrefix defines the logstash prefix index name to write events when logstash_format is true (default: logstash).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashPrefix")]
    pub logstash_prefix: Option<String>,
    /// Optional, The login credentials to connect to Opensearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ClusterOutputOutputsOpensearchPassword>,
    /// Path defines the REST API endpoint of Opensearch to post write requests (default: nil).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port number of your Opensearch node (default: 9200).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Specify https if your Opensearch endpoint supports SSL (default: http).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
    /// Optional, The login credentials to connect to Opensearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<ClusterOutputOutputsOpensearchUser>,
}

/// Optional, The login credentials to connect to Opensearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsOpensearchPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsOpensearchPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsOpensearchPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsOpensearchPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsOpensearchPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Opensearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsOpensearchUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterOutputOutputsOpensearchUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsOpensearchUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClusterOutputOutputsOpensearchUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsOpensearchUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_s3 plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsS3 {
    /// The AWS access key id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsKeyId")]
    pub aws_key_id: Option<String>,
    /// The AWS secret key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsSecKey")]
    pub aws_sec_key: Option<String>,
    /// This prevents AWS SDK from breaking endpoint URL
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forcePathStyle")]
    pub force_path_style: Option<bool>,
    /// The path prefix of the files on S3.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The proxy URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUri")]
    pub proxy_uri: Option<String>,
    /// The Amazon S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    pub s3_bucket: Option<String>,
    /// The endpoint URL (like "http://localhost:9000/")
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Endpoint")]
    pub s3_endpoint: Option<String>,
    /// The actual S3 path. This is interpolated to the actual path.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3ObjectKeyFormat")]
    pub s3_object_key_format: Option<String>,
    /// The Amazon S3 region name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Region")]
    pub s3_region: Option<String>,
    /// The AWS KMS enctyption algorithm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sseCustomerAlgorithm")]
    pub sse_customer_algorithm: Option<String>,
    /// The AWS KMS key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sseCustomerKey")]
    pub sse_customer_key: Option<String>,
    /// The AWS KMS key MD5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sseCustomerKeyMd5")]
    pub sse_customer_key_md5: Option<String>,
    /// The AWS KMS key ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ssekmsKeyId")]
    pub ssekms_key_id: Option<String>,
    /// Verify the SSL certificate of the endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslVerifyPeer")]
    pub ssl_verify_peer: Option<bool>,
    /// The compression type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storeAs")]
    pub store_as: Option<ClusterOutputOutputsS3StoreAs>,
    /// This timestamp is added to each file name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeSliceFormat")]
    pub time_slice_format: Option<String>,
    /// the following parameters are for S3 kms https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useServerSideEncryption")]
    pub use_server_side_encryption: Option<String>,
}

/// out_s3 plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterOutputOutputsS3StoreAs {
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "lzo")]
    Lzo,
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "txt")]
    Txt,
}

/// out_stdout plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputOutputsStdout {
}

/// ClusterOutputStatus defines the observed state of ClusterOutput
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterOutputStatus {
}

