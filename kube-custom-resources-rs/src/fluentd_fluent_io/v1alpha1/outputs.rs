// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/fluent/fluent-operator/fluentd.fluent.io/v1alpha1/outputs.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
}
use self::prelude::*;

/// OutputSpec defines the desired state of Output
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "fluentd.fluent.io", version = "v1alpha1", kind = "Output", plural = "outputs")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct OutputSpec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub outputs: Option<Vec<OutputOutputs>>,
}

/// Output defines all available output plugins and their parameters
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputs {
    /// buffer section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub buffer: Option<OutputOutputsBuffer>,
    /// out_cloudwatch plugin
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudWatch")]
    pub cloud_watch: Option<OutputOutputsCloudWatch>,
    /// copy plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub copy: Option<OutputOutputsCopy>,
    /// Custom plugin type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customPlugin")]
    pub custom_plugin: Option<OutputOutputsCustomPlugin>,
    /// datadog plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datadog: Option<OutputOutputsDatadog>,
    /// out_es plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<OutputOutputsElasticsearch>,
    /// out_es datastreams plugin
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "elasticsearchDataStream")]
    pub elasticsearch_data_stream: Option<OutputOutputsElasticsearchDataStream>,
    /// format section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<OutputOutputsFormat>,
    /// out_forward plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<OutputOutputsForward>,
    /// out_http plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<OutputOutputsHttp>,
    /// inject section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inject: Option<OutputOutputsInject>,
    /// out_kafka plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<OutputOutputsKafka>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// out_loki plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loki: Option<OutputOutputsLoki>,
    /// out_opensearch plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opensearch: Option<OutputOutputsOpensearch>,
    /// out_s3 plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<OutputOutputsS3>,
    /// out_stdout plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<OutputOutputsStdout>,
    /// Which tag to be matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OutputOutputsBuffer {
    /// Calculates the number of records, chunk size, during chunk resume.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "calcNumRecords")]
    pub calc_num_records: Option<String>,
    /// ChunkFormat specifies the chunk format for calc_num_records.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chunkFormat")]
    pub chunk_format: Option<OutputOutputsBufferChunkFormat>,
    /// The max number of events that each chunks can store in it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chunkLimitRecords")]
    pub chunk_limit_records: Option<String>,
    /// Buffer parameters
    /// The max size of each chunks: events will be written into chunks until the size of chunks become this size
    /// Default: 8MB (memory) / 256MB (file)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chunkLimitSize")]
    pub chunk_limit_size: Option<String>,
    /// Fluentd will decompress these compressed chunks automatically before passing them to the output plugin
    /// If gzip is set, Fluentd compresses data records before writing to buffer chunks.
    /// Default:text.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compress: Option<OutputOutputsBufferCompress>,
    /// The timeout (seconds) until output plugin decides if the async write operation has failed. Default is 60s
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "delayedCommitTimeout")]
    pub delayed_commit_timeout: Option<String>,
    /// Instead of storing unrecoverable chunks in the backup directory, just discard them. This option is new in Fluentd v1.2.6.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableChunkBackup")]
    pub disable_chunk_backup: Option<bool>,
    /// Flush parameters
    /// This specifies whether to flush/write all buffer chunks on shutdown or not.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushAtShutdown")]
    pub flush_at_shutdown: Option<bool>,
    /// FlushInterval defines the flush interval
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushInterval")]
    pub flush_interval: Option<String>,
    /// FlushMode defines the flush mode:
    /// lazy: flushes/writes chunks once per timekey
    /// interval: flushes/writes chunks per specified time via flush_interval
    /// immediate: flushes/writes chunks immediately after events are appended into chunks
    /// default: equals to lazy if time is specified as chunk key, interval otherwise
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushMode")]
    pub flush_mode: Option<OutputOutputsBufferFlushMode>,
    /// The number of threads to flush/write chunks in parallel
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushThreadCount")]
    pub flush_thread_count: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// If true, uses local time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// OverflowAtction defines the output plugin behave when its buffer queue is full.
    /// Default: throw_exception
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "overflowAction")]
    pub overflow_action: Option<String>,
    /// The path where buffer chunks are stored. This field would make no effect in memory buffer plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Changes the suffix of the buffer file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathSuffix")]
    pub path_suffix: Option<String>,
    /// The queue length limitation of this buffer plugin instance. Default: 0.95
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queueLimitLength")]
    pub queue_limit_length: Option<String>,
    /// Limit the number of queued chunks. Default: 1
    /// If a smaller flush_interval is set, e.g. 1s,
    /// there are lots of small queued chunks in the buffer.
    /// With file buffer, it may consume a lot of fd resources when output destination has a problem.
    /// This parameter mitigates such situations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queuedChunksLimitSize")]
    pub queued_chunks_limit_size: Option<i64>,
    /// The base number of exponential backoff for retries.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryExponentialBackoffBase")]
    pub retry_exponential_backoff_base: Option<String>,
    /// If true, plugin will ignore retry_timeout and retry_max_times options and retry flushing forever.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryForever")]
    pub retry_forever: Option<bool>,
    /// The maximum interval (seconds) for exponential backoff between retries while failing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryMaxInterval")]
    pub retry_max_interval: Option<String>,
    /// The maximum number of times to retry to flush the failed chunks. Default: none
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryMaxTimes")]
    pub retry_max_times: Option<i64>,
    /// If true, the output plugin will retry after randomized interval not to do burst retries
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryRandomize")]
    pub retry_randomize: Option<bool>,
    /// The ratio of retry_timeout to switch to use the secondary while failing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retrySecondaryThreshold")]
    pub retry_secondary_threshold: Option<String>,
    /// Retry parameters
    /// The maximum time (seconds) to retry to flush again the failed chunks, until the plugin discards the buffer chunks
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryTimeout")]
    pub retry_timeout: Option<String>,
    /// Output plugin will retry periodically with fixed intervals.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryType")]
    pub retry_type: Option<String>,
    /// Wait in seconds before the next retry to flush or constant factor of exponential backoff
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryWait")]
    pub retry_wait: Option<String>,
    /// The output plugins group events into chunks.
    /// Chunk keys, specified as the argument of <buffer> section, control how to group events into chunks.
    /// If tag is empty, which means blank Chunk Keys.
    /// Tag also supports Nested Field, combination of Chunk Keys, placeholders, etc.
    /// See https://docs.fluentd.org/configuration/buffer-section.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
    /// Process value according to the specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Uses the specified time format as a fallback in the specified order. You can parse undetermined time format by using time_format_fallbacks. This options is enabled when time_type is mixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormatFallbacks")]
    pub time_format_fallbacks: Option<String>,
    /// parses/formats value according to this type, default is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeType")]
    pub time_type: Option<OutputOutputsBufferTimeType>,
    /// Output plugin will flush chunks per specified time (enabled when time is specified in chunk keys)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timekey: Option<String>,
    /// Output plugin will write chunks after timekey_wait seconds later after timekey expiration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timekeyWait")]
    pub timekey_wait: Option<String>,
    /// Uses the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
    /// The size limitation of this buffer plugin instance
    /// Default: 512MB (memory) / 64GB (file)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalLimitSize")]
    pub total_limit_size: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(rename = "type")]
    pub r#type: OutputOutputsBufferType,
    /// If true, uses UTC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub utc: Option<bool>,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsBufferChunkFormat {
    #[serde(rename = "msgpack")]
    Msgpack,
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "auto")]
    Auto,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsBufferCompress {
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "gzip")]
    Gzip,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsBufferFlushMode {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "lazy")]
    Lazy,
    #[serde(rename = "interval")]
    Interval,
    #[serde(rename = "immediate")]
    Immediate,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsBufferTimeType {
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "unixtime")]
    Unixtime,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "mixed")]
    Mixed,
}

/// buffer section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsBufferType {
    #[serde(rename = "file")]
    File,
    #[serde(rename = "memory")]
    Memory,
    #[serde(rename = "file_single")]
    FileSingle,
}

/// out_cloudwatch plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsCloudWatch {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoCreateStream")]
    pub auto_create_stream: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsEcsAuthentication")]
    pub aws_ecs_authentication: Option<bool>,
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsKeyId")]
    pub aws_key_id: Option<OutputOutputsCloudWatchAwsKeyId>,
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsSecKey")]
    pub aws_sec_key: Option<OutputOutputsCloudWatchAwsSecKey>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsDurationSeconds")]
    pub aws_sts_duration_seconds: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsEndpointUrl")]
    pub aws_sts_endpoint_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsExternalId")]
    pub aws_sts_external_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsPolicy")]
    pub aws_sts_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsRoleArn")]
    pub aws_sts_role_arn: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsStsSessionName")]
    pub aws_sts_session_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsUseSts")]
    pub aws_use_sts: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub concurrency: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "durationSeconds")]
    pub duration_seconds: Option<String>,
    /// Specify an AWS endpoint to send data to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpProxy")]
    pub http_proxy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeTimeKey")]
    pub include_time_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonHandler")]
    pub json_handler: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupAwsTags")]
    pub log_group_aws_tags: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupAwsTagsKey")]
    pub log_group_aws_tags_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupName")]
    pub log_group_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logGroupNameKey")]
    pub log_group_name_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logRejectedRequest")]
    pub log_rejected_request: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamName")]
    pub log_stream_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logStreamNameKey")]
    pub log_stream_name_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEventsPerBatch")]
    pub max_events_per_batch: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxMessageLength")]
    pub max_message_length: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageKeys")]
    pub message_keys: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putLogEventsDisableRetryLimit")]
    pub put_log_events_disable_retry_limit: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putLogEventsRetryLimit")]
    pub put_log_events_retry_limit: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "putLogEventsRetryWait")]
    pub put_log_events_retry_wait: Option<String>,
    /// The AWS region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeLogGroupAwsTagsKey")]
    pub remove_log_group_aws_tags_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeLogGroupNameKey")]
    pub remove_log_group_name_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeLogStreamNameKey")]
    pub remove_log_stream_name_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeRetentionInDaysKey")]
    pub remove_retention_in_days_key: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionInDays")]
    pub retention_in_days: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionInDaysKey")]
    pub retention_in_days_key: Option<String>,
    /// ARN of an IAM role to assume (for cross account access).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// Role Session name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleSessionName")]
    pub role_session_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslVerifyPeer")]
    pub ssl_verify_peer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTagAsGroup")]
    pub use_tag_as_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTagAsStream")]
    pub use_tag_as_stream: Option<String>,
    /// Web identity token file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webIdentityTokenFile")]
    pub web_identity_token_file: Option<String>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsCloudWatchAwsKeyId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsCloudWatchAwsKeyIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsCloudWatchAwsKeyIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsCloudWatchAwsKeyIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsCloudWatchAwsKeyIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsCloudWatchAwsSecKey {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsCloudWatchAwsSecKeyValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsCloudWatchAwsSecKeyValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsCloudWatchAwsSecKeyValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsCloudWatchAwsSecKeyValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// copy plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OutputOutputsCopy {
    /// CopyMode defines how to pass the events to <store> plugins.
    #[serde(rename = "copyMode")]
    pub copy_mode: OutputOutputsCopyCopyMode,
}

/// copy plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsCopyCopyMode {
    #[serde(rename = "no_copy")]
    NoCopy,
    #[serde(rename = "shallow")]
    Shallow,
    #[serde(rename = "deep")]
    Deep,
    #[serde(rename = "marshal")]
    Marshal,
}

/// Custom plugin type
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsCustomPlugin {
    pub config: String,
}

/// datadog plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsDatadog {
    /// This parameter is required in order to authenticate your fluent agent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<OutputOutputsDatadogApiKey>,
    /// Set the log compression level for HTTP (1 to 9, 9 being the best ratio)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionLevel")]
    pub compression_level: Option<i32>,
    /// Used by Datadog to identify the host submitting the logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ddHostname")]
    pub dd_hostname: Option<String>,
    /// This tells Datadog what integration it is
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ddSource")]
    pub dd_source: Option<String>,
    /// Multiple value attribute. Can be used to refine the source attribute
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ddSourcecategory")]
    pub dd_sourcecategory: Option<String>,
    /// Custom tags with the following format "key1:value1, key2:value2"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ddTags")]
    pub dd_tags: Option<String>,
    /// Proxy endpoint when logs are not directly forwarded to Datadog
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// HTTP proxy, only takes effect if HTTP forwarding is enabled (use_http). Defaults to HTTP_PROXY/http_proxy env vars.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpProxy")]
    pub http_proxy: Option<String>,
    /// Automatically include the Fluentd tag in the record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeTagKey")]
    pub include_tag_key: Option<bool>,
    /// The maximum time waited between each retry in seconds
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBackoff")]
    pub max_backoff: Option<i32>,
    /// The number of retries before the output plugin stops. Set to -1 for unlimited retries
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    /// Disable SSL validation (useful for proxy forwarding)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noSSLValidation")]
    pub no_ssl_validation: Option<bool>,
    /// Proxy port when logs are not directly forwarded to Datadog and ssl is not used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Used by Datadog to correlate between logs, traces and metrics.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    /// Port used to send logs over a SSL encrypted connection to Datadog. If use_http is disabled, use 10516 for the US region and 443 for the EU region.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslPort")]
    pub ssl_port: Option<i32>,
    /// Where to store the Fluentd tag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagKey")]
    pub tag_key: Option<String>,
    /// Name of the attribute which will contain timestamp of the log event. If nil, timestamp attribute is not added.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timestampKey")]
    pub timestamp_key: Option<String>,
    /// Enable log compression for HTTP
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useCompression")]
    pub use_compression: Option<bool>,
    /// Enable HTTP forwarding. If you disable it, make sure to change the port to 10514 or ssl_port to 10516
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useHTTP")]
    pub use_http: Option<bool>,
    /// Event format, if true, the event is sent in json format. Othwerwise, in plain text.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useJson")]
    pub use_json: Option<bool>,
    /// If true, the agent initializes a secure connection to Datadog. In clear TCP otherwise.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSSL")]
    pub use_ssl: Option<bool>,
}

/// This parameter is required in order to authenticate your fluent agent.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsDatadogApiKey {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsDatadogApiKeyValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsDatadogApiKeyValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsDatadogApiKeyValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsDatadogApiKeyValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_es plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearch {
    /// Optional, Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Optional, Absolute path to client Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCert")]
    pub client_cert: Option<String>,
    /// Optional, Absolute path to client private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientKey")]
    pub client_key: Option<String>,
    /// Optional, password for ClientKey file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientKeyPassword")]
    pub client_key_password: Option<OutputOutputsElasticsearchClientKeyPassword>,
    /// Authenticate towards Elastic Cloud using cloudAuth.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudAuth")]
    pub cloud_auth: Option<OutputOutputsElasticsearchCloudAuth>,
    /// Authenticate towards Elastic Cloud using CloudId. If set, cloudAuth must
    /// be set as well and host, port, user and password are ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudId")]
    pub cloud_id: Option<OutputOutputsElasticsearchCloudId>,
    /// Optional, Enable Index Lifecycle Management (ILM)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIlm")]
    pub enable_ilm: Option<bool>,
    /// Optional, Indicates whether to fail when max_retry_putting_template is exceeded. If you have multiple output plugin, you could use this property to do not fail on fluentd statup (default: false)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOnPuttingTemplateRetryExceeded")]
    pub fail_on_putting_template_retry_exceeded: Option<bool>,
    /// The hostname of your Elasticsearch node (default: localhost).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Hosts defines a list of hosts if you want to connect to more than one Elasticsearch nodes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<String>,
    /// Optional, Specify ILM policy contents as Hash
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ilmPolicy")]
    pub ilm_policy: Option<String>,
    /// Optional, Specify ILM policy id
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ilmPolicyId")]
    pub ilm_policy_id: Option<String>,
    /// Optional, Specify whether overwriting ilm policy or not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ilmPolicyOverride")]
    pub ilm_policy_override: Option<bool>,
    /// IndexName defines the placeholder syntax of Fluentd plugin API. See https://docs.fluentd.org/configuration/buffer-section.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexName")]
    pub index_name: Option<String>,
    /// Optional, Enable logging of 400 reason without enabling debug log level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logEs400Reason")]
    pub log_es400_reason: Option<bool>,
    /// If true, Fluentd uses the conventional index name format logstash-%Y.%m.%d (default: false). This option supersedes the index_name option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashFormat")]
    pub logstash_format: Option<bool>,
    /// LogstashPrefix defines the logstash prefix index name to write events when logstash_format is true (default: logstash).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashPrefix")]
    pub logstash_prefix: Option<String>,
    /// Optional, You can specify times of retry putting template (default: 10)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetryPuttingTemplate")]
    pub max_retry_putting_template: Option<i32>,
    /// Optional, The login credentials to connect to Elasticsearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<OutputOutputsElasticsearchPassword>,
    /// Path defines the REST API endpoint of Elasticsearch to post write requests (default: nil).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port number of your Elasticsearch node (default: 9200).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Optional, Indicates that the plugin should reset connection on any error (reconnect on next send) (default: false)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconnectOnError")]
    pub reconnect_on_error: Option<bool>,
    /// Optional, Automatically reload connection after 10000 documents (default: true)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reloadConnections")]
    pub reload_connections: Option<bool>,
    /// Optional, Indicates that the elasticsearch-transport will try to reload the nodes addresses if there is a failure while making the request, this can be useful to quickly remove a dead node from the list of addresses (default: false)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reloadOnFailure")]
    pub reload_on_failure: Option<bool>,
    /// Optional, HTTP Timeout (default: 5)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestTimeout")]
    pub request_timeout: Option<String>,
    /// Specify https if your Elasticsearch endpoint supports SSL (default: http).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
    /// Optional, Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslVerify")]
    pub ssl_verify: Option<bool>,
    /// Optional, Suppress '[types removal]' warnings on elasticsearch 7.x
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suppressTypeName")]
    pub suppress_type_name: Option<bool>,
    /// Optional, Always update the template, even if it already exists (default: false)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateOverwrite")]
    pub template_overwrite: Option<bool>,
    /// Optional, The login credentials to connect to Elasticsearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<OutputOutputsElasticsearchUser>,
}

/// Optional, password for ClientKey file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchClientKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchClientKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchClientKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchClientKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchClientKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Authenticate towards Elastic Cloud using cloudAuth.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchCloudAuth {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchCloudAuthValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchCloudAuthValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchCloudAuthValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchCloudAuthValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Authenticate towards Elastic Cloud using CloudId. If set, cloudAuth must
/// be set as well and host, port, user and password are ignored.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchCloudId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchCloudIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchCloudIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchCloudIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchCloudIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Elasticsearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Elasticsearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_es datastreams plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStream {
    /// Optional, Absolute path to CA certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Optional, Absolute path to client Certificate file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCert")]
    pub client_cert: Option<String>,
    /// Optional, Absolute path to client private Key file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientKey")]
    pub client_key: Option<String>,
    /// Optional, password for ClientKey file
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientKeyPassword")]
    pub client_key_password: Option<OutputOutputsElasticsearchDataStreamClientKeyPassword>,
    /// Authenticate towards Elastic Cloud using cloudAuth.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudAuth")]
    pub cloud_auth: Option<OutputOutputsElasticsearchDataStreamCloudAuth>,
    /// Authenticate towards Elastic Cloud using CloudId. If set, cloudAuth must
    /// be set as well and host, port, user and password are ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudId")]
    pub cloud_id: Option<OutputOutputsElasticsearchDataStreamCloudId>,
    /// Optional, You can specify the name of an existing ILM policy, which will be applied to the data stream. If not present, it creates a new ILM default policy (unless data_stream_template_name is defined, in that case the ILM will be set to the one specified in the matching index template)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataStreamIlmName")]
    pub data_stream_ilm_name: Option<String>,
    /// Optional, You can specify the ILM policy contents as hash. If not present, it will apply the ILM default policy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataStreamIlmPolicy")]
    pub data_stream_ilm_policy: Option<String>,
    /// Optional, Specify whether the data stream ILM policy should be overwritten
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataStreamIlmPolicyOverwrite")]
    pub data_stream_ilm_policy_overwrite: Option<bool>,
    /// You can specify Elasticsearch data stream name by this parameter. This parameter is mandatory for elasticsearch_data_stream
    #[serde(rename = "dataStreamName")]
    pub data_stream_name: String,
    /// Optional, You can specify an existing matching index template for the data stream. If not present, it creates a new matching index template
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataStreamTemplateName")]
    pub data_stream_template_name: Option<String>,
    /// Optional, Specify whether index patterns should include a wildcard (*) when creating an index template. This is particularly useful to prevent errors in scenarios where index templates are generated automatically, and multiple services with distinct suffixes are in use
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataStreamTemplateUseIndexPatternsWildcard")]
    pub data_stream_template_use_index_patterns_wildcard: Option<bool>,
    /// Optional, Enable Index Lifecycle Management (ILM)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIlm")]
    pub enable_ilm: Option<bool>,
    /// Optional, Indicates whether to fail when max_retry_putting_template is exceeded. If you have multiple output plugin, you could use this property to do not fail on fluentd statup (default: false)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOnPuttingTemplateRetryExceeded")]
    pub fail_on_putting_template_retry_exceeded: Option<bool>,
    /// The hostname of your Elasticsearch node (default: localhost).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Hosts defines a list of hosts if you want to connect to more than one Elasticsearch nodes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<String>,
    /// Optional, Specify ILM policy contents as Hash
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ilmPolicy")]
    pub ilm_policy: Option<String>,
    /// Optional, Specify ILM policy id
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ilmPolicyId")]
    pub ilm_policy_id: Option<String>,
    /// Optional, Specify whether overwriting ilm policy or not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ilmPolicyOverride")]
    pub ilm_policy_override: Option<bool>,
    /// Optional, Enable logging of 400 reason without enabling debug log level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logEs400Reason")]
    pub log_es400_reason: Option<bool>,
    /// Optional, You can specify times of retry putting template (default: 10)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetryPuttingTemplate")]
    pub max_retry_putting_template: Option<i32>,
    /// Optional, The login credentials to connect to Elasticsearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<OutputOutputsElasticsearchDataStreamPassword>,
    /// Path defines the REST API endpoint of Elasticsearch to post write requests (default: nil).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port number of your Elasticsearch node (default: 9200).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Optional, Indicates that the plugin should reset connection on any error (reconnect on next send) (default: false)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconnectOnError")]
    pub reconnect_on_error: Option<bool>,
    /// Optional, Automatically reload connection after 10000 documents (default: true)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reloadConnections")]
    pub reload_connections: Option<bool>,
    /// Optional, Indicates that the elasticsearch-transport will try to reload the nodes addresses if there is a failure while making the request, this can be useful to quickly remove a dead node from the list of addresses (default: false)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reloadOnFailure")]
    pub reload_on_failure: Option<bool>,
    /// Optional, HTTP Timeout (default: 5)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestTimeout")]
    pub request_timeout: Option<String>,
    /// Specify https if your Elasticsearch endpoint supports SSL (default: http).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
    /// Optional, Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslVerify")]
    pub ssl_verify: Option<bool>,
    /// Optional, Suppress '[types removal]' warnings on elasticsearch 7.x
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suppressTypeName")]
    pub suppress_type_name: Option<bool>,
    /// Optional, Always update the template, even if it already exists (default: false)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateOverwrite")]
    pub template_overwrite: Option<bool>,
    /// Optional, The login credentials to connect to Elasticsearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<OutputOutputsElasticsearchDataStreamUser>,
}

/// Optional, password for ClientKey file
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamClientKeyPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchDataStreamClientKeyPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamClientKeyPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchDataStreamClientKeyPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamClientKeyPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Authenticate towards Elastic Cloud using cloudAuth.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamCloudAuth {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchDataStreamCloudAuthValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamCloudAuthValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchDataStreamCloudAuthValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamCloudAuthValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Authenticate towards Elastic Cloud using CloudId. If set, cloudAuth must
/// be set as well and host, port, user and password are ignored.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamCloudId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchDataStreamCloudIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamCloudIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchDataStreamCloudIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamCloudIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Elasticsearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchDataStreamPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchDataStreamPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Elasticsearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsElasticsearchDataStreamUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsElasticsearchDataStreamUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsElasticsearchDataStreamUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// format section
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsFormat {
    /// Delimiter for each field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delimiter: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// If true, uses local time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Specify newline characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub newline: Option<OutputOutputsFormatNewline>,
    /// Output tag field if true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputTag")]
    pub output_tag: Option<bool>,
    /// Output time field if true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputTime")]
    pub output_time: Option<bool>,
    /// Process value according to the specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Uses the specified time format as a fallback in the specified order. You can parse undetermined time format by using time_format_fallbacks. This options is enabled when time_type is mixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormatFallbacks")]
    pub time_format_fallbacks: Option<String>,
    /// parses/formats value according to this type, default is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeType")]
    pub time_type: Option<OutputOutputsFormatTimeType>,
    /// Uses the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<OutputOutputsFormatType>,
    /// If true, uses UTC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub utc: Option<bool>,
}

/// format section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsFormatNewline {
    #[serde(rename = "lf")]
    Lf,
    #[serde(rename = "crlf")]
    Crlf,
}

/// format section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsFormatTimeType {
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "unixtime")]
    Unixtime,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "mixed")]
    Mixed,
}

/// format section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsFormatType {
    #[serde(rename = "out_file")]
    OutFile,
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "ltsv")]
    Ltsv,
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "msgpack")]
    Msgpack,
    #[serde(rename = "hash")]
    Hash,
    #[serde(rename = "single_value")]
    SingleValue,
}

/// out_forward plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForward {
    /// This option is used when require_ack_response is true. This default value is based on popular tcp_syn_retries.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResponseTimeout")]
    pub ack_response_timeout: Option<String>,
    /// The connection timeout for the socket. When the connection is timed out during the connection establishment, Errno::ETIMEDOUT error is raised.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Enable client-side DNS round robin. Uniform randomly pick an IP address to send data when a hostname has several IP addresses.
    /// heartbeat_type udp is not available with dns_round_robintrue. Use heartbeat_type tcp or heartbeat_type none.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsRoundRobin")]
    pub dns_round_robin: Option<bool>,
    /// Sets TTL to expire DNS cache in seconds. Set 0 not to use DNS Cache.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expireDnsCache")]
    pub expire_dns_cache: Option<String>,
    /// The hard timeout used to detect server failure. The default value is equal to the send_timeout parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hardTimeout")]
    pub hard_timeout: Option<String>,
    /// The interval of the heartbeat packer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "heartbeatInterval")]
    pub heartbeat_interval: Option<String>,
    /// Specifies the transport protocol for heartbeats. Set none to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "heartbeatType")]
    pub heartbeat_type: Option<OutputOutputsForwardHeartbeatType>,
    /// Ignores DNS resolution and errors at startup time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreNetworkErrorsAtStartup")]
    pub ignore_network_errors_at_startup: Option<bool>,
    /// Enables the keepalive connection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<bool>,
    /// Timeout for keepalive. Default value is nil which means to keep the connection alive as long as possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveTimeout")]
    pub keepalive_timeout: Option<String>,
    /// Use the "Phi accrual failure detector" to detect server failure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phiFailureDetector")]
    pub phi_failure_detector: Option<bool>,
    /// The threshold parameter used to detect server faults.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phiThreshold")]
    pub phi_threshold: Option<i64>,
    /// The wait time before accepting a server fault recovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoverWait")]
    pub recover_wait: Option<String>,
    /// Changes the protocol to at-least-once. The plugin waits the ack from destination's in_forward plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAckResponse")]
    pub require_ack_response: Option<bool>,
    /// ServiceDiscovery defines the security section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<OutputOutputsForwardSecurity>,
    /// The timeout time when sending event logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendTimeout")]
    pub send_timeout: Option<String>,
    /// Servers defines the servers section, at least one is required
    pub servers: Vec<OutputOutputsForwardServers>,
    /// ServiceDiscovery defines the service_discovery section
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDiscovery")]
    pub service_discovery: Option<OutputOutputsForwardServiceDiscovery>,
    /// Allows self-signed certificates or not.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsAllowSelfSignedCert")]
    pub tls_allow_self_signed_cert: Option<bool>,
    /// The certificate logical store name on Windows system certstore. This parameter is for Windows only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCertLogicalStoreName")]
    pub tls_cert_logical_store_name: Option<String>,
    /// The additional CA certificate path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCertPath")]
    pub tls_cert_path: Option<String>,
    /// The certificate thumbprint for searching from Windows system certstore. This parameter is for Windows only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCertThumbprint")]
    pub tls_cert_thumbprint: Option<String>,
    /// Enables the certificate enterprise store on Windows system certstore. This parameter is for Windows only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCertUseEnterpriseStore")]
    pub tls_cert_use_enterprise_store: Option<bool>,
    /// The cipher configuration of TLS transport.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCiphers")]
    pub tls_ciphers: Option<String>,
    /// The client certificate path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientCertPath")]
    pub tls_client_cert_path: Option<String>,
    /// The TLS private key passphrase for the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientPrivateKeyPassphrase")]
    pub tls_client_private_key_passphrase: Option<String>,
    /// The client private key path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientPrivateKeyPath")]
    pub tls_client_private_key_path: Option<String>,
    /// Skips all verification of certificates or not.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsInsecureMode")]
    pub tls_insecure_mode: Option<bool>,
    /// Verifies hostname of servers and certificates or not in TLS transport.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVerifyHostname")]
    pub tls_verify_hostname: Option<bool>,
    /// The default version of TLS transport.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVersion")]
    pub tls_version: Option<OutputOutputsForwardTlsVersion>,
    /// Verify that a connection can be made with one of out_forward nodes at the time of startup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verifyConnectionAtStartup")]
    pub verify_connection_at_startup: Option<bool>,
}

/// out_forward plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsForwardHeartbeatType {
    #[serde(rename = "transport")]
    Transport,
    #[serde(rename = "tcp")]
    Tcp,
    #[serde(rename = "udp")]
    Udp,
    #[serde(rename = "none")]
    None,
}

/// ServiceDiscovery defines the security section
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardSecurity {
    /// Allows the anonymous source. <client> sections are required, if disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowAnonymousSource")]
    pub allow_anonymous_source: Option<String>,
    /// The hostname.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfHostname")]
    pub self_hostname: Option<String>,
    /// The shared key for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedKey")]
    pub shared_key: Option<String>,
    /// Defines user section directly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<OutputOutputsForwardSecurityUser>,
    /// If true, user-based authentication is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userAuth")]
    pub user_auth: Option<String>,
}

/// Defines user section directly.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardSecurityUser {
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<OutputOutputsForwardSecurityUserPassword>,
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<OutputOutputsForwardSecurityUserUsername>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardSecurityUserPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsForwardSecurityUserPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardSecurityUserPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsForwardSecurityUserPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardSecurityUserPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardSecurityUserUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsForwardSecurityUserUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardSecurityUserUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsForwardSecurityUserUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardSecurityUserUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Server defines the common parameters for the server plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServers {
    /// Host defines the IP address or host name of the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Name defines the name of the server. Used for logging and certificate verification in TLS transport (when the host is the address).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Password defines the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<OutputOutputsForwardServersPassword>,
    /// Port defines the port number of the host. Note that both TCP packets (event stream) and UDP packets (heartbeat messages) are sent to this port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// SharedKey defines the shared key per server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedKey")]
    pub shared_key: Option<String>,
    /// Standby marks a node as the standby node for an Active-Standby model between Fluentd nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// Username defines the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<OutputOutputsForwardServersUsername>,
    /// Weight defines the load balancing weight
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<String>,
}

/// Password defines the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServersPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsForwardServersPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServersPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsForwardServersPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServersPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServersUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsForwardServersUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServersUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsForwardServersUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServersUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ServiceDiscovery defines the service_discovery section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct OutputOutputsForwardServiceDiscovery {
    /// The encoding of the configuration file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "confEncoding")]
    pub conf_encoding: Option<String>,
    /// DnsLookup resolves the hostname to IP address of the SRV's Target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsLookup")]
    pub dns_lookup: Option<String>,
    /// DnsServerHost defines the hostname of the DNS server to request the SRV record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsServerHost")]
    pub dns_server_host: Option<String>,
    /// The name in RFC2782.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Interval defines the interval of sending requests to DNS server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// The path of the target list. Default is '/etc/fluent/sd.yaml'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Proto without the underscore in RFC2782.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proto: Option<String>,
    /// The server section of this plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server: Option<OutputOutputsForwardServiceDiscoveryServer>,
    /// Service without the underscore in RFC2782.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(rename = "type")]
    pub r#type: OutputOutputsForwardServiceDiscoveryType,
}

/// The server section of this plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServiceDiscoveryServer {
    /// Host defines the IP address or host name of the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Name defines the name of the server. Used for logging and certificate verification in TLS transport (when the host is the address).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Password defines the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<OutputOutputsForwardServiceDiscoveryServerPassword>,
    /// Port defines the port number of the host. Note that both TCP packets (event stream) and UDP packets (heartbeat messages) are sent to this port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// SharedKey defines the shared key per server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedKey")]
    pub shared_key: Option<String>,
    /// Standby marks a node as the standby node for an Active-Standby model between Fluentd nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// Username defines the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<OutputOutputsForwardServiceDiscoveryServerUsername>,
    /// Weight defines the load balancing weight
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<String>,
}

/// Password defines the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServiceDiscoveryServerPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsForwardServiceDiscoveryServerPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServiceDiscoveryServerPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsForwardServiceDiscoveryServerPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServiceDiscoveryServerPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServiceDiscoveryServerUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsForwardServiceDiscoveryServerUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServiceDiscoveryServerUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsForwardServiceDiscoveryServerUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsForwardServiceDiscoveryServerUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ServiceDiscovery defines the service_discovery section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsForwardServiceDiscoveryType {
    #[serde(rename = "static")]
    Static,
    #[serde(rename = "file")]
    File,
    #[serde(rename = "srv")]
    Srv,
}

/// out_forward plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsForwardTlsVersion {
    #[serde(rename = "TLSv1_1")]
    TlSv11,
    #[serde(rename = "TLSv1_2")]
    TlSv12,
}

/// out_http plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsHttp {
    /// Auth section for this plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<OutputOutputsHttpAuth>,
    /// ContentType defines Content-Type for HTTP request. out_http automatically set Content-Type for built-in formatters when this parameter is not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<String>,
    /// Endpoint defines the endpoint for HTTP request. If you want to use HTTPS, use https prefix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Raise UnrecoverableError when the response code is not SUCCESS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorResponseAsUnrecoverable")]
    pub error_response_as_unrecoverable: Option<bool>,
    /// Headers defines the additional headers for HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<String>,
    /// Additional placeholder based headers for HTTP request. If you want to use tag or record field, use this parameter instead of headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headersFromPlaceholders")]
    pub headers_from_placeholders: Option<String>,
    /// HttpMethod defines the method for HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpMethod")]
    pub http_method: Option<OutputOutputsHttpHttpMethod>,
    /// JsonArray defines whether to use the array format of JSON or not
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonArray")]
    pub json_array: Option<bool>,
    /// OpenTimeout defines the connection open timeout in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openTimeout")]
    pub open_timeout: Option<i64>,
    /// Proxy defines the proxy for HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<String>,
    /// ReadTimeout defines the read timeout in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readTimeout")]
    pub read_timeout: Option<i64>,
    /// The list of retryable response codes. If the response code is included in this list, out_http retries the buffer flush.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryableResponseCodes")]
    pub retryable_response_codes: Option<String>,
    /// SslTimeout defines the TLS timeout in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslTimeout")]
    pub ssl_timeout: Option<i64>,
    /// TlsCaCertPath defines the CA certificate path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCaCertPath")]
    pub tls_ca_cert_path: Option<String>,
    /// TlsCiphers defines the cipher suites configuration of TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCiphers")]
    pub tls_ciphers: Option<String>,
    /// TlsClientCertPath defines the client certificate path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientCertPath")]
    pub tls_client_cert_path: Option<String>,
    /// TlsPrivateKeyPassphrase defines the client private key passphrase for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPrivateKeyPassphrase")]
    pub tls_private_key_passphrase: Option<String>,
    /// TlsPrivateKeyPath defines the client private key path for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPrivateKeyPath")]
    pub tls_private_key_path: Option<String>,
    /// TlsVerifyMode defines the verify mode of TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVerifyMode")]
    pub tls_verify_mode: Option<OutputOutputsHttpTlsVerifyMode>,
    /// TlsVersion defines the default version of TLS transport.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVersion")]
    pub tls_version: Option<OutputOutputsHttpTlsVersion>,
}

/// Auth section for this plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsHttpAuth {
    /// The method for HTTP authentication. Now only basic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<String>,
    /// The password for basic authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<OutputOutputsHttpAuthPassword>,
    /// The username for basic authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<OutputOutputsHttpAuthUsername>,
}

/// The password for basic authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsHttpAuthPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsHttpAuthPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsHttpAuthPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsHttpAuthPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsHttpAuthPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The username for basic authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsHttpAuthUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsHttpAuthUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsHttpAuthUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsHttpAuthUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsHttpAuthUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsHttpHttpMethod {
    #[serde(rename = "post")]
    Post,
    #[serde(rename = "put")]
    Put,
}

/// out_http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsHttpTlsVerifyMode {
    #[serde(rename = "peer")]
    Peer,
    #[serde(rename = "none")]
    None,
}

/// out_http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsHttpTlsVersion {
    #[serde(rename = "TLSv1_1")]
    TlSv11,
    #[serde(rename = "TLSv1_2")]
    TlSv12,
}

/// inject section
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsInject {
    /// Hostname value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// The field name to inject hostname
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostnameKey")]
    pub hostname_key: Option<String>,
    /// Time section
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inline: Option<OutputOutputsInjectInline>,
    /// The field name to inject tag
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagKey")]
    pub tag_key: Option<String>,
    /// The field name to inject time
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// The field name to inject worker_id
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workerIdKey")]
    pub worker_id_key: Option<String>,
}

/// Time section
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsInjectInline {
    /// If true, uses local time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    /// Process value according to the specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Uses the specified time format as a fallback in the specified order. You can parse undetermined time format by using time_format_fallbacks. This options is enabled when time_type is mixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormatFallbacks")]
    pub time_format_fallbacks: Option<String>,
    /// parses/formats value according to this type, default is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeType")]
    pub time_type: Option<OutputOutputsInjectInlineTimeType>,
    /// Uses the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
    /// If true, uses UTC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub utc: Option<bool>,
}

/// Time section
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsInjectInlineTimeType {
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "unixtime")]
    Unixtime,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "mixed")]
    Mixed,
}

/// out_kafka plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsKafka {
    /// The list of all seed brokers, with their host and port information. Default: localhost:9092
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub brokers: Option<String>,
    /// The codec the producer uses to compress messages (default: nil).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionCodec")]
    pub compression_codec: Option<OutputOutputsKafkaCompressionCodec>,
    /// The name of the default topic. (default: nil)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultTopic")]
    pub default_topic: Option<String>,
    /// The number of acks required per request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredAcks")]
    pub required_acks: Option<i64>,
    /// The field name for the target topic. If the field value is app, this plugin writes events to the app topic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicKey")]
    pub topic_key: Option<String>,
    /// Set fluentd event time to Kafka's CreateTime.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useEventTime")]
    pub use_event_time: Option<bool>,
}

/// out_kafka plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsKafkaCompressionCodec {
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "snappy")]
    Snappy,
}

/// out_loki plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLoki {
    /// Set path to file with bearer authentication token
    /// Can be used as alterntative to HTTP basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenFile")]
    pub bearer_token_file: Option<String>,
    /// If a record only has 1 key, then just set the log line to the value and discard the key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropSingleKey")]
    pub drop_single_key: Option<bool>,
    /// If set to true, it will add all Kubernetes labels to the Stream labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extractKubernetesLabels")]
    pub extract_kubernetes_labels: Option<bool>,
    /// Password for user defined in HTTP_User
    /// Set HTTP basic authentication password
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPassword")]
    pub http_password: Option<OutputOutputsLokiHttpPassword>,
    /// Set HTTP basic authentication user name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpUser")]
    pub http_user: Option<OutputOutputsLokiHttpUser>,
    /// Whether or not to include the fluentd_thread label when multiple threads are used for flushing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeThreadLabel")]
    pub include_thread_label: Option<bool>,
    /// Disable certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// Optional list of record keys that will be placed as stream labels.
    /// This configuration property is for records key only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelKeys")]
    pub label_keys: Option<Vec<String>>,
    /// Stream labels for API request. It can be multiple comma separated of strings specifying  key=value pairs.
    /// In addition to fixed parameters, it also allows to add custom record keys (similar to label_keys property).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<Vec<String>>,
    /// Format to use when flattening the record to a log line. Valid values are json or key_value.
    /// If set to json,  the log line sent to Loki will be the Fluentd record dumped as JSON.
    /// If set to key_value, the log line will be each item in the record concatenated together (separated by a single space) in the format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lineFormat")]
    pub line_format: Option<OutputOutputsLokiLineFormat>,
    /// Optional list of record keys that will be removed from stream labels.
    /// This configuration property is for records key only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeKeys")]
    pub remove_keys: Option<Vec<String>>,
    /// Tenant ID used by default to push logs to Loki.
    /// If omitted or empty it assumes Loki is running in single-tenant mode and no X-Scope-OrgID header is sent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantID")]
    pub tenant_id: Option<OutputOutputsLokiTenantId>,
    /// TlsCaCert defines the CA certificate file for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsCaCertFile")]
    pub tls_ca_cert_file: Option<String>,
    /// TlsClientCert defines the client certificate file for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsClientCertFile")]
    pub tls_client_cert_file: Option<String>,
    /// TlsPrivateKey defines the client private key file for TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPrivateKeyFile")]
    pub tls_private_key_file: Option<String>,
    /// Loki URL.
    pub url: String,
}

/// Password for user defined in HTTP_User
/// Set HTTP basic authentication password
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLokiHttpPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsLokiHttpPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLokiHttpPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsLokiHttpPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLokiHttpPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Set HTTP basic authentication user name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLokiHttpUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsLokiHttpUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLokiHttpUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsLokiHttpUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLokiHttpUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_loki plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsLokiLineFormat {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "key_value")]
    KeyValue,
}

/// Tenant ID used by default to push logs to Loki.
/// If omitted or empty it assumes Loki is running in single-tenant mode and no X-Scope-OrgID header is sent.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLokiTenantId {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsLokiTenantIdValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLokiTenantIdValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsLokiTenantIdValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsLokiTenantIdValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_opensearch plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsOpensearch {
    /// The hostname of your Opensearch node (default: localhost).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Hosts defines a list of hosts if you want to connect to more than one Openearch nodes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<String>,
    /// IndexName defines the placeholder syntax of Fluentd plugin API. See https://docs.fluentd.org/configuration/buffer-section.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexName")]
    pub index_name: Option<String>,
    /// If true, Fluentd uses the conventional index name format logstash-%Y.%m.%d (default: false). This option supersedes the index_name option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashFormat")]
    pub logstash_format: Option<bool>,
    /// LogstashPrefix defines the logstash prefix index name to write events when logstash_format is true (default: logstash).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logstashPrefix")]
    pub logstash_prefix: Option<String>,
    /// Optional, The login credentials to connect to Opensearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<OutputOutputsOpensearchPassword>,
    /// Path defines the REST API endpoint of Opensearch to post write requests (default: nil).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port number of your Opensearch node (default: 9200).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Specify https if your Opensearch endpoint supports SSL (default: http).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
    /// Optional, Force certificate validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslVerify")]
    pub ssl_verify: Option<bool>,
    /// Optional, The login credentials to connect to Opensearch
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<OutputOutputsOpensearchUser>,
}

/// Optional, The login credentials to connect to Opensearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsOpensearchPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsOpensearchPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsOpensearchPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsOpensearchPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsOpensearchPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional, The login credentials to connect to Opensearch
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsOpensearchUser {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<OutputOutputsOpensearchUserValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsOpensearchUserValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<OutputOutputsOpensearchUserValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsOpensearchUserValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// out_s3 plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsS3 {
    /// The AWS access key id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsKeyId")]
    pub aws_key_id: Option<String>,
    /// The AWS secret key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsSecKey")]
    pub aws_sec_key: Option<String>,
    /// This prevents AWS SDK from breaking endpoint URL
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forcePathStyle")]
    pub force_path_style: Option<bool>,
    /// The path prefix of the files on S3.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The proxy URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUri")]
    pub proxy_uri: Option<String>,
    /// The Amazon S3 bucket name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Bucket")]
    pub s3_bucket: Option<String>,
    /// The endpoint URL (like "http://localhost:9000/")
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Endpoint")]
    pub s3_endpoint: Option<String>,
    /// The actual S3 path. This is interpolated to the actual path.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3ObjectKeyFormat")]
    pub s3_object_key_format: Option<String>,
    /// The Amazon S3 region name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3Region")]
    pub s3_region: Option<String>,
    /// The AWS KMS enctyption algorithm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sseCustomerAlgorithm")]
    pub sse_customer_algorithm: Option<String>,
    /// The AWS KMS key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sseCustomerKey")]
    pub sse_customer_key: Option<String>,
    /// The AWS KMS key MD5.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sseCustomerKeyMd5")]
    pub sse_customer_key_md5: Option<String>,
    /// The AWS KMS key ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ssekmsKeyId")]
    pub ssekms_key_id: Option<String>,
    /// Verify the SSL certificate of the endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslVerifyPeer")]
    pub ssl_verify_peer: Option<bool>,
    /// The compression type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storeAs")]
    pub store_as: Option<OutputOutputsS3StoreAs>,
    /// This timestamp is added to each file name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeSliceFormat")]
    pub time_slice_format: Option<String>,
    /// the following parameters are for S3 kms https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useServerSideEncryption")]
    pub use_server_side_encryption: Option<String>,
}

/// out_s3 plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum OutputOutputsS3StoreAs {
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "lzo")]
    Lzo,
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "txt")]
    Txt,
}

/// out_stdout plugin
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputOutputsStdout {
}

/// OutputStatus defines the observed state of Output
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OutputStatus {
}

