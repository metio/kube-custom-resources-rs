// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/fluent/fluent-operator/fluentd.fluent.io/v1alpha1/inputs.yaml --derive=PartialEq
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// InputSpec defines the desired state of Input
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "fluentd.fluent.io", version = "v1alpha1", kind = "Input", plural = "inputs")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct InputSpec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inputs: Option<Vec<InputInputs>>,
}

/// Input defines all available input plugins and their parameters
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputs {
    /// Custom plugin type
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customPlugin")]
    pub custom_plugin: Option<InputInputsCustomPlugin>,
    /// in_forward plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub forward: Option<InputInputsForward>,
    /// in_http plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<InputInputsHttp>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The @label parameter is to route the input events to <label> sections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// monitor_agent plugin
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitorAgent")]
    pub monitor_agent: Option<InputInputsMonitorAgent>,
    /// in_sample plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sample: Option<InputInputsSample>,
    /// in_tail plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tail: Option<InputInputsTail>,
}

/// Custom plugin type
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsCustomPlugin {
    pub config: String,
}

/// in_forward plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForward {
    /// Adds the prefix to the incoming event's tag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addTagPrefix")]
    pub add_tag_prefix: Option<String>,
    /// The port to listen to, default is "0.0.0.0"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bind: Option<String>,
    /// The size limit of the received chunk. If the chunk size is larger than this value, the received chunk is dropped.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chunkSizeLimit")]
    pub chunk_size_limit: Option<String>,
    /// The warning size limit of the received chunk. If the chunk size is larger than this value, a warning message will be sent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chunkSizeWarnLimit")]
    pub chunk_size_warn_limit: Option<String>,
    /// The security section of client plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client: Option<InputInputsForwardClient>,
    /// The connections will be disconnected right after receiving a message, if true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyKeepalive")]
    pub deny_keepalive: Option<bool>,
    /// The timeout used to set the linger option.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lingerTimeout")]
    pub linger_timeout: Option<i64>,
    /// The port to listen to, default is 24224.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Tries to resolve hostname from IP addresses or not.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resolveHostname")]
    pub resolve_hostname: Option<bool>,
    /// The security section of forward plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<InputInputsForwardSecurity>,
    /// Enables the TCP keepalive for sockets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendKeepalivePacket")]
    pub send_keepalive_packet: Option<bool>,
    /// Skips the invalid incoming event.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipInvalidEvent")]
    pub skip_invalid_event: Option<bool>,
    /// The field name of the client's source address. If set, the client's address will be set to its key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceAddressKey")]
    pub source_address_key: Option<String>,
    /// The field name of the client's hostname. If set, the client's hostname will be set to its key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceHostnameKey")]
    pub source_hostname_key: Option<String>,
    /// in_forward uses incoming event's tag by default (See Protocol Section). If the tag parameter is set, its value is used instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
    /// The transport section of forward plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transport: Option<InputInputsForwardTransport>,
    /// The security section of user plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<InputInputsForwardUser>,
}

/// The security section of client plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardClient {
    /// The IP address or hostname of the client. This is exclusive with Network.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The network address specification. This is exclusive with Host.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// The shared key per client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedKey")]
    pub shared_key: Option<String>,
    /// The array of usernames.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<String>,
}

/// The security section of forward plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardSecurity {
    /// Allows the anonymous source. <client> sections are required, if disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowAnonymousSource")]
    pub allow_anonymous_source: Option<String>,
    /// The hostname.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selfHostname")]
    pub self_hostname: Option<String>,
    /// The shared key for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedKey")]
    pub shared_key: Option<String>,
    /// Defines user section directly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<InputInputsForwardSecurityUser>,
    /// If true, user-based authentication is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userAuth")]
    pub user_auth: Option<String>,
}

/// Defines user section directly.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardSecurityUser {
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<InputInputsForwardSecurityUserPassword>,
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<InputInputsForwardSecurityUserUsername>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardSecurityUserPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<InputInputsForwardSecurityUserPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardSecurityUserPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<InputInputsForwardSecurityUserPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardSecurityUserPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardSecurityUserUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<InputInputsForwardSecurityUserUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardSecurityUserUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<InputInputsForwardSecurityUserUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardSecurityUserUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The transport section of forward plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardTransport {
    /// for Cert generated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertPath")]
    pub ca_cert_path: Option<String>,
    /// for Cert signed by public CA
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPrivateKeyPassphrase")]
    pub ca_private_key_passphrase: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPrivateKeyPath")]
    pub ca_private_key_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certPath")]
    pub cert_path: Option<String>,
    /// other parameters
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certVerifier")]
    pub cert_verifier: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ciphers: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertAuth")]
    pub client_cert_auth: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyPassphrase")]
    pub private_key_passphrase: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyPath")]
    pub private_key_path: Option<String>,
    /// The protocal name of this plugin, i.e: tls
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// The security section of user plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardUser {
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<InputInputsForwardUserPassword>,
    /// Secret defines the key of a value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<InputInputsForwardUserUsername>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardUserPassword {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<InputInputsForwardUserPasswordValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardUserPasswordValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<InputInputsForwardUserPasswordValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardUserPasswordValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret defines the key of a value.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardUserUsername {
    /// ValueSource defines how to find a value's key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<InputInputsForwardUserUsernameValueFrom>,
}

/// ValueSource defines how to find a value's key.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardUserUsernameValueFrom {
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<InputInputsForwardUserUsernameValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsForwardUserUsernameValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// in_http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsHttp {
    /// Adds HTTP_ prefix headers to the record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addHttpHeaders")]
    pub add_http_headers: Option<bool>,
    /// Adds REMOTE_ADDR field to the record. The value of REMOTE_ADDR is the client's address. i.e: X-Forwarded-For: host1, host2
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addRemoteAddr")]
    pub add_remote_addr: Option<String>,
    /// The port to listen to, default is "0.0.0.0"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bind: Option<String>,
    /// The size limit of the POSTed element.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodySizeLimit")]
    pub body_size_limit: Option<String>,
    /// Whitelist domains for CORS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsAllOrigins")]
    pub cors_all_origins: Option<String>,
    /// Add Access-Control-Allow-Credentials header. It's needed when a request's credentials mode is include
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsAllowCredentials")]
    pub cors_allow_credentials: Option<String>,
    /// The timeout limit for keeping the connection alive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepaliveTimeout")]
    pub keepalive_timeout: Option<String>,
    /// The parse section of http plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<InputInputsHttpParse>,
    /// The port to listen to, default is 9880.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Responds with an empty GIF image of 1x1 pixel (rather than an empty string).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "respondsWithEmptyImg")]
    pub responds_with_empty_img: Option<bool>,
    /// The transport section of http plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transport: Option<InputInputsHttpTransport>,
}

/// The parse section of http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsHttpParse {
    /// Path to the file that includes custom grok patterns.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customPatternPath")]
    pub custom_pattern_path: Option<String>,
    /// If true, use Fluent::Eventnow(current time) as a timestamp when time_key is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "estimateCurrentEvent")]
    pub estimate_current_event: Option<bool>,
    /// Specifies the regular expression for matching logs. Regular expression also supports i and m suffix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Grok Sections
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grok: Option<Vec<InputInputsHttpParseGrok>>,
    /// The key has grok failure reason.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grokFailureKey")]
    pub grok_failure_key: Option<String>,
    /// The pattern of grok.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grokPattern")]
    pub grok_pattern: Option<String>,
    /// Specify grok pattern series set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grokPatternSeries")]
    pub grok_pattern_series: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// If true, keep time field in th record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepTimeKey")]
    pub keep_time_key: Option<bool>,
    /// If true, uses local time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// The regexp to match beginning of multiline. This is only for "multiline_grok".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multiLineStartRegexp")]
    pub multi_line_start_regexp: Option<String>,
    /// Process value according to the specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Uses the specified time format as a fallback in the specified order. You can parse undetermined time format by using time_format_fallbacks. This options is enabled when time_type is mixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormatFallbacks")]
    pub time_format_fallbacks: Option<String>,
    /// Specify time field for event time. If the event doesn't have this field, current time is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// parses/formats value according to this type, default is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeType")]
    pub time_type: Option<InputInputsHttpParseTimeType>,
    /// Specify timeout for parse processing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
    /// Uses the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(rename = "type")]
    pub r#type: InputInputsHttpParseType,
    /// Specify types for converting field into another, i.e: types user_id:integer,paid:bool,paid_usd_amount:float
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub types: Option<String>,
    /// If true, uses UTC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub utc: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsHttpParseGrok {
    /// If true, keep time field in the record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepTimeKey")]
    pub keep_time_key: Option<bool>,
    /// The name of this grok section.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The pattern of grok. Required parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    /// Process value using specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Specify time field for event time. If the event doesn't have this field, current time is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// Use specified timezone. one can parse/format the time value in the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    pub time_zone: Option<String>,
}

/// The parse section of http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum InputInputsHttpParseTimeType {
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "unixtime")]
    Unixtime,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "mixed")]
    Mixed,
}

/// The parse section of http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum InputInputsHttpParseType {
    #[serde(rename = "regexp")]
    Regexp,
    #[serde(rename = "apache2")]
    Apache2,
    #[serde(rename = "apache_error")]
    ApacheError,
    #[serde(rename = "nginx")]
    Nginx,
    #[serde(rename = "syslog")]
    Syslog,
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
    #[serde(rename = "ltsv")]
    Ltsv,
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "multiline")]
    Multiline,
    #[serde(rename = "none")]
    None,
    #[serde(rename = "grok")]
    Grok,
    #[serde(rename = "multiline_grok")]
    MultilineGrok,
}

/// The transport section of http plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsHttpTransport {
    /// for Cert generated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertPath")]
    pub ca_cert_path: Option<String>,
    /// for Cert signed by public CA
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPath")]
    pub ca_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPrivateKeyPassphrase")]
    pub ca_private_key_passphrase: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caPrivateKeyPath")]
    pub ca_private_key_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certPath")]
    pub cert_path: Option<String>,
    /// other parameters
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certVerifier")]
    pub cert_verifier: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ciphers: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertAuth")]
    pub client_cert_auth: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyPassphrase")]
    pub private_key_passphrase: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyPath")]
    pub private_key_path: Option<String>,
    /// The protocal name of this plugin, i.e: tls
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// monitor_agent plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsMonitorAgent {
    /// The bind address to listen to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bind: Option<String>,
    /// The interval time between event emits. This will be used when "tag" is configured.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emitInterval")]
    pub emit_interval: Option<i64>,
    /// You can set this option to false to remove the config field from the response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeConfig")]
    pub include_config: Option<bool>,
    /// You can set this option to false to remove the retry field from the response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeRetry")]
    pub include_retry: Option<bool>,
    /// The port to listen to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// If you set this parameter, this plugin emits metrics as records.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

/// in_sample plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsSample {
    /// If specified, each generated event has an auto-incremented key field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoIncrementKey")]
    pub auto_increment_key: Option<String>,
    /// It configures how many events to generate per second.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rate: Option<i64>,
    /// The sample data to be generated. It should be either an array of JSON hashes or a single JSON hash. If it is an array of JSON hashes, the hashes in the array are cycled through in order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sample: Option<String>,
    /// The number of events in the event stream of each emit.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<i64>,
    /// The tag of the event. The value is the tag assigned to the generated events.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

/// in_tail plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsTail {
    /// Emits unmatched lines when <parse> format is not matched for incoming logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emitUnmatchedLines")]
    pub emit_unmatched_lines: Option<bool>,
    /// Enables the additional inotify-based watcher. Setting this parameter to false will disable the inotify events and use only timer watcher for file tailing. This option is mainly for avoiding the stuck issue with inotify.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableStatWatcher")]
    pub enable_stat_watcher: Option<bool>,
    /// Enables the additional watch timer. Setting this parameter to false will significantly reduce CPU and I/O consumption when tailing a large number of files on systems with inotify support. The default is true which results in an additional 1 second timer being used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableWatchTimer")]
    pub enable_watch_timer: Option<bool>,
    /// Specifies the encoding of reading lines. By default, in_tail emits string value as ASCII-8BIT encoding. If encoding is specified, in_tail changes string to encoding. If encoding and fromEncoding both are specified, in_tail tries to encode string from fromEncoding to encoding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encoding: Option<String>,
    /// The paths excluded from the watcher list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludePath")]
    pub exclude_path: Option<Vec<String>>,
    /// Avoid to read rotated files duplicately. You should set true when you use * or strftime format in path.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followInodes")]
    pub follow_inodes: Option<bool>,
    /// Specifies the encoding of reading lines. By default, in_tail emits string value as ASCII-8BIT encoding. If encoding is specified, in_tail changes string to encoding. If encoding and fromEncoding both are specified, in_tail tries to encode string from fromEncoding to encoding.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEncoding")]
    pub from_encoding: Option<String>,
    /// The in_tail plugin can assign each log file to a group, based on user defined rules. The limit parameter controls the total number of lines collected for a group within a rate_period time interval.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<InputInputsTailGroup>,
    /// If you have to exclude the non-permission files from the watch list, set this parameter to true. It suppresses the repeated permission error logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreRepeatedPermissionError")]
    pub ignore_repeated_permission_error: Option<bool>,
    /// Limits the watching files that the modification time is within the specified time range when using * in path.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "limitRecentlyModified")]
    pub limit_recently_modified: Option<i32>,
    /// The maximum length of a line. Longer lines than it will be just skipped.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLineSize")]
    pub max_line_size: Option<i32>,
    /// The interval of flushing the buffer for multiline format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multilineFlushInterval")]
    pub multiline_flush_interval: Option<i32>,
    /// Opens and closes the file on every update instead of leaving it open until it gets rotated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openOnEveryUpdate")]
    pub open_on_every_update: Option<bool>,
    /// Parse defines various parameters for the parse plugin
    pub parse: InputInputsTailParse,
    /// The path(s) to read. Multiple paths can be specified, separated by comma ','.
    pub path: String,
    /// Adds the watching file path to the path_key field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathKey")]
    pub path_key: Option<String>,
    /// This parameter is for strftime formatted path like /path/to/%Y/%m/%d/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathTimezone")]
    pub path_timezone: Option<String>,
    /// (recommended) Fluentd will record the position it last read from this file. pos_file handles multiple positions in one file so no need to have multiple pos_file parameters per source. Don't share pos_file between in_tail configurations. It causes unexpected behavior e.g. corrupt pos_file content.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "posFile")]
    pub pos_file: Option<String>,
    /// The interval of doing compaction of pos file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "posFileCompactionInterval")]
    pub pos_file_compaction_interval: Option<i32>,
    /// The number of reading bytes per second to read with I/O operation. This value should be equal or greater than 8192.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readBytesLimitPerSecond")]
    pub read_bytes_limit_per_second: Option<i32>,
    /// Starts to read the logs from the head of the file or the last read position recorded in pos_file, not tail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readFromHead")]
    pub read_from_head: Option<bool>,
    /// The number of lines to read with each I/O operation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLinesLimit")]
    pub read_lines_limit: Option<i32>,
    /// The interval to refresh the list of watch files. This is used when the path includes *.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<i32>,
    /// in_tail actually does a bit more than tail -F itself. When rotating a file, some data may still need to be written to the old file as opposed to the new one. in_tail takes care of this by keeping a reference to the old file (even after it has been rotated) for some time before transitioning completely to the new file. This helps prevent data designated for the old file from getting lost. By default, this time interval is 5 seconds. The rotate_wait parameter accepts a single integer representing the number of seconds you want this time interval to be.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rotateWait")]
    pub rotate_wait: Option<i32>,
    /// Skips the refresh of the watch list on startup. This reduces the startup time when * is used in path.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipRefreshOnStartup")]
    pub skip_refresh_on_startup: Option<bool>,
    /// The tag of the event.
    pub tag: String,
}

/// The in_tail plugin can assign each log file to a group, based on user defined rules. The limit parameter controls the total number of lines collected for a group within a rate_period time interval.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsTailGroup {
    /// Specifies the regular expression for extracting metadata (namespace, podname) from log file path. Default value of the pattern regexp extracts information about namespace, podname, docker_id, container of the log (K8s specific).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    /// Time period in which the group line limit is applied. in_tail resets the counter after every rate_period interval.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ratePeriod")]
    pub rate_period: Option<i32>,
    /// Grouping rules for log files.
    pub rule: InputInputsTailGroupRule,
}

/// Grouping rules for log files.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsTailGroupRule {
    /// Maximum number of lines allowed from a group in rate_period time interval. The default value of -1 doesn't throttle log files of that group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limit: Option<i32>,
    /// match parameter is used to check if a file belongs to a particular group based on hash keys (named captures from pattern) and hash values (regexp in string)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<BTreeMap<String, String>>,
}

/// Parse defines various parameters for the parse plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsTailParse {
    /// Path to the file that includes custom grok patterns.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customPatternPath")]
    pub custom_pattern_path: Option<String>,
    /// If true, use Fluent::Eventnow(current time) as a timestamp when time_key is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "estimateCurrentEvent")]
    pub estimate_current_event: Option<bool>,
    /// Specifies the regular expression for matching logs. Regular expression also supports i and m suffix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Grok Sections
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grok: Option<Vec<InputInputsTailParseGrok>>,
    /// The key has grok failure reason.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grokFailureKey")]
    pub grok_failure_key: Option<String>,
    /// The pattern of grok.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grokPattern")]
    pub grok_pattern: Option<String>,
    /// Specify grok pattern series set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grokPatternSeries")]
    pub grok_pattern_series: Option<String>,
    /// The @id parameter specifies a unique name for the configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// If true, keep time field in th record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepTimeKey")]
    pub keep_time_key: Option<bool>,
    /// If true, uses local time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub localtime: Option<bool>,
    /// The @log_level parameter specifies the plugin-specific logging level
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// The regexp to match beginning of multiline. This is only for "multiline_grok".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multiLineStartRegexp")]
    pub multi_line_start_regexp: Option<String>,
    /// Process value according to the specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Uses the specified time format as a fallback in the specified order. You can parse undetermined time format by using time_format_fallbacks. This options is enabled when time_type is mixed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormatFallbacks")]
    pub time_format_fallbacks: Option<String>,
    /// Specify time field for event time. If the event doesn't have this field, current time is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// parses/formats value according to this type, default is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeType")]
    pub time_type: Option<InputInputsTailParseTimeType>,
    /// Specify timeout for parse processing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
    /// Uses the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
    /// The @type parameter specifies the type of the plugin.
    #[serde(rename = "type")]
    pub r#type: InputInputsTailParseType,
    /// Specify types for converting field into another, i.e: types user_id:integer,paid:bool,paid_usd_amount:float
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub types: Option<String>,
    /// If true, uses UTC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub utc: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputInputsTailParseGrok {
    /// If true, keep time field in the record.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepTimeKey")]
    pub keep_time_key: Option<bool>,
    /// The name of this grok section.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The pattern of grok. Required parameter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    /// Process value using specified format. This is available only when time_type is string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeFormat")]
    pub time_format: Option<String>,
    /// Specify time field for event time. If the event doesn't have this field, current time is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeKey")]
    pub time_key: Option<String>,
    /// Use specified timezone. one can parse/format the time value in the specified timezone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    pub time_zone: Option<String>,
}

/// Parse defines various parameters for the parse plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum InputInputsTailParseTimeType {
    #[serde(rename = "float")]
    Float,
    #[serde(rename = "unixtime")]
    Unixtime,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "mixed")]
    Mixed,
}

/// Parse defines various parameters for the parse plugin
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum InputInputsTailParseType {
    #[serde(rename = "regexp")]
    Regexp,
    #[serde(rename = "apache2")]
    Apache2,
    #[serde(rename = "apache_error")]
    ApacheError,
    #[serde(rename = "nginx")]
    Nginx,
    #[serde(rename = "syslog")]
    Syslog,
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
    #[serde(rename = "ltsv")]
    Ltsv,
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "multiline")]
    Multiline,
    #[serde(rename = "none")]
    None,
    #[serde(rename = "grok")]
    Grok,
    #[serde(rename = "multiline_grok")]
    MultilineGrok,
}

/// InputStatus defines the observed state of Input
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct InputStatus {
}

