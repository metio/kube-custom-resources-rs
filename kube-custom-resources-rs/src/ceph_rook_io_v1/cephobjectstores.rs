// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/rook/rook/ceph.rook.io/v1/cephobjectstores.yaml --derive=Default --derive=PartialEq
// kopium version: 0.16.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// ObjectStoreSpec represent the spec of a pool
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "ceph.rook.io", version = "v1", kind = "CephObjectStore", plural = "cephobjectstores")]
#[kube(namespaced)]
#[kube(status = "CephObjectStoreStatus")]
#[kube(schema = "disabled")]
pub struct CephObjectStoreSpec {
    /// The list of allowed namespaces in addition to the object store namespace where ceph object store users may be created. Specify "*" to allow all namespaces, otherwise list individual namespaces that are to be allowed. This is useful for applications that need object store credentials to be created in their own namespace, where neither OBCs nor COSI is being used to create buckets. The default is empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowUsersInNamespaces")]
    pub allow_users_in_namespaces: Option<Vec<String>>,
    /// The data pool settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataPool")]
    pub data_pool: Option<CephObjectStoreDataPool>,
    /// The rgw pod info
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<CephObjectStoreGateway>,
    /// The RGW health probes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<CephObjectStoreHealthCheck>,
    /// The metadata pool settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataPool")]
    pub metadata_pool: Option<CephObjectStoreMetadataPool>,
    /// Preserve pools on object store deletion
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preservePoolsOnDelete")]
    pub preserve_pools_on_delete: Option<bool>,
    /// Security represents security settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<CephObjectStoreSecurity>,
    /// The multisite info
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<CephObjectStoreZone>,
}

/// The data pool settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPool {
    /// DEPRECATED: use Parameters instead, e.g., Parameters["compression_mode"] = "force" The inline compression mode in Bluestore OSD to set to (options are: none, passive, aggressive, force) Do NOT set a default value for kubebuilder as this will override the Parameters
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionMode")]
    pub compression_mode: Option<CephObjectStoreDataPoolCompressionMode>,
    /// The root of the crush hierarchy utilized by the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crushRoot")]
    pub crush_root: Option<String>,
    /// The device class the OSD should set to for use in the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceClass")]
    pub device_class: Option<String>,
    /// EnableRBDStats is used to enable gathering of statistics for all RBD images in the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRBDStats")]
    pub enable_rbd_stats: Option<bool>,
    /// The erasure code settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "erasureCoded")]
    pub erasure_coded: Option<CephObjectStoreDataPoolErasureCoded>,
    /// The failure domain: osd/host/(region or zone if available) - technically also any type in the crush map
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomain")]
    pub failure_domain: Option<String>,
    /// The mirroring settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirroring: Option<CephObjectStoreDataPoolMirroring>,
    /// Parameters is a list of properties to enable on a given pool
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<BTreeMap<String, String>>,
    /// The quota settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quotas: Option<CephObjectStoreDataPoolQuotas>,
    /// The replication settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicated: Option<CephObjectStoreDataPoolReplicated>,
    /// The mirroring statusCheck
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusCheck")]
    pub status_check: Option<CephObjectStoreDataPoolStatusCheck>,
}

/// The data pool settings
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephObjectStoreDataPoolCompressionMode {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "passive")]
    Passive,
    #[serde(rename = "aggressive")]
    Aggressive,
    #[serde(rename = "force")]
    Force,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// The erasure code settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolErasureCoded {
    /// The algorithm for erasure coding
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<String>,
    /// Number of coding chunks per object in an erasure coded storage pool (required for erasure-coded pool type). This is the number of OSDs that can be lost simultaneously before data cannot be recovered.
    #[serde(rename = "codingChunks")]
    pub coding_chunks: i64,
    /// Number of data chunks per object in an erasure coded storage pool (required for erasure-coded pool type). The number of chunks required to recover an object when any single OSD is lost is the same as dataChunks so be aware that the larger the number of data chunks, the higher the cost of recovery.
    #[serde(rename = "dataChunks")]
    pub data_chunks: i64,
}

/// The mirroring settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolMirroring {
    /// Enabled whether this pool is mirrored or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Mode is the mirroring mode: either pool or image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// Peers represents the peers spec
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peers: Option<CephObjectStoreDataPoolMirroringPeers>,
    /// SnapshotSchedules is the scheduling of snapshot for mirrored images/pools
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotSchedules")]
    pub snapshot_schedules: Option<Vec<CephObjectStoreDataPoolMirroringSnapshotSchedules>>,
}

/// Peers represents the peers spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolMirroringPeers {
    /// SecretNames represents the Kubernetes Secret names to add rbd-mirror or cephfs-mirror peers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretNames")]
    pub secret_names: Option<Vec<String>>,
}

/// SnapshotScheduleSpec represents the snapshot scheduling settings of a mirrored pool
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolMirroringSnapshotSchedules {
    /// Interval represent the periodicity of the snapshot.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Path is the path to snapshot, only valid for CephFS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// StartTime indicates when to start the snapshot
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// The quota settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolQuotas {
    /// MaxBytes represents the quota in bytes Deprecated in favor of MaxSize
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<i64>,
    /// MaxObjects represents the quota in objects
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxObjects")]
    pub max_objects: Option<i64>,
    /// MaxSize represents the quota in bytes as a string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSize")]
    pub max_size: Option<String>,
}

/// The replication settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolReplicated {
    /// HybridStorage represents hybrid storage tier settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hybridStorage")]
    pub hybrid_storage: Option<CephObjectStoreDataPoolReplicatedHybridStorage>,
    /// ReplicasPerFailureDomain the number of replica in the specified failure domain
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasPerFailureDomain")]
    pub replicas_per_failure_domain: Option<i64>,
    /// RequireSafeReplicaSize if false allows you to set replica 1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireSafeReplicaSize")]
    pub require_safe_replica_size: Option<bool>,
    /// Size - Number of copies per object in a replicated storage pool, including the object itself (required for replicated pool type)
    pub size: i64,
    /// SubFailureDomain the name of the sub-failure domain
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subFailureDomain")]
    pub sub_failure_domain: Option<String>,
    /// TargetSizeRatio gives a hint (%) to Ceph in terms of expected consumption of the total cluster capacity
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSizeRatio")]
    pub target_size_ratio: Option<f64>,
}

/// HybridStorage represents hybrid storage tier settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolReplicatedHybridStorage {
    /// PrimaryDeviceClass represents high performance tier (for example SSD or NVME) for Primary OSD
    #[serde(rename = "primaryDeviceClass")]
    pub primary_device_class: String,
    /// SecondaryDeviceClass represents low performance tier (for example HDDs) for remaining OSDs
    #[serde(rename = "secondaryDeviceClass")]
    pub secondary_device_class: String,
}

/// The mirroring statusCheck
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolStatusCheck {
    /// HealthCheckSpec represents the health check of an object store bucket
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<CephObjectStoreDataPoolStatusCheckMirror>,
}

/// HealthCheckSpec represents the health check of an object store bucket
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreDataPoolStatusCheckMirror {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Interval is the internal in second or minute for the health check to run like 60s for 60 seconds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
}

/// The rgw pod info
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGateway {
    /// The annotations-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// The name of the secret that stores custom ca-bundle with root and intermediate certificates.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caBundleRef")]
    pub ca_bundle_ref: Option<String>,
    /// Whether rgw dashboard is enabled for the rgw daemon. If not set, the rgw dashboard will be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dashboardEnabled")]
    pub dashboard_enabled: Option<bool>,
    /// DisableMultisiteSyncTraffic, when true, prevents this object store's gateways from transmitting multisite replication data. Note that this value does not affect whether gateways receive multisite replication traffic: see ObjectZone.spec.customEndpoints for that. If false or unset, this object store's gateways will be able to transmit multisite replication data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableMultisiteSyncTraffic")]
    pub disable_multisite_sync_traffic: Option<bool>,
    /// ExternalRgwEndpoints points to external RGW endpoint(s). Multiple endpoints can be given, but for stability of ObjectBucketClaims, we highly recommend that users give only a single external RGW endpoint that is a load balancer that sends requests to the multiple RGWs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalRgwEndpoints")]
    pub external_rgw_endpoints: Option<Vec<CephObjectStoreGatewayExternalRgwEndpoints>>,
    /// Whether host networking is enabled for the rgw daemon. If not set, the network settings from the cluster CR will be applied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// The number of pods in the rgw replicaset.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<i32>,
    /// The labels-related configuration to add/set on each Pod related object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// The affinity to place the rgw pods (default is to place on any available node)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub placement: Option<CephObjectStoreGatewayPlacement>,
    /// The port the rgw service will be listening on (http)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// PriorityClassName sets priority classes on the rgw pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// The resource requirements for the rgw pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CephObjectStoreGatewayResources>,
    /// The port the rgw service will be listening on (https)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securePort")]
    pub secure_port: Option<i32>,
    /// The configuration related to add/set on each rgw service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<CephObjectStoreGatewayService>,
    /// The name of the secret that stores the ssl certificate for secure rgw connections
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslCertificateRef")]
    pub ssl_certificate_ref: Option<String>,
}

/// EndpointAddress is a tuple that describes a single IP address or host name. This is a subset of Kubernetes's v1.EndpointAddress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayExternalRgwEndpoints {
    /// The DNS-addressable Hostname of this endpoint. This field will be preferred over IP if both are given.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// The IP of this endpoint. As a legacy behavior, this supports being given a DNS-adressable hostname as well.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
}

/// The affinity to place the rgw pods (default is to place on any available node)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacement {
    /// NodeAffinity is a group of node affinity scheduling rules
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<CephObjectStoreGatewayPlacementNodeAffinity>,
    /// PodAffinity is a group of inter pod affinity scheduling rules
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<CephObjectStoreGatewayPlacementPodAffinity>,
    /// PodAntiAffinity is a group of inter pod anti affinity scheduling rules
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<CephObjectStoreGatewayPlacementPodAntiAffinity>,
    /// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<CephObjectStoreGatewayPlacementTolerations>>,
    /// TopologySpreadConstraint specifies how to spread matching pods among the given topology
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<CephObjectStoreGatewayPlacementTopologySpreadConstraints>>,
}

/// NodeAffinity is a group of node affinity scheduling rules
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

/// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// A node selector term, associated with the corresponding weight.
    pub preference: CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    pub weight: i32,
}

/// A node selector term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /// A list of node selector requirements by node's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    /// A list of node selector requirements by node's fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// Required. A list of node selector terms. The terms are ORed.
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

/// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /// A list of node selector requirements by node's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    /// A list of node selector requirements by node's fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// PodAffinity is a group of inter pod affinity scheduling rules
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// Required. A pod affinity term, associated with the corresponding weight.
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    /// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
    pub weight: i32,
}

/// Required. A pod affinity term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /// A label query over a set of resources, in this case pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    /// A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// A label query over a set of resources, in this case pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    /// A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// PodAntiAffinity is a group of inter pod anti affinity scheduling rules
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// Required. A pod affinity term, associated with the corresponding weight.
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    /// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
    pub weight: i32,
}

/// Required. A pod affinity term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /// A label query over a set of resources, in this case pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    /// A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// A label query over a set of resources, in this case pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    /// A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementTopologySpreadConstraints {
    /// LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<CephObjectStoreGatewayPlacementTopologySpreadConstraintsLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector. MatchLabelKeys cannot be set when LabelSelector isn't set. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector. 
    ///  This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | |  P P  |  P P  |   P   | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    /// MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule. 
    ///  For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew. 
    ///  This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDomains")]
    pub min_domains: Option<i32>,
    /// NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations. 
    ///  If this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinityPolicy")]
    pub node_affinity_policy: Option<String>,
    /// NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included. 
    ///  If this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeTaintsPolicy")]
    pub node_taints_policy: Option<String>,
    /// TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology. And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology. It's a required field.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    /// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

/// LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementTopologySpreadConstraintsLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CephObjectStoreGatewayPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayPlacementTopologySpreadConstraintsLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// The resource requirements for the rgw pods
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<CephObjectStoreGatewayResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// The configuration related to add/set on each rgw service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreGatewayService {
    /// The annotations-related configuration to add/set on each rgw service. nullable optional
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
}

/// The RGW health probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheck {
    /// ProbeSpec is a wrapper around Probe so it can be enabled or disabled for a Ceph daemon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<CephObjectStoreHealthCheckReadinessProbe>,
    /// ProbeSpec is a wrapper around Probe so it can be enabled or disabled for a Ceph daemon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<CephObjectStoreHealthCheckStartupProbe>,
}

/// ProbeSpec is a wrapper around Probe so it can be enabled or disabled for a Ceph daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbe {
    /// Disabled determines whether probe is disable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probe: Option<CephObjectStoreHealthCheckReadinessProbeProbe>,
}

/// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<CephObjectStoreHealthCheckReadinessProbeProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<CephObjectStoreHealthCheckReadinessProbeProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<CephObjectStoreHealthCheckReadinessProbeProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<CephObjectStoreHealthCheckReadinessProbeProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). 
    ///  If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<CephObjectStoreHealthCheckReadinessProbeProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host. Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeHttpGetHttpHeaders {
    /// The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckReadinessProbeProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ProbeSpec is a wrapper around Probe so it can be enabled or disabled for a Ceph daemon
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbe {
    /// Disabled determines whether probe is disable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probe: Option<CephObjectStoreHealthCheckStartupProbeProbe>,
}

/// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<CephObjectStoreHealthCheckStartupProbeProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<CephObjectStoreHealthCheckStartupProbeProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<CephObjectStoreHealthCheckStartupProbeProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<CephObjectStoreHealthCheckStartupProbeProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). 
    ///  If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<CephObjectStoreHealthCheckStartupProbeProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host. Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeHttpGetHttpHeaders {
    /// The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreHealthCheckStartupProbeProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// The metadata pool settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPool {
    /// DEPRECATED: use Parameters instead, e.g., Parameters["compression_mode"] = "force" The inline compression mode in Bluestore OSD to set to (options are: none, passive, aggressive, force) Do NOT set a default value for kubebuilder as this will override the Parameters
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionMode")]
    pub compression_mode: Option<CephObjectStoreMetadataPoolCompressionMode>,
    /// The root of the crush hierarchy utilized by the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crushRoot")]
    pub crush_root: Option<String>,
    /// The device class the OSD should set to for use in the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceClass")]
    pub device_class: Option<String>,
    /// EnableRBDStats is used to enable gathering of statistics for all RBD images in the pool
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRBDStats")]
    pub enable_rbd_stats: Option<bool>,
    /// The erasure code settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "erasureCoded")]
    pub erasure_coded: Option<CephObjectStoreMetadataPoolErasureCoded>,
    /// The failure domain: osd/host/(region or zone if available) - technically also any type in the crush map
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomain")]
    pub failure_domain: Option<String>,
    /// The mirroring settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirroring: Option<CephObjectStoreMetadataPoolMirroring>,
    /// Parameters is a list of properties to enable on a given pool
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<BTreeMap<String, String>>,
    /// The quota settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quotas: Option<CephObjectStoreMetadataPoolQuotas>,
    /// The replication settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicated: Option<CephObjectStoreMetadataPoolReplicated>,
    /// The mirroring statusCheck
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusCheck")]
    pub status_check: Option<CephObjectStoreMetadataPoolStatusCheck>,
}

/// The metadata pool settings
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CephObjectStoreMetadataPoolCompressionMode {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "passive")]
    Passive,
    #[serde(rename = "aggressive")]
    Aggressive,
    #[serde(rename = "force")]
    Force,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// The erasure code settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolErasureCoded {
    /// The algorithm for erasure coding
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<String>,
    /// Number of coding chunks per object in an erasure coded storage pool (required for erasure-coded pool type). This is the number of OSDs that can be lost simultaneously before data cannot be recovered.
    #[serde(rename = "codingChunks")]
    pub coding_chunks: i64,
    /// Number of data chunks per object in an erasure coded storage pool (required for erasure-coded pool type). The number of chunks required to recover an object when any single OSD is lost is the same as dataChunks so be aware that the larger the number of data chunks, the higher the cost of recovery.
    #[serde(rename = "dataChunks")]
    pub data_chunks: i64,
}

/// The mirroring settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolMirroring {
    /// Enabled whether this pool is mirrored or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Mode is the mirroring mode: either pool or image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
    /// Peers represents the peers spec
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peers: Option<CephObjectStoreMetadataPoolMirroringPeers>,
    /// SnapshotSchedules is the scheduling of snapshot for mirrored images/pools
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snapshotSchedules")]
    pub snapshot_schedules: Option<Vec<CephObjectStoreMetadataPoolMirroringSnapshotSchedules>>,
}

/// Peers represents the peers spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolMirroringPeers {
    /// SecretNames represents the Kubernetes Secret names to add rbd-mirror or cephfs-mirror peers
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretNames")]
    pub secret_names: Option<Vec<String>>,
}

/// SnapshotScheduleSpec represents the snapshot scheduling settings of a mirrored pool
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolMirroringSnapshotSchedules {
    /// Interval represent the periodicity of the snapshot.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Path is the path to snapshot, only valid for CephFS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// StartTime indicates when to start the snapshot
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// The quota settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolQuotas {
    /// MaxBytes represents the quota in bytes Deprecated in favor of MaxSize
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<i64>,
    /// MaxObjects represents the quota in objects
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxObjects")]
    pub max_objects: Option<i64>,
    /// MaxSize represents the quota in bytes as a string
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSize")]
    pub max_size: Option<String>,
}

/// The replication settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolReplicated {
    /// HybridStorage represents hybrid storage tier settings
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hybridStorage")]
    pub hybrid_storage: Option<CephObjectStoreMetadataPoolReplicatedHybridStorage>,
    /// ReplicasPerFailureDomain the number of replica in the specified failure domain
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasPerFailureDomain")]
    pub replicas_per_failure_domain: Option<i64>,
    /// RequireSafeReplicaSize if false allows you to set replica 1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireSafeReplicaSize")]
    pub require_safe_replica_size: Option<bool>,
    /// Size - Number of copies per object in a replicated storage pool, including the object itself (required for replicated pool type)
    pub size: i64,
    /// SubFailureDomain the name of the sub-failure domain
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subFailureDomain")]
    pub sub_failure_domain: Option<String>,
    /// TargetSizeRatio gives a hint (%) to Ceph in terms of expected consumption of the total cluster capacity
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetSizeRatio")]
    pub target_size_ratio: Option<f64>,
}

/// HybridStorage represents hybrid storage tier settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolReplicatedHybridStorage {
    /// PrimaryDeviceClass represents high performance tier (for example SSD or NVME) for Primary OSD
    #[serde(rename = "primaryDeviceClass")]
    pub primary_device_class: String,
    /// SecondaryDeviceClass represents low performance tier (for example HDDs) for remaining OSDs
    #[serde(rename = "secondaryDeviceClass")]
    pub secondary_device_class: String,
}

/// The mirroring statusCheck
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolStatusCheck {
    /// HealthCheckSpec represents the health check of an object store bucket
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<CephObjectStoreMetadataPoolStatusCheckMirror>,
}

/// HealthCheckSpec represents the health check of an object store bucket
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreMetadataPoolStatusCheckMirror {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Interval is the internal in second or minute for the health check to run like 60s for 60 seconds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
}

/// Security represents security settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSecurity {
    /// KeyRotation defines options for Key Rotation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyRotation")]
    pub key_rotation: Option<CephObjectStoreSecurityKeyRotation>,
    /// KeyManagementService is the main Key Management option
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kms: Option<CephObjectStoreSecurityKms>,
    /// The settings for supporting AWS-SSE:S3 with RGW
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<CephObjectStoreSecurityS3>,
}

/// KeyRotation defines options for Key Rotation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSecurityKeyRotation {
    /// Enabled represents whether the key rotation is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Schedule represents the cron schedule for key rotation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<String>,
}

/// KeyManagementService is the main Key Management option
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSecurityKms {
    /// ConnectionDetails contains the KMS connection details (address, port etc)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionDetails")]
    pub connection_details: Option<BTreeMap<String, String>>,
    /// TokenSecretName is the kubernetes secret containing the KMS token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecretName")]
    pub token_secret_name: Option<String>,
}

/// The settings for supporting AWS-SSE:S3 with RGW
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreSecurityS3 {
    /// ConnectionDetails contains the KMS connection details (address, port etc)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionDetails")]
    pub connection_details: Option<BTreeMap<String, String>>,
    /// TokenSecretName is the kubernetes secret containing the KMS token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecretName")]
    pub token_secret_name: Option<String>,
}

/// The multisite info
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreZone {
    /// RGW Zone the Object Store is in
    pub name: String,
}

/// ObjectStoreStatus represents the status of a Ceph Object Store resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<CephObjectStoreStatusConditions>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<CephObjectStoreStatusEndpoints>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub info: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// ObservedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// ConditionType represent a resource's status
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
}

/// Condition represents a status condition on any Rook-Ceph Custom Resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreStatusConditions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastHeartbeatTime")]
    pub last_heartbeat_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// ConditionReason is a reason for a condition
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// ConditionType represent a resource's status
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CephObjectStoreStatusEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<Vec<String>>,
}

