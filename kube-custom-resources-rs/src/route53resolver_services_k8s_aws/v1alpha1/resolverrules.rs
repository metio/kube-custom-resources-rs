// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/aws-controllers-k8s/route53resolver-controller/route53resolver.services.k8s.aws/v1alpha1/resolverrules.yaml --derive=Default --derive=PartialEq
// kopium version: 0.17.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;

/// ResolverRuleSpec defines the desired state of ResolverRule.
/// 
/// 
/// For queries that originate in your VPC, detailed information about a Resolver
/// rule, which specifies how to route DNS queries out of the VPC. The ResolverRule
/// parameter appears in the response to a CreateResolverRule (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html),
/// DeleteResolverRule (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverRule.html),
/// GetResolverRule (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html),
/// ListResolverRules (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html),
/// or UpdateResolverRule (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html)
/// request.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "route53resolver.services.k8s.aws", version = "v1alpha1", kind = "ResolverRule", plural = "resolverrules")]
#[kube(namespaced)]
#[kube(status = "ResolverRuleStatus")]
#[kube(schema = "disabled")]
pub struct ResolverRuleSpec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub associations: Option<Vec<ResolverRuleAssociations>>,
    /// DNS queries for this domain name are forwarded to the IP addresses that you
    /// specify in TargetIps. If a query matches multiple Resolver rules (example.com
    /// and www.example.com), outbound DNS queries are routed using the Resolver
    /// rule that contains the most specific domain name (www.example.com).
    #[serde(rename = "domainName")]
    pub domain_name: String,
    /// A friendly name that lets you easily find a rule in the Resolver dashboard
    /// in the Route 53 console.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The ID of the outbound Resolver endpoint that you want to use to route DNS
    /// queries to the IP addresses that you specify in TargetIps.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resolverEndpointID")]
    pub resolver_endpoint_id: Option<String>,
    /// When you want to forward DNS queries for specified domain name to resolvers
    /// on your network, specify FORWARD.
    /// 
    /// 
    /// When you have a forwarding rule to forward DNS queries for a domain to your
    /// network and you want Resolver to process queries for a subdomain of that
    /// domain, specify SYSTEM.
    /// 
    /// 
    /// For example, to forward DNS queries for example.com to resolvers on your
    /// network, you create a rule and specify FORWARD for RuleType. To then have
    /// Resolver process queries for apex.example.com, you create a rule and specify
    /// SYSTEM for RuleType.
    /// 
    /// 
    /// Currently, only Resolver can create rules that have a value of RECURSIVE
    /// for RuleType.
    #[serde(rename = "ruleType")]
    pub rule_type: String,
    /// A list of the tag keys and values that you want to associate with the endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<ResolverRuleTags>>,
    /// The IPs that you want Resolver to forward DNS queries to. You can specify
    /// only IPv4 addresses. Separate IP addresses with a space.
    /// 
    /// 
    /// TargetIps is available only when the value of Rule type is FORWARD.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetIPs")]
    pub target_i_ps: Option<Vec<ResolverRuleTargetIPs>>,
}

/// In the response to an AssociateResolverRule (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html),
/// DisassociateResolverRule (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html),
/// or ListResolverRuleAssociations (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html)
/// request, provides information about an association between a Resolver rule
/// and a VPC. The association determines which DNS queries that originate in
/// the VPC are forwarded to your network.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ResolverRuleAssociations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resolverRuleID")]
    pub resolver_rule_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusMessage")]
    pub status_message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcID")]
    pub vpc_id: Option<String>,
}

/// One tag that you want to add to the specified resource. A tag consists of
/// a Key (a name for the tag) and a Value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ResolverRuleTags {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// In a CreateResolverRule (https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html)
/// request, an array of the IPs that you want to forward DNS queries to.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ResolverRuleTargetIPs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ipv6: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// ResolverRuleStatus defines the observed state of ResolverRule
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ResolverRuleStatus {
    /// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
    /// that is used to contain resource sync state, account ownership,
    /// constructed ARN for the resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResourceMetadata")]
    pub ack_resource_metadata: Option<ResolverRuleStatusAckResourceMetadata>,
    /// All CRS managed by ACK have a common `Status.Conditions` member that
    /// contains a collection of `ackv1alpha1.Condition` objects that describe
    /// the various terminal states of the CR and its backend AWS service API
    /// resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// The date and time that the Resolver rule was created, in Unix time format
    /// and Coordinated Universal Time (UTC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationTime")]
    pub creation_time: Option<String>,
    /// A unique string that you specified when you created the Resolver rule. CreatorRequestId
    /// identifies the request and allows failed requests to be retried without the
    /// risk of running the operation twice.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creatorRequestID")]
    pub creator_request_id: Option<String>,
    /// The ID that Resolver assigned to the Resolver rule when you created it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The date and time that the Resolver rule was last updated, in Unix time format
    /// and Coordinated Universal Time (UTC).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modificationTime")]
    pub modification_time: Option<String>,
    /// When a rule is shared with another Amazon Web Services account, the account
    /// ID of the account that the rule is shared with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownerID")]
    pub owner_id: Option<String>,
    /// Whether the rule is shared and, if so, whether the current account is sharing
    /// the rule with another account, or another account is sharing the rule with
    /// the current account.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shareStatus")]
    pub share_status: Option<String>,
    /// A code that specifies the current status of the Resolver rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// A detailed description of the status of a Resolver rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusMessage")]
    pub status_message: Option<String>,
}

/// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
/// that is used to contain resource sync state, account ownership,
/// constructed ARN for the resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ResolverRuleStatusAckResourceMetadata {
    /// ARN is the Amazon Resource Name for the resource. This is a
    /// globally-unique identifier and is set only by the ACK service controller
    /// once the controller has orchestrated the creation of the resource OR
    /// when it has verified that an "adopted" resource (a resource where the
    /// ARN annotation was set by the Kubernetes user on the CR) exists and
    /// matches the supplied CR's Spec field values.
    /// TODO(vijat@): Find a better strategy for resources that do not have ARN in CreateOutputResponse
    /// https://github.com/aws/aws-controllers-k8s/issues/270
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// OwnerAccountID is the AWS Account ID of the account that owns the
    /// backend AWS service API resource.
    #[serde(rename = "ownerAccountID")]
    pub owner_account_id: String,
    /// Region is the AWS region in which the resource exists or will exist.
    pub region: String,
}

