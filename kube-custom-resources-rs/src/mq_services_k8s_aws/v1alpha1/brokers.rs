// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/aws-controllers-k8s/mq-controller/mq.services.k8s.aws/v1alpha1/brokers.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// BrokerSpec defines the desired state of Broker.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "mq.services.k8s.aws", version = "v1alpha1", kind = "Broker", plural = "brokers")]
#[kube(namespaced)]
#[kube(status = "BrokerStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct BrokerSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authenticationStrategy")]
    pub authentication_strategy: Option<String>,
    #[serde(rename = "autoMinorVersionUpgrade")]
    pub auto_minor_version_upgrade: bool,
    /// A list of information about the configuration.
    /// 
    /// 
    /// Does not apply to RabbitMQ brokers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<BrokerConfiguration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creatorRequestID")]
    pub creator_request_id: Option<String>,
    #[serde(rename = "deploymentMode")]
    pub deployment_mode: String,
    /// Does not apply to RabbitMQ brokers.
    /// 
    /// 
    /// Encryption options for the broker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "encryptionOptions")]
    pub encryption_options: Option<BrokerEncryptionOptions>,
    #[serde(rename = "engineType")]
    pub engine_type: String,
    #[serde(rename = "engineVersion")]
    pub engine_version: String,
    #[serde(rename = "hostInstanceType")]
    pub host_instance_type: String,
    /// Optional. The metadata of the LDAP server used to authenticate and authorize
    /// connections to the broker.
    /// 
    /// 
    /// Does not apply to RabbitMQ brokers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ldapServerMetadata")]
    pub ldap_server_metadata: Option<BrokerLdapServerMetadata>,
    /// The list of information about logs to be enabled for the specified broker.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logs: Option<BrokerLogs>,
    /// The scheduled time period relative to UTC during which Amazon MQ begins to
    /// apply pending updates or patches to the broker.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindowStartTime")]
    pub maintenance_window_start_time: Option<BrokerMaintenanceWindowStartTime>,
    pub name: String,
    #[serde(rename = "publiclyAccessible")]
    pub publicly_accessible: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupRefs")]
    pub security_group_refs: Option<Vec<BrokerSecurityGroupRefs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroups")]
    pub security_groups: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageType")]
    pub storage_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetIDs")]
    pub subnet_i_ds: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetRefs")]
    pub subnet_refs: Option<Vec<BrokerSubnetRefs>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
    pub users: Vec<BrokerUsers>,
}

/// A list of information about the configuration.
/// 
/// 
/// Does not apply to RabbitMQ brokers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub revision: Option<i64>,
}

/// Does not apply to RabbitMQ brokers.
/// 
/// 
/// Encryption options for the broker.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerEncryptionOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kmsKeyID")]
    pub kms_key_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useAWSOwnedKey")]
    pub use_aws_owned_key: Option<bool>,
}

/// Optional. The metadata of the LDAP server used to authenticate and authorize
/// connections to the broker.
/// 
/// 
/// Does not apply to RabbitMQ brokers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerLdapServerMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleBase")]
    pub role_base: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleName")]
    pub role_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleSearchMatching")]
    pub role_search_matching: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleSearchSubtree")]
    pub role_search_subtree: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountPassword")]
    pub service_account_password: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountUsername")]
    pub service_account_username: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userBase")]
    pub user_base: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userRoleName")]
    pub user_role_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userSearchMatching")]
    pub user_search_matching: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userSearchSubtree")]
    pub user_search_subtree: Option<bool>,
}

/// The list of information about logs to be enabled for the specified broker.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerLogs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audit: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub general: Option<bool>,
}

/// The scheduled time period relative to UTC during which Amazon MQ begins to
/// apply pending updates or patches to the broker.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerMaintenanceWindowStartTime {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dayOfWeek")]
    pub day_of_week: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeOfDay")]
    pub time_of_day: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeZone")]
    pub time_zone: Option<String>,
}

/// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
/// type to provide more user friendly syntax for references using 'from' field
/// Ex:
/// APIIDRef:
/// 
/// 
/// 	from:
/// 	  name: my-api
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerSecurityGroupRefs {
    /// AWSResourceReference provides all the values necessary to reference another
    /// k8s resource for finding the identifier(Id/ARN/Name)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<BrokerSecurityGroupRefsFrom>,
}

/// AWSResourceReference provides all the values necessary to reference another
/// k8s resource for finding the identifier(Id/ARN/Name)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerSecurityGroupRefsFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
/// type to provide more user friendly syntax for references using 'from' field
/// Ex:
/// APIIDRef:
/// 
/// 
/// 	from:
/// 	  name: my-api
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerSubnetRefs {
    /// AWSResourceReference provides all the values necessary to reference another
    /// k8s resource for finding the identifier(Id/ARN/Name)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<BrokerSubnetRefsFrom>,
}

/// AWSResourceReference provides all the values necessary to reference another
/// k8s resource for finding the identifier(Id/ARN/Name)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerSubnetRefsFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// A user associated with the broker. For RabbitMQ brokers, one and only one
/// administrative user is accepted and created when a broker is first provisioned.
/// All subsequent broker users are created by making RabbitMQ API calls directly
/// to brokers or via the RabbitMQ web console.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerUsers {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consoleAccess")]
    pub console_access: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
    /// SecretKeyReference combines a k8s corev1.SecretReference with a
    /// specific key within the referred-to Secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<BrokerUsersPassword>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// SecretKeyReference combines a k8s corev1.SecretReference with a
/// specific key within the referred-to Secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerUsersPassword {
    /// Key is the key within the secret
    pub key: String,
    /// name is unique within a namespace to reference a secret resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// namespace defines the space within which the secret name must be unique.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// BrokerStatus defines the observed state of Broker
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerStatus {
    /// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
    /// that is used to contain resource sync state, account ownership,
    /// constructed ARN for the resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResourceMetadata")]
    pub ack_resource_metadata: Option<BrokerStatusAckResourceMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerID")]
    pub broker_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerInstances")]
    pub broker_instances: Option<Vec<BrokerStatusBrokerInstances>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerState")]
    pub broker_state: Option<String>,
    /// All CRS managed by ACK have a common `Status.Conditions` member that
    /// contains a collection of `ackv1alpha1.Condition` objects that describe
    /// the various terminal states of the CR and its backend AWS service API
    /// resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

/// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
/// that is used to contain resource sync state, account ownership,
/// constructed ARN for the resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerStatusAckResourceMetadata {
    /// ARN is the Amazon Resource Name for the resource. This is a
    /// globally-unique identifier and is set only by the ACK service controller
    /// once the controller has orchestrated the creation of the resource OR
    /// when it has verified that an "adopted" resource (a resource where the
    /// ARN annotation was set by the Kubernetes user on the CR) exists and
    /// matches the supplied CR's Spec field values.
    /// TODO(vijat@): Find a better strategy for resources that do not have ARN in CreateOutputResponse
    /// https://github.com/aws/aws-controllers-k8s/issues/270
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// OwnerAccountID is the AWS Account ID of the account that owns the
    /// backend AWS service API resource.
    #[serde(rename = "ownerAccountID")]
    pub owner_account_id: String,
    /// Region is the AWS region in which the resource exists or will exist.
    pub region: String,
}

/// Returns information about all brokers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BrokerStatusBrokerInstances {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consoleURL")]
    pub console_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddress")]
    pub ip_address: Option<String>,
}

