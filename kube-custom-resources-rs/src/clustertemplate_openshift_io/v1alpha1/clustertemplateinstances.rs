// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/stolostron/cluster-templates-operator/clustertemplate.openshift.io/v1alpha1/clustertemplateinstances.yaml --derive=PartialEq
// kopium version: 0.16.5

use kube::CustomResource;
use serde::{Serialize, Deserialize};

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "clustertemplate.openshift.io", version = "v1alpha1", kind = "ClusterTemplateInstance", plural = "clustertemplateinstances")]
#[kube(namespaced)]
#[kube(status = "ClusterTemplateInstanceStatus")]
#[kube(schema = "disabled")]
pub struct ClusterTemplateInstanceSpec {
    /// A reference to ClusterTemplate which will be used for installing and setting up the cluster
    #[serde(rename = "clusterTemplateRef")]
    pub cluster_template_ref: String,
    /// A reference to a secret which contains kubeconfig of the cluster. If specified day1 operation won't be executed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeconfigSecretRef")]
    pub kubeconfig_secret_ref: Option<String>,
    /// Helm parameters to be passed to cluster installation or setup
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<Vec<ClusterTemplateInstanceParameters>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTemplateInstanceParameters {
    /// Name of the application set to which parameter is applied
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSetup")]
    pub cluster_setup: Option<String>,
    /// Name of the Helm parameter
    pub name: String,
    /// Value of the Helm parameter
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTemplateInstanceStatus {
    /// A reference for secret which contains username and password under keys "username" and "password"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminPassword")]
    pub admin_password: Option<ClusterTemplateInstanceStatusAdminPassword>,
    /// API server URL of the new cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServerURL")]
    pub api_server_url: Option<String>,
    /// Status of each cluster setup
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSetup")]
    pub cluster_setup: Option<Vec<ClusterTemplateInstanceStatusClusterSetup>>,
    /// Secrets create by cluster setup which provide credentials for applications created by cluster setup
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterSetupSecrets")]
    pub cluster_setup_secrets: Option<Vec<ClusterTemplateInstanceStatusClusterSetupSecrets>>,
    /// Resource conditions
    pub conditions: Vec<ClusterTemplateInstanceStatusConditions>,
    /// Console URL of the new cluster. The value is taken from ManagedCluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consoleURL")]
    pub console_url: Option<String>,
    /// Time of first attempt of login to a new cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firstLoginAttempt")]
    pub first_login_attempt: Option<String>,
    /// A reference for secret which contains kubeconfig under key "kubeconfig"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kubeconfig: Option<ClusterTemplateInstanceStatusKubeconfig>,
    /// A reference to ManagedCluster resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedCluster")]
    pub managed_cluster: Option<ClusterTemplateInstanceStatusManagedCluster>,
    /// Additional message for Phase
    pub message: String,
    /// Represents instance installaton & setup phase
    pub phase: String,
}

/// A reference for secret which contains username and password under keys "username" and "password"
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTemplateInstanceStatusAdminPassword {
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTemplateInstanceStatusClusterSetup {
    /// Description of the cluster setup status
    pub message: String,
    /// Name of the cluster setup
    pub name: String,
    /// Status of the cluster setup
    pub status: String,
}

/// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTemplateInstanceStatusClusterSetupSecrets {
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTemplateInstanceStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: ClusterTemplateInstanceStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterTemplateInstanceStatusConditionsStatus {
    True,
    False,
    Unknown,
}

/// A reference for secret which contains kubeconfig under key "kubeconfig"
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTemplateInstanceStatusKubeconfig {
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// A reference to ManagedCluster resource
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTemplateInstanceStatusManagedCluster {
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

