// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/furiko-io/furiko/execution.furiko.io/v1alpha1/jobconfigs.yaml --derive=Default --derive=PartialEq
// kopium version: 0.16.2

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// JobConfigSpec defines the desired state of the JobConfig.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "execution.furiko.io", version = "v1alpha1", kind = "JobConfig", plural = "jobconfigs")]
#[kube(namespaced)]
#[kube(status = "JobConfigStatus")]
#[kube(schema = "disabled")]
pub struct JobConfigSpec {
    /// Concurrency defines the behaviour of multiple concurrent Jobs.
    pub concurrency: JobConfigConcurrency,
    /// Option is an optional field that defines how the JobConfig is parameterized. Each option defined here can subsequently be used in the Template via context variable substitution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<JobConfigOption>,
    /// Schedule is an optional field that defines automatic scheduling of the JobConfig.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<JobConfigSchedule>,
    /// Template for creating the Job.
    pub template: JobConfigTemplate,
}

/// Concurrency defines the behaviour of multiple concurrent Jobs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigConcurrency {
    /// Maximum number of Jobs that can be running concurrently for the same JobConfig. Cannot be specified if Policy is set to Allow. 
    ///  Defaults to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConcurrency")]
    pub max_concurrency: Option<i64>,
    /// Policy describes how to treat concurrent executions of the same JobConfig.
    pub policy: String,
}

/// Option is an optional field that defines how the JobConfig is parameterized. Each option defined here can subsequently be used in the Template via context variable substitution.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigOption {
    /// Options is a list of job options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<JobConfigOptionOptions>>,
}

/// Option defines a single job option.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigOptionOptions {
    /// Bool adds additional configuration for OptionTypeBool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bool: Option<JobConfigOptionOptionsBool>,
    /// Date adds additional configuration for OptionTypeDate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub date: Option<JobConfigOptionOptionsDate>,
    /// Label is an optional human-readable label for this option, which is purely used for display purposes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// Multi adds additional configuration for OptionTypeMulti.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub multi: Option<JobConfigOptionOptionsMulti>,
    /// The name of the job option. Will be substituted as `${option.NAME}`. Must match the following regex: ^[a-zA-Z_0-9.-]+$
    pub name: String,
    /// Required defines whether this field is required. 
    ///  Default: false
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    /// Select adds additional configuration for OptionTypeSelect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub select: Option<JobConfigOptionOptionsSelect>,
    /// String adds additional configuration for OptionTypeString.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub string: Option<JobConfigOptionOptionsString>,
    /// The type of the job option. Can be one of: bool, string, select, multi, date
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Bool adds additional configuration for OptionTypeBool.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigOptionOptionsBool {
    /// Default value, will be used to populate the option if not specified.
    pub default: bool,
    /// If Format is custom, will be substituted if value is false. Can also be an empty string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "falseVal")]
    pub false_val: Option<String>,
    /// Determines how to format the value as string. Can be one of: TrueFalse, OneZero, YesNo, Custom 
    ///  Default: TrueFalse
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
    /// If Format is custom, will be substituted if value is true. Can also be an empty string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trueVal")]
    pub true_val: Option<String>,
}

/// Date adds additional configuration for OptionTypeDate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigOptionOptionsDate {
    /// Date format in moment.js format. If not specified, will use RFC3339 format by default. 
    ///  Date format reference: https://momentjs.com/docs/#/displaying/format/ 
    ///  Default:
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
}

/// Multi adds additional configuration for OptionTypeMulti.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigOptionOptionsMulti {
    /// Whether to allow custom values instead of just the list of allowed values. 
    ///  Default: false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCustom")]
    pub allow_custom: Option<bool>,
    /// Default values, will be used to populate the option if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<Vec<String>>,
    /// Delimiter to join values by.
    pub delimiter: String,
    /// List of values to be chosen from.
    pub values: Vec<String>,
}

/// Select adds additional configuration for OptionTypeSelect.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigOptionOptionsSelect {
    /// Whether to allow custom values instead of just the list of allowed values. 
    ///  Default: false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCustom")]
    pub allow_custom: Option<bool>,
    /// Default value, will be used to populate the option if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<String>,
    /// List of values to be chosen from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// String adds additional configuration for OptionTypeString.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigOptionOptionsString {
    /// Optional default value, will be used to populate the option if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<String>,
    /// Whether to trim spaces before substitution. 
    ///  Default: false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trimSpaces")]
    pub trim_spaces: Option<bool>,
}

/// Schedule is an optional field that defines automatic scheduling of the JobConfig.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigSchedule {
    /// Specifies any constraints that should apply to this Schedule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub constraints: Option<JobConfigScheduleConstraints>,
    /// Specify a schedule using cron expressions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cron: Option<JobConfigScheduleCron>,
    /// If true, then automatic scheduling will be disabled for the JobConfig.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Specifies the time that the schedule was last updated. This prevents accidental back-scheduling. 
    ///  For example, if a JobConfig that was previously disabled from automatic scheduling is now enabled, we do not want to perform back-scheduling for schedules after LastScheduled prior to updating of the JobConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastUpdated")]
    pub last_updated: Option<String>,
}

/// Specifies any constraints that should apply to this Schedule.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigScheduleConstraints {
    /// Specifies the latest possible time that is allowed to be scheduled. If set, the scheduler should not create schedules after this time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notAfter")]
    pub not_after: Option<String>,
    /// Specifies the earliest possible time that is allowed to be scheduled. If set, the scheduler should not create schedules before this time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notBefore")]
    pub not_before: Option<String>,
}

/// Specify a schedule using cron expressions.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigScheduleCron {
    /// Cron expression to specify how the JobConfig will be periodically scheduled. Example: "0 0/5 * * *". 
    ///  Supports cron schedules with optional "seconds" and "years" fields, i.e. can parse between 5 to 7 tokens. 
    ///  More information: https://github.com/furiko-io/cronexpr
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// List of cron expressions to specify how the JobConfig will be periodically scheduled. 
    ///  Take for example a requirement to schedule a job every day at 3AM, 3:30AM and 4AM. There is no way to represent this with a single cron expression, but we could do so with two cron expressions: "0/30 3 * * *", and "0 4 * * *". 
    ///  Exactly one of Expression or Expressions must be specified. If two expressions fall on the same time, only one of them will take effect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expressions: Option<Vec<String>>,
    /// Timezone to interpret the cron schedule in. For example, a cron schedule of "0 10 * * *" with a timezone of "Asia/Singapore" will be interpreted as running at 02:00:00 UTC time every day. 
    ///  Timezone must be one of the following: 
    ///  1. A valid tz string (e.g. "Asia/Singapore", "America/New_York"). 2. A UTC offset with minutes (e.g. UTC-10:00). 3. A GMT offset with minutes (e.g. GMT+05:30). The meaning is the same as its UTC counterpart. 
    ///  This field merely is used for parsing the cron Expression, and has nothing to do with /etc/timezone inside the container (i.e. it will not set $TZ automatically). 
    ///  Defaults to the controller's default configured timezone.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
}

/// Template for creating the Job.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigTemplate {
    /// Standard object's metadata that will be added to Job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, serde_json::Value>>,
    /// Specification of the desired behavior of the job.
    pub spec: JobConfigTemplateSpec,
}

/// Specification of the desired behavior of the job.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigTemplateSpec {
    /// Defines whether tasks are allowed to be force deleted or not. If the node is unresponsive, it may be possible that the task cannot be killed by normal graceful deletion. The controller may choose to force delete the task, which would ignore the final state of the task since the node is unable to return whether the task is actually still alive. 
    ///  If not set to true, there may be some cases when there may actually be two concurrently running tasks when even when ConcurrencyPolicyForbid. Setting this to true would prevent this from happening, but the Job may remain stuck indefinitely until the node recovers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forbidTaskForceDeletion")]
    pub forbid_task_force_deletion: Option<bool>,
    /// Specifies maximum number of attempts before the Job will terminate in failure. If defined, the controller will wait retryDelaySeconds before creating the next task. Once maxAttempts is reached, the Job terminates in RetryLimitExceeded. 
    ///  If parallelism is also defined, this corresponds to the maximum attempts for each parallel task. That is, if there are 5 parallel task to be run at a time, with maxAttempts of 3, the Job may create up to a maximum of 15 tasks if each has failed. 
    ///  Value must be a positive integer. Defaults to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAttempts")]
    pub max_attempts: Option<i64>,
    /// Describes how to run multiple tasks in parallel for the Job. If not set, then there will be at most a single task running at any time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallelism: Option<JobConfigTemplateSpecParallelism>,
    /// Optional duration in seconds to wait between retries. If left empty or zero, it means no delay (i.e. retry immediately). 
    ///  If parallelism is also defined, the retry delay is from the time of the last failed task with the same index. That is, if there are two parallel tasks - index 0 and index 1 - which failed at t=0 and t=15, with retryDelaySeconds of 30, the controller will only create the next attempts at t=30 and t=45 respectively. 
    ///  Value must be a non-negative integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryDelaySeconds")]
    pub retry_delay_seconds: Option<i64>,
    /// Optional duration in seconds to wait before terminating the task if it is still pending. This field is useful to prevent jobs from being stuck forever if the Job has a deadline to start running by. If not set, it will be set to the DefaultPendingTimeoutSeconds configuration value in the controller. To disable pending timeout, set this to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskPendingTimeoutSeconds")]
    pub task_pending_timeout_seconds: Option<i64>,
    /// Defines the template to create a single task in the Job.
    #[serde(rename = "taskTemplate")]
    pub task_template: JobConfigTemplateSpecTaskTemplate,
}

/// Describes how to run multiple tasks in parallel for the Job. If not set, then there will be at most a single task running at any time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigTemplateSpecParallelism {
    /// Defines when the Job will complete when there are multiple tasks running in parallel. For example, if using the AllSuccessful strategy, the Job will only terminate once all parallel tasks have terminated successfully, or once any task has exhausted its maxAttempts limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "completionStrategy")]
    pub completion_strategy: Option<String>,
    /// Specifies an exact number of tasks to be run in parallel. The index number can be retrieved via the "${task.index_num}" context variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withCount")]
    pub with_count: Option<i64>,
    /// Specifies a list of keys corresponding to each task that will be run in parallel. The index key can be retrieved via the "${task.index_key}" context variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withKeys")]
    pub with_keys: Option<Vec<String>>,
    /// Specifies a matrix of key-value pairs, with each key mapped to a list of possible values, such that tasks will be started for each combination of key-value pairs. The matrix values can be retrieved via context variables in the following format: "${task.index_matrix.<key>}".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withMatrix")]
    pub with_matrix: Option<BTreeMap<String, String>>,
}

/// Defines the template to create a single task in the Job.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigTemplateSpecTaskTemplate {
    /// Describes how to create tasks as Pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pod: Option<JobConfigTemplateSpecTaskTemplatePod>,
}

/// Describes how to create tasks as Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigTemplateSpecTaskTemplatePod {
    /// Standard object's metadata that will be added to Pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, serde_json::Value>>,
    /// Specification of the desired behavior of the pod. API docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#podspec-v1-core 
    ///  Supports context variable substitution in the following fields for containers and initContainers: image, command, args, env.value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

/// JobConfigStatus defines the observed state of the JobConfig.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigStatus {
    /// Total number of active jobs created for the JobConfig. An active job is one that is waiting to create a task, waiting for a task to be running, or has a running task.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active: Option<i64>,
    /// A list of pointers to active Job objects for the JobConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeJobs")]
    pub active_jobs: Option<Vec<JobConfigStatusActiveJobs>>,
    /// The last timestamp that the job config was executed, including both scheduled and adhoc executions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastExecuted")]
    pub last_executed: Option<String>,
    /// The last known schedule time for this job config, used to persist state during controller downtime. If the controller was down for a short period of time, any schedules that were missed during the downtime will be back-scheduled, subject to the number of schedules missed since LastScheduled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastScheduled")]
    pub last_scheduled: Option<String>,
    /// Total number of Jobs queued for the JobConfig. A job that is queued is one that is not yet started.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queued: Option<i64>,
    /// A list of pointers to Job objects queued for the JobConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queuedJobs")]
    pub queued_jobs: Option<Vec<JobConfigStatusQueuedJobs>>,
    /// Human-readable and high-level representation of the status of the JobConfig.
    pub state: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigStatusActiveJobs {
    /// Timestamp that the Job was created.
    #[serde(rename = "creationTimestamp")]
    pub creation_timestamp: String,
    /// Name of the Job.
    pub name: String,
    /// Phase of the Job.
    pub phase: String,
    /// Timestamp that the Job was started.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// UID of the Job.
    pub uid: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct JobConfigStatusQueuedJobs {
    /// Timestamp that the Job was created.
    #[serde(rename = "creationTimestamp")]
    pub creation_timestamp: String,
    /// Name of the Job.
    pub name: String,
    /// Phase of the Job.
    pub phase: String,
    /// Timestamp that the Job was started.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    /// UID of the Job.
    pub uid: String,
}

