// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/3scale/3scale-operator/capabilities.3scale.net/v1beta1/backends.yaml --derive=PartialEq
// kopium version: 0.16.5

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// BackendSpec defines the desired state of Backend
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "capabilities.3scale.net", version = "v1beta1", kind = "Backend", plural = "backends")]
#[kube(namespaced)]
#[kube(status = "BackendStatus")]
#[kube(schema = "disabled")]
pub struct BackendSpec {
    /// Description is a human readable text of the backend
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mappingRules")]
    pub mapping_rules: Option<Vec<BackendMappingRules>>,
    /// Methods Map: system_name -> MethodSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub methods: Option<BTreeMap<String, BackendMethods>>,
    /// Metrics Map: system_name -> MetricSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<BTreeMap<String, BackendMetrics>>,
    /// Name is human readable name for the backend
    pub name: String,
    /// PrivateBaseURL Private Base URL of the API
    #[serde(rename = "privateBaseURL")]
    pub private_base_url: String,
    /// ProviderAccountRef references account provider credentials
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerAccountRef")]
    pub provider_account_ref: Option<BackendProviderAccountRef>,
    /// SystemName identifies uniquely the backend within the account provider Default value will be sanitized Name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "systemName")]
    pub system_name: Option<String>,
}

/// MappingRuleSpec defines the desired state of Product's MappingRule
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BackendMappingRules {
    #[serde(rename = "httpMethod")]
    pub http_method: BackendMappingRulesHttpMethod,
    pub increment: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last: Option<bool>,
    #[serde(rename = "metricMethodRef")]
    pub metric_method_ref: String,
    pub pattern: String,
}

/// MappingRuleSpec defines the desired state of Product's MappingRule
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum BackendMappingRulesHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "CONNECT")]
    Connect,
}

/// Methods Map: system_name -> MethodSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BackendMethods {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "friendlyName")]
    pub friendly_name: Option<String>,
}

/// Metrics Map: system_name -> MetricSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BackendMetrics {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "friendlyName")]
    pub friendly_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
}

/// ProviderAccountRef references account provider credentials
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BackendProviderAccountRef {
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// BackendStatus defines the observed state of Backend
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BackendStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backendId")]
    pub backend_id: Option<i64>,
    /// Current state of the 3scale backend. Conditions represent the latest available observations of an object's state
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<BackendStatusConditions>>,
    /// ObservedGeneration reflects the generation of the most recently observed Backend Spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// 3scale control plane host
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerAccountHost")]
    pub provider_account_host: Option<String>,
}

/// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
///  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BackendStatusConditions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    pub status: String,
    /// ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
    ///  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
    #[serde(rename = "type")]
    pub r#type: String,
}

