// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/hashicorp/vault-secrets-operator/secrets.hashicorp.com/v1beta1/vaultauths.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// VaultAuthSpec defines the desired state of VaultAuth
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "secrets.hashicorp.com", version = "v1beta1", kind = "VaultAuth", plural = "vaultauths")]
#[kube(namespaced)]
#[kube(status = "VaultAuthStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct VaultAuthSpec {
    /// AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod.
    /// This field allows administrators to customize which Kubernetes namespaces are authorized to
    /// use with this AuthMethod. While Vault will still enforce its own rules, this has the added
    /// configurability of restricting which VaultAuthMethods can be used by which namespaces.
    /// Accepted values:
    /// []{"*"} - wildcard, all namespaces.
    /// []{"a", "b"} - list of namespaces.
    /// unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this
    /// is the default behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedNamespaces")]
    pub allowed_namespaces: Option<Vec<String>>,
    /// AppRole specific auth configuration, requires that the Method be set to `appRole`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appRole")]
    pub app_role: Option<VaultAuthAppRole>,
    /// AWS specific auth configuration, requires that Method be set to `aws`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<VaultAuthAws>,
    /// GCP specific auth configuration, requires that Method be set to `gcp`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gcp: Option<VaultAuthGcp>,
    /// Headers to be included in all Vault requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, String>>,
    /// JWT specific auth configuration, requires that the Method be set to `jwt`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<VaultAuthJwt>,
    /// Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kubernetes: Option<VaultAuthKubernetes>,
    /// Method to use when authenticating to Vault.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<VaultAuthMethod>,
    /// Mount to use when authenticating to auth method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mount: Option<String>,
    /// Namespace to auth to in Vault
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Params to use when authenticating to Vault
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, String>>,
    /// StorageEncryption provides the necessary configuration to encrypt the client storage cache.
    /// This should only be configured when client cache persistence with encryption is enabled.
    /// This is done by passing setting the manager's commandline argument
    /// --client-cache-persistence-model=direct-encrypted. Typically, there should only ever
    /// be one VaultAuth configured with StorageEncryption in the Cluster, and it should have
    /// the label: cacheStorageEncryption=true
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageEncryption")]
    pub storage_encryption: Option<VaultAuthStorageEncryption>,
    /// VaultAuthGlobalRef.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vaultAuthGlobalRef")]
    pub vault_auth_global_ref: Option<VaultAuthVaultAuthGlobalRef>,
    /// VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace,
    /// eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to
    /// namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the
    /// Operator will default to the `default` VaultConnection, configured in the operator's namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vaultConnectionRef")]
    pub vault_connection_ref: Option<String>,
}

/// AppRole specific auth configuration, requires that the Method be set to `appRole`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VaultAuthAppRole {
    /// RoleID of the AppRole Role to use for authenticating to Vault.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleId")]
    pub role_id: Option<String>,
    /// SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which
    /// provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the
    /// AppRole Role's secretID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<String>,
}

/// AWS specific auth configuration, requires that Method be set to `aws`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VaultAuthAws {
    /// The Vault header value to include in the STS signing request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerValue")]
    pub header_value: Option<String>,
    /// The IAM endpoint to use; if not set will use the default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iamEndpoint")]
    pub iam_endpoint: Option<String>,
    /// IRSAServiceAccount name to use with IAM Roles for Service Accounts
    /// (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This
    /// ServiceAccount will be checked for other EKS annotations:
    /// eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "irsaServiceAccount")]
    pub irsa_service_account: Option<String>,
    /// AWS Region to use for signing the authentication request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// Vault role to use for authenticating
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// SecretRef is the name of a Kubernetes Secret in the consumer's (VDS/VSS/PKI) namespace
    /// which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`,
    /// `session_token`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<String>,
    /// The role session name to use when creating a webidentity provider
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionName")]
    pub session_name: Option<String>,
    /// The STS endpoint to use; if not set will use the default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stsEndpoint")]
    pub sts_endpoint: Option<String>,
}

/// GCP specific auth configuration, requires that Method be set to `gcp`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VaultAuthGcp {
    /// GKE cluster name. Defaults to the cluster-name returned from the operator
    /// pod's local metadata server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterName")]
    pub cluster_name: Option<String>,
    /// GCP project ID. Defaults to the project-id returned from the operator
    /// pod's local metadata server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectID")]
    pub project_id: Option<String>,
    /// GCP Region of the GKE cluster's identity provider. Defaults to the region
    /// returned from the operator pod's local metadata server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// Vault role to use for authenticating
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// WorkloadIdentityServiceAccount is the name of a Kubernetes service
    /// account (in the same Kubernetes namespace as the Vault*Secret referencing
    /// this resource) which has been configured for workload identity in GKE.
    /// Should be annotated with "iam.gke.io/gcp-service-account".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadIdentityServiceAccount")]
    pub workload_identity_service_account: Option<String>,
}

/// JWT specific auth configuration, requires that the Method be set to `jwt`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VaultAuthJwt {
    /// TokenAudiences to include in the ServiceAccount token.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// Role to use for authenticating to Vault.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which
    /// provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must
    /// have a key named `jwt` which holds the JWT token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<String>,
    /// ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's
    /// JWT authentication backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// TokenExpirationSeconds to set the ServiceAccount token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenExpirationSeconds")]
    pub token_expiration_seconds: Option<i64>,
}

/// Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VaultAuthKubernetes {
    /// TokenAudiences to include in the ServiceAccount token.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// Role to use for authenticating to Vault.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// ServiceAccount to use when authenticating to Vault's
    /// authentication backend. This must reside in the consuming secret's (VDS/VSS/PKI) namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// TokenExpirationSeconds to set the ServiceAccount token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenExpirationSeconds")]
    pub token_expiration_seconds: Option<i64>,
}

/// VaultAuthSpec defines the desired state of VaultAuth
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VaultAuthMethod {
    #[serde(rename = "kubernetes")]
    Kubernetes,
    #[serde(rename = "jwt")]
    Jwt,
    #[serde(rename = "appRole")]
    AppRole,
    #[serde(rename = "aws")]
    Aws,
    #[serde(rename = "gcp")]
    Gcp,
}

/// StorageEncryption provides the necessary configuration to encrypt the client storage cache.
/// This should only be configured when client cache persistence with encryption is enabled.
/// This is done by passing setting the manager's commandline argument
/// --client-cache-persistence-model=direct-encrypted. Typically, there should only ever
/// be one VaultAuth configured with StorageEncryption in the Cluster, and it should have
/// the label: cacheStorageEncryption=true
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VaultAuthStorageEncryption {
    /// KeyName to use for encrypt/decrypt operations via Vault Transit.
    #[serde(rename = "keyName")]
    pub key_name: String,
    /// Mount path of the Transit engine in Vault.
    pub mount: String,
}

/// VaultAuthGlobalRef.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VaultAuthVaultAuthGlobalRef {
    /// AllowDefault when set to true will use the default VaultAuthGlobal resource
    /// as the default if Name is not set. The 'allow-default-globals' option must be
    /// set on the operator's '-global-vault-auth-options' flag
    /// 
    /// 
    /// The default VaultAuthGlobal search is conditional.
    /// When a ref Namespace is set, the search for the default
    /// VaultAuthGlobal resource is constrained to that namespace.
    /// Otherwise, the search order is:
    /// 1. The default VaultAuthGlobal resource in the referring VaultAuth resource's
    /// namespace.
    /// 2. The default VaultAuthGlobal resource in the Operator's namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowDefault")]
    pub allow_default: Option<bool>,
    /// MergeStrategy configures the merge strategy for HTTP headers and parameters
    /// that are included in all Vault authentication requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mergeStrategy")]
    pub merge_strategy: Option<VaultAuthVaultAuthGlobalRefMergeStrategy>,
    /// Name of the VaultAuthGlobal resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the VaultAuthGlobal resource. If not provided, the namespace of
    /// the referring VaultAuth resource is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// MergeStrategy configures the merge strategy for HTTP headers and parameters
/// that are included in all Vault authentication requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VaultAuthVaultAuthGlobalRefMergeStrategy {
    /// Headers configures the merge strategy for HTTP headers that are included in
    /// all Vault requests. Choices are `union`, `replace`, or `none`.
    /// 
    /// 
    /// If `union` is set, the headers from the VaultAuthGlobal and VaultAuth
    /// resources are merged. The headers from the VaultAuth always take precedence.
    /// 
    /// 
    /// If `replace` is set, the first set of non-empty headers taken in order from:
    /// VaultAuth, VaultAuthGlobal auth method, VaultGlobal default headers.
    /// 
    /// 
    /// If `none` is set, the headers from the
    /// VaultAuthGlobal resource are ignored and only the headers from the VaultAuth
    /// resource are used. The default is `none`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<VaultAuthVaultAuthGlobalRefMergeStrategyHeaders>,
    /// Params configures the merge strategy for HTTP parameters that are included in
    /// all Vault requests. Choices are `union`, `replace`, or `none`.
    /// 
    /// 
    /// If `union` is set, the parameters from the VaultAuthGlobal and VaultAuth
    /// resources are merged. The parameters from the VaultAuth always take
    /// precedence.
    /// 
    /// 
    /// If `replace` is set, the first set of non-empty parameters taken in order from:
    /// VaultAuth, VaultAuthGlobal auth method, VaultGlobal default parameters.
    /// 
    /// 
    /// If `none` is set, the parameters from the VaultAuthGlobal resource are ignored
    /// and only the parameters from the VaultAuth resource are used. The default is
    /// `none`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<VaultAuthVaultAuthGlobalRefMergeStrategyParams>,
}

/// MergeStrategy configures the merge strategy for HTTP headers and parameters
/// that are included in all Vault authentication requests.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VaultAuthVaultAuthGlobalRefMergeStrategyHeaders {
    #[serde(rename = "union")]
    Union,
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "none")]
    None,
}

/// MergeStrategy configures the merge strategy for HTTP headers and parameters
/// that are included in all Vault authentication requests.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VaultAuthVaultAuthGlobalRefMergeStrategyParams {
    #[serde(rename = "union")]
    Union,
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "none")]
    None,
}

/// VaultAuthStatus defines the observed state of VaultAuth
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VaultAuthStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "specHash")]
    pub spec_hash: Option<String>,
    /// Valid auth mechanism.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub valid: Option<bool>,
}

