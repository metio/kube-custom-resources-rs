// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/kubernetes-sigs/cluster-api-provider-ibmcloud/infrastructure.cluster.x-k8s.io/v1beta2/ibmpowervsclusters.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// IBMPowerVSClusterSpec defines the desired state of IBMPowerVSCluster.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "infrastructure.cluster.x-k8s.io", version = "v1beta2", kind = "IBMPowerVSCluster", plural = "ibmpowervsclusters")]
#[kube(namespaced)]
#[kube(status = "IBMPowerVSClusterStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct IBMPowerVSClusterSpec {
    /// ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlaneEndpoint")]
    pub control_plane_endpoint: Option<IBMPowerVSClusterControlPlaneEndpoint>,
    /// cosInstance contains options to configure a supporting IBM Cloud COS bucket for this
    /// cluster - currently used for nodes requiring Ignition
    /// (https://coreos.github.io/ignition/) for bootstrapping (requires
    /// BootstrapFormatIgnition feature flag to be enabled).
    /// when powervs.cluster.x-k8s.io/create-infra=true annotation is set on IBMPowerVSCluster resource and Ignition is set, then
    /// 1. CosInstance.Name should be set not setting will result in webhook error.
    /// 2. CosInstance.BucketName should be set not setting will result in webhook error.
    /// 3. CosInstance.BucketRegion should be set not setting will result in webhook error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cosInstance")]
    pub cos_instance: Option<IBMPowerVSClusterCosInstance>,
    /// dhcpServer is contains the configuration to be used while creating a new DHCP server in PowerVS workspace.
    /// when the field is omitted, CLUSTER_NAME will be used as DHCPServer.Name and DHCP server will be created.
    /// it will automatically create network with name DHCPSERVER<DHCPServer.Name>_Private in PowerVS workspace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dhcpServer")]
    pub dhcp_server: Option<IBMPowerVSClusterDhcpServer>,
    /// Ignition defined options related to the bootstrapping systems where Ignition is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignition: Option<IBMPowerVSClusterIgnition>,
    /// loadBalancers is optional configuration for configuring loadbalancers to control plane or data plane nodes.
    /// when omitted system will create a default public loadbalancer with name CLUSTER_NAME-loadbalancer.
    /// when specified a vpc loadbalancer will be created and controlPlaneEndpoint will be set with associated hostname of loadbalancer.
    /// ControlPlaneEndpoint will be set with associated hostname of public loadbalancer.
    /// when LoadBalancers[].ID is set, its expected that there exist a loadbalancer with ID or else system will give error.
    /// when LoadBalancers[].Name is set, system will first check for loadbalancer with Name, if not exist system will create new loadbalancer.
    /// For each loadbalancer a default backed pool and front listener will be configured with port 6443.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancers")]
    pub load_balancers: Option<Vec<IBMPowerVSClusterLoadBalancers>>,
    /// Network is the reference to the Network to use for this cluster.
    /// when the field is omitted, A DHCP service will be created in the Power VS workspace and its private network will be used.
    /// the DHCP service created network will have the following name format
    /// 1. in the case of DHCPServer.Name is not set the name will be DHCPSERVER<CLUSTER_NAME>_Private.
    /// 2. if DHCPServer.Name is set the name will be DHCPSERVER<DHCPServer.Name>_Private.
    /// when Network.ID is set, its expected that there exist a network in PowerVS workspace with id or else system will give error.
    /// when Network.Name is set, system will first check for network with Name in PowerVS workspace, if not exist network will be created by DHCP service.
    /// Network.RegEx is not yet supported and system will ignore the value.
    pub network: IBMPowerVSClusterNetwork,
    /// resourceGroup name under which the resources will be created.
    /// when powervs.cluster.x-k8s.io/create-infra=true annotation is set on IBMPowerVSCluster resource,
    /// 1. it is expected to set the ResourceGroup.Name, not setting will result in webhook error.
    /// ResourceGroup.ID and ResourceGroup.Regex is not yet supported and system will ignore the value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceGroup")]
    pub resource_group: Option<IBMPowerVSClusterResourceGroup>,
    /// serviceInstance is the reference to the Power VS server workspace on which the server instance(VM) will be created.
    /// Power VS server workspace is a container for all Power VS instances at a specific geographic region.
    /// serviceInstance can be created via IBM Cloud catalog or CLI.
    /// supported serviceInstance identifier in PowerVSResource are Name and ID and that can be obtained from IBM Cloud UI or IBM Cloud cli.
    /// More detail about Power VS service instance.
    /// https://cloud.ibm.com/docs/power-iaas?topic=power-iaas-creating-power-virtual-server
    /// when omitted system will dynamically create the service instance with name CLUSTER_NAME-serviceInstance.
    /// when ServiceInstance.ID is set, its expected that there exist a service instance in PowerVS workspace with id or else system will give error.
    /// when ServiceInstance.Name is set, system will first check for service instance with Name in PowerVS workspace, if not exist system will create new instance.
    /// if there are more than one service instance exist with the ServiceInstance.Name in given Zone, installation fails with an error. Use ServiceInstance.ID in those situations to use the specific service instance.
    /// ServiceInstance.Regex is not yet supported not yet supported and system will ignore the value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceInstance")]
    pub service_instance: Option<IBMPowerVSClusterServiceInstance>,
    /// ServiceInstanceID is the id of the power cloud instance where the vsi instance will get deployed.
    /// Deprecated: use ServiceInstance instead
    #[serde(rename = "serviceInstanceID")]
    pub service_instance_id: String,
    /// transitGateway contains information about IBM Cloud TransitGateway
    /// IBM Cloud TransitGateway helps in establishing network connectivity between IBM Cloud Power VS and VPC infrastructure
    /// more information about TransitGateway can be found here https://www.ibm.com/products/transit-gateway.
    /// when TransitGateway.ID is set, its expected that there exist a TransitGateway with ID or else system will give error.
    /// when TransitGateway.Name is set, system will first check for TransitGateway with Name, if not exist system will create new TransitGateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitGateway")]
    pub transit_gateway: Option<IBMPowerVSClusterTransitGateway>,
    /// vpc contains information about IBM Cloud VPC resources.
    /// when omitted system will dynamically create the VPC with name CLUSTER_NAME-vpc.
    /// when VPC.ID is set, its expected that there exist a VPC with ID or else system will give error.
    /// when VPC.Name is set, system will first check for VPC with Name, if not exist system will create new VPC.
    /// when powervs.cluster.x-k8s.io/create-infra=true annotation is set on IBMPowerVSCluster resource,
    /// 1. it is expected to set the VPC.Region, not setting will result in webhook error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vpc: Option<IBMPowerVSClusterVpc>,
    /// VPCSecurityGroups to attach it to the VPC resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSecurityGroups")]
    pub vpc_security_groups: Option<Vec<IBMPowerVSClusterVpcSecurityGroups>>,
    /// vpcSubnets contains information about IBM Cloud VPC Subnet resources.
    /// when omitted system will create the subnets in all the zone corresponding to VPC.Region, with name CLUSTER_NAME-vpcsubnet-ZONE_NAME.
    /// possible values can be found here https://cloud.ibm.com/docs/power-iaas?topic=power-iaas-creating-power-virtual-server.
    /// when VPCSubnets[].ID is set, its expected that there exist a subnet with ID or else system will give error.
    /// when VPCSubnets[].Zone is not set, a random zone is picked from available zones of VPC.Region.
    /// when VPCSubnets[].Name is not set, system will set name as CLUSTER_NAME-vpcsubnet-INDEX.
    /// if subnet with name VPCSubnets[].Name not found, system will create new subnet in VPCSubnets[].Zone.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSubnets")]
    pub vpc_subnets: Option<Vec<IBMPowerVSClusterVpcSubnets>>,
    /// zone is the name of Power VS zone where the cluster will be created
    /// possible values can be found here https://cloud.ibm.com/docs/power-iaas?topic=power-iaas-creating-power-virtual-server.
    /// when powervs.cluster.x-k8s.io/create-infra=true annotation is set on IBMPowerVSCluster resource,
    /// 1. it is expected to set the zone, not setting will result in webhook error.
    /// 2. the zone should have PER capabilities, or else system will give error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<String>,
}

/// ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterControlPlaneEndpoint {
    /// The hostname on which the API server is serving.
    pub host: String,
    /// The port on which the API server is serving.
    pub port: i32,
}

/// cosInstance contains options to configure a supporting IBM Cloud COS bucket for this
/// cluster - currently used for nodes requiring Ignition
/// (https://coreos.github.io/ignition/) for bootstrapping (requires
/// BootstrapFormatIgnition feature flag to be enabled).
/// when powervs.cluster.x-k8s.io/create-infra=true annotation is set on IBMPowerVSCluster resource and Ignition is set, then
/// 1. CosInstance.Name should be set not setting will result in webhook error.
/// 2. CosInstance.BucketName should be set not setting will result in webhook error.
/// 3. CosInstance.BucketRegion should be set not setting will result in webhook error.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterCosInstance {
    /// bucketName is IBM cloud COS bucket name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketName")]
    pub bucket_name: Option<String>,
    /// bucketRegion is IBM cloud COS bucket region
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bucketRegion")]
    pub bucket_region: Option<String>,
    /// name defines name of IBM cloud COS instance to be created.
    /// when IBMPowerVSCluster.Ignition is set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// dhcpServer is contains the configuration to be used while creating a new DHCP server in PowerVS workspace.
/// when the field is omitted, CLUSTER_NAME will be used as DHCPServer.Name and DHCP server will be created.
/// it will automatically create network with name DHCPSERVER<DHCPServer.Name>_Private in PowerVS workspace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterDhcpServer {
    /// Optional cidr for DHCP private network
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// Optional DNS Server for DHCP service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsServer")]
    pub dns_server: Option<String>,
    /// Optional id of the existing DHCPServer
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Optional name of DHCP Service. Only alphanumeric characters and dashes are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Optional indicates if SNAT will be enabled for DHCP service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub snat: Option<bool>,
}

/// Ignition defined options related to the bootstrapping systems where Ignition is used.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterIgnition {
    /// Version defines which version of Ignition will be used to generate bootstrap data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<IBMPowerVSClusterIgnitionVersion>,
}

/// Ignition defined options related to the bootstrapping systems where Ignition is used.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum IBMPowerVSClusterIgnitionVersion {
    #[serde(rename = "2.3")]
    r#_23,
    #[serde(rename = "2.4")]
    r#_24,
    #[serde(rename = "3.0")]
    r#_30,
    #[serde(rename = "3.1")]
    r#_31,
    #[serde(rename = "3.2")]
    r#_32,
    #[serde(rename = "3.3")]
    r#_33,
    #[serde(rename = "3.4")]
    r#_34,
}

/// VPCLoadBalancerSpec defines the desired state of an VPC load balancer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterLoadBalancers {
    /// AdditionalListeners sets the additional listeners for the control plane load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalListeners")]
    pub additional_listeners: Option<Vec<IBMPowerVSClusterLoadBalancersAdditionalListeners>>,
    /// id of the loadbalancer
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Name sets the name of the VPC load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// public indicates that load balancer is public or private
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
}

/// AdditionalListenerSpec defines the desired state of an
/// additional listener on an VPC load balancer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterLoadBalancersAdditionalListeners {
    /// Port sets the port for the additional listener.
    pub port: i64,
}

/// Network is the reference to the Network to use for this cluster.
/// when the field is omitted, A DHCP service will be created in the Power VS workspace and its private network will be used.
/// the DHCP service created network will have the following name format
/// 1. in the case of DHCPServer.Name is not set the name will be DHCPSERVER<CLUSTER_NAME>_Private.
/// 2. if DHCPServer.Name is set the name will be DHCPSERVER<DHCPServer.Name>_Private.
/// when Network.ID is set, its expected that there exist a network in PowerVS workspace with id or else system will give error.
/// when Network.Name is set, system will first check for network with Name in PowerVS workspace, if not exist network will be created by DHCP service.
/// Network.RegEx is not yet supported and system will ignore the value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterNetwork {
    /// ID of resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Name of resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Regular expression to match resource,
    /// In case of multiple resources matches the provided regular expression the first matched resource will be selected
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

/// resourceGroup name under which the resources will be created.
/// when powervs.cluster.x-k8s.io/create-infra=true annotation is set on IBMPowerVSCluster resource,
/// 1. it is expected to set the ResourceGroup.Name, not setting will result in webhook error.
/// ResourceGroup.ID and ResourceGroup.Regex is not yet supported and system will ignore the value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterResourceGroup {
    /// ID of resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Name of resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Regular expression to match resource,
    /// In case of multiple resources matches the provided regular expression the first matched resource will be selected
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

/// serviceInstance is the reference to the Power VS server workspace on which the server instance(VM) will be created.
/// Power VS server workspace is a container for all Power VS instances at a specific geographic region.
/// serviceInstance can be created via IBM Cloud catalog or CLI.
/// supported serviceInstance identifier in PowerVSResource are Name and ID and that can be obtained from IBM Cloud UI or IBM Cloud cli.
/// More detail about Power VS service instance.
/// https://cloud.ibm.com/docs/power-iaas?topic=power-iaas-creating-power-virtual-server
/// when omitted system will dynamically create the service instance with name CLUSTER_NAME-serviceInstance.
/// when ServiceInstance.ID is set, its expected that there exist a service instance in PowerVS workspace with id or else system will give error.
/// when ServiceInstance.Name is set, system will first check for service instance with Name in PowerVS workspace, if not exist system will create new instance.
/// if there are more than one service instance exist with the ServiceInstance.Name in given Zone, installation fails with an error. Use ServiceInstance.ID in those situations to use the specific service instance.
/// ServiceInstance.Regex is not yet supported not yet supported and system will ignore the value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterServiceInstance {
    /// ID of resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Name of resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Regular expression to match resource,
    /// In case of multiple resources matches the provided regular expression the first matched resource will be selected
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

/// transitGateway contains information about IBM Cloud TransitGateway
/// IBM Cloud TransitGateway helps in establishing network connectivity between IBM Cloud Power VS and VPC infrastructure
/// more information about TransitGateway can be found here https://www.ibm.com/products/transit-gateway.
/// when TransitGateway.ID is set, its expected that there exist a TransitGateway with ID or else system will give error.
/// when TransitGateway.Name is set, system will first check for TransitGateway with Name, if not exist system will create new TransitGateway.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterTransitGateway {
    /// globalRouting indicates whether to set global routing true or not while creating the transit gateway.
    /// set this field to true only when PowerVS and VPC are from different regions, if they are same it's suggested to use local routing by setting the field to false.
    /// when the field is omitted,  based on PowerVS region (region associated with IBMPowerVSCluster.Spec.Zone) and VPC region(IBMPowerVSCluster.Spec.VPC.Region) system will decide whether to enable globalRouting or not.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalRouting")]
    pub global_routing: Option<bool>,
    /// id of resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// name of resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// vpc contains information about IBM Cloud VPC resources.
/// when omitted system will dynamically create the VPC with name CLUSTER_NAME-vpc.
/// when VPC.ID is set, its expected that there exist a VPC with ID or else system will give error.
/// when VPC.Name is set, system will first check for VPC with Name, if not exist system will create new VPC.
/// when powervs.cluster.x-k8s.io/create-infra=true annotation is set on IBMPowerVSCluster resource,
/// 1. it is expected to set the VPC.Region, not setting will result in webhook error.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterVpc {
    /// id of resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// name of resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// region of IBM Cloud VPC.
    /// when powervs.cluster.x-k8s.io/create-infra=true annotation is set on IBMPowerVSCluster resource,
    /// it is expected to set the region, not setting will result in webhook error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
}

/// VPCSecurityGroup defines a VPC Security Group that should exist or be created within the specified VPC, with the specified Security Group Rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterVpcSecurityGroups {
    /// id of the Security Group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// name of the Security Group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// rules are the Security Group Rules for the Security Group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<IBMPowerVSClusterVpcSecurityGroupsRules>>,
    /// tags are tags to add to the Security Group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
}

/// VPCSecurityGroupRule defines a VPC Security Group Rule for a specified Security Group.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct IBMPowerVSClusterVpcSecurityGroupsRules {
    /// action defines whether to allow or deny traffic defined by the Security Group Rule.
    pub action: IBMPowerVSClusterVpcSecurityGroupsRulesAction,
    /// destination is a VPCSecurityGroupRulePrototype which defines the destination of outbound traffic for the Security Group Rule.
    /// Only used when direction is VPCSecurityGroupRuleDirectionOutbound.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub destination: Option<IBMPowerVSClusterVpcSecurityGroupsRulesDestination>,
    /// direction defines whether the traffic is inbound or outbound for the Security Group Rule.
    pub direction: IBMPowerVSClusterVpcSecurityGroupsRulesDirection,
    /// securityGroupID is the ID of the Security Group for the Security Group Rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupID")]
    pub security_group_id: Option<String>,
    /// source is a VPCSecurityGroupRulePrototype which defines the source of inbound traffic for the Security Group Rule.
    /// Only used when direction is VPCSecurityGroupRuleDirectionInbound.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<IBMPowerVSClusterVpcSecurityGroupsRulesSource>,
}

/// VPCSecurityGroupRule defines a VPC Security Group Rule for a specified Security Group.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum IBMPowerVSClusterVpcSecurityGroupsRulesAction {
    #[serde(rename = "allow")]
    Allow,
    #[serde(rename = "deny")]
    Deny,
}

/// destination is a VPCSecurityGroupRulePrototype which defines the destination of outbound traffic for the Security Group Rule.
/// Only used when direction is VPCSecurityGroupRuleDirectionOutbound.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct IBMPowerVSClusterVpcSecurityGroupsRulesDestination {
    /// icmpCode is the ICMP code for the Rule.
    /// Only used when Protocol is VPCSecurityGroupRuleProtocolIcmp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "icmpCode")]
    pub icmp_code: Option<i64>,
    /// icmpType is the ICMP type for the Rule.
    /// Only used when Protocol is VPCSecurityGroupRuleProtocolIcmp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "icmpType")]
    pub icmp_type: Option<i64>,
    /// portRange is a range of ports allowed for the Rule's remote.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    pub port_range: Option<IBMPowerVSClusterVpcSecurityGroupsRulesDestinationPortRange>,
    /// protocol defines the traffic protocol used for the Security Group Rule.
    pub protocol: IBMPowerVSClusterVpcSecurityGroupsRulesDestinationProtocol,
    /// remotes is a set of VPCSecurityGroupRuleRemote's that define the traffic allowed by the Rule's remote.
    /// Specifying multiple VPCSecurityGroupRuleRemote's creates a unique Security Group Rule with the shared Protocol, PortRange, etc.
    /// This allows for easier management of Security Group Rule's for sets of CIDR's, IP's, etc.
    pub remotes: Vec<IBMPowerVSClusterVpcSecurityGroupsRulesDestinationRemotes>,
}

/// portRange is a range of ports allowed for the Rule's remote.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterVpcSecurityGroupsRulesDestinationPortRange {
    /// maximumPort is the inclusive upper range of ports.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumPort")]
    pub maximum_port: Option<i64>,
    /// minimumPort is the inclusive lower range of ports.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumPort")]
    pub minimum_port: Option<i64>,
}

/// destination is a VPCSecurityGroupRulePrototype which defines the destination of outbound traffic for the Security Group Rule.
/// Only used when direction is VPCSecurityGroupRuleDirectionOutbound.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum IBMPowerVSClusterVpcSecurityGroupsRulesDestinationProtocol {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "icmp")]
    Icmp,
    #[serde(rename = "tcp")]
    Tcp,
    #[serde(rename = "udp")]
    Udp,
}

/// VPCSecurityGroupRuleRemote defines a VPC Security Group Rule's remote details.
/// The type of remote defines the additional remote details where are used for defining the remote.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct IBMPowerVSClusterVpcSecurityGroupsRulesDestinationRemotes {
    ///  address is the address to use for the remote's destination/source.
    /// Only used when remoteType is VPCSecurityGroupRuleRemoteTypeAddress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// cidrSubnetName is the name of the VPC Subnet to retrieve the CIDR from, to use for the remote's destination/source.
    /// Only used when remoteType is VPCSecurityGroupRuleRemoteTypeCIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrSubnetName")]
    pub cidr_subnet_name: Option<String>,
    /// remoteType defines the type of filter to define for the remote's destination/source.
    #[serde(rename = "remoteType")]
    pub remote_type: IBMPowerVSClusterVpcSecurityGroupsRulesDestinationRemotesRemoteType,
    /// securityGroupName is the name of the VPC Security Group to use for the remote's destination/source.
    /// Only used when remoteType is VPCSecurityGroupRuleRemoteTypeSG
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupName")]
    pub security_group_name: Option<String>,
}

/// VPCSecurityGroupRuleRemote defines a VPC Security Group Rule's remote details.
/// The type of remote defines the additional remote details where are used for defining the remote.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum IBMPowerVSClusterVpcSecurityGroupsRulesDestinationRemotesRemoteType {
    #[serde(rename = "any")]
    Any,
    #[serde(rename = "cidr")]
    Cidr,
    #[serde(rename = "address")]
    Address,
    #[serde(rename = "sg")]
    Sg,
}

/// VPCSecurityGroupRule defines a VPC Security Group Rule for a specified Security Group.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum IBMPowerVSClusterVpcSecurityGroupsRulesDirection {
    #[serde(rename = "inbound")]
    Inbound,
    #[serde(rename = "outbound")]
    Outbound,
}

/// source is a VPCSecurityGroupRulePrototype which defines the source of inbound traffic for the Security Group Rule.
/// Only used when direction is VPCSecurityGroupRuleDirectionInbound.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct IBMPowerVSClusterVpcSecurityGroupsRulesSource {
    /// icmpCode is the ICMP code for the Rule.
    /// Only used when Protocol is VPCSecurityGroupRuleProtocolIcmp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "icmpCode")]
    pub icmp_code: Option<i64>,
    /// icmpType is the ICMP type for the Rule.
    /// Only used when Protocol is VPCSecurityGroupRuleProtocolIcmp.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "icmpType")]
    pub icmp_type: Option<i64>,
    /// portRange is a range of ports allowed for the Rule's remote.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    pub port_range: Option<IBMPowerVSClusterVpcSecurityGroupsRulesSourcePortRange>,
    /// protocol defines the traffic protocol used for the Security Group Rule.
    pub protocol: IBMPowerVSClusterVpcSecurityGroupsRulesSourceProtocol,
    /// remotes is a set of VPCSecurityGroupRuleRemote's that define the traffic allowed by the Rule's remote.
    /// Specifying multiple VPCSecurityGroupRuleRemote's creates a unique Security Group Rule with the shared Protocol, PortRange, etc.
    /// This allows for easier management of Security Group Rule's for sets of CIDR's, IP's, etc.
    pub remotes: Vec<IBMPowerVSClusterVpcSecurityGroupsRulesSourceRemotes>,
}

/// portRange is a range of ports allowed for the Rule's remote.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterVpcSecurityGroupsRulesSourcePortRange {
    /// maximumPort is the inclusive upper range of ports.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumPort")]
    pub maximum_port: Option<i64>,
    /// minimumPort is the inclusive lower range of ports.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumPort")]
    pub minimum_port: Option<i64>,
}

/// source is a VPCSecurityGroupRulePrototype which defines the source of inbound traffic for the Security Group Rule.
/// Only used when direction is VPCSecurityGroupRuleDirectionInbound.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum IBMPowerVSClusterVpcSecurityGroupsRulesSourceProtocol {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "icmp")]
    Icmp,
    #[serde(rename = "tcp")]
    Tcp,
    #[serde(rename = "udp")]
    Udp,
}

/// VPCSecurityGroupRuleRemote defines a VPC Security Group Rule's remote details.
/// The type of remote defines the additional remote details where are used for defining the remote.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct IBMPowerVSClusterVpcSecurityGroupsRulesSourceRemotes {
    ///  address is the address to use for the remote's destination/source.
    /// Only used when remoteType is VPCSecurityGroupRuleRemoteTypeAddress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// cidrSubnetName is the name of the VPC Subnet to retrieve the CIDR from, to use for the remote's destination/source.
    /// Only used when remoteType is VPCSecurityGroupRuleRemoteTypeCIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrSubnetName")]
    pub cidr_subnet_name: Option<String>,
    /// remoteType defines the type of filter to define for the remote's destination/source.
    #[serde(rename = "remoteType")]
    pub remote_type: IBMPowerVSClusterVpcSecurityGroupsRulesSourceRemotesRemoteType,
    /// securityGroupName is the name of the VPC Security Group to use for the remote's destination/source.
    /// Only used when remoteType is VPCSecurityGroupRuleRemoteTypeSG
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupName")]
    pub security_group_name: Option<String>,
}

/// VPCSecurityGroupRuleRemote defines a VPC Security Group Rule's remote details.
/// The type of remote defines the additional remote details where are used for defining the remote.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum IBMPowerVSClusterVpcSecurityGroupsRulesSourceRemotesRemoteType {
    #[serde(rename = "any")]
    Any,
    #[serde(rename = "cidr")]
    Cidr,
    #[serde(rename = "address")]
    Address,
    #[serde(rename = "sg")]
    Sg,
}

/// Subnet describes a subnet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterVpcSubnets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<String>,
}

/// IBMPowerVSClusterStatus defines the observed state of IBMPowerVSCluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatus {
    /// Conditions defines current service state of the IBMPowerVSCluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// cosInstance is reference to IBM Cloud COS Instance resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cosInstance")]
    pub cos_instance: Option<IBMPowerVSClusterStatusCosInstance>,
    /// dhcpServer is the reference to the Power VS DHCP server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dhcpServer")]
    pub dhcp_server: Option<IBMPowerVSClusterStatusDhcpServer>,
    /// loadBalancers reference to IBM Cloud VPC Loadbalancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancers")]
    pub load_balancers: Option<BTreeMap<String, IBMPowerVSClusterStatusLoadBalancers>>,
    /// networkID is the reference to the Power VS network to use for this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<IBMPowerVSClusterStatusNetwork>,
    /// ready is true when the provider resource is ready.
    pub ready: bool,
    /// ResourceGroup is the reference to the Power VS resource group under which the resources will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceGroupID")]
    pub resource_group_id: Option<IBMPowerVSClusterStatusResourceGroupId>,
    /// serviceInstance is the reference to the Power VS service on which the server instance(VM) will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceInstance")]
    pub service_instance: Option<IBMPowerVSClusterStatusServiceInstance>,
    /// transitGateway is reference to IBM Cloud TransitGateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "transitGateway")]
    pub transit_gateway: Option<IBMPowerVSClusterStatusTransitGateway>,
    /// vpc is reference to IBM Cloud VPC resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vpc: Option<IBMPowerVSClusterStatusVpc>,
    /// vpcSecurityGroups is reference to IBM Cloud VPC security group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSecurityGroups")]
    pub vpc_security_groups: Option<BTreeMap<String, IBMPowerVSClusterStatusVpcSecurityGroups>>,
    /// vpcSubnet is reference to IBM Cloud VPC subnet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSubnet")]
    pub vpc_subnet: Option<BTreeMap<String, IBMPowerVSClusterStatusVpcSubnet>>,
}

/// cosInstance is reference to IBM Cloud COS Instance resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusCosInstance {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// id represents the id of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// dhcpServer is the reference to the Power VS DHCP server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusDhcpServer {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// id represents the id of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// loadBalancers reference to IBM Cloud VPC Loadbalancer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusLoadBalancers {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// hostname is the hostname of load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// id of VPC load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// State is the status of the load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

/// networkID is the reference to the Power VS network to use for this cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusNetwork {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// id represents the id of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// ResourceGroup is the reference to the Power VS resource group under which the resources will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusResourceGroupId {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// id represents the id of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// serviceInstance is the reference to the Power VS service on which the server instance(VM) will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusServiceInstance {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// id represents the id of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// transitGateway is reference to IBM Cloud TransitGateway.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusTransitGateway {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// id represents the id of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// vpc is reference to IBM Cloud VPC resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusVpc {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// id represents the id of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// vpcSecurityGroups is reference to IBM Cloud VPC security group.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusVpcSecurityGroups {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// id represents the id of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// rules contains the id of rules created under the security group
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ruleIDs")]
    pub rule_i_ds: Option<Vec<String>>,
}

/// vpcSubnet is reference to IBM Cloud VPC subnet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IBMPowerVSClusterStatusVpcSubnet {
    /// controllerCreated indicates whether the resource is created by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerCreated")]
    pub controller_created: Option<bool>,
    /// id represents the id of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

