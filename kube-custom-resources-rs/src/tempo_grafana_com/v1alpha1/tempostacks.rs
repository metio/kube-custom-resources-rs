// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/grafana/tempo-operator/tempo.grafana.com/v1alpha1/tempostacks.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// TempoStackSpec defines the desired state of TempoStack.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "tempo.grafana.com", version = "v1alpha1", kind = "TempoStack", plural = "tempostacks")]
#[kube(namespaced)]
#[kube(status = "TempoStackStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct TempoStackSpec {
    /// ExtraConfigSpec defines extra configurations for tempo that will be merged with the operator generated, configurations defined here
    /// has precedence and could override generated config.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraConfig")]
    pub extra_config: Option<TempoStackExtraConfig>,
    /// HashRing defines the spec for the distributed hash ring configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashRing")]
    pub hash_ring: Option<TempoStackHashRing>,
    /// Images defines the image for each container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub images: Option<TempoStackImages>,
    /// LimitSpec is used to limit ingestion and querying rates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<TempoStackLimits>,
    /// ManagementState defines if the CR should be managed by the operator or not.
    /// Default is managed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementState")]
    pub management_state: Option<TempoStackManagementState>,
    /// ObservabilitySpec defines how telemetry data gets handled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub observability: Option<TempoStackObservability>,
    /// ReplicationFactor is used to define how many component replicas should exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicationFactor")]
    pub replication_factor: Option<i64>,
    /// Resources defines resources configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackResources>,
    /// Retention period defined by dataset.
    /// User can specify how long data should be stored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retention: Option<TempoStackRetention>,
    /// SearchSpec control the configuration for the search capabilities.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub search: Option<TempoStackSearch>,
    /// ServiceAccount defines the service account to use for all tempo components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// Storage defines the spec for the object storage endpoint to store traces.
    /// User is required to create secret and supply it.
    pub storage: TempoStackStorage,
    /// StorageClassName for PVCs used by ingester. Defaults to nil (default storage class in the cluster).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// StorageSize for PVCs used by ingester. Defaults to 10Gi.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageSize")]
    pub storage_size: Option<IntOrString>,
    /// Template defines requirements for a set of tempo components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TempoStackTemplate>,
    /// Tenants defines the per-tenant authentication and authorization spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenants: Option<TempoStackTenants>,
}

/// ExtraConfigSpec defines extra configurations for tempo that will be merged with the operator generated, configurations defined here
/// has precedence and could override generated config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackExtraConfig {
    /// Tempo defines any extra Tempo configuration, which will be merged with the operator's generated Tempo configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tempo: Option<serde_json::Value>,
}

/// HashRing defines the spec for the distributed hash ring configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackHashRing {
    /// MemberList configuration spec
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memberlist: Option<TempoStackHashRingMemberlist>,
}

/// MemberList configuration spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackHashRingMemberlist {
    /// EnableIPv6 enables IPv6 support for the memberlist based hash ring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIPv6")]
    pub enable_i_pv6: Option<bool>,
}

/// Images defines the image for each container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackImages {
    /// OauthProxy defines the oauth proxy image used to protect the jaegerUI on single tenant.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthProxy")]
    pub oauth_proxy: Option<String>,
    /// Tempo defines the tempo container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tempo: Option<String>,
    /// TempoGateway defines the tempo-gateway container image.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoGateway")]
    pub tempo_gateway: Option<String>,
    /// TempoGatewayOpa defines the OPA sidecar container for TempoGateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoGatewayOpa")]
    pub tempo_gateway_opa: Option<String>,
    /// TempoQuery defines the tempo-query container image.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoQuery")]
    pub tempo_query: Option<String>,
}

/// LimitSpec is used to limit ingestion and querying rates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimits {
    /// Global is used to define global rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<TempoStackLimitsGlobal>,
    /// PerTenant is used to define rate limits per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTenant")]
    pub per_tenant: Option<BTreeMap<String, TempoStackLimitsPerTenant>>,
}

/// Global is used to define global rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsGlobal {
    /// Ingestion is used to define ingestion rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingestion: Option<TempoStackLimitsGlobalIngestion>,
    /// Query is used to define query rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query: Option<TempoStackLimitsGlobalQuery>,
}

/// Ingestion is used to define ingestion rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsGlobalIngestion {
    /// IngestionBurstSizeBytes defines the burst size (bytes) used in ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionBurstSizeBytes")]
    pub ingestion_burst_size_bytes: Option<i64>,
    /// IngestionRateLimitBytes defines the Per-user ingestion rate limit (bytes) used in ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionRateLimitBytes")]
    pub ingestion_rate_limit_bytes: Option<i64>,
    /// MaxBytesPerTrace defines the maximum number of bytes of an acceptable trace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytesPerTrace")]
    pub max_bytes_per_trace: Option<i64>,
    /// MaxTracesPerUser defines the maximum number of traces a user can send.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTracesPerUser")]
    pub max_traces_per_user: Option<i64>,
}

/// Query is used to define query rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsGlobalQuery {
    /// MaxBytesPerTagValues defines the maximum size in bytes of a tag-values query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytesPerTagValues")]
    pub max_bytes_per_tag_values: Option<i64>,
    /// DEPRECATED. MaxSearchBytesPerTrace defines the maximum size of search data for a single
    /// trace in bytes.
    /// default: `0` to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSearchBytesPerTrace")]
    pub max_search_bytes_per_trace: Option<i64>,
    /// MaxSearchDuration defines the maximum allowed time range for a search.
    /// If this value is not set, then spec.search.maxDuration is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSearchDuration")]
    pub max_search_duration: Option<String>,
}

/// PerTenant is used to define rate limits per tenant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsPerTenant {
    /// Ingestion is used to define ingestion rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingestion: Option<TempoStackLimitsPerTenantIngestion>,
    /// Query is used to define query rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query: Option<TempoStackLimitsPerTenantQuery>,
}

/// Ingestion is used to define ingestion rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsPerTenantIngestion {
    /// IngestionBurstSizeBytes defines the burst size (bytes) used in ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionBurstSizeBytes")]
    pub ingestion_burst_size_bytes: Option<i64>,
    /// IngestionRateLimitBytes defines the Per-user ingestion rate limit (bytes) used in ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionRateLimitBytes")]
    pub ingestion_rate_limit_bytes: Option<i64>,
    /// MaxBytesPerTrace defines the maximum number of bytes of an acceptable trace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytesPerTrace")]
    pub max_bytes_per_trace: Option<i64>,
    /// MaxTracesPerUser defines the maximum number of traces a user can send.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTracesPerUser")]
    pub max_traces_per_user: Option<i64>,
}

/// Query is used to define query rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsPerTenantQuery {
    /// MaxBytesPerTagValues defines the maximum size in bytes of a tag-values query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytesPerTagValues")]
    pub max_bytes_per_tag_values: Option<i64>,
    /// DEPRECATED. MaxSearchBytesPerTrace defines the maximum size of search data for a single
    /// trace in bytes.
    /// default: `0` to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSearchBytesPerTrace")]
    pub max_search_bytes_per_trace: Option<i64>,
    /// MaxSearchDuration defines the maximum allowed time range for a search.
    /// If this value is not set, then spec.search.maxDuration is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSearchDuration")]
    pub max_search_duration: Option<String>,
}

/// TempoStackSpec defines the desired state of TempoStack.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackManagementState {
    Managed,
    Unmanaged,
}

/// ObservabilitySpec defines how telemetry data gets handled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservability {
    /// Grafana defines the Grafana configuration for operands.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grafana: Option<TempoStackObservabilityGrafana>,
    /// Metrics defines the metrics configuration for operands.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<TempoStackObservabilityMetrics>,
    /// Tracing defines a config for operands.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tracing: Option<TempoStackObservabilityTracing>,
}

/// Grafana defines the Grafana configuration for operands.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityGrafana {
    /// CreateDatasource specifies if a Grafana Datasource should be created for Tempo.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createDatasource")]
    pub create_datasource: Option<bool>,
    /// InstanceSelector specifies the Grafana instance where the datasource should be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceSelector")]
    pub instance_selector: Option<TempoStackObservabilityGrafanaInstanceSelector>,
}

/// InstanceSelector specifies the Grafana instance where the datasource should be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityGrafanaInstanceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<TempoStackObservabilityGrafanaInstanceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityGrafanaInstanceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Metrics defines the metrics configuration for operands.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityMetrics {
    /// CreatePrometheusRules specifies if Prometheus rules for alerts should be created for Tempo components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createPrometheusRules")]
    pub create_prometheus_rules: Option<bool>,
    /// CreateServiceMonitors specifies if ServiceMonitors should be created for Tempo components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createServiceMonitors")]
    pub create_service_monitors: Option<bool>,
}

/// Tracing defines a config for operands.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityTracing {
    /// JaegerAgentEndpoint defines the jaeger endpoint data gets send to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jaeger_agent_endpoint: Option<String>,
    /// SamplingFraction defines the sampling ratio. Valid values are 0 to 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sampling_fraction: Option<String>,
}

/// Resources defines resources configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackResources {
    /// The total amount of resources for Tempo instance.
    /// The operator autonomously splits resources between deployed Tempo components.
    /// Only limits are supported, the operator calculates requests automatically.
    /// See http://github.com/grafana/tempo/issues/1540.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total: Option<TempoStackResourcesTotal>,
}

/// The total amount of resources for Tempo instance.
/// The operator autonomously splits resources between deployed Tempo components.
/// Only limits are supported, the operator calculates requests automatically.
/// See http://github.com/grafana/tempo/issues/1540.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackResourcesTotal {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackResourcesTotalClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackResourcesTotalClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// Retention period defined by dataset.
/// User can specify how long data should be stored.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackRetention {
    /// Global is used to configure global retention.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<TempoStackRetentionGlobal>,
    /// PerTenant is used to configure retention per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTenant")]
    pub per_tenant: Option<BTreeMap<String, TempoStackRetentionPerTenant>>,
}

/// Global is used to configure global retention.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackRetentionGlobal {
    /// Traces defines retention period. Supported parameter suffixes are "s", "m" and "h".
    /// example: 336h
    /// default: value is 48h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub traces: Option<String>,
}

/// PerTenant is used to configure retention per tenant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackRetentionPerTenant {
    /// Traces defines retention period. Supported parameter suffixes are "s", "m" and "h".
    /// example: 336h
    /// default: value is 48h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub traces: Option<String>,
}

/// SearchSpec control the configuration for the search capabilities.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackSearch {
    /// Limit used for search requests if none is set by the caller (default: 20)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultResultLimit")]
    pub default_result_limit: Option<i64>,
    /// The maximum allowed time range for a search, default: 0s which means unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDuration")]
    pub max_duration: Option<String>,
    /// The maximum allowed value of the limit parameter on search requests. If the search request limit parameter
    /// exceeds the value configured here it will be set to the value configured here.
    /// The default value of 0 disables this limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxResultLimit")]
    pub max_result_limit: Option<i64>,
}

/// Storage defines the spec for the object storage endpoint to store traces.
/// User is required to create secret and supply it.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TempoStackStorage {
    /// Secret for object storage authentication.
    /// Name of a secret in the same namespace as the TempoStack custom resource.
    pub secret: TempoStackStorageSecret,
    /// TLS configuration for reaching the object storage endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<TempoStackStorageTls>,
}

/// Secret for object storage authentication.
/// Name of a secret in the same namespace as the TempoStack custom resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TempoStackStorageSecret {
    /// Name of a secret in the namespace configured for object storage secrets.
    pub name: String,
    /// Type of object storage that should be used
    #[serde(rename = "type")]
    pub r#type: TempoStackStorageSecretType,
}

/// Secret for object storage authentication.
/// Name of a secret in the same namespace as the TempoStack custom resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackStorageSecretType {
    #[serde(rename = "azure")]
    Azure,
    #[serde(rename = "gcs")]
    Gcs,
    #[serde(rename = "s3")]
    S3,
}

/// TLS configuration for reaching the object storage endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackStorageTls {
    /// CA is the name of a ConfigMap containing a CA certificate (service-ca.crt).
    /// It needs to be in the same namespace as the Tempo custom resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caName")]
    pub ca_name: Option<String>,
    /// Cert is the name of a Secret containing a certificate (tls.crt) and private key (tls.key).
    /// It needs to be in the same namespace as the Tempo custom resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certName")]
    pub cert_name: Option<String>,
    /// Enabled defines if TLS is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// MinVersion defines the minimum acceptable TLS version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<String>,
}

/// Template defines requirements for a set of tempo components.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplate {
    /// Compactor defines the tempo compactor component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compactor: Option<TempoStackTemplateCompactor>,
    /// Distributor defines the distributor component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distributor: Option<TempoStackTemplateDistributor>,
    /// Gateway defines the tempo gateway spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<TempoStackTemplateGateway>,
    /// Ingester defines the ingester component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingester: Option<TempoStackTemplateIngester>,
    /// Querier defines the querier component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub querier: Option<TempoStackTemplateQuerier>,
    /// TempoQueryFrontendSpec defines the query frontend spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryFrontend")]
    pub query_frontend: Option<TempoStackTemplateQueryFrontend>,
}

/// Compactor defines the tempo compactor component spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateCompactor {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateCompactorResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateCompactorTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateCompactorResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateCompactorResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateCompactorResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateCompactorTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Distributor defines the distributor component spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributor {
    /// TempoComponentSpec is embedded to extend this definition with further options.
    /// 
    /// 
    /// Currently, there is no way to inline this field.
    /// See: https://github.com/golang/go/issues/6213
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub component: Option<TempoStackTemplateDistributorComponent>,
    /// TLS defines TLS configuration for distributor receivers
    /// 
    /// 
    /// If openshift feature flag `servingCertsService` is enabled and TLS is enabled but no
    /// certName or caName is specified, OpenShift service serving certificates will  be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<TempoStackTemplateDistributorTls>,
}

/// TempoComponentSpec is embedded to extend this definition with further options.
/// 
/// 
/// Currently, there is no way to inline this field.
/// See: https://github.com/golang/go/issues/6213
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorComponent {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateDistributorComponentResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateDistributorComponentTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorComponentResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateDistributorComponentResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorComponentResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorComponentTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// TLS defines TLS configuration for distributor receivers
/// 
/// 
/// If openshift feature flag `servingCertsService` is enabled and TLS is enabled but no
/// certName or caName is specified, OpenShift service serving certificates will  be used.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorTls {
    /// CA is the name of a ConfigMap containing a CA certificate (service-ca.crt).
    /// It needs to be in the same namespace as the Tempo custom resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caName")]
    pub ca_name: Option<String>,
    /// Cert is the name of a Secret containing a certificate (tls.crt) and private key (tls.key).
    /// It needs to be in the same namespace as the Tempo custom resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certName")]
    pub cert_name: Option<String>,
    /// Enabled defines if TLS is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// MinVersion defines the minimum acceptable TLS version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<String>,
}

/// Gateway defines the tempo gateway spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGateway {
    /// TempoComponentSpec is embedded to extend this definition with further options.
    /// 
    /// 
    /// Currently there is no way to inline this field.
    /// See: https://github.com/golang/go/issues/6213
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub component: Option<TempoStackTemplateGatewayComponent>,
    pub enabled: bool,
    /// Ingress defines gateway Ingress options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<TempoStackTemplateGatewayIngress>,
}

/// TempoComponentSpec is embedded to extend this definition with further options.
/// 
/// 
/// Currently there is no way to inline this field.
/// See: https://github.com/golang/go/issues/6213
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayComponent {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateGatewayComponentResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateGatewayComponentTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayComponentResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateGatewayComponentResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayComponentResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayComponentTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Ingress defines gateway Ingress options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayIngress {
    /// Annotations defines the annotations of the Ingress object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Host defines the hostname of the Ingress object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// IngressClassName defines the name of an IngressClass cluster resource.
    /// Defines which ingress controller serves this ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Route defines the options for the OpenShift route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<TempoStackTemplateGatewayIngressRoute>,
    /// Type defines the type of Ingress for the Jaeger Query UI.
    /// Currently ingress, route and none are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<TempoStackTemplateGatewayIngressType>,
}

/// Route defines the options for the OpenShift route.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayIngressRoute {
    /// Termination defines the termination type.
    /// The default is "edge".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub termination: Option<TempoStackTemplateGatewayIngressRouteTermination>,
}

/// Route defines the options for the OpenShift route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTemplateGatewayIngressRouteTermination {
    #[serde(rename = "insecure")]
    Insecure,
    #[serde(rename = "edge")]
    Edge,
    #[serde(rename = "passthrough")]
    Passthrough,
    #[serde(rename = "reencrypt")]
    Reencrypt,
}

/// Ingress defines gateway Ingress options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTemplateGatewayIngressType {
    #[serde(rename = "ingress")]
    Ingress,
    #[serde(rename = "route")]
    Route,
}

/// Ingester defines the ingester component spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateIngester {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateIngesterResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateIngesterTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateIngesterResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateIngesterResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateIngesterResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateIngesterTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Querier defines the querier component spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQuerier {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateQuerierResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateQuerierTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQuerierResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateQuerierResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQuerierResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQuerierTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// TempoQueryFrontendSpec defines the query frontend spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontend {
    /// TempoComponentSpec is embedded to extend this definition with further options.
    /// 
    /// 
    /// Currently there is no way to inline this field.
    /// See: https://github.com/golang/go/issues/6213
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub component: Option<TempoStackTemplateQueryFrontendComponent>,
    /// JaegerQuery defines options specific to the Jaeger Query component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jaegerQuery")]
    pub jaeger_query: Option<TempoStackTemplateQueryFrontendJaegerQuery>,
}

/// TempoComponentSpec is embedded to extend this definition with further options.
/// 
/// 
/// Currently there is no way to inline this field.
/// See: https://github.com/golang/go/issues/6213
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendComponent {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateQueryFrontendComponentResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateQueryFrontendComponentTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendComponentResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateQueryFrontendComponentResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendComponentResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendComponentTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// JaegerQuery defines options specific to the Jaeger Query component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQuery {
    /// Authentication defines the options for the oauth proxy used to protect jaeger UI
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<TempoStackTemplateQueryFrontendJaegerQueryAuthentication>,
    /// Enabled defines if the Jaeger Query component should be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Ingress defines the options for the Jaeger Query ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<TempoStackTemplateQueryFrontendJaegerQueryIngress>,
    /// MonitorTab defines the monitor tab configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitorTab")]
    pub monitor_tab: Option<TempoStackTemplateQueryFrontendJaegerQueryMonitorTab>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateQueryFrontendJaegerQueryResources>,
    /// ServicesQueryDuration defines how long the services will be available in the services list
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicesQueryDuration")]
    pub services_query_duration: Option<String>,
}

/// Authentication defines the options for the oauth proxy used to protect jaeger UI
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryAuthentication {
    /// Defines if the authentication will be enabled for jaeger UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Resources defines the compute resource requirements of the OAuth Proxy container.
    /// The OAuth Proxy performs authentication and authorization of incoming requests to Jaeger UI when multi-tenancy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateQueryFrontendJaegerQueryAuthenticationResources>,
    /// SAR defines the SAR to be used in the oauth-proxy
    /// default is "{"namespace": "<tempo_stack_namespace>", "resource": "pods", "verb": "get"}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sar: Option<String>,
}

/// Resources defines the compute resource requirements of the OAuth Proxy container.
/// The OAuth Proxy performs authentication and authorization of incoming requests to Jaeger UI when multi-tenancy is disabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryAuthenticationResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// Ingress defines the options for the Jaeger Query ingress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryIngress {
    /// Annotations defines the annotations of the Ingress object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Host defines the hostname of the Ingress object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// IngressClassName defines the name of an IngressClass cluster resource.
    /// Defines which ingress controller serves this ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Route defines the options for the OpenShift route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<TempoStackTemplateQueryFrontendJaegerQueryIngressRoute>,
    /// Type defines the type of Ingress for the Jaeger Query UI.
    /// Currently ingress, route and none are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<TempoStackTemplateQueryFrontendJaegerQueryIngressType>,
}

/// Route defines the options for the OpenShift route.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryIngressRoute {
    /// Termination defines the termination type.
    /// The default is "edge".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub termination: Option<TempoStackTemplateQueryFrontendJaegerQueryIngressRouteTermination>,
}

/// Route defines the options for the OpenShift route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTemplateQueryFrontendJaegerQueryIngressRouteTermination {
    #[serde(rename = "insecure")]
    Insecure,
    #[serde(rename = "edge")]
    Edge,
    #[serde(rename = "passthrough")]
    Passthrough,
    #[serde(rename = "reencrypt")]
    Reencrypt,
}

/// Ingress defines the options for the Jaeger Query ingress.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTemplateQueryFrontendJaegerQueryIngressType {
    #[serde(rename = "ingress")]
    Ingress,
    #[serde(rename = "route")]
    Route,
}

/// MonitorTab defines the monitor tab configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryMonitorTab {
    /// Enabled enables the monitor tab in the Jaeger console.
    /// The PrometheusEndpoint must be configured to enable this feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// PrometheusEndpoint defines the endpoint to the Prometheus instance that contains the span rate, error, and duration (RED) metrics.
    /// For instance on OpenShift this is set to https://thanos-querier.openshift-monitoring.svc.cluster.local:9091
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusEndpoint")]
    pub prometheus_endpoint: Option<String>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateQueryFrontendJaegerQueryResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// Tenants defines the per-tenant authentication and authorization spec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TempoStackTenants {
    /// Authentication defines the tempo-gateway component authentication configuration spec per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<Vec<TempoStackTenantsAuthentication>>,
    /// Authorization defines the tempo-gateway component authorization configuration spec per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<TempoStackTenantsAuthorization>,
    /// Mode defines the multitenancy mode.
    pub mode: TempoStackTenantsMode,
}

/// AuthenticationSpec defines the oidc configuration per tenant for tempo Gateway component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthentication {
    /// OIDC defines the spec for the OIDC tenant's authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oidc: Option<TempoStackTenantsAuthenticationOidc>,
    /// TenantID defines a universally unique identifier of the tenant.
    /// Unlike the tenantName, which must be unique at a given time, the tenantId must be unique over the entire lifetime of the Tempo deployment.
    /// Tempo uses this ID to prefix objects in the object storage.
    #[serde(rename = "tenantId")]
    pub tenant_id: String,
    /// TenantName defines a human readable, unique name of the tenant.
    /// The value of this field must be specified in the X-Scope-OrgID header and in the resources field of a ClusterRole to identify the tenant.
    #[serde(rename = "tenantName")]
    pub tenant_name: String,
}

/// OIDC defines the spec for the OIDC tenant's authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthenticationOidc {
    /// Group claim field from ID Token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupClaim")]
    pub group_claim: Option<String>,
    /// IssuerURL defines the URL for issuer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerURL")]
    pub issuer_url: Option<String>,
    /// RedirectURL defines the URL for redirect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectURL")]
    pub redirect_url: Option<String>,
    /// Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<TempoStackTenantsAuthenticationOidcSecret>,
    /// User claim field from ID Token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernameClaim")]
    pub username_claim: Option<String>,
}

/// Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthenticationOidcSecret {
    /// Name of a secret in the namespace configured for tenant secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Authorization defines the tempo-gateway component authorization configuration spec per tenant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthorization {
    /// RoleBindings defines configuration to bind a set of roles to a set of subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleBindings")]
    pub role_bindings: Option<Vec<TempoStackTenantsAuthorizationRoleBindings>>,
    /// Roles defines a set of permissions to interact with a tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<TempoStackTenantsAuthorizationRoles>>,
}

/// RoleBindingsSpec binds a set of roles to a set of subjects.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthorizationRoleBindings {
    pub name: String,
    pub roles: Vec<String>,
    pub subjects: Vec<TempoStackTenantsAuthorizationRoleBindingsSubjects>,
}

/// Subject represents a subject that has been bound to a role.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TempoStackTenantsAuthorizationRoleBindingsSubjects {
    /// SubjectKind is a kind of Tempo Gateway RBAC subject.
    pub kind: TempoStackTenantsAuthorizationRoleBindingsSubjectsKind,
    pub name: String,
}

/// Subject represents a subject that has been bound to a role.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTenantsAuthorizationRoleBindingsSubjectsKind {
    #[serde(rename = "user")]
    User,
    #[serde(rename = "group")]
    Group,
}

/// RoleSpec describes a set of permissions to interact with a tenant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthorizationRoles {
    pub name: String,
    pub permissions: Vec<String>,
    pub resources: Vec<String>,
    pub tenants: Vec<String>,
}

/// Tenants defines the per-tenant authentication and authorization spec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTenantsMode {
    #[serde(rename = "static")]
    Static,
    #[serde(rename = "openshift")]
    Openshift,
}

/// TempoStackStatus defines the observed state of TempoStack.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackStatus {
    /// Components provides summary of all Tempo pod status grouped
    /// per component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<TempoStackStatusComponents>,
    /// Conditions of the Tempo deployment health.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// Version of the Tempo Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "operatorVersion")]
    pub operator_version: Option<String>,
    /// DEPRECATED. Version of the Tempo Query component used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoQueryVersion")]
    pub tempo_query_version: Option<String>,
    /// Version of the managed Tempo instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoVersion")]
    pub tempo_version: Option<String>,
}

/// Components provides summary of all Tempo pod status grouped
/// per component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackStatusComponents {
    /// Compactor is a map to the pod status of the compactor pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compactor: Option<BTreeMap<String, String>>,
    /// Distributor is a map to the per pod status of the distributor deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distributor: Option<BTreeMap<String, String>>,
    /// Gateway is a map to the per pod status of the query frontend deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<BTreeMap<String, String>>,
    /// Ingester is a map to the per pod status of the ingester statefulset
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingester: Option<BTreeMap<String, String>>,
    /// Querier is a map to the per pod status of the querier deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub querier: Option<BTreeMap<String, String>>,
    /// QueryFrontend is a map to the per pod status of the query frontend deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryFrontend")]
    pub query_frontend: Option<BTreeMap<String, String>>,
}

