// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/grafana/tempo-operator/tempo.grafana.com/v1alpha1/tempostacks.yaml --derive=Default --derive=PartialEq --smart-derive-elision
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// TempoStackSpec defines the desired state of TempoStack.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "tempo.grafana.com", version = "v1alpha1", kind = "TempoStack", plural = "tempostacks")]
#[kube(namespaced)]
#[kube(status = "TempoStackStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct TempoStackSpec {
    /// ExtraConfigSpec defines extra configurations for tempo that will be merged with the operator generated, configurations defined here has precedence and could override generated config.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraConfig")]
    pub extra_config: Option<TempoStackExtraConfig>,
    /// HashRing defines the spec for the distributed hash ring configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashRing")]
    pub hash_ring: Option<TempoStackHashRing>,
    /// Images defines the image for each container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub images: Option<TempoStackImages>,
    /// LimitSpec is used to limit ingestion and querying rates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<TempoStackLimits>,
    /// ManagementState defines if the CR should be managed by the operator or not. Default is managed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementState")]
    pub management_state: Option<TempoStackManagementState>,
    /// ObservabilitySpec defines how telemetry data gets handled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub observability: Option<TempoStackObservability>,
    /// ReplicationFactor is used to define how many component replicas should exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicationFactor")]
    pub replication_factor: Option<i64>,
    /// Resources defines resources configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackResources>,
    /// NOTE: currently this field is not considered. Retention period defined by dataset. User can specify how long data should be stored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retention: Option<TempoStackRetention>,
    /// SearchSpec control the configuration for the search capabilities.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub search: Option<TempoStackSearch>,
    /// ServiceAccount defines the service account to use for all tempo components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// Storage defines the spec for the object storage endpoint to store traces. User is required to create secret and supply it.
    pub storage: TempoStackStorage,
    /// StorageClassName for PVCs used by ingester. Defaults to nil (default storage class in the cluster).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// StorageSize for PVCs used by ingester. Defaults to 10Gi.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageSize")]
    pub storage_size: Option<IntOrString>,
    /// Template defines requirements for a set of tempo components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TempoStackTemplate>,
    /// Tenants defines the per-tenant authentication and authorization spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenants: Option<TempoStackTenants>,
}

/// ExtraConfigSpec defines extra configurations for tempo that will be merged with the operator generated, configurations defined here has precedence and could override generated config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackExtraConfig {
    /// Tempo defines any extra Tempo configuration, which will be merged with the operator's generated Tempo configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tempo: Option<serde_json::Value>,
}

/// HashRing defines the spec for the distributed hash ring configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackHashRing {
    /// MemberList configuration spec
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memberlist: Option<TempoStackHashRingMemberlist>,
}

/// MemberList configuration spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackHashRingMemberlist {
    /// EnableIPv6 enables IPv6 support for the memberlist based hash ring.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableIPv6")]
    pub enable_i_pv6: Option<bool>,
}

/// Images defines the image for each container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackImages {
    /// OauthProxy defines the oauth proxy image used to protect the jaegerUI on single tenant.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauthProxy")]
    pub oauth_proxy: Option<String>,
    /// Tempo defines the tempo container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tempo: Option<String>,
    /// TempoGateway defines the tempo-gateway container image.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoGateway")]
    pub tempo_gateway: Option<String>,
    /// TempoGatewayOpa defines the OPA sidecar container for TempoGateway.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoGatewayOpa")]
    pub tempo_gateway_opa: Option<String>,
    /// TempoQuery defines the tempo-query container image.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoQuery")]
    pub tempo_query: Option<String>,
}

/// LimitSpec is used to limit ingestion and querying rates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimits {
    /// Global is used to define global rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<TempoStackLimitsGlobal>,
    /// PerTenant is used to define rate limits per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTenant")]
    pub per_tenant: Option<BTreeMap<String, TempoStackLimitsPerTenant>>,
}

/// Global is used to define global rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsGlobal {
    /// Ingestion is used to define ingestion rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingestion: Option<TempoStackLimitsGlobalIngestion>,
    /// Query is used to define query rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query: Option<TempoStackLimitsGlobalQuery>,
}

/// Ingestion is used to define ingestion rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsGlobalIngestion {
    /// IngestionBurstSizeBytes defines the burst size (bytes) used in ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionBurstSizeBytes")]
    pub ingestion_burst_size_bytes: Option<i64>,
    /// IngestionRateLimitBytes defines the Per-user ingestion rate limit (bytes) used in ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionRateLimitBytes")]
    pub ingestion_rate_limit_bytes: Option<i64>,
    /// MaxBytesPerTrace defines the maximum number of bytes of an acceptable trace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytesPerTrace")]
    pub max_bytes_per_trace: Option<i64>,
    /// MaxTracesPerUser defines the maximum number of traces a user can send.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTracesPerUser")]
    pub max_traces_per_user: Option<i64>,
}

/// Query is used to define query rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsGlobalQuery {
    /// MaxBytesPerTagValues defines the maximum size in bytes of a tag-values query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytesPerTagValues")]
    pub max_bytes_per_tag_values: Option<i64>,
    /// DEPRECATED. MaxSearchBytesPerTrace defines the maximum size of search data for a single trace in bytes. default: `0` to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSearchBytesPerTrace")]
    pub max_search_bytes_per_trace: Option<i64>,
    /// MaxSearchDuration defines the maximum allowed time range for a search. If this value is not set, then spec.search.maxDuration is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSearchDuration")]
    pub max_search_duration: Option<String>,
}

/// PerTenant is used to define rate limits per tenant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsPerTenant {
    /// Ingestion is used to define ingestion rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingestion: Option<TempoStackLimitsPerTenantIngestion>,
    /// Query is used to define query rate limits.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query: Option<TempoStackLimitsPerTenantQuery>,
}

/// Ingestion is used to define ingestion rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsPerTenantIngestion {
    /// IngestionBurstSizeBytes defines the burst size (bytes) used in ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionBurstSizeBytes")]
    pub ingestion_burst_size_bytes: Option<i64>,
    /// IngestionRateLimitBytes defines the Per-user ingestion rate limit (bytes) used in ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionRateLimitBytes")]
    pub ingestion_rate_limit_bytes: Option<i64>,
    /// MaxBytesPerTrace defines the maximum number of bytes of an acceptable trace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytesPerTrace")]
    pub max_bytes_per_trace: Option<i64>,
    /// MaxTracesPerUser defines the maximum number of traces a user can send.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxTracesPerUser")]
    pub max_traces_per_user: Option<i64>,
}

/// Query is used to define query rate limits.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackLimitsPerTenantQuery {
    /// MaxBytesPerTagValues defines the maximum size in bytes of a tag-values query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytesPerTagValues")]
    pub max_bytes_per_tag_values: Option<i64>,
    /// DEPRECATED. MaxSearchBytesPerTrace defines the maximum size of search data for a single trace in bytes. default: `0` to disable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSearchBytesPerTrace")]
    pub max_search_bytes_per_trace: Option<i64>,
    /// MaxSearchDuration defines the maximum allowed time range for a search. If this value is not set, then spec.search.maxDuration is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSearchDuration")]
    pub max_search_duration: Option<String>,
}

/// TempoStackSpec defines the desired state of TempoStack.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackManagementState {
    Managed,
    Unmanaged,
}

/// ObservabilitySpec defines how telemetry data gets handled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservability {
    /// Grafana defines the Grafana configuration for operands.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grafana: Option<TempoStackObservabilityGrafana>,
    /// Metrics defines the metrics configuration for operands.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<TempoStackObservabilityMetrics>,
    /// Tracing defines a config for operands.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tracing: Option<TempoStackObservabilityTracing>,
}

/// Grafana defines the Grafana configuration for operands.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityGrafana {
    /// CreateDatasource specifies if a Grafana Datasource should be created for Tempo.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createDatasource")]
    pub create_datasource: Option<bool>,
    /// InstanceSelector specifies the Grafana instance where the datasource should be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceSelector")]
    pub instance_selector: Option<TempoStackObservabilityGrafanaInstanceSelector>,
}

/// InstanceSelector specifies the Grafana instance where the datasource should be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityGrafanaInstanceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<TempoStackObservabilityGrafanaInstanceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityGrafanaInstanceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Metrics defines the metrics configuration for operands.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityMetrics {
    /// CreatePrometheusRules specifies if Prometheus rules for alerts should be created for Tempo components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createPrometheusRules")]
    pub create_prometheus_rules: Option<bool>,
    /// CreateServiceMonitors specifies if ServiceMonitors should be created for Tempo components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createServiceMonitors")]
    pub create_service_monitors: Option<bool>,
}

/// Tracing defines a config for operands.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackObservabilityTracing {
    /// JaegerAgentEndpoint defines the jaeger endpoint data gets send to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jaeger_agent_endpoint: Option<String>,
    /// SamplingFraction defines the sampling ratio. Valid values are 0 to 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sampling_fraction: Option<String>,
}

/// Resources defines resources configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackResources {
    /// The total amount of resources for Tempo instance. The operator autonomously splits resources between deployed Tempo components. Only limits are supported, the operator calculates requests automatically. See http://github.com/grafana/tempo/issues/1540.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub total: Option<TempoStackResourcesTotal>,
}

/// The total amount of resources for Tempo instance. The operator autonomously splits resources between deployed Tempo components. Only limits are supported, the operator calculates requests automatically. See http://github.com/grafana/tempo/issues/1540.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackResourcesTotal {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackResourcesTotalClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackResourcesTotalClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// NOTE: currently this field is not considered. Retention period defined by dataset. User can specify how long data should be stored.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackRetention {
    /// Global is used to configure global retention.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<TempoStackRetentionGlobal>,
    /// PerTenant is used to configure retention per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTenant")]
    pub per_tenant: Option<BTreeMap<String, TempoStackRetentionPerTenant>>,
}

/// Global is used to configure global retention.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackRetentionGlobal {
    /// Traces defines retention period. Supported parameter suffixes are "s", "m" and "h". example: 336h default: value is 48h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub traces: Option<String>,
}

/// PerTenant is used to configure retention per tenant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackRetentionPerTenant {
    /// Traces defines retention period. Supported parameter suffixes are "s", "m" and "h". example: 336h default: value is 48h.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub traces: Option<String>,
}

/// SearchSpec control the configuration for the search capabilities.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackSearch {
    /// Limit used for search requests if none is set by the caller (default: 20)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultResultLimit")]
    pub default_result_limit: Option<i64>,
    /// The maximum allowed time range for a search, default: 0s which means unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDuration")]
    pub max_duration: Option<String>,
    /// The maximum allowed value of the limit parameter on search requests. If the search request limit parameter exceeds the value configured here it will be set to the value configured here. The default value of 0 disables this limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxResultLimit")]
    pub max_result_limit: Option<i64>,
}

/// Storage defines the spec for the object storage endpoint to store traces. User is required to create secret and supply it.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TempoStackStorage {
    /// Secret for object storage authentication. Name of a secret in the same namespace as the TempoStack custom resource.
    pub secret: TempoStackStorageSecret,
    /// TLS configuration for reaching the object storage endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<TempoStackStorageTls>,
}

/// Secret for object storage authentication. Name of a secret in the same namespace as the TempoStack custom resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TempoStackStorageSecret {
    /// Name of a secret in the namespace configured for object storage secrets.
    pub name: String,
    /// Type of object storage that should be used
    #[serde(rename = "type")]
    pub r#type: TempoStackStorageSecretType,
}

/// Secret for object storage authentication. Name of a secret in the same namespace as the TempoStack custom resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackStorageSecretType {
    #[serde(rename = "azure")]
    Azure,
    #[serde(rename = "gcs")]
    Gcs,
    #[serde(rename = "s3")]
    S3,
}

/// TLS configuration for reaching the object storage endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackStorageTls {
    /// CA is the name of a ConfigMap containing a CA certificate (service-ca.crt). It needs to be in the same namespace as the Tempo custom resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caName")]
    pub ca_name: Option<String>,
    /// Cert is the name of a Secret containing a certificate (tls.crt) and private key (tls.key). It needs to be in the same namespace as the Tempo custom resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certName")]
    pub cert_name: Option<String>,
    /// Enabled defines if TLS is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// MinVersion defines the minimum acceptable TLS version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<String>,
}

/// Template defines requirements for a set of tempo components.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplate {
    /// Compactor defines the tempo compactor component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compactor: Option<TempoStackTemplateCompactor>,
    /// Distributor defines the distributor component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distributor: Option<TempoStackTemplateDistributor>,
    /// Gateway defines the tempo gateway spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<TempoStackTemplateGateway>,
    /// Ingester defines the ingester component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingester: Option<TempoStackTemplateIngester>,
    /// Querier defines the querier component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub querier: Option<TempoStackTemplateQuerier>,
    /// TempoQueryFrontendSpec defines the query frontend spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryFrontend")]
    pub query_frontend: Option<TempoStackTemplateQueryFrontend>,
}

/// Compactor defines the tempo compactor component spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateCompactor {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateCompactorResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateCompactorTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateCompactorResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateCompactorResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateCompactorResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateCompactorTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Distributor defines the distributor component spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributor {
    /// TempoComponentSpec is embedded to extend this definition with further options. 
    ///  Currently, there is no way to inline this field. See: https://github.com/golang/go/issues/6213
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub component: Option<TempoStackTemplateDistributorComponent>,
    /// TLS defines TLS configuration for distributor receivers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<TempoStackTemplateDistributorTls>,
}

/// TempoComponentSpec is embedded to extend this definition with further options. 
///  Currently, there is no way to inline this field. See: https://github.com/golang/go/issues/6213
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorComponent {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateDistributorComponentResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateDistributorComponentTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorComponentResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateDistributorComponentResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorComponentResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorComponentTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// TLS defines TLS configuration for distributor receivers
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateDistributorTls {
    /// CA is the name of a ConfigMap containing a CA certificate (service-ca.crt). It needs to be in the same namespace as the Tempo custom resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caName")]
    pub ca_name: Option<String>,
    /// Cert is the name of a Secret containing a certificate (tls.crt) and private key (tls.key). It needs to be in the same namespace as the Tempo custom resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certName")]
    pub cert_name: Option<String>,
    /// Enabled defines if TLS is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// MinVersion defines the minimum acceptable TLS version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<String>,
}

/// Gateway defines the tempo gateway spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGateway {
    /// TempoComponentSpec is embedded to extend this definition with further options. 
    ///  Currently there is no way to inline this field. See: https://github.com/golang/go/issues/6213
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub component: Option<TempoStackTemplateGatewayComponent>,
    pub enabled: bool,
    /// Ingress defines gateway Ingress options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<TempoStackTemplateGatewayIngress>,
}

/// TempoComponentSpec is embedded to extend this definition with further options. 
///  Currently there is no way to inline this field. See: https://github.com/golang/go/issues/6213
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayComponent {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateGatewayComponentResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateGatewayComponentTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayComponentResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateGatewayComponentResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayComponentResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayComponentTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Ingress defines gateway Ingress options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayIngress {
    /// Annotations defines the annotations of the Ingress object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Host defines the hostname of the Ingress object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// IngressClassName defines the name of an IngressClass cluster resource. Defines which ingress controller serves this ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Route defines the options for the OpenShift route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<TempoStackTemplateGatewayIngressRoute>,
    /// Type defines the type of Ingress for the Jaeger Query UI. Currently ingress, route and none are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<TempoStackTemplateGatewayIngressType>,
}

/// Route defines the options for the OpenShift route.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateGatewayIngressRoute {
    /// Termination defines the termination type. The default is "edge".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub termination: Option<TempoStackTemplateGatewayIngressRouteTermination>,
}

/// Route defines the options for the OpenShift route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTemplateGatewayIngressRouteTermination {
    #[serde(rename = "insecure")]
    Insecure,
    #[serde(rename = "edge")]
    Edge,
    #[serde(rename = "passthrough")]
    Passthrough,
    #[serde(rename = "reencrypt")]
    Reencrypt,
}

/// Ingress defines gateway Ingress options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTemplateGatewayIngressType {
    #[serde(rename = "ingress")]
    Ingress,
    #[serde(rename = "route")]
    Route,
}

/// Ingester defines the ingester component spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateIngester {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateIngesterResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateIngesterTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateIngesterResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateIngesterResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateIngesterResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateIngesterTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Querier defines the querier component spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQuerier {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateQuerierResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateQuerierTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQuerierResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateQuerierResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQuerierResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQuerierTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// TempoQueryFrontendSpec defines the query frontend spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontend {
    /// TempoComponentSpec is embedded to extend this definition with further options. 
    ///  Currently there is no way to inline this field. See: https://github.com/golang/go/issues/6213
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub component: Option<TempoStackTemplateQueryFrontendComponent>,
    /// JaegerQuery defines options specific to the Jaeger Query component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jaegerQuery")]
    pub jaeger_query: Option<TempoStackTemplateQueryFrontendJaegerQuery>,
}

/// TempoComponentSpec is embedded to extend this definition with further options. 
///  Currently there is no way to inline this field. See: https://github.com/golang/go/issues/6213
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendComponent {
    /// NodeSelector defines the simple form of the node-selection constraint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replicas to be created for this component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateQueryFrontendComponentResources>,
    /// Tolerations defines component-specific pod tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<TempoStackTemplateQueryFrontendComponentTolerations>>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendComponentResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateQueryFrontendComponentResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendComponentResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendComponentTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// JaegerQuery defines options specific to the Jaeger Query component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQuery {
    /// Authentication defines the options for the oauth proxy used to protect jaeger UI
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<TempoStackTemplateQueryFrontendJaegerQueryAuthentication>,
    /// Enabled defines if the Jaeger Query component should be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Ingress defines the options for the Jaeger Query ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<TempoStackTemplateQueryFrontendJaegerQueryIngress>,
    /// MonitorTab defines the monitor tab configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitorTab")]
    pub monitor_tab: Option<TempoStackTemplateQueryFrontendJaegerQueryMonitorTab>,
    /// Resources defines resources for this component, this will override the calculated resources derived from total
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateQueryFrontendJaegerQueryResources>,
    /// ServicesQueryDuration defines how long the services will be available in the services list
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicesQueryDuration")]
    pub services_query_duration: Option<String>,
}

/// Authentication defines the options for the oauth proxy used to protect jaeger UI
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryAuthentication {
    /// Defines if the authentication will be enabled for jaeger UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Resources defines the compute resource requirements of the OAuth Proxy container. The OAuth Proxy performs authentication and authorization of incoming requests to Jaeger UI when multi-tenancy is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TempoStackTemplateQueryFrontendJaegerQueryAuthenticationResources>,
    /// SAR defines the SAR to be used in the oauth-proxy default is "{"namespace": "<tempo_stack_namespace>", "resource": "pods", "verb": "get"}
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sar: Option<String>,
}

/// Resources defines the compute resource requirements of the OAuth Proxy container. The OAuth Proxy performs authentication and authorization of incoming requests to Jaeger UI when multi-tenancy is disabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryAuthenticationResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// Ingress defines the options for the Jaeger Query ingress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryIngress {
    /// Annotations defines the annotations of the Ingress object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Host defines the hostname of the Ingress object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// IngressClassName defines the name of an IngressClass cluster resource. Defines which ingress controller serves this ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Route defines the options for the OpenShift route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<TempoStackTemplateQueryFrontendJaegerQueryIngressRoute>,
    /// Type defines the type of Ingress for the Jaeger Query UI. Currently ingress, route and none are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<TempoStackTemplateQueryFrontendJaegerQueryIngressType>,
}

/// Route defines the options for the OpenShift route.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryIngressRoute {
    /// Termination defines the termination type. The default is "edge".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub termination: Option<TempoStackTemplateQueryFrontendJaegerQueryIngressRouteTermination>,
}

/// Route defines the options for the OpenShift route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTemplateQueryFrontendJaegerQueryIngressRouteTermination {
    #[serde(rename = "insecure")]
    Insecure,
    #[serde(rename = "edge")]
    Edge,
    #[serde(rename = "passthrough")]
    Passthrough,
    #[serde(rename = "reencrypt")]
    Reencrypt,
}

/// Ingress defines the options for the Jaeger Query ingress.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTemplateQueryFrontendJaegerQueryIngressType {
    #[serde(rename = "ingress")]
    Ingress,
    #[serde(rename = "route")]
    Route,
}

/// MonitorTab defines the monitor tab configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryMonitorTab {
    /// Enabled enables the monitor tab in the Jaeger console. The PrometheusEndpoint must be configured to enable this feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// PrometheusEndpoint defines the endpoint to the Prometheus instance that contains the span rate, error, and duration (RED) metrics. For instance on OpenShift this is set to https://thanos-querier.openshift-monitoring.svc.cluster.local:9091
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusEndpoint")]
    pub prometheus_endpoint: Option<String>,
}

/// Resources defines resources for this component, this will override the calculated resources derived from total
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. 
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. 
    ///  This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TempoStackTemplateQueryFrontendJaegerQueryResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTemplateQueryFrontendJaegerQueryResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// Tenants defines the per-tenant authentication and authorization spec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TempoStackTenants {
    /// Authentication defines the tempo-gateway component authentication configuration spec per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<Vec<TempoStackTenantsAuthentication>>,
    /// Authorization defines the tempo-gateway component authorization configuration spec per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<TempoStackTenantsAuthorization>,
    /// Mode defines the multitenancy mode.
    pub mode: TempoStackTenantsMode,
}

/// AuthenticationSpec defines the oidc configuration per tenant for tempo Gateway component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthentication {
    /// OIDC defines the spec for the OIDC tenant's authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oidc: Option<TempoStackTenantsAuthenticationOidc>,
    /// TenantID defines a universally unique identifier of the tenant. Unlike the tenantName, which must be unique at a given time, the tenantId must be unique over the entire lifetime of the Tempo deployment. Tempo uses this ID to prefix objects in the object storage.
    #[serde(rename = "tenantId")]
    pub tenant_id: String,
    /// TenantName defines a human readable, unique name of the tenant. The value of this field must be specified in the X-Scope-OrgID header and in the resources field of a ClusterRole to identify the tenant.
    #[serde(rename = "tenantName")]
    pub tenant_name: String,
}

/// OIDC defines the spec for the OIDC tenant's authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthenticationOidc {
    /// Group claim field from ID Token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupClaim")]
    pub group_claim: Option<String>,
    /// IssuerURL defines the URL for issuer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerURL")]
    pub issuer_url: Option<String>,
    /// RedirectURL defines the URL for redirect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectURL")]
    pub redirect_url: Option<String>,
    /// Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<TempoStackTenantsAuthenticationOidcSecret>,
    /// User claim field from ID Token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernameClaim")]
    pub username_claim: Option<String>,
}

/// Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthenticationOidcSecret {
    /// Name of a secret in the namespace configured for tenant secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Authorization defines the tempo-gateway component authorization configuration spec per tenant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthorization {
    /// RoleBindings defines configuration to bind a set of roles to a set of subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleBindings")]
    pub role_bindings: Option<Vec<TempoStackTenantsAuthorizationRoleBindings>>,
    /// Roles defines a set of permissions to interact with a tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<TempoStackTenantsAuthorizationRoles>>,
}

/// RoleBindingsSpec binds a set of roles to a set of subjects.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthorizationRoleBindings {
    pub name: String,
    pub roles: Vec<String>,
    pub subjects: Vec<TempoStackTenantsAuthorizationRoleBindingsSubjects>,
}

/// Subject represents a subject that has been bound to a role.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TempoStackTenantsAuthorizationRoleBindingsSubjects {
    /// SubjectKind is a kind of Tempo Gateway RBAC subject.
    pub kind: TempoStackTenantsAuthorizationRoleBindingsSubjectsKind,
    pub name: String,
}

/// Subject represents a subject that has been bound to a role.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTenantsAuthorizationRoleBindingsSubjectsKind {
    #[serde(rename = "user")]
    User,
    #[serde(rename = "group")]
    Group,
}

/// RoleSpec describes a set of permissions to interact with a tenant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackTenantsAuthorizationRoles {
    pub name: String,
    pub permissions: Vec<String>,
    pub resources: Vec<String>,
    pub tenants: Vec<String>,
}

/// Tenants defines the per-tenant authentication and authorization spec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TempoStackTenantsMode {
    #[serde(rename = "static")]
    Static,
    #[serde(rename = "openshift")]
    Openshift,
}

/// TempoStackStatus defines the observed state of TempoStack.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackStatus {
    /// Components provides summary of all Tempo pod status grouped per component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<TempoStackStatusComponents>,
    /// Conditions of the Tempo deployment health.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// Version of the Tempo Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "operatorVersion")]
    pub operator_version: Option<String>,
    /// DEPRECATED. Version of the Tempo Query component used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoQueryVersion")]
    pub tempo_query_version: Option<String>,
    /// Version of the managed Tempo instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tempoVersion")]
    pub tempo_version: Option<String>,
}

/// Components provides summary of all Tempo pod status grouped per component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TempoStackStatusComponents {
    /// Compactor is a map to the pod status of the compactor pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compactor: Option<BTreeMap<String, String>>,
    /// Distributor is a map to the per pod status of the distributor deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distributor: Option<BTreeMap<String, String>>,
    /// Gateway is a map to the per pod status of the query frontend deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<BTreeMap<String, String>>,
    /// Ingester is a map to the per pod status of the ingester statefulset
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingester: Option<BTreeMap<String, String>>,
    /// Querier is a map to the per pod status of the querier deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub querier: Option<BTreeMap<String, String>>,
    /// QueryFrontend is a map to the per pod status of the query frontend deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryFrontend")]
    pub query_frontend: Option<BTreeMap<String, String>>,
}

