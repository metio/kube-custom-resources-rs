// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive Default --derive PartialEq --docs --filename ./crd-catalog/ipfs-cluster/ipfs-operator/cluster.ipfs.io/v1alpha1/ipfsclusters.yaml
// kopium version: 0.16.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// IpfsClusterSpec defines the desired state of the IpfsCluster.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "cluster.ipfs.io", version = "v1alpha1", kind = "IpfsCluster", plural = "ipfsclusters")]
#[kube(namespaced)]
#[kube(status = "IpfsClusterStatus")]
#[kube(schema = "disabled")]
pub struct IpfsClusterSpec {
    /// clusterStorage defines the amount of storage to be used by IPFS Cluster.
    #[serde(rename = "clusterStorage")]
    pub cluster_storage: IntOrString,
    /// follows defines the list of other IPFS Clusters this one should follow.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub follows: Option<Vec<IpfsClusterFollows>>,
    /// ipfsResources specifies the resource requirements for each IPFS container. If this value is omitted, then the operator will automatically determine these settings based on the storage sizes used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipfsResources")]
    pub ipfs_resources: Option<IpfsClusterIpfsResources>,
    /// ipfsStorage defines the total storage to be allocated by this resource.
    #[serde(rename = "ipfsStorage")]
    pub ipfs_storage: IntOrString,
    /// networking defines network configuration settings.
    pub networking: IpfsClusterNetworking,
    /// replicas sets the number of replicas of IPFS Cluster nodes we should be running.
    pub replicas: i32,
    /// reprovider Describes the settings that each IPFS node should use when reproviding content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reprovider: Option<IpfsClusterReprovider>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpfsClusterFollows {
    pub name: String,
    pub template: String,
}

/// ipfsResources specifies the resource requirements for each IPFS container. If this value is omitted, then the operator will automatically determine these settings based on the storage sizes used.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpfsClusterIpfsResources {
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// networking defines network configuration settings.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpfsClusterNetworking {
    /// circuitRelays defines how many CircuitRelays should be created.
    #[serde(rename = "circuitRelays")]
    pub circuit_relays: i32,
    /// public is a switch which defines whether this IPFSCluster will use the global IPFS network or create its own.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
}

/// reprovider Describes the settings that each IPFS node should use when reproviding content.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpfsClusterReprovider {
    /// Interval sets the time between rounds of reproviding local content to the routing system. Defaults to '12h'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Strategy specifies the reprovider strategy, defaults to 'all'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<IpfsClusterReproviderStrategy>,
}

/// reprovider Describes the settings that each IPFS node should use when reproviding content.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum IpfsClusterReproviderStrategy {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "pinned")]
    Pinned,
    #[serde(rename = "roots")]
    Roots,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpfsClusterStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "circuitRelays")]
    pub circuit_relays: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<IpfsClusterStatusConditions>>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpfsClusterStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: IpfsClusterStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum IpfsClusterStatusConditionsStatus {
    True,
    False,
    Unknown,
}

