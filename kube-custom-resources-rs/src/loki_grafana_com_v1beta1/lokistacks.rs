// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --auto --filename ./crd-catalog/grafana/loki/loki.grafana.com/v1beta1/lokistacks.yaml
// kopium version: 0.16.1

use kube::CustomResource;
use schemars::JsonSchema;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// LokiStackSpec defines the desired state of LokiStack
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "loki.grafana.com", version = "v1beta1", kind = "LokiStack", plural = "lokistacks")]
#[kube(namespaced)]
#[kube(status = "LokiStackStatus")]
pub struct LokiStackSpec {
    /// Limits defines the per-tenant limits to be applied to log stream processing and the per-tenant the config overrides.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<LokiStackLimits>,
    /// ManagementState defines if the CR should be managed by the operator or not. Default is managed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managementState")]
    pub management_state: Option<LokiStackManagementState>,
    /// ReplicationFactor defines the policy for log stream replication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicationFactor")]
    pub replication_factor: Option<i32>,
    /// Rules defines the spec for the ruler component
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<LokiStackRules>,
    /// Size defines one of the support Loki deployment scale out sizes.
    pub size: LokiStackSize,
    /// Storage defines the spec for the object storage endpoint to store logs.
    pub storage: LokiStackStorage,
    /// Storage class name defines the storage class for ingester/querier PVCs.
    #[serde(rename = "storageClassName")]
    pub storage_class_name: String,
    /// Template defines the resource/limits/tolerations/nodeselectors per component
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<LokiStackTemplate>,
    /// Tenants defines the per-tenant authentication and authorization spec for the lokistack-gateway component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenants: Option<LokiStackTenants>,
}

/// Limits defines the per-tenant limits to be applied to log stream processing and the per-tenant the config overrides.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackLimits {
    /// Global defines the limits applied globally across the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<LokiStackLimitsGlobal>,
    /// Tenants defines the limits and overrides applied per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenants: Option<BTreeMap<String, LokiStackLimitsTenants>>,
}

/// Global defines the limits applied globally across the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackLimitsGlobal {
    /// IngestionLimits defines the limits applied on ingested log streams.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingestion: Option<LokiStackLimitsGlobalIngestion>,
    /// QueryLimits defines the limit applied on querying log streams.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queries: Option<LokiStackLimitsGlobalQueries>,
}

/// IngestionLimits defines the limits applied on ingested log streams.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackLimitsGlobalIngestion {
    /// IngestionBurstSize defines the local rate-limited sample size per distributor replica. It should be set to the set at least to the maximum logs size expected in a single push request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionBurstSize")]
    pub ingestion_burst_size: Option<i32>,
    /// IngestionRate defines the sample size per second. Units MB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionRate")]
    pub ingestion_rate: Option<i32>,
    /// MaxGlobalStreamsPerTenant defines the maximum number of active streams per tenant, across the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxGlobalStreamsPerTenant")]
    pub max_global_streams_per_tenant: Option<i32>,
    /// MaxLabelNameLength defines the maximum number of characters allowed for label keys in log streams.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLabelNameLength")]
    pub max_label_name_length: Option<i32>,
    /// MaxLabelNamesPerSeries defines the maximum number of label names per series in each log stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLabelNamesPerSeries")]
    pub max_label_names_per_series: Option<i32>,
    /// MaxLabelValueLength defines the maximum number of characters allowed for label values in log streams.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLabelValueLength")]
    pub max_label_value_length: Option<i32>,
    /// MaxLineSize defines the maximum line size on ingestion path. Units in Bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLineSize")]
    pub max_line_size: Option<i32>,
}

/// QueryLimits defines the limit applied on querying log streams.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackLimitsGlobalQueries {
    /// MaxChunksPerQuery defines the maximum number of chunks that can be fetched by a single query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxChunksPerQuery")]
    pub max_chunks_per_query: Option<i32>,
    /// MaxEntriesLimitsPerQuery defines the maximum number of log entries that will be returned for a query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEntriesLimitPerQuery")]
    pub max_entries_limit_per_query: Option<i32>,
    /// MaxQuerySeries defines the maximum of unique series that is returned by a metric query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxQuerySeries")]
    pub max_query_series: Option<i32>,
}

/// Tenants defines the limits and overrides applied per tenant.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackLimitsTenants {
    /// IngestionLimits defines the limits applied on ingested log streams.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingestion: Option<LokiStackLimitsTenantsIngestion>,
    /// QueryLimits defines the limit applied on querying log streams.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queries: Option<LokiStackLimitsTenantsQueries>,
}

/// IngestionLimits defines the limits applied on ingested log streams.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackLimitsTenantsIngestion {
    /// IngestionBurstSize defines the local rate-limited sample size per distributor replica. It should be set to the set at least to the maximum logs size expected in a single push request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionBurstSize")]
    pub ingestion_burst_size: Option<i32>,
    /// IngestionRate defines the sample size per second. Units MB.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestionRate")]
    pub ingestion_rate: Option<i32>,
    /// MaxGlobalStreamsPerTenant defines the maximum number of active streams per tenant, across the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxGlobalStreamsPerTenant")]
    pub max_global_streams_per_tenant: Option<i32>,
    /// MaxLabelNameLength defines the maximum number of characters allowed for label keys in log streams.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLabelNameLength")]
    pub max_label_name_length: Option<i32>,
    /// MaxLabelNamesPerSeries defines the maximum number of label names per series in each log stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLabelNamesPerSeries")]
    pub max_label_names_per_series: Option<i32>,
    /// MaxLabelValueLength defines the maximum number of characters allowed for label values in log streams.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLabelValueLength")]
    pub max_label_value_length: Option<i32>,
    /// MaxLineSize defines the maximum line size on ingestion path. Units in Bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLineSize")]
    pub max_line_size: Option<i32>,
}

/// QueryLimits defines the limit applied on querying log streams.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackLimitsTenantsQueries {
    /// MaxChunksPerQuery defines the maximum number of chunks that can be fetched by a single query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxChunksPerQuery")]
    pub max_chunks_per_query: Option<i32>,
    /// MaxEntriesLimitsPerQuery defines the maximum number of log entries that will be returned for a query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxEntriesLimitPerQuery")]
    pub max_entries_limit_per_query: Option<i32>,
    /// MaxQuerySeries defines the maximum of unique series that is returned by a metric query.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxQuerySeries")]
    pub max_query_series: Option<i32>,
}

/// LokiStackSpec defines the desired state of LokiStack
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LokiStackManagementState {
    Managed,
    Unmanaged,
}

/// Rules defines the spec for the ruler component
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackRules {
    /// Enabled defines a flag to enable/disable the ruler component
    pub enabled: bool,
    /// Namespaces to be selected for PrometheusRules discovery. If unspecified, only the same namespace as the LokiStack object is in is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<LokiStackRulesNamespaceSelector>,
    /// A selector to select which LokiRules to mount for loading alerting/recording rules from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<LokiStackRulesSelector>,
}

/// Namespaces to be selected for PrometheusRules discovery. If unspecified, only the same namespace as the LokiStack object is in is used.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackRulesNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<LokiStackRulesNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackRulesNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A selector to select which LokiRules to mount for loading alerting/recording rules from.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackRulesSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<LokiStackRulesSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackRulesSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// LokiStackSpec defines the desired state of LokiStack
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LokiStackSize {
    #[serde(rename = "1x.extra-small")]
    r#_1xExtraSmall,
    #[serde(rename = "1x.small")]
    r#_1xSmall,
    #[serde(rename = "1x.medium")]
    r#_1xMedium,
}

/// Storage defines the spec for the object storage endpoint to store logs.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackStorage {
    /// Schemas for reading and writing logs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schemas: Option<Vec<LokiStackStorageSchemas>>,
    /// Secret for object storage authentication. Name of a secret in the same namespace as the LokiStack custom resource.
    pub secret: LokiStackStorageSecret,
    /// TLS configuration for reaching the object storage endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<LokiStackStorageTls>,
}

/// ObjectStorageSchema defines the requirements needed to configure a new storage schema.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackStorageSchemas {
    /// EffectiveDate is the date in UTC that the schema will be applied on. To ensure readibility of logs, this date should be before the current date in UTC.
    #[serde(rename = "effectiveDate")]
    pub effective_date: String,
    /// Version for writing and reading logs.
    pub version: LokiStackStorageSchemasVersion,
}

/// ObjectStorageSchema defines the requirements needed to configure a new storage schema.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LokiStackStorageSchemasVersion {
    #[serde(rename = "v11")]
    V11,
    #[serde(rename = "v12")]
    V12,
}

/// Secret for object storage authentication. Name of a secret in the same namespace as the LokiStack custom resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackStorageSecret {
    /// Name of a secret in the namespace configured for object storage secrets.
    pub name: String,
    /// Type of object storage that should be used
    #[serde(rename = "type")]
    pub r#type: LokiStackStorageSecretType,
}

/// Secret for object storage authentication. Name of a secret in the same namespace as the LokiStack custom resource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LokiStackStorageSecretType {
    #[serde(rename = "azure")]
    Azure,
    #[serde(rename = "gcs")]
    Gcs,
    #[serde(rename = "s3")]
    S3,
    #[serde(rename = "swift")]
    Swift,
}

/// TLS configuration for reaching the object storage endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackStorageTls {
    /// CA is the name of a ConfigMap containing a CA certificate. It needs to be in the same namespace as the LokiStack custom resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caName")]
    pub ca_name: Option<String>,
}

/// Template defines the resource/limits/tolerations/nodeselectors per component
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplate {
    /// Compactor defines the compaction component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compactor: Option<LokiStackTemplateCompactor>,
    /// Distributor defines the distributor component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distributor: Option<LokiStackTemplateDistributor>,
    /// Gateway defines the lokistack gateway component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<LokiStackTemplateGateway>,
    /// IndexGateway defines the index gateway component spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexGateway")]
    pub index_gateway: Option<LokiStackTemplateIndexGateway>,
    /// Ingester defines the ingester component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingester: Option<LokiStackTemplateIngester>,
    /// Querier defines the querier component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub querier: Option<LokiStackTemplateQuerier>,
    /// QueryFrontend defines the query frontend component spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryFrontend")]
    pub query_frontend: Option<LokiStackTemplateQueryFrontend>,
    /// Ruler defines the ruler component spec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ruler: Option<LokiStackTemplateRuler>,
}

/// Compactor defines the compaction component spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateCompactor {
    /// NodeSelector defines the labels required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replica pods of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Tolerations defines the tolerations required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<LokiStackTemplateCompactorTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateCompactorTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Distributor defines the distributor component spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateDistributor {
    /// NodeSelector defines the labels required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replica pods of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Tolerations defines the tolerations required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<LokiStackTemplateDistributorTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateDistributorTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Gateway defines the lokistack gateway component spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateGateway {
    /// NodeSelector defines the labels required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replica pods of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Tolerations defines the tolerations required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<LokiStackTemplateGatewayTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateGatewayTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// IndexGateway defines the index gateway component spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateIndexGateway {
    /// NodeSelector defines the labels required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replica pods of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Tolerations defines the tolerations required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<LokiStackTemplateIndexGatewayTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateIndexGatewayTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Ingester defines the ingester component spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateIngester {
    /// NodeSelector defines the labels required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replica pods of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Tolerations defines the tolerations required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<LokiStackTemplateIngesterTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateIngesterTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Querier defines the querier component spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateQuerier {
    /// NodeSelector defines the labels required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replica pods of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Tolerations defines the tolerations required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<LokiStackTemplateQuerierTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateQuerierTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// QueryFrontend defines the query frontend component spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateQueryFrontend {
    /// NodeSelector defines the labels required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replica pods of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Tolerations defines the tolerations required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<LokiStackTemplateQueryFrontendTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateQueryFrontendTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Ruler defines the ruler component spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateRuler {
    /// NodeSelector defines the labels required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Replicas defines the number of replica pods of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Tolerations defines the tolerations required by a node to schedule the component onto it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<LokiStackTemplateRulerTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTemplateRulerTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Tenants defines the per-tenant authentication and authorization spec for the lokistack-gateway component.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTenants {
    /// Authentication defines the lokistack-gateway component authentication configuration spec per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<Vec<LokiStackTenantsAuthentication>>,
    /// Authorization defines the lokistack-gateway component authorization configuration spec per tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<LokiStackTenantsAuthorization>,
    /// Mode defines the mode in which lokistack-gateway component will be configured.
    pub mode: LokiStackTenantsMode,
}

/// AuthenticationSpec defines the oidc configuration per tenant for lokiStack Gateway component.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTenantsAuthentication {
    /// OIDC defines the spec for the OIDC tenant's authentication.
    pub oidc: LokiStackTenantsAuthenticationOidc,
    /// TenantID defines the id of the tenant.
    #[serde(rename = "tenantId")]
    pub tenant_id: String,
    /// TenantName defines the name of the tenant.
    #[serde(rename = "tenantName")]
    pub tenant_name: String,
}

/// OIDC defines the spec for the OIDC tenant's authentication.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTenantsAuthenticationOidc {
    /// Group claim field from ID Token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupClaim")]
    pub group_claim: Option<String>,
    /// IssuerURL defines the URL for issuer.
    #[serde(rename = "issuerURL")]
    pub issuer_url: String,
    /// RedirectURL defines the URL for redirect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectURL")]
    pub redirect_url: Option<String>,
    /// Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
    pub secret: LokiStackTenantsAuthenticationOidcSecret,
    /// User claim field from ID Token
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usernameClaim")]
    pub username_claim: Option<String>,
}

/// Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTenantsAuthenticationOidcSecret {
    /// Name of a secret in the namespace configured for tenant secrets.
    pub name: String,
}

/// Authorization defines the lokistack-gateway component authorization configuration spec per tenant.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTenantsAuthorization {
    /// OPA defines the spec for the third-party endpoint for tenant's authorization.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opa: Option<LokiStackTenantsAuthorizationOpa>,
    /// RoleBindings defines configuration to bind a set of roles to a set of subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleBindings")]
    pub role_bindings: Option<Vec<LokiStackTenantsAuthorizationRoleBindings>>,
    /// Roles defines a set of permissions to interact with a tenant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<LokiStackTenantsAuthorizationRoles>>,
}

/// OPA defines the spec for the third-party endpoint for tenant's authorization.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTenantsAuthorizationOpa {
    /// URL defines the third-party endpoint for authorization.
    pub url: String,
}

/// RoleBindingsSpec binds a set of roles to a set of subjects.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTenantsAuthorizationRoleBindings {
    pub name: String,
    pub roles: Vec<String>,
    pub subjects: Vec<LokiStackTenantsAuthorizationRoleBindingsSubjects>,
}

/// Subject represents a subject that has been bound to a role.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTenantsAuthorizationRoleBindingsSubjects {
    /// SubjectKind is a kind of LokiStack Gateway RBAC subject.
    pub kind: LokiStackTenantsAuthorizationRoleBindingsSubjectsKind,
    pub name: String,
}

/// Subject represents a subject that has been bound to a role.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LokiStackTenantsAuthorizationRoleBindingsSubjectsKind {
    #[serde(rename = "user")]
    User,
    #[serde(rename = "group")]
    Group,
}

/// RoleSpec describes a set of permissions to interact with a tenant.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackTenantsAuthorizationRoles {
    pub name: String,
    pub permissions: Vec<String>,
    pub resources: Vec<String>,
    pub tenants: Vec<String>,
}

/// Tenants defines the per-tenant authentication and authorization spec for the lokistack-gateway component.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LokiStackTenantsMode {
    #[serde(rename = "static")]
    Static,
    #[serde(rename = "dynamic")]
    Dynamic,
    #[serde(rename = "openshift-logging")]
    OpenshiftLogging,
}

/// LokiStackStatus defines the observed state of LokiStack
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackStatus {
    /// Components provides summary of all Loki pod status grouped per component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<LokiStackStatusComponents>,
    /// Conditions of the Loki deployment health.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<LokiStackStatusConditions>>,
    /// Storage provides summary of all changes that have occurred to the storage configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<LokiStackStatusStorage>,
}

/// Components provides summary of all Loki pod status grouped per component.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackStatusComponents {
    /// Compactor is a map to the pod status of the compactor pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compactor: Option<BTreeMap<String, String>>,
    /// Distributor is a map to the per pod status of the distributor deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distributor: Option<BTreeMap<String, String>>,
    /// Gateway is a map to the per pod status of the lokistack gateway deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<BTreeMap<String, String>>,
    /// IndexGateway is a map to the per pod status of the index gateway statefulset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexGateway")]
    pub index_gateway: Option<BTreeMap<String, String>>,
    /// Ingester is a map to the per pod status of the ingester statefulset
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingester: Option<BTreeMap<String, String>>,
    /// Querier is a map to the per pod status of the querier deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub querier: Option<BTreeMap<String, String>>,
    /// QueryFrontend is a map to the per pod status of the query frontend deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryFrontend")]
    pub query_frontend: Option<BTreeMap<String, String>>,
    /// Ruler is a map to the per pod status of the lokistack ruler statefulset.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ruler: Option<BTreeMap<String, String>>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: LokiStackStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LokiStackStatusConditionsStatus {
    True,
    False,
    Unknown,
}

/// Storage provides summary of all changes that have occurred to the storage configuration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackStatusStorage {
    /// Schemas is a list of schemas which have been applied to the LokiStack.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schemas: Option<Vec<LokiStackStatusStorageSchemas>>,
}

/// ObjectStorageSchema defines the requirements needed to configure a new storage schema.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LokiStackStatusStorageSchemas {
    /// EffectiveDate is the date in UTC that the schema will be applied on. To ensure readibility of logs, this date should be before the current date in UTC.
    #[serde(rename = "effectiveDate")]
    pub effective_date: String,
    /// Version for writing and reading logs.
    pub version: LokiStackStatusStorageSchemasVersion,
}

/// ObjectStorageSchema defines the requirements needed to configure a new storage schema.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum LokiStackStatusStorageSchemasVersion {
    #[serde(rename = "v11")]
    V11,
    #[serde(rename = "v12")]
    V12,
}

