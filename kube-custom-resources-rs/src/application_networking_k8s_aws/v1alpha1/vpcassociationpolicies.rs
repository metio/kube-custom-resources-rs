// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/aws/aws-application-networking-k8s/application-networking.k8s.aws/v1alpha1/vpcassociationpolicies.yaml --derive=PartialEq
// kopium version: 0.16.5

use kube::CustomResource;
use serde::{Serialize, Deserialize};

/// VpcAssociationPolicySpec defines the desired state of VpcAssociationPolicy.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "application-networking.k8s.aws", version = "v1alpha1", kind = "VpcAssociationPolicy", plural = "vpcassociationpolicies")]
#[kube(namespaced)]
#[kube(status = "VpcAssociationPolicyStatus")]
#[kube(schema = "disabled")]
pub struct VpcAssociationPolicySpec {
    /// AssociateWithVpc indicates whether the VpcServiceNetworkAssociation should be created for the current VPC of k8s cluster. 
    ///  This value will be considered true by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "associateWithVpc")]
    pub associate_with_vpc: Option<bool>,
    /// SecurityGroupIds defines the security groups enforced on the VpcServiceNetworkAssociation. Security groups does not take effect if AssociateWithVpc is set to false. 
    ///  For more details, please check the VPC Lattice documentation https://docs.aws.amazon.com/vpc-lattice/latest/ug/security-groups.html
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupIds")]
    pub security_group_ids: Option<Vec<String>>,
    /// TargetRef points to the kubernetes Gateway resource that will have this policy attached. 
    ///  This field is following the guidelines of Kubernetes Gateway API policy attachment.
    #[serde(rename = "targetRef")]
    pub target_ref: VpcAssociationPolicyTargetRef,
}

/// TargetRef points to the kubernetes Gateway resource that will have this policy attached. 
///  This field is following the guidelines of Kubernetes Gateway API policy attachment.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct VpcAssociationPolicyTargetRef {
    /// Group is the group of the target resource.
    pub group: String,
    /// Kind is kind of the target resource.
    pub kind: String,
    /// Name is the name of the target resource.
    pub name: String,
    /// Namespace is the namespace of the referent. When unspecified, the local namespace is inferred. Even when policy targets a resource in a different namespace, it MUST only apply to traffic originating from the same namespace as the policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// VpcAssociationPolicyStatus defines the observed state of VpcAssociationPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct VpcAssociationPolicyStatus {
    /// Conditions describe the current conditions of the VpcAssociationPolicy. 
    ///  Implementations should prefer to express Policy conditions using the `PolicyConditionType` and `PolicyConditionReason` constants so that operators and tools can converge on a common vocabulary to describe VpcAssociationPolicy state. 
    ///  Known condition types are: 
    ///  * "Accepted"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<VpcAssociationPolicyStatusConditions>>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct VpcAssociationPolicyStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: VpcAssociationPolicyStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VpcAssociationPolicyStatusConditionsStatus {
    True,
    False,
    Unknown,
}

