// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/kyverno/kyverno/kyverno.io/v2beta1/cleanuppolicies.yaml --derive=PartialEq
// kopium version: 0.16.2

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use std::collections::HashMap;

/// Spec declares policy behaviors.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "kyverno.io", version = "v2beta1", kind = "CleanupPolicy", plural = "cleanuppolicies")]
#[kube(namespaced)]
#[kube(status = "CleanupPolicyStatus")]
#[kube(schema = "disabled")]
pub struct CleanupPolicySpec {
    /// Conditions defines the conditions used to select the resources which will be cleaned up.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<CleanupPolicyConditions>,
    /// Context defines variables and data sources that can be used during rule execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<Vec<CleanupPolicyContext>>,
    /// ExcludeResources defines when cleanuppolicy should not be applied. The exclude criteria can include resource information (e.g. kind, name, namespace, labels) and admission review request information like the name or role.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exclude: Option<CleanupPolicyExclude>,
    /// MatchResources defines when cleanuppolicy should be applied. The match criteria can include resource information (e.g. kind, name, namespace, labels) and admission review request information like the user name or role. At least one kind is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<CleanupPolicyMatch>,
    /// The schedule in Cron format
    pub schedule: String,
}

/// Conditions defines the conditions used to select the resources which will be cleaned up.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyConditions {
    /// AllConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, all of the conditions need to pass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<CleanupPolicyConditionsAll>>,
    /// AnyConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, at least one of the conditions need to pass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<CleanupPolicyConditionsAny>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyConditionsAll {
    /// Key is the context entry (using JMESPath) for conditional rule evaluation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<HashMap<String, serde_json::Value>>,
    /// Message is an optional display message
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<CleanupPolicyConditionsAllOperator>,
    /// Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<HashMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CleanupPolicyConditionsAllOperator {
    Equals,
    NotEquals,
    AnyIn,
    AllIn,
    AnyNotIn,
    AllNotIn,
    GreaterThanOrEquals,
    GreaterThan,
    LessThanOrEquals,
    LessThan,
    DurationGreaterThanOrEquals,
    DurationGreaterThan,
    DurationLessThanOrEquals,
    DurationLessThan,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyConditionsAny {
    /// Key is the context entry (using JMESPath) for conditional rule evaluation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<HashMap<String, serde_json::Value>>,
    /// Message is an optional display message
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<CleanupPolicyConditionsAnyOperator>,
    /// Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<HashMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CleanupPolicyConditionsAnyOperator {
    Equals,
    NotEquals,
    AnyIn,
    AllIn,
    AnyNotIn,
    AllNotIn,
    GreaterThanOrEquals,
    GreaterThan,
    LessThanOrEquals,
    LessThan,
    DurationGreaterThanOrEquals,
    DurationGreaterThan,
    DurationLessThanOrEquals,
    DurationLessThan,
}

/// ContextEntry adds variables and data sources to a rule Context. Either a ConfigMap reference or a APILookup must be provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyContext {
    /// APICall is an HTTP request to the Kubernetes API server, or other JSON web service. The data returned is stored in the context with the name for the context entry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiCall")]
    pub api_call: Option<CleanupPolicyContextApiCall>,
    /// ConfigMap is the ConfigMap reference.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<CleanupPolicyContextConfigMap>,
    /// ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistry")]
    pub image_registry: Option<CleanupPolicyContextImageRegistry>,
    /// Name is the variable name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Variable defines an arbitrary JMESPath context variable that can be defined inline.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variable: Option<CleanupPolicyContextVariable>,
}

/// APICall is an HTTP request to the Kubernetes API server, or other JSON web service. The data returned is stored in the context with the name for the context entry.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyContextApiCall {
    /// Data specifies the POST data sent to the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<Vec<CleanupPolicyContextApiCallData>>,
    /// JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of "items | length(@)" applied to the API server response for the URLPath "/apis/apps/v1/deployments" will return the total count of deployments across all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jmesPath")]
    pub jmes_path: Option<String>,
    /// Method is the HTTP request type (GET or POST).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<CleanupPolicyContextApiCallMethod>,
    /// Service is an API call to a JSON web service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<CleanupPolicyContextApiCallService>,
    /// URLPath is the URL path to be used in the HTTP GET or POST request to the Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments"). The format required is the same format used by the `kubectl get --raw` command. See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls for details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlPath")]
    pub url_path: Option<String>,
}

/// RequestData contains the HTTP POST data
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyContextApiCallData {
    /// Key is a unique identifier for the data value
    pub key: String,
    /// Value is the data value
    pub value: HashMap<String, serde_json::Value>,
}

/// APICall is an HTTP request to the Kubernetes API server, or other JSON web service. The data returned is stored in the context with the name for the context entry.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CleanupPolicyContextApiCallMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
}

/// Service is an API call to a JSON web service
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyContextApiCallService {
    /// CABundle is a PEM encoded CA bundle which will be used to validate the server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caBundle")]
    pub ca_bundle: Option<String>,
    /// URL is the JSON web service URL. A typical form is `https://{service}.{namespace}:{port}/{path}`.
    pub url: String,
}

/// ConfigMap is the ConfigMap reference.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyContextConfigMap {
    /// Name is the ConfigMap name.
    pub name: String,
    /// Namespace is the ConfigMap namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyContextImageRegistry {
    /// ImageRegistryCredentials provides credentials that will be used for authentication with registry
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRegistryCredentials")]
    pub image_registry_credentials: Option<CleanupPolicyContextImageRegistryImageRegistryCredentials>,
    /// JMESPath is an optional JSON Match Expression that can be used to transform the ImageData struct returned as a result of processing the image reference.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jmesPath")]
    pub jmes_path: Option<String>,
    /// Reference is image reference to a container image in the registry. Example: ghcr.io/kyverno/kyverno:latest
    pub reference: String,
}

/// ImageRegistryCredentials provides credentials that will be used for authentication with registry
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyContextImageRegistryImageRegistryCredentials {
    /// AllowInsecureRegistry allows insecure access to a registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowInsecureRegistry")]
    pub allow_insecure_registry: Option<bool>,
    /// Providers specifies a list of OCI Registry names, whose authentication providers are provided. It can be of one of these values: default,google,azure,amazon,github.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub providers: Option<Vec<String>>,
    /// Secrets specifies a list of secrets that are provided for credentials. Secrets must live in the Kyverno namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
}

/// Variable defines an arbitrary JMESPath context variable that can be defined inline.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyContextVariable {
    /// Default is an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<HashMap<String, serde_json::Value>>,
    /// JMESPath is an optional JMESPath Expression that can be used to transform the variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jmesPath")]
    pub jmes_path: Option<String>,
    /// Value is any arbitrary JSON object representable in YAML or JSON form.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<HashMap<String, serde_json::Value>>,
}

/// ExcludeResources defines when cleanuppolicy should not be applied. The exclude criteria can include resource information (e.g. kind, name, namespace, labels) and admission review request information like the name or role.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExclude {
    /// All allows specifying resources which will be ANDed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<CleanupPolicyExcludeAll>>,
    /// Any allows specifying resources which will be ORed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<CleanupPolicyExcludeAny>>,
}

/// ResourceFilter allow users to "AND" or "OR" between resources
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAll {
    /// ClusterRoles is the list of cluster-wide role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRoles")]
    pub cluster_roles: Option<Vec<String>>,
    /// ResourceDescription contains information about the resource being created or modified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CleanupPolicyExcludeAllResources>,
    /// Roles is the list of namespaced role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
    /// Subjects is the list of subject names like users, user groups, and service accounts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<CleanupPolicyExcludeAllSubjects>>,
}

/// ResourceDescription contains information about the resource being created or modified.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAllResources {
    /// Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Kinds is a list of resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinds: Option<Vec<String>>,
    /// Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CleanupPolicyExcludeAllResourcesNamespaceSelector>,
    /// Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CleanupPolicyExcludeAllResourcesSelector>,
}

/// NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAllResourcesNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyExcludeAllResourcesNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAllResourcesNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAllResourcesSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyExcludeAllResourcesSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAllResourcesSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAllSubjects {
    /// APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    pub kind: String,
    /// Name of the object being referenced.
    pub name: String,
    /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ResourceFilter allow users to "AND" or "OR" between resources
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAny {
    /// ClusterRoles is the list of cluster-wide role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRoles")]
    pub cluster_roles: Option<Vec<String>>,
    /// ResourceDescription contains information about the resource being created or modified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CleanupPolicyExcludeAnyResources>,
    /// Roles is the list of namespaced role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
    /// Subjects is the list of subject names like users, user groups, and service accounts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<CleanupPolicyExcludeAnySubjects>>,
}

/// ResourceDescription contains information about the resource being created or modified.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAnyResources {
    /// Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Kinds is a list of resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinds: Option<Vec<String>>,
    /// Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CleanupPolicyExcludeAnyResourcesNamespaceSelector>,
    /// Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CleanupPolicyExcludeAnyResourcesSelector>,
}

/// NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAnyResourcesNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyExcludeAnyResourcesNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAnyResourcesNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAnyResourcesSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyExcludeAnyResourcesSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAnyResourcesSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyExcludeAnySubjects {
    /// APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    pub kind: String,
    /// Name of the object being referenced.
    pub name: String,
    /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// MatchResources defines when cleanuppolicy should be applied. The match criteria can include resource information (e.g. kind, name, namespace, labels) and admission review request information like the user name or role. At least one kind is required.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatch {
    /// All allows specifying resources which will be ANDed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<CleanupPolicyMatchAll>>,
    /// Any allows specifying resources which will be ORed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<CleanupPolicyMatchAny>>,
}

/// ResourceFilter allow users to "AND" or "OR" between resources
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAll {
    /// ClusterRoles is the list of cluster-wide role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRoles")]
    pub cluster_roles: Option<Vec<String>>,
    /// ResourceDescription contains information about the resource being created or modified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CleanupPolicyMatchAllResources>,
    /// Roles is the list of namespaced role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
    /// Subjects is the list of subject names like users, user groups, and service accounts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<CleanupPolicyMatchAllSubjects>>,
}

/// ResourceDescription contains information about the resource being created or modified.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAllResources {
    /// Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Kinds is a list of resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinds: Option<Vec<String>>,
    /// Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CleanupPolicyMatchAllResourcesNamespaceSelector>,
    /// Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CleanupPolicyMatchAllResourcesSelector>,
}

/// NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAllResourcesNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyMatchAllResourcesNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAllResourcesNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAllResourcesSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyMatchAllResourcesSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAllResourcesSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAllSubjects {
    /// APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    pub kind: String,
    /// Name of the object being referenced.
    pub name: String,
    /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ResourceFilter allow users to "AND" or "OR" between resources
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAny {
    /// ClusterRoles is the list of cluster-wide role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRoles")]
    pub cluster_roles: Option<Vec<String>>,
    /// ResourceDescription contains information about the resource being created or modified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<CleanupPolicyMatchAnyResources>,
    /// Roles is the list of namespaced role names for the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
    /// Subjects is the list of subject names like users, user groups, and service accounts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<CleanupPolicyMatchAnySubjects>>,
}

/// ResourceDescription contains information about the resource being created or modified.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAnyResources {
    /// Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Kinds is a list of resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kinds: Option<Vec<String>>,
    /// Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<CleanupPolicyMatchAnyResourcesNamespaceSelector>,
    /// Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<CleanupPolicyMatchAnyResourcesSelector>,
}

/// NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAnyResourcesNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyMatchAnyResourcesNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAnyResourcesNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAnyResourcesSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CleanupPolicyMatchAnyResourcesSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAnyResourcesSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyMatchAnySubjects {
    /// APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    pub kind: String,
    /// Name of the object being referenced.
    pub name: String,
    /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Status contains policy runtime data.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<CleanupPolicyStatusConditions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastExecutionTime")]
    pub last_execution_time: Option<String>,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CleanupPolicyStatusConditions {
    /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    /// message is a human readable message indicating details about the transition. This may be an empty string.
    pub message: String,
    /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    pub reason: String,
    /// status of the condition, one of True, False, Unknown.
    pub status: CleanupPolicyStatusConditionsStatus,
    /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
///  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
///  // other fields }
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CleanupPolicyStatusConditionsStatus {
    True,
    False,
    Unknown,
}

