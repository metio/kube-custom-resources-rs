// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/VictoriaMetrics/operator/operator.victoriametrics.com/v1beta1/vmservicescrapes.yaml --derive=Default --derive=PartialEq
// kopium version: 0.18.0

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// VMServiceScrapeSpec defines the desired state of VMServiceScrape
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "operator.victoriametrics.com", version = "v1beta1", kind = "VMServiceScrape", plural = "vmservicescrapes")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
pub struct VMServiceScrapeSpec {
    /// AttachMetadata configures metadata attaching from service discovery
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attach_metadata: Option<VMServiceScrapeAttachMetadata>,
    /// DiscoveryRole - defines kubernetes_sd role for objects discovery.
    /// by default, its endpoints.
    /// can be changed to service or endpointslices.
    /// note, that with service setting, you have to use port: "name"
    /// and cannot use targetPort for endpoints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discoveryRole")]
    pub discovery_role: Option<VMServiceScrapeDiscoveryRole>,
    /// A list of endpoints allowed as part of this ServiceScrape.
    pub endpoints: Vec<VMServiceScrapeEndpoints>,
    /// The label to use to retrieve the job name from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobLabel")]
    pub job_label: Option<String>,
    /// Selector to select which namespaces the Endpoints objects are discovered from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<VMServiceScrapeNamespaceSelector>,
    /// PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTargetLabels")]
    pub pod_target_labels: Option<Vec<String>>,
    /// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// Selector to select Endpoints objects by corresponding Service labels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<VMServiceScrapeSelector>,
    /// TargetLabels transfers labels on the Kubernetes Service onto the target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabels")]
    pub target_labels: Option<Vec<String>>,
}

/// AttachMetadata configures metadata attaching from service discovery
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeAttachMetadata {
    /// Node instructs vmagent to add node specific metadata from service discovery
    /// Valid for roles: pod, endpoints, endpointslice.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<bool>,
}

/// VMServiceScrapeSpec defines the desired state of VMServiceScrape
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VMServiceScrapeDiscoveryRole {
    #[serde(rename = "endpoints")]
    Endpoints,
    #[serde(rename = "service")]
    Service,
    #[serde(rename = "endpointslices")]
    Endpointslices,
}

/// Endpoint defines a scrapeable endpoint serving Prometheus metrics.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpoints {
    /// AttachMetadata configures metadata attaching from service discovery
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attach_metadata: Option<VMServiceScrapeEndpointsAttachMetadata>,
    /// Authorization with http header Authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<VMServiceScrapeEndpointsAuthorization>,
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    /// More info: https://prometheus.io/docs/operating/configuration/#endpoints
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<VMServiceScrapeEndpointsBasicAuth>,
    /// File to read bearer token for scraping targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenFile")]
    pub bearer_token_file: Option<String>,
    /// Secret to mount to read bearer token for scraping targets. The secret
    /// needs to be in the same namespace as the service scrape and accessible by
    /// the victoria-metrics operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<VMServiceScrapeEndpointsBearerTokenSecret>,
    /// FollowRedirects controls redirects for scraping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub follow_redirects: Option<bool>,
    /// HonorLabels chooses the metric's labels on collisions with target labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorLabels")]
    pub honor_labels: Option<bool>,
    /// HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorTimestamps")]
    pub honor_timestamps: Option<bool>,
    /// Interval at which metrics should be scraped
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// MetricRelabelConfigs to apply to samples before ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelConfigs")]
    pub metric_relabel_configs: Option<Vec<VMServiceScrapeEndpointsMetricRelabelConfigs>>,
    /// OAuth2 defines auth configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<VMServiceScrapeEndpointsOauth2>,
    /// Optional HTTP URL parameters
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, String>>,
    /// HTTP path to scrape for metrics.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// RelabelConfigs to apply to samples before scraping.
    /// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relabelConfigs")]
    pub relabel_configs: Option<Vec<VMServiceScrapeEndpointsRelabelConfigs>>,
    /// SampleLimit defines per-endpoint limit on number of scraped samples that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// HTTP scheme to use for scraping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<VMServiceScrapeEndpointsScheme>,
    /// Timeout after which the scrape is ended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// ScrapeInterval is the same as Interval and has priority over it.
    /// one of scrape_interval or interval can be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_interval: Option<String>,
    /// Name or number of the pod port this endpoint refers to. Mutually exclusive with port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPort")]
    pub target_port: Option<IntOrString>,
    /// TLSConfig configuration to use when scraping the endpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VMServiceScrapeEndpointsTlsConfig>,
    /// VMScrapeParams defines VictoriaMetrics specific scrape parametrs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vm_scrape_params: Option<VMServiceScrapeEndpointsVmScrapeParams>,
}

/// AttachMetadata configures metadata attaching from service discovery
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsAttachMetadata {
    /// Node instructs vmagent to add node specific metadata from service discovery
    /// Valid for roles: pod, endpoints, endpointslice.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<bool>,
}

/// Authorization with http header Authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsAuthorization {
    /// Reference to the secret with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<VMServiceScrapeEndpointsAuthorizationCredentials>,
    /// File with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsFile")]
    pub credentials_file: Option<String>,
    /// Type of authorization, default to bearer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to the secret with value for authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
/// More info: https://prometheus.io/docs/operating/configuration/#endpoints
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMServiceScrapeEndpointsBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMServiceScrapeEndpointsBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret to mount to read bearer token for scraping targets. The secret
/// needs to be in the same namespace as the service scrape and accessible by
/// the victoria-metrics operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion.
/// It defines `<metric_relabel_configs>`-section of configuration.
/// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsMetricRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<BTreeMap<String, serde_json::Value>>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details https://github.com/VictoriaMetrics/operator/issues/131
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details https://github.com/VictoriaMetrics/operator/issues/131
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// OAuth2 defines auth configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsOauth2 {
    /// The secret or configmap containing the OAuth2 client id
    pub client_id: VMServiceScrapeEndpointsOauth2ClientId,
    /// The secret containing the OAuth2 client secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<VMServiceScrapeEndpointsOauth2ClientSecret>,
    /// ClientSecretFile defines path for client secret file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret_file: Option<String>,
    /// Parameters to append to the token URL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// OAuth2 scopes used for the token request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// The URL to fetch the token from
    pub token_url: String,
}

/// The secret or configmap containing the OAuth2 client id
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMServiceScrapeEndpointsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMServiceScrapeEndpointsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret containing the OAuth2 client secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion.
/// It defines `<metric_relabel_configs>`-section of configuration.
/// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<BTreeMap<String, serde_json::Value>>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details https://github.com/VictoriaMetrics/operator/issues/131
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details https://github.com/VictoriaMetrics/operator/issues/131
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// Endpoint defines a scrapeable endpoint serving Prometheus metrics.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VMServiceScrapeEndpointsScheme {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

/// TLSConfig configuration to use when scraping the endpoint
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMServiceScrapeEndpointsTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMServiceScrapeEndpointsTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMServiceScrapeEndpointsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMServiceScrapeEndpointsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMServiceScrapeEndpointsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMServiceScrapeEndpointsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMServiceScrapeEndpointsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// VMScrapeParams defines VictoriaMetrics specific scrape parametrs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable_compression: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable_keep_alive: Option<bool>,
    /// Headers allows sending custom headers to scrape targets
    /// must be in of semicolon separated header with it's value
    /// eg:
    /// headerName: headerValue
    /// vmagent supports since 1.79.0 version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metric_relabel_debug: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub no_stale_markers: Option<bool>,
    /// ProxyClientConfig configures proxy auth settings for scraping
    /// See feature description https://docs.victoriametrics.com/vmagent.html#scraping-targets-via-a-proxy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_client_config: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relabel_debug: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_align_interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_offset: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stream_parse: Option<bool>,
}

/// ProxyClientConfig configures proxy auth settings for scraping
/// See feature description https://docs.victoriametrics.com/vmagent.html#scraping-targets-via-a-proxy
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfig {
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigBasicAuth>,
    /// SecretKeySelector selects a key of a Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigBearerToken>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    /// TLSConfig specifies TLSConfig configuration parameters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfig>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigBearerToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLSConfig specifies TLSConfig configuration parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeEndpointsVmScrapeParamsProxyClientConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selector to select which namespaces the Endpoints objects are discovered from.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeNamespaceSelector {
    /// Boolean describing whether all namespaces are selected in contrast to a
    /// list restricting them.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<bool>,
    /// List of namespace names.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchNames")]
    pub match_names: Option<Vec<String>>,
}

/// Selector to select Endpoints objects by corresponding Service labels.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VMServiceScrapeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// VMServiceScrapeStatus defines the observed state of VMServiceScrape
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMServiceScrapeStatus {
}

