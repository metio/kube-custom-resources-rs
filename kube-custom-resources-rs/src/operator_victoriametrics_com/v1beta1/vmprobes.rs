// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/VictoriaMetrics/operator/operator.victoriametrics.com/v1beta1/vmprobes.yaml --derive=Default --derive=PartialEq
// kopium version: 0.20.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// VMProbeSpec contains specification parameters for a Probe.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "operator.victoriametrics.com", version = "v1beta1", kind = "VMProbe", plural = "vmprobes")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct VMProbeSpec {
    /// Authorization with http header Authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<VMProbeAuthorization>,
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    /// More info: https://prometheus.io/docs/operating/configuration/#endpoints
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<VMProbeBasicAuth>,
    /// File to read bearer token for scraping targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenFile")]
    pub bearer_token_file: Option<String>,
    /// Secret to mount to read bearer token for scraping targets. The secret
    /// needs to be in the same namespace as the service scrape and accessible by
    /// the victoria-metrics operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<VMProbeBearerTokenSecret>,
    /// FollowRedirects controls redirects for scraping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub follow_redirects: Option<bool>,
    /// Interval at which targets are probed using the configured prober.
    /// If not specified Prometheus' global scrape interval is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// The job name assigned to scraped metrics by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobName")]
    pub job_name: Option<String>,
    /// The module to use for probing specifying how to probe the target.
    /// Example module configuring in the blackbox exporter:
    /// https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub module: Option<String>,
    /// OAuth2 defines auth configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<VMProbeOauth2>,
    /// Optional HTTP URL parameters
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, String>>,
    /// ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// Timeout for scraping metrics from the Prometheus exporter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// ScrapeInterval is the same as Interval and has priority over it.
    /// one of scrape_interval or interval can be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_interval: Option<String>,
    /// SeriesLimit defines per-scrape limit on number of unique time series
    /// a single target can expose during all the scrapes on the time window of 24h.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seriesLimit")]
    pub series_limit: Option<i64>,
    /// Targets defines a set of static and/or dynamically discovered targets to be probed using the prober.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<VMProbeTargets>,
    /// TLSConfig configuration to use when scraping the endpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VMProbeTlsConfig>,
    /// Specification for the prober to use for probing targets.
    /// The prober.URL parameter is required. Targets cannot be probed if left empty.
    #[serde(rename = "vmProberSpec")]
    pub vm_prober_spec: VMProbeVmProberSpec,
    /// VMScrapeParams defines VictoriaMetrics specific scrape parametrs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vm_scrape_params: Option<VMProbeVmScrapeParams>,
}

/// Authorization with http header Authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeAuthorization {
    /// Reference to the secret with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<VMProbeAuthorizationCredentials>,
    /// File with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsFile")]
    pub credentials_file: Option<String>,
    /// Type of authorization, default to bearer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to the secret with value for authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
/// More info: https://prometheus.io/docs/operating/configuration/#endpoints
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMProbeBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMProbeBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret to mount to read bearer token for scraping targets. The secret
/// needs to be in the same namespace as the service scrape and accessible by
/// the victoria-metrics operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OAuth2 defines auth configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeOauth2 {
    /// The secret or configmap containing the OAuth2 client id
    pub client_id: VMProbeOauth2ClientId,
    /// The secret containing the OAuth2 client secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<VMProbeOauth2ClientSecret>,
    /// ClientSecretFile defines path for client secret file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret_file: Option<String>,
    /// Parameters to append to the token URL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// OAuth2 scopes used for the token request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// The URL to fetch the token from
    pub token_url: String,
}

/// The secret or configmap containing the OAuth2 client id
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMProbeOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMProbeOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret containing the OAuth2 client secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Targets defines a set of static and/or dynamically discovered targets to be probed using the prober.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTargets {
    /// Ingress defines the set of dynamically discovered ingress objects which hosts are considered for probing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<VMProbeTargetsIngress>,
    /// StaticConfig defines static targets which are considers for probing.
    /// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticConfig")]
    pub static_config: Option<VMProbeTargetsStaticConfig>,
}

/// Ingress defines the set of dynamically discovered ingress objects which hosts are considered for probing.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTargetsIngress {
    /// Select Ingress objects by namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<VMProbeTargetsIngressNamespaceSelector>,
    /// RelabelConfigs to apply to samples before ingestion.
    /// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relabelingConfigs")]
    pub relabeling_configs: Option<Vec<VMProbeTargetsIngressRelabelingConfigs>>,
    /// Select Ingress objects by labels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<VMProbeTargetsIngressSelector>,
}

/// Select Ingress objects by namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTargetsIngressNamespaceSelector {
    /// Boolean describing whether all namespaces are selected in contrast to a
    /// list restricting them.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<bool>,
    /// List of namespace names.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchNames")]
    pub match_names: Option<Vec<String>>,
}

/// RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion.
/// It defines `<metric_relabel_configs>`-section of configuration.
/// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTargetsIngressRelabelingConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// https://docs.victoriametrics.com/vmagent/#relabeling-enhancements
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details https://github.com/VictoriaMetrics/operator/issues/131
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details https://github.com/VictoriaMetrics/operator/issues/131
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// Select Ingress objects by labels.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTargetsIngressSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VMProbeTargetsIngressSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTargetsIngressSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// StaticConfig defines static targets which are considers for probing.
/// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTargetsStaticConfig {
    /// Labels assigned to all metrics scraped from the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relabelingConfigs")]
    pub relabeling_configs: Option<Vec<VMProbeTargetsStaticConfigRelabelingConfigs>>,
    /// Targets is a list of URLs to probe using the configured prober.
    pub targets: Vec<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion.
/// It defines `<metric_relabel_configs>`-section of configuration.
/// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTargetsStaticConfigRelabelingConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// https://docs.victoriametrics.com/vmagent/#relabeling-enhancements
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details https://github.com/VictoriaMetrics/operator/issues/131
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details https://github.com/VictoriaMetrics/operator/issues/131
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// TLSConfig configuration to use when scraping the endpoint
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMProbeTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMProbeTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMProbeTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMProbeTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMProbeTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMProbeTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMProbeTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Specification for the prober to use for probing targets.
/// The prober.URL parameter is required. Targets cannot be probed if left empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmProberSpec {
    /// Path to collect metrics from.
    /// Defaults to `/probe`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// HTTP scheme to use for scraping.
    /// Defaults to `http`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<VMProbeVmProberSpecScheme>,
    /// Mandatory URL of the prober.
    pub url: String,
}

/// Specification for the prober to use for probing targets.
/// The prober.URL parameter is required. Targets cannot be probed if left empty.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VMProbeVmProberSpecScheme {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

/// VMScrapeParams defines VictoriaMetrics specific scrape parametrs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable_compression: Option<bool>,
    /// disable_keepalive allows disabling HTTP keep-alive when scraping targets.
    /// By default, HTTP keep-alive is enabled, so TCP connections to scrape targets
    /// could be re-used.
    /// See https://docs.victoriametrics.com/vmagent.html#scrape_config-enhancements
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable_keep_alive: Option<bool>,
    /// Headers allows sending custom headers to scrape targets
    /// must be in of semicolon separated header with it's value
    /// eg:
    /// headerName: headerValue
    /// vmagent supports since 1.79.0 version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// deprecated since [v1.85](https://github.com/VictoriaMetrics/VictoriaMetrics/releases/tag/v1.85.0), will be removed in next release
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metric_relabel_debug: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub no_stale_markers: Option<bool>,
    /// ProxyClientConfig configures proxy auth settings for scraping
    /// See feature description https://docs.victoriametrics.com/vmagent.html#scraping-targets-via-a-proxy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_client_config: Option<VMProbeVmScrapeParamsProxyClientConfig>,
    /// deprecated since [v1.85](https://github.com/VictoriaMetrics/VictoriaMetrics/releases/tag/v1.85.0), will be removed in next release
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relabel_debug: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_align_interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_offset: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stream_parse: Option<bool>,
}

/// ProxyClientConfig configures proxy auth settings for scraping
/// See feature description https://docs.victoriametrics.com/vmagent.html#scraping-targets-via-a-proxy
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfig {
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMProbeVmScrapeParamsProxyClientConfigBasicAuth>,
    /// SecretKeySelector selects a key of a Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token: Option<VMProbeVmScrapeParamsProxyClientConfigBearerToken>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    /// TLSConfig specifies TLSConfig configuration parameters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<VMProbeVmScrapeParamsProxyClientConfigTlsConfig>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMProbeVmScrapeParamsProxyClientConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMProbeVmScrapeParamsProxyClientConfigBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigBearerToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLSConfig specifies TLSConfig configuration parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMProbeVmScrapeParamsProxyClientConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMProbeVmScrapeParamsProxyClientConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMProbeVmScrapeParamsProxyClientConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMProbeVmScrapeParamsProxyClientConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMProbeVmScrapeParamsProxyClientConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMProbeVmScrapeParamsProxyClientConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMProbeVmScrapeParamsProxyClientConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeVmScrapeParamsProxyClientConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// VMProbeStatus defines the observed state of VMProbe
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMProbeStatus {
}

