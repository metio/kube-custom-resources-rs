// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/VictoriaMetrics/operator/operator.victoriametrics.com/v1beta1/vmalertmanagerconfigs.yaml --derive=Default --derive=PartialEq
// kopium version: 0.19.0

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// VMAlertmanagerConfigSpec defines configuration for VMAlertmanagerConfig
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "operator.victoriametrics.com", version = "v1beta1", kind = "VMAlertmanagerConfig", plural = "vmalertmanagerconfigs")]
#[kube(namespaced)]
#[kube(status = "VMAlertmanagerConfigStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct VMAlertmanagerConfigSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "-")]
    pub kopium_dash: Option<String>,
    /// InhibitRules will only apply for alerts matching
    /// the resource's namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inhibit_rules: Option<Vec<VMAlertmanagerConfigInhibitRules>>,
    /// MuteTimeInterval - global mute time
    /// See https://prometheus.io/docs/alerting/latest/configuration/#mute_time_interval
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mute_time_intervals: Option<Vec<VMAlertmanagerConfigMuteTimeIntervals>>,
    /// Receivers defines alert receivers.
    /// without defined Route, receivers will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub receivers: Option<Vec<VMAlertmanagerConfigReceivers>>,
    /// Route definition for alertmanager, may include nested routes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<VMAlertmanagerConfigRoute>,
    /// ParsingError contents error with context if operator was failed to parse json object from kubernetes api server
    /// TimeIntervals modern config option, use it instead of  mute_time_intervals
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time_intervals: Option<Vec<VMAlertmanagerConfigTimeIntervals>>,
}

/// InhibitRule defines an inhibition rule that allows to mute alerts when other
/// alerts are already firing.
/// Note, it doesn't support deprecated alertmanager config options.
/// See https://prometheus.io/docs/alerting/latest/configuration/#inhibit_rule
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigInhibitRules {
    /// Labels that must have an equal value in the source and target alert for
    /// the inhibition to take effect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub equal: Option<Vec<String>>,
    /// SourceMatchers defines a list of matchers for which one or more alerts have
    /// to exist for the inhibition to take effect.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source_matchers: Option<Vec<String>>,
    /// TargetMatchers defines a list of matchers that have to be fulfilled by the target
    /// alerts to be muted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target_matchers: Option<Vec<String>>,
}

/// MuteTimeInterval for alerts
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigMuteTimeIntervals {
    /// Name of interval
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// TimeIntervals interval configuration
    pub time_intervals: Vec<VMAlertmanagerConfigMuteTimeIntervalsTimeIntervals>,
}

/// TimeInterval defines intervals of time
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigMuteTimeIntervalsTimeIntervals {
    /// DayOfMonth defines list of numerical days in the month. Days begin at 1. Negative values are also accepted.
    /// for example, ['1:5', '-3:-1']
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub days_of_month: Option<Vec<String>>,
    /// Location in golang time location form, e.g. UTC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// Months  defines list of calendar months identified by a case-insentive name (e.g. ‘January’) or numeric 1.
    /// For example, ['1:3', 'may:august', 'december']
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub months: Option<Vec<String>>,
    /// Times defines time range for mute
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub times: Option<Vec<VMAlertmanagerConfigMuteTimeIntervalsTimeIntervalsTimes>>,
    /// Weekdays defines list of days of the week, where the week begins on Sunday and ends on Saturday.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weekdays: Option<Vec<String>>,
    /// Years defines numerical list of years, ranges are accepted.
    /// For example, ['2020:2022', '2030']
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub years: Option<Vec<String>>,
}

/// TimeRange  ranges inclusive of the starting time and exclusive of the end time
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigMuteTimeIntervalsTimeIntervalsTimes {
    /// EndTime for example HH:MM
    pub end_time: String,
    /// StartTime for example  HH:MM
    pub start_time: String,
}

/// Receiver defines one or more notification integrations.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceivers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discord_configs: Option<Vec<VMAlertmanagerConfigReceiversDiscordConfigs>>,
    /// EmailConfigs defines email notification configurations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub email_configs: Option<Vec<VMAlertmanagerConfigReceiversEmailConfigs>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub msteams_configs: Option<Vec<VMAlertmanagerConfigReceiversMsteamsConfigs>>,
    /// Name of the receiver. Must be unique across all items from the list.
    pub name: String,
    /// OpsGenieConfigs defines ops genie notification configurations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opsgenie_configs: Option<Vec<VMAlertmanagerConfigReceiversOpsgenieConfigs>>,
    /// PagerDutyConfigs defines pager duty notification configurations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pagerduty_configs: Option<Vec<VMAlertmanagerConfigReceiversPagerdutyConfigs>>,
    /// PushoverConfigs defines push over notification configurations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pushover_configs: Option<Vec<VMAlertmanagerConfigReceiversPushoverConfigs>>,
    /// SlackConfigs defines slack notification configurations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slack_configs: Option<Vec<VMAlertmanagerConfigReceiversSlackConfigs>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sns_configs: Option<Vec<VMAlertmanagerConfigReceiversSnsConfigs>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub telegram_configs: Option<Vec<VMAlertmanagerConfigReceiversTelegramConfigs>>,
    /// VictorOpsConfigs defines victor ops notification configurations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub victorops_configs: Option<Vec<VMAlertmanagerConfigReceiversVictoropsConfigs>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webex_configs: Option<Vec<VMAlertmanagerConfigReceiversWebexConfigs>>,
    /// WebhookConfigs defines webhook notification configurations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webhook_configs: Option<Vec<VMAlertmanagerConfigReceiversWebhookConfigs>>,
    /// WeChatConfigs defines wechat notification configurations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wechat_configs: Option<Vec<VMAlertmanagerConfigReceiversWechatConfigs>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigs {
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfig>,
    /// The message body template
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    /// The message title template
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// The discord webhook URL
    /// one of `urlSecret` and `url` must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webhook_url: Option<String>,
    /// URLSecret defines secret name and key at the CRD namespace.
    /// It must contain the webhook URL.
    /// one of `urlSecret` and `url` must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webhook_url_secret: Option<VMAlertmanagerConfigReceiversDiscordConfigsWebhookUrlSecret>,
}

/// HTTP client configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfig {
    /// TODO oAuth2 support
    /// BasicAuth for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuth>,
    /// BearerTokenFile defines filename for bearer token, it must be mounted to pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    /// The secret's key that contains the bearer token
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_secret: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigBearerTokenSecret>,
    /// Optional proxy URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// TLS configuration for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfig>,
}

/// TODO oAuth2 support
/// BasicAuth for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret's key that contains the bearer token
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// URLSecret defines secret name and key at the CRD namespace.
/// It must contain the webhook URL.
/// one of `urlSecret` and `url` must be defined.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversDiscordConfigsWebhookUrlSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EmailConfig configures notifications via Email.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigs {
    /// The identity to use for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_identity: Option<String>,
    /// AuthPassword defines secret name and key at CRD namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_password: Option<VMAlertmanagerConfigReceiversEmailConfigsAuthPassword>,
    /// AuthSecret defines secrent name and key at CRD namespace.
    /// It must contain the CRAM-MD5 secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_secret: Option<VMAlertmanagerConfigReceiversEmailConfigsAuthSecret>,
    /// The username to use for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_username: Option<String>,
    /// The sender address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Further headers email header key/value pairs. Overrides any headers
    /// previously set by the notification implementation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, String>>,
    /// The hostname to identify to the SMTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hello: Option<String>,
    /// The HTML body of the email notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html: Option<String>,
    /// The SMTP TLS requirement.
    /// Note that Go does not support unencrypted connections to remote SMTP endpoints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub require_tls: Option<bool>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    /// The SMTP host through which emails are sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub smarthost: Option<String>,
    /// The text body of the email notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// TLS configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<VMAlertmanagerConfigReceiversEmailConfigsTlsConfig>,
    /// The email address to send notifications to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// AuthPassword defines secret name and key at CRD namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// AuthSecret defines secrent name and key at CRD namespace.
/// It must contain the CRAM-MD5 secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsAuthSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMAlertmanagerConfigReceiversEmailConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversEmailConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigs {
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfig>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    /// The text body of the teams notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// The title of the teams notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// The incoming webhook URL
    /// one of `urlSecret` and `url` must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webhook_url: Option<String>,
    /// URLSecret defines secret name and key at the CRD namespace.
    /// It must contain the webhook URL.
    /// one of `urlSecret` and `url` must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webhook_url_secret: Option<VMAlertmanagerConfigReceiversMsteamsConfigsWebhookUrlSecret>,
}

/// HTTP client configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfig {
    /// TODO oAuth2 support
    /// BasicAuth for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuth>,
    /// BearerTokenFile defines filename for bearer token, it must be mounted to pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    /// The secret's key that contains the bearer token
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_secret: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigBearerTokenSecret>,
    /// Optional proxy URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// TLS configuration for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfig>,
}

/// TODO oAuth2 support
/// BasicAuth for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret's key that contains the bearer token
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// URLSecret defines secret name and key at the CRD namespace.
/// It must contain the webhook URL.
/// one of `urlSecret` and `url` must be defined.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversMsteamsConfigsWebhookUrlSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpsGenieConfig configures notifications via OpsGenie.
/// See https://prometheus.io/docs/alerting/latest/configuration/#opsgenie_config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversOpsgenieConfigs {
    /// Comma separated list of actions that will be available for the alert.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<String>,
    /// The URL to send OpsGenie API requests to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<String>,
    /// The secret's key that contains the OpsGenie API key.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_key: Option<VMAlertmanagerConfigReceiversOpsgenieConfigsApiKey>,
    /// Description of the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// A set of arbitrary key/value pairs that provide further detail about the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details: Option<BTreeMap<String, String>>,
    /// Optional field that can be used to specify which domain alert is related to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity: Option<String>,
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<BTreeMap<String, serde_json::Value>>,
    /// Alert text limited to 130 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Additional alert note.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    /// Priority level of alert. Possible values are P1, P2, P3, P4, and P5.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<String>,
    /// List of responders responsible for notifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub responders: Option<Vec<VMAlertmanagerConfigReceiversOpsgenieConfigsResponders>>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    /// Backlink to the sender of the notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// Comma separated list of tags attached to the notifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<String>,
    /// Whether to update message and description of the alert in OpsGenie if it already exists
    /// By default, the alert is never updated in OpsGenie, the new message only appears in activity log.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub update_alerts: Option<bool>,
}

/// The secret's key that contains the OpsGenie API key.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversOpsgenieConfigsApiKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpsGenieConfigResponder defines a responder to an incident.
/// One of `id`, `name` or `username` has to be defined.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversOpsgenieConfigsResponders {
    /// ID of the responder.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Name of the responder.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Type of responder.
    #[serde(rename = "type")]
    pub r#type: String,
    /// Username of the responder.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// PagerDutyConfig configures notifications via PagerDuty.
/// See https://prometheus.io/docs/alerting/latest/configuration/#pagerduty_config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversPagerdutyConfigs {
    /// The class/type of the event.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class: Option<String>,
    /// Client identification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client: Option<String>,
    /// Backlink to the sender of notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_url: Option<String>,
    /// The part or component of the affected system that is broken.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub component: Option<String>,
    /// Description of the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Arbitrary key/value pairs that provide further detail about the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details: Option<BTreeMap<String, String>>,
    /// A cluster or grouping of sources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<BTreeMap<String, serde_json::Value>>,
    /// Images to attach to the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub images: Option<Vec<VMAlertmanagerConfigReceiversPagerdutyConfigsImages>>,
    /// Links to attach to the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<VMAlertmanagerConfigReceiversPagerdutyConfigsLinks>>,
    /// The secret's key that contains the PagerDuty integration key (when using
    /// Events API v2). Either this field or `serviceKey` needs to be defined.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routing_key: Option<VMAlertmanagerConfigReceiversPagerdutyConfigsRoutingKey>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    /// The secret's key that contains the PagerDuty service key (when using
    /// integration type "Prometheus"). Either this field or `routingKey` needs to
    /// be defined.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_key: Option<VMAlertmanagerConfigReceiversPagerdutyConfigsServiceKey>,
    /// Severity of the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
    /// The URL to send requests to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// ImageConfig is used to attach images to the incident.
/// See https://developer.pagerduty.com/docs/ZG9jOjExMDI5NTgx-send-an-alert-event#the-images-property
/// for more information.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversPagerdutyConfigsImages {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alt: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub href: Option<String>,
    pub source: String,
}

/// LinkConfig is used to attach text links to the incident.
/// See https://developer.pagerduty.com/docs/ZG9jOjExMDI5NTgx-send-an-alert-event#the-links-property
/// for more information.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversPagerdutyConfigsLinks {
    pub href: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}

/// The secret's key that contains the PagerDuty integration key (when using
/// Events API v2). Either this field or `serviceKey` needs to be defined.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversPagerdutyConfigsRoutingKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret's key that contains the PagerDuty service key (when using
/// integration type "Prometheus"). Either this field or `routingKey` needs to
/// be defined.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversPagerdutyConfigsServiceKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// PushoverConfig configures notifications via Pushover.
/// See https://prometheus.io/docs/alerting/latest/configuration/#pushover_config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversPushoverConfigs {
    /// How long your notification will continue to be retried for, unless the user
    /// acknowledges the notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expire: Option<String>,
    /// Whether notification message is HTML or plain text.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html: Option<bool>,
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<BTreeMap<String, serde_json::Value>>,
    /// Notification message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Priority, see https://pushover.net/api#priority
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<String>,
    /// How often the Pushover servers will send the same notification to the user.
    /// Must be at least 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry: Option<String>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    /// The name of one of the sounds supported by device clients to override the user's default sound choice
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sound: Option<String>,
    /// Notification title.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// The secret's key that contains the registered application’s API token, see https://pushover.net/apps.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<VMAlertmanagerConfigReceiversPushoverConfigsToken>,
    /// A supplementary URL shown alongside the message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// A title for supplementary URL, otherwise just the URL is shown
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url_title: Option<String>,
    /// The secret's key that contains the recipient user’s user key.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user_key: Option<VMAlertmanagerConfigReceiversPushoverConfigsUserKey>,
}

/// The secret's key that contains the registered application’s API token, see https://pushover.net/apps.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversPushoverConfigsToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret's key that contains the recipient user’s user key.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversPushoverConfigsUserKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SlackConfig configures notifications via Slack.
/// See https://prometheus.io/docs/alerting/latest/configuration/#slack_config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSlackConfigs {
    /// A list of Slack actions that are sent with each notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<VMAlertmanagerConfigReceiversSlackConfigsActions>>,
    /// The secret's key that contains the Slack webhook URL.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_url: Option<VMAlertmanagerConfigReceiversSlackConfigsApiUrl>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callback_id: Option<String>,
    /// The channel or user to send notifications to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fallback: Option<String>,
    /// A list of Slack fields that are sent with each notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<VMAlertmanagerConfigReceiversSlackConfigsFields>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub footer: Option<String>,
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<BTreeMap<String, serde_json::Value>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icon_emoji: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icon_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub link_names: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mrkdwn_in: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pretext: Option<String>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short_fields: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thumb_url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title_link: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// SlackAction configures a single Slack action that is sent with each
/// notification.
/// See https://api.slack.com/docs/message-attachments#action_fields and
/// https://api.slack.com/docs/message-buttons for more information.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSlackConfigsActions {
    /// SlackConfirmationField protect users from destructive actions or
    /// particularly distinguished decisions by asking them to confirm their button
    /// click one more time.
    /// See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub confirm: Option<VMAlertmanagerConfigReceiversSlackConfigsActionsConfirm>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<String>,
    pub text: String,
    #[serde(rename = "type")]
    pub r#type: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// SlackConfirmationField protect users from destructive actions or
/// particularly distinguished decisions by asking them to confirm their button
/// click one more time.
/// See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields
/// for more information.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSlackConfigsActionsConfirm {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dismiss_text: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ok_text: Option<String>,
    pub text: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}

/// The secret's key that contains the Slack webhook URL.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSlackConfigsApiUrl {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SlackField configures a single Slack field that is sent with each notification.
/// See https://api.slack.com/docs/message-attachments#fields for more information.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSlackConfigsFields {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short: Option<bool>,
    pub title: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigs {
    /// The api URL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_url: Option<String>,
    /// SNS message attributes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attributes: Option<BTreeMap<String, String>>,
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfig>,
    /// The message content of the SNS notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Phone number if message is delivered via SMS
    /// Specify this, topic_arn or target_arn
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phone_number: Option<String>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    /// Configure the AWS Signature Verification 4 signing process
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sigv4: Option<VMAlertmanagerConfigReceiversSnsConfigsSigv4>,
    /// The subject line if message is delivered to an email endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<String>,
    /// Mobile platform endpoint ARN if message is delivered via mobile notifications
    /// Specify this, topic_arn or phone_number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target_arn: Option<String>,
    /// SNS topic ARN, either specify this, phone_number or target_arn
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic_arn: Option<String>,
}

/// HTTP client configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfig {
    /// TODO oAuth2 support
    /// BasicAuth for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuth>,
    /// BearerTokenFile defines filename for bearer token, it must be mounted to pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    /// The secret's key that contains the bearer token
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_secret: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigBearerTokenSecret>,
    /// Optional proxy URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// TLS configuration for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfig>,
}

/// TODO oAuth2 support
/// BasicAuth for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret's key that contains the bearer token
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Configure the AWS Signature Verification 4 signing process
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsSigv4 {
    /// The AWS API keys. Both access_key and secret_key must be supplied or both must be blank.
    /// If blank the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` are used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub access_key: Option<String>,
    /// secret key selector to get the keys from a Kubernetes Secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub access_key_selector: Option<VMAlertmanagerConfigReceiversSnsConfigsSigv4AccessKeySelector>,
    /// Named AWS profile used to authenticate
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profile: Option<String>,
    /// AWS region, if blank the region from the default credentials chain is used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// AWS Role ARN, an alternative to using AWS API keys
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// secret key selector to get the keys from a Kubernetes Secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_key_selector: Option<VMAlertmanagerConfigReceiversSnsConfigsSigv4SecretKeySelector>,
}

/// secret key selector to get the keys from a Kubernetes Secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsSigv4AccessKeySelector {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret key selector to get the keys from a Kubernetes Secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversSnsConfigsSigv4SecretKeySelector {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversTelegramConfigs {
    /// APIUrl the Telegram API URL i.e. https://api.telegram.org.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_url: Option<String>,
    /// BotToken token for the bot
    /// https://core.telegram.org/bots/api
    pub bot_token: VMAlertmanagerConfigReceiversTelegramConfigsBotToken,
    /// ChatID is ID of the chat where to send the messages.
    pub chat_id: i64,
    /// DisableNotifications
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable_notifications: Option<bool>,
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<BTreeMap<String, serde_json::Value>>,
    /// Message is templated message
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// ParseMode for telegram message,
    /// supported values are MarkdownV2, Markdown, Markdown and empty string for plain text.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse_mode: Option<String>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
}

/// BotToken token for the bot
/// https://core.telegram.org/bots/api
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversTelegramConfigsBotToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// VictorOpsConfig configures notifications via VictorOps.
/// See https://prometheus.io/docs/alerting/latest/configuration/#victorops_config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigs {
    /// The secret's key that contains the API key to use when talking to the VictorOps API.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_key: Option<VMAlertmanagerConfigReceiversVictoropsConfigsApiKey>,
    /// The VictorOps API URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_url: Option<String>,
    /// Adds optional custom fields
    /// https://github.com/prometheus/alertmanager/blob/v0.24.0/config/notifiers.go#L537
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_fields: Option<BTreeMap<String, String>>,
    /// Contains summary of the alerted problem.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity_display_name: Option<String>,
    /// The HTTP client's configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfig>,
    /// Describes the behavior of the alert (CRITICAL, WARNING, INFO).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message_type: Option<String>,
    /// The monitoring tool the state message is from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monitoring_tool: Option<String>,
    /// A key used to map the alert to a team.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routing_key: Option<String>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    /// Contains long explanation of the alerted problem.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state_message: Option<String>,
}

/// The secret's key that contains the API key to use when talking to the VictorOps API.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsApiKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The HTTP client's configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfig {
    /// TODO oAuth2 support
    /// BasicAuth for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuth>,
    /// BearerTokenFile defines filename for bearer token, it must be mounted to pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    /// The secret's key that contains the bearer token
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_secret: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigBearerTokenSecret>,
    /// Optional proxy URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// TLS configuration for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfig>,
}

/// TODO oAuth2 support
/// BasicAuth for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret's key that contains the bearer token
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigs {
    /// The Webex Teams API URL, i.e. https://webexapis.com/v1/messages
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_url: Option<String>,
    /// HTTP client configuration. You must use this configuration to supply the bot token as part of the HTTP `Authorization` header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfig>,
    /// The message body template
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// The ID of the Webex Teams room where to send the messages
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub room_id: Option<String>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
}

/// HTTP client configuration. You must use this configuration to supply the bot token as part of the HTTP `Authorization` header.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfig {
    /// TODO oAuth2 support
    /// BasicAuth for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuth>,
    /// BearerTokenFile defines filename for bearer token, it must be mounted to pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    /// The secret's key that contains the bearer token
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_secret: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigBearerTokenSecret>,
    /// Optional proxy URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// TLS configuration for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfig>,
}

/// TODO oAuth2 support
/// BasicAuth for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret's key that contains the bearer token
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// WebhookConfig configures notifications via a generic receiver supporting the webhook payload.
/// See https://prometheus.io/docs/alerting/latest/configuration/#webhook_config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebhookConfigs {
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<BTreeMap<String, serde_json::Value>>,
    /// Maximum number of alerts to be sent per webhook message. When 0, all alerts are included.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_alerts: Option<i32>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    /// URL to send requests to,
    /// one of `urlSecret` and `url` must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// URLSecret defines secret name and key at the CRD namespace.
    /// It must contain the webhook URL.
    /// one of `urlSecret` and `url` must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url_secret: Option<VMAlertmanagerConfigReceiversWebhookConfigsUrlSecret>,
}

/// URLSecret defines secret name and key at the CRD namespace.
/// It must contain the webhook URL.
/// one of `urlSecret` and `url` must be defined.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWebhookConfigsUrlSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// WeChatConfig configures notifications via WeChat.
/// See https://prometheus.io/docs/alerting/latest/configuration/#wechat_config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub agent_id: Option<String>,
    /// The secret's key that contains the WeChat API key.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_secret: Option<VMAlertmanagerConfigReceiversWechatConfigsApiSecret>,
    /// The WeChat API URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_url: Option<String>,
    /// The corp id for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub corp_id: Option<String>,
    /// HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_config: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfig>,
    /// API request data as defined by the WeChat API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message_type: Option<String>,
    /// SendResolved controls notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub send_resolved: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to_party: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to_tag: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to_user: Option<String>,
}

/// The secret's key that contains the WeChat API key.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsApiSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// HTTP client configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfig {
    /// TODO oAuth2 support
    /// BasicAuth for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuth>,
    /// BearerTokenFile defines filename for bearer token, it must be mounted to pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    /// The secret's key that contains the bearer token
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_secret: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigBearerTokenSecret>,
    /// Optional proxy URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// TLS configuration for the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfig>,
}

/// TODO oAuth2 support
/// BasicAuth for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuth {
    /// The secret in the service scrape namespace that contains the password
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// The secret in the service scrape namespace that contains the username
    /// for authentication.
    /// It must be at them same namespace as CRD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuthUsername>,
}

/// The secret in the service scrape namespace that contains the password
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service scrape namespace that contains the username
/// for authentication.
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret's key that contains the bearer token
/// It must be at them same namespace as CRD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration for the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfig {
    /// Stuct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Stuct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Route definition for alertmanager, may include nested routes.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigRoute {
    /// ActiveTimeIntervals Times when the route should be active
    /// These must match the name at time_intervals
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active_time_intervals: Option<Vec<String>>,
    /// Continue indicating whether an alert should continue matching subsequent
    /// sibling nodes. It will always be true for the first-level route if disableRouteContinueEnforce for vmalertmanager not set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continue")]
    pub r#continue: Option<bool>,
    /// List of labels to group by.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group_by: Option<Vec<String>>,
    /// How long to wait before sending an updated notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group_interval: Option<String>,
    /// How long to wait before sending the initial notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group_wait: Option<String>,
    /// List of matchers that the alert’s labels should match. For the first
    /// level route, the operator adds a namespace: "CRD_NS" matcher.
    /// https://prometheus.io/docs/alerting/latest/configuration/#matcher
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matchers: Option<Vec<String>>,
    /// MuteTimeIntervals for alerts
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mute_time_intervals: Option<Vec<String>>,
    /// Name of the receiver for this route.
    pub receiver: String,
    /// How long to wait before repeating the last notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repeat_interval: Option<String>,
    /// Child routes.
    /// https://prometheus.io/docs/alerting/latest/configuration/#route
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routes: Option<Vec<BTreeMap<String, serde_json::Value>>>,
}

/// MuteTimeInterval for alerts
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigTimeIntervals {
    /// Name of interval
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// TimeIntervals interval configuration
    pub time_intervals: Vec<VMAlertmanagerConfigTimeIntervalsTimeIntervals>,
}

/// TimeInterval defines intervals of time
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigTimeIntervalsTimeIntervals {
    /// DayOfMonth defines list of numerical days in the month. Days begin at 1. Negative values are also accepted.
    /// for example, ['1:5', '-3:-1']
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub days_of_month: Option<Vec<String>>,
    /// Location in golang time location form, e.g. UTC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// Months  defines list of calendar months identified by a case-insentive name (e.g. ‘January’) or numeric 1.
    /// For example, ['1:3', 'may:august', 'december']
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub months: Option<Vec<String>>,
    /// Times defines time range for mute
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub times: Option<Vec<VMAlertmanagerConfigTimeIntervalsTimeIntervalsTimes>>,
    /// Weekdays defines list of days of the week, where the week begins on Sunday and ends on Saturday.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weekdays: Option<Vec<String>>,
    /// Years defines numerical list of years, ranges are accepted.
    /// For example, ['2020:2022', '2030']
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub years: Option<Vec<String>>,
}

/// TimeRange  ranges inclusive of the starting time and exclusive of the end time
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigTimeIntervalsTimeIntervalsTimes {
    /// EndTime for example HH:MM
    pub end_time: String,
    /// StartTime for example  HH:MM
    pub start_time: String,
}

/// VMAlertmanagerConfigStatus defines the observed state of VMAlertmanagerConfig
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMAlertmanagerConfigStatus {
    /// ErrorReason describes validation or any other errors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

