// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/GoogleCloudPlatform/spark-on-k8s-operator/sparkoperator.k8s.io/v1beta2/scheduledsparkapplications.yaml --derive=PartialEq
// kopium version: 0.16.1

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "sparkoperator.k8s.io", version = "v1beta2", kind = "ScheduledSparkApplication", plural = "scheduledsparkapplications")]
#[kube(namespaced)]
#[kube(status = "ScheduledSparkApplicationStatus")]
#[kube(schema = "disabled")]
pub struct ScheduledSparkApplicationSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "concurrencyPolicy")]
    pub concurrency_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failedRunHistoryLimit")]
    pub failed_run_history_limit: Option<i32>,
    pub schedule: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successfulRunHistoryLimit")]
    pub successful_run_history_limit: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suspend: Option<bool>,
    pub template: ScheduledSparkApplicationTemplate,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchScheduler")]
    pub batch_scheduler: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSchedulerOptions")]
    pub batch_scheduler_options: Option<ScheduledSparkApplicationTemplateBatchSchedulerOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deps: Option<ScheduledSparkApplicationTemplateDeps>,
    pub driver: ScheduledSparkApplicationTemplateDriver,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicAllocation")]
    pub dynamic_allocation: Option<ScheduledSparkApplicationTemplateDynamicAllocation>,
    pub executor: ScheduledSparkApplicationTemplateExecutor,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureRetries")]
    pub failure_retries: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hadoopConf")]
    pub hadoop_conf: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hadoopConfigMap")]
    pub hadoop_config_map: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecrets")]
    pub image_pull_secrets: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mainApplicationFile")]
    pub main_application_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mainClass")]
    pub main_class: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryOverheadFactor")]
    pub memory_overhead_factor: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<ScheduledSparkApplicationTemplateMode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monitoring: Option<ScheduledSparkApplicationTemplateMonitoring>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUser")]
    pub proxy_user: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pythonVersion")]
    pub python_version: Option<ScheduledSparkApplicationTemplatePythonVersion>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<ScheduledSparkApplicationTemplateRestartPolicy>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sparkConf")]
    pub spark_conf: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sparkConfigMap")]
    pub spark_config_map: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sparkUIOptions")]
    pub spark_ui_options: Option<ScheduledSparkApplicationTemplateSparkUiOptions>,
    #[serde(rename = "sparkVersion")]
    pub spark_version: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeToLiveSeconds")]
    pub time_to_live_seconds: Option<i64>,
    #[serde(rename = "type")]
    pub r#type: ScheduledSparkApplicationTemplateType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<ScheduledSparkApplicationTemplateVolumes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateBatchSchedulerOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queue: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDeps {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludePackages")]
    pub exclude_packages: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jars: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub packages: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pyFiles")]
    pub py_files: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repositories: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriver {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<ScheduledSparkApplicationTemplateDriverAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMaps")]
    pub config_maps: Option<Vec<ScheduledSparkApplicationTemplateDriverConfigMaps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreLimit")]
    pub core_limit: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreRequest")]
    pub core_request: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cores: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<ScheduledSparkApplicationTemplateDriverDnsConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ScheduledSparkApplicationTemplateDriverEnv>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ScheduledSparkApplicationTemplateDriverEnvFrom>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envSecretKeyRefs")]
    pub env_secret_key_refs: Option<BTreeMap<String, ScheduledSparkApplicationTemplateDriverEnvSecretKeyRefs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envVars")]
    pub env_vars: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gpu: Option<ScheduledSparkApplicationTemplateDriverGpu>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostAliases")]
    pub host_aliases: Option<Vec<ScheduledSparkApplicationTemplateDriverHostAliases>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainers>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "javaOptions")]
    pub java_options: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesMaster")]
    pub kubernetes_master: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ScheduledSparkApplicationTemplateDriverLifecycle>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryOverhead")]
    pub memory_overhead: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podName")]
    pub pod_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podSecurityContext")]
    pub pod_security_context: Option<ScheduledSparkApplicationTemplateDriverPodSecurityContext>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<ScheduledSparkApplicationTemplateDriverSecrets>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ScheduledSparkApplicationTemplateDriverSecurityContext>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAnnotations")]
    pub service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shareProcessNamespace")]
    pub share_process_namespace: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecars>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<ScheduledSparkApplicationTemplateDriverTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ScheduledSparkApplicationTemplateDriverVolumeMounts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<ScheduledSparkApplicationTemplateDriverAffinityNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<ScheduledSparkApplicationTemplateDriverAffinityPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: ScheduledSparkApplicationTemplateDriverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ScheduledSparkApplicationTemplateDriverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ScheduledSparkApplicationTemplateDriverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverConfigMaps {
    pub name: String,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverDnsConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nameservers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<ScheduledSparkApplicationTemplateDriverDnsConfigOptions>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub searches: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverDnsConfigOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnv {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ScheduledSparkApplicationTemplateDriverEnvValueFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnvValueFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ScheduledSparkApplicationTemplateDriverEnvValueFromConfigMapKeyRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ScheduledSparkApplicationTemplateDriverEnvValueFromFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ScheduledSparkApplicationTemplateDriverEnvValueFromResourceFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ScheduledSparkApplicationTemplateDriverEnvValueFromSecretKeyRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnvValueFromConfigMapKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnvValueFromFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnvValueFromResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnvValueFromSecretKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnvFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ScheduledSparkApplicationTemplateDriverEnvFromConfigMapRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateDriverEnvFromSecretRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnvFromConfigMapRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnvFromSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverEnvSecretKeyRefs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverGpu {
    pub name: String,
    pub quantity: i64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverHostAliases {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersEnv>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersEnvFrom>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ScheduledSparkApplicationTemplateDriverInitContainersLifecycle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbe>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ScheduledSparkApplicationTemplateDriverInitContainersResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ScheduledSparkApplicationTemplateDriverInitContainersSecurityContext>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ScheduledSparkApplicationTemplateDriverInitContainersStartupProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersVolumeDevices>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersVolumeMounts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersEnv {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFromConfigMapKeyRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFromFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFromResourceFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFromSecretKeyRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFromConfigMapKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFromFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFromResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersEnvValueFromSecretKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersEnvFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ScheduledSparkApplicationTemplateDriverInitContainersEnvFromConfigMapRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateDriverInitContainersEnvFromSecretRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersEnvFromConfigMapRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersEnvFromSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecycle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStart>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStop>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStart {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStartExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStartHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStartTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStartExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStartHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStartHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStartHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePostStartTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStop {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStopExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStopHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStopTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStopExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStopHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStopHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStopHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLifecyclePreStopTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersLivenessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersPorts {
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub protocol: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersReadinessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersSecurityContext {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ScheduledSparkApplicationTemplateDriverInitContainersSecurityContextCapabilities>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ScheduledSparkApplicationTemplateDriverInitContainersSecurityContextSeLinuxOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ScheduledSparkApplicationTemplateDriverInitContainersSecurityContextSeccompProfile>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ScheduledSparkApplicationTemplateDriverInitContainersSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersSecurityContextCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersSecurityContextSeccompProfile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersSecurityContextWindowsOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersStartupProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverInitContainersStartupProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverInitContainersStartupProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverInitContainersStartupProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersStartupProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersStartupProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverInitContainersStartupProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersStartupProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersStartupProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersVolumeDevices {
    #[serde(rename = "devicePath")]
    pub device_path: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverInitContainersVolumeMounts {
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecycle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ScheduledSparkApplicationTemplateDriverLifecyclePostStart>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ScheduledSparkApplicationTemplateDriverLifecyclePreStop>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePostStart {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverLifecyclePostStartExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverLifecyclePostStartHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverLifecyclePostStartTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePostStartExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePostStartHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverLifecyclePostStartHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePostStartHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePostStartTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePreStop {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverLifecyclePreStopExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverLifecyclePreStopHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverLifecyclePreStopTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePreStopExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePreStopHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverLifecyclePreStopHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePreStopHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverLifecyclePreStopTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverPodSecurityContext {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsGroup")]
    pub fs_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ScheduledSparkApplicationTemplateDriverPodSecurityContextSeLinuxOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "supplementalGroups")]
    pub supplemental_groups: Option<Vec<i64>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sysctls: Option<Vec<ScheduledSparkApplicationTemplateDriverPodSecurityContextSysctls>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ScheduledSparkApplicationTemplateDriverPodSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverPodSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverPodSecurityContextSysctls {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverPodSecurityContextWindowsOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSecrets {
    pub name: String,
    pub path: String,
    #[serde(rename = "secretType")]
    pub secret_type: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSecurityContext {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ScheduledSparkApplicationTemplateDriverSecurityContextCapabilities>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ScheduledSparkApplicationTemplateDriverSecurityContextSeLinuxOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ScheduledSparkApplicationTemplateDriverSecurityContextSeccompProfile>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ScheduledSparkApplicationTemplateDriverSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSecurityContextCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSecurityContextSeccompProfile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSecurityContextWindowsOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecars {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsEnv>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsEnvFrom>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ScheduledSparkApplicationTemplateDriverSidecarsLifecycle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbe>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ScheduledSparkApplicationTemplateDriverSidecarsResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ScheduledSparkApplicationTemplateDriverSidecarsSecurityContext>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ScheduledSparkApplicationTemplateDriverSidecarsStartupProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsVolumeDevices>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsVolumeMounts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsEnv {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFromConfigMapKeyRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFromFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFromResourceFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFromSecretKeyRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFromConfigMapKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFromFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFromResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsEnvValueFromSecretKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsEnvFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ScheduledSparkApplicationTemplateDriverSidecarsEnvFromConfigMapRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateDriverSidecarsEnvFromSecretRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsEnvFromConfigMapRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsEnvFromSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecycle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStart>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStop>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStart {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStartExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStartHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStartTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStartExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStartHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStartHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStartHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePostStartTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStop {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStopExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStopHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStopTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStopExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStopHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStopHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStopHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLifecyclePreStopTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsLivenessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsPorts {
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub protocol: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsReadinessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsSecurityContext {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ScheduledSparkApplicationTemplateDriverSidecarsSecurityContextCapabilities>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ScheduledSparkApplicationTemplateDriverSidecarsSecurityContextSeLinuxOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ScheduledSparkApplicationTemplateDriverSidecarsSecurityContextSeccompProfile>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ScheduledSparkApplicationTemplateDriverSidecarsSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsSecurityContextCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsSecurityContextSeccompProfile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsSecurityContextWindowsOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsStartupProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateDriverSidecarsStartupProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateDriverSidecarsStartupProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateDriverSidecarsStartupProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsStartupProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsStartupProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateDriverSidecarsStartupProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsStartupProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsStartupProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsVolumeDevices {
    #[serde(rename = "devicePath")]
    pub device_path: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverSidecarsVolumeMounts {
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDriverVolumeMounts {
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateDynamicAllocation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialExecutors")]
    pub initial_executors: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxExecutors")]
    pub max_executors: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minExecutors")]
    pub min_executors: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shuffleTrackingTimeout")]
    pub shuffle_tracking_timeout: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutor {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<ScheduledSparkApplicationTemplateExecutorAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMaps")]
    pub config_maps: Option<Vec<ScheduledSparkApplicationTemplateExecutorConfigMaps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreLimit")]
    pub core_limit: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreRequest")]
    pub core_request: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cores: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deleteOnTermination")]
    pub delete_on_termination: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<ScheduledSparkApplicationTemplateExecutorDnsConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ScheduledSparkApplicationTemplateExecutorEnv>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ScheduledSparkApplicationTemplateExecutorEnvFrom>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envSecretKeyRefs")]
    pub env_secret_key_refs: Option<BTreeMap<String, ScheduledSparkApplicationTemplateExecutorEnvSecretKeyRefs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envVars")]
    pub env_vars: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gpu: Option<ScheduledSparkApplicationTemplateExecutorGpu>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostAliases")]
    pub host_aliases: Option<Vec<ScheduledSparkApplicationTemplateExecutorHostAliases>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainers>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "javaOptions")]
    pub java_options: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryOverhead")]
    pub memory_overhead: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podSecurityContext")]
    pub pod_security_context: Option<ScheduledSparkApplicationTemplateExecutorPodSecurityContext>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<ScheduledSparkApplicationTemplateExecutorSecrets>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ScheduledSparkApplicationTemplateExecutorSecurityContext>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shareProcessNamespace")]
    pub share_process_namespace: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecars>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<ScheduledSparkApplicationTemplateExecutorTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ScheduledSparkApplicationTemplateExecutorVolumeMounts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<ScheduledSparkApplicationTemplateExecutorAffinityPodAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorConfigMaps {
    pub name: String,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorDnsConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nameservers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<ScheduledSparkApplicationTemplateExecutorDnsConfigOptions>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub searches: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorDnsConfigOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnv {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ScheduledSparkApplicationTemplateExecutorEnvValueFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnvValueFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ScheduledSparkApplicationTemplateExecutorEnvValueFromConfigMapKeyRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ScheduledSparkApplicationTemplateExecutorEnvValueFromFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ScheduledSparkApplicationTemplateExecutorEnvValueFromResourceFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ScheduledSparkApplicationTemplateExecutorEnvValueFromSecretKeyRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnvValueFromConfigMapKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnvValueFromFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnvValueFromResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnvValueFromSecretKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnvFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ScheduledSparkApplicationTemplateExecutorEnvFromConfigMapRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateExecutorEnvFromSecretRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnvFromConfigMapRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnvFromSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorEnvSecretKeyRefs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorGpu {
    pub name: String,
    pub quantity: i64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorHostAliases {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersEnv>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersEnvFrom>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLifecycle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbe>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ScheduledSparkApplicationTemplateExecutorInitContainersResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContext>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersVolumeDevices>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersVolumeMounts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersEnv {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFromConfigMapKeyRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFromFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFromResourceFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFromSecretKeyRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFromConfigMapKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFromFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFromResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersEnvValueFromSecretKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersEnvFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ScheduledSparkApplicationTemplateExecutorInitContainersEnvFromConfigMapRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateExecutorInitContainersEnvFromSecretRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersEnvFromConfigMapRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersEnvFromSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecycle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStart>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStop>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStart {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStartExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStartHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStartTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStartExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStartHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStartHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStartHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePostStartTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStop {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStopExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStopHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStopTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStopExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStopHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStopHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStopHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLifecyclePreStopTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersLivenessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersPorts {
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub protocol: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersReadinessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContext {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContextCapabilities>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContextSeLinuxOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContextSeccompProfile>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContextCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContextSeccompProfile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersSecurityContextWindowsOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersStartupProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersVolumeDevices {
    #[serde(rename = "devicePath")]
    pub device_path: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorInitContainersVolumeMounts {
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorPodSecurityContext {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsGroup")]
    pub fs_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ScheduledSparkApplicationTemplateExecutorPodSecurityContextSeLinuxOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "supplementalGroups")]
    pub supplemental_groups: Option<Vec<i64>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sysctls: Option<Vec<ScheduledSparkApplicationTemplateExecutorPodSecurityContextSysctls>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ScheduledSparkApplicationTemplateExecutorPodSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorPodSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorPodSecurityContextSysctls {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorPodSecurityContextWindowsOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSecrets {
    pub name: String,
    pub path: String,
    #[serde(rename = "secretType")]
    pub secret_type: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSecurityContext {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ScheduledSparkApplicationTemplateExecutorSecurityContextCapabilities>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ScheduledSparkApplicationTemplateExecutorSecurityContextSeLinuxOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ScheduledSparkApplicationTemplateExecutorSecurityContextSeccompProfile>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ScheduledSparkApplicationTemplateExecutorSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSecurityContextCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSecurityContextSeccompProfile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSecurityContextWindowsOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecars {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsEnv>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsEnvFrom>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLifecycle>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbe>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ScheduledSparkApplicationTemplateExecutorSidecarsResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContext>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsVolumeDevices>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsVolumeMounts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsEnv {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFromConfigMapKeyRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFromFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFromResourceFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFromSecretKeyRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFromConfigMapKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFromFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFromResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsEnvValueFromSecretKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsEnvFrom {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ScheduledSparkApplicationTemplateExecutorSidecarsEnvFromConfigMapRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateExecutorSidecarsEnvFromSecretRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsEnvFromConfigMapRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsEnvFromSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecycle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStart>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStop>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStart {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStartExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStartHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStartTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStartExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStartHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStartHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStartHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePostStartTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStop {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStopExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStopHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStopTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStopExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStopHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStopHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStopHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLifecyclePreStopTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsLivenessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsPorts {
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub protocol: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsReadinessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContext {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContextCapabilities>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContextSeLinuxOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContextSeccompProfile>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContextCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContextSeccompProfile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsSecurityContextWindowsOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbeExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbeHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbeTcpSocket>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsStartupProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsVolumeDevices {
    #[serde(rename = "devicePath")]
    pub device_path: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorSidecarsVolumeMounts {
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateExecutorVolumeMounts {
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScheduledSparkApplicationTemplateMode {
    #[serde(rename = "cluster")]
    Cluster,
    #[serde(rename = "client")]
    Client,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateMonitoring {
    #[serde(rename = "exposeDriverMetrics")]
    pub expose_driver_metrics: bool,
    #[serde(rename = "exposeExecutorMetrics")]
    pub expose_executor_metrics: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsProperties")]
    pub metrics_properties: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsPropertiesFile")]
    pub metrics_properties_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prometheus: Option<ScheduledSparkApplicationTemplateMonitoringPrometheus>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateMonitoringPrometheus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configFile")]
    pub config_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<String>,
    #[serde(rename = "jmxExporterJar")]
    pub jmx_exporter_jar: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portName")]
    pub port_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScheduledSparkApplicationTemplatePythonVersion {
    #[serde(rename = "2")]
    r#_2,
    #[serde(rename = "3")]
    r#_3,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateRestartPolicy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onFailureRetries")]
    pub on_failure_retries: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onFailureRetryInterval")]
    pub on_failure_retry_interval: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onSubmissionFailureRetries")]
    pub on_submission_failure_retries: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "onSubmissionFailureRetryInterval")]
    pub on_submission_failure_retry_interval: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ScheduledSparkApplicationTemplateRestartPolicyType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScheduledSparkApplicationTemplateRestartPolicyType {
    Never,
    Always,
    OnFailure,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateSparkUiOptions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressAnnotations")]
    pub ingress_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressTLS")]
    pub ingress_tls: Option<Vec<ScheduledSparkApplicationTemplateSparkUiOptionsIngressTls>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAnnotations")]
    pub service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicePort")]
    pub service_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateSparkUiOptionsIngressTls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScheduledSparkApplicationTemplateType {
    Java,
    Python,
    Scala,
    R,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsElasticBlockStore")]
    pub aws_elastic_block_store: Option<ScheduledSparkApplicationTemplateVolumesAwsElasticBlockStore>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureDisk")]
    pub azure_disk: Option<ScheduledSparkApplicationTemplateVolumesAzureDisk>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureFile")]
    pub azure_file: Option<ScheduledSparkApplicationTemplateVolumesAzureFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephfs: Option<ScheduledSparkApplicationTemplateVolumesCephfs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cinder: Option<ScheduledSparkApplicationTemplateVolumesCinder>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScheduledSparkApplicationTemplateVolumesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<ScheduledSparkApplicationTemplateVolumesCsi>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ScheduledSparkApplicationTemplateVolumesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<ScheduledSparkApplicationTemplateVolumesEmptyDir>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<ScheduledSparkApplicationTemplateVolumesEphemeral>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fc: Option<ScheduledSparkApplicationTemplateVolumesFc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flexVolume")]
    pub flex_volume: Option<ScheduledSparkApplicationTemplateVolumesFlexVolume>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flocker: Option<ScheduledSparkApplicationTemplateVolumesFlocker>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDisk")]
    pub gce_persistent_disk: Option<ScheduledSparkApplicationTemplateVolumesGcePersistentDisk>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitRepo")]
    pub git_repo: Option<ScheduledSparkApplicationTemplateVolumesGitRepo>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glusterfs: Option<ScheduledSparkApplicationTemplateVolumesGlusterfs>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<ScheduledSparkApplicationTemplateVolumesHostPath>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iscsi: Option<ScheduledSparkApplicationTemplateVolumesIscsi>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nfs: Option<ScheduledSparkApplicationTemplateVolumesNfs>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<ScheduledSparkApplicationTemplateVolumesPersistentVolumeClaim>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "photonPersistentDisk")]
    pub photon_persistent_disk: Option<ScheduledSparkApplicationTemplateVolumesPhotonPersistentDisk>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portworxVolume")]
    pub portworx_volume: Option<ScheduledSparkApplicationTemplateVolumesPortworxVolume>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<ScheduledSparkApplicationTemplateVolumesProjected>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quobyte: Option<ScheduledSparkApplicationTemplateVolumesQuobyte>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbd: Option<ScheduledSparkApplicationTemplateVolumesRbd>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scaleIO")]
    pub scale_io: Option<ScheduledSparkApplicationTemplateVolumesScaleIo>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScheduledSparkApplicationTemplateVolumesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storageos: Option<ScheduledSparkApplicationTemplateVolumesStorageos>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vsphereVolume")]
    pub vsphere_volume: Option<ScheduledSparkApplicationTemplateVolumesVsphereVolume>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesAwsElasticBlockStore {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesAzureDisk {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachingMode")]
    pub caching_mode: Option<String>,
    #[serde(rename = "diskName")]
    pub disk_name: String,
    #[serde(rename = "diskURI")]
    pub disk_uri: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesAzureFile {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(rename = "secretName")]
    pub secret_name: String,
    #[serde(rename = "shareName")]
    pub share_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesCephfs {
    pub monitors: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretFile")]
    pub secret_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateVolumesCephfsSecretRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesCephfsSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesCinder {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateVolumesCinderSecretRef>,
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesCinderSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ScheduledSparkApplicationTemplateVolumesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesCsi {
    pub driver: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePublishSecretRef")]
    pub node_publish_secret_ref: Option<ScheduledSparkApplicationTemplateVolumesCsiNodePublishSecretRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributes")]
    pub volume_attributes: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesCsiNodePublishSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ScheduledSparkApplicationTemplateVolumesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ScheduledSparkApplicationTemplateVolumesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ScheduledSparkApplicationTemplateVolumesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesEmptyDir {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesEphemeral {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<ScheduledSparkApplicationTemplateVolumesEphemeralVolumeClaimTemplate>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesEphemeralVolumeClaimTemplate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ScheduledSparkApplicationTemplateVolumesEphemeralVolumeClaimTemplateSpec>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesEphemeralVolumeClaimTemplateSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ScheduledSparkApplicationTemplateVolumesEphemeralVolumeClaimTemplateSpecResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesEphemeralVolumeClaimTemplateSpecResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<ScheduledSparkApplicationTemplateVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesFc {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lun: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetWWNs")]
    pub target_ww_ns: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wwids: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesFlexVolume {
    pub driver: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateVolumesFlexVolumeSecretRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesFlexVolumeSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesFlocker {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetName")]
    pub dataset_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetUUID")]
    pub dataset_uuid: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesGcePersistentDisk {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    #[serde(rename = "pdName")]
    pub pd_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesGitRepo {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    pub repository: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub revision: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesGlusterfs {
    pub endpoints: String,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesHostPath {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesIscsi {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthDiscovery")]
    pub chap_auth_discovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthSession")]
    pub chap_auth_session: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initiatorName")]
    pub initiator_name: Option<String>,
    pub iqn: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iscsiInterface")]
    pub iscsi_interface: Option<String>,
    pub lun: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub portals: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateVolumesIscsiSecretRef>,
    #[serde(rename = "targetPortal")]
    pub target_portal: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesIscsiSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesNfs {
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    pub server: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesPersistentVolumeClaim {
    #[serde(rename = "claimName")]
    pub claim_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesPhotonPersistentDisk {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(rename = "pdID")]
    pub pd_id: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesPortworxVolume {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjected {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    pub sources: Vec<ScheduledSparkApplicationTemplateVolumesProjectedSources>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScheduledSparkApplicationTemplateVolumesProjectedSourcesConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ScheduledSparkApplicationTemplateVolumesProjectedSourcesDownwardApi>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScheduledSparkApplicationTemplateVolumesProjectedSourcesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<ScheduledSparkApplicationTemplateVolumesProjectedSourcesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSourcesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ScheduledSparkApplicationTemplateVolumesProjectedSourcesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSourcesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSourcesDownwardApi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ScheduledSparkApplicationTemplateVolumesProjectedSourcesDownwardApiItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSourcesDownwardApiItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ScheduledSparkApplicationTemplateVolumesProjectedSourcesDownwardApiItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ScheduledSparkApplicationTemplateVolumesProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSourcesDownwardApiItemsFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSourcesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ScheduledSparkApplicationTemplateVolumesProjectedSourcesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSourcesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesProjectedSourcesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesQuobyte {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    pub registry: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    pub volume: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesRbd {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    pub image: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyring: Option<String>,
    pub monitors: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateVolumesRbdSecretRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesRbdSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesScaleIo {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    pub gateway: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protectionDomain")]
    pub protection_domain: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(rename = "secretRef")]
    pub secret_ref: ScheduledSparkApplicationTemplateVolumesScaleIoSecretRef,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslEnabled")]
    pub ssl_enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageMode")]
    pub storage_mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    pub system: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesScaleIoSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ScheduledSparkApplicationTemplateVolumesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesStorageos {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ScheduledSparkApplicationTemplateVolumesStorageosSecretRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeNamespace")]
    pub volume_namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesStorageosSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationTemplateVolumesVsphereVolume {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyID")]
    pub storage_policy_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyName")]
    pub storage_policy_name: Option<String>,
    #[serde(rename = "volumePath")]
    pub volume_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScheduledSparkApplicationStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastRun")]
    pub last_run: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastRunName")]
    pub last_run_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nextRun")]
    pub next_run: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pastFailedRunNames")]
    pub past_failed_run_names: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pastSuccessfulRunNames")]
    pub past_successful_run_names: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scheduleState")]
    pub schedule_state: Option<String>,
}

