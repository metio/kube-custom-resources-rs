// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/projectcontour/contour/projectcontour.io/v1alpha1/contourdeployments.yaml --derive=PartialEq
// kopium version: 0.18.0

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;

/// ContourDeploymentSpec specifies options for how a Contour
/// instance should be provisioned.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "projectcontour.io", version = "v1alpha1", kind = "ContourDeployment", plural = "contourdeployments")]
#[kube(namespaced)]
#[kube(status = "ContourDeploymentStatus")]
#[kube(schema = "disabled")]
pub struct ContourDeploymentSpec {
    /// Contour specifies deployment-time settings for the Contour
    /// part of the installation, i.e. the xDS server/control plane
    /// and associated resources, including things like replica count
    /// for the Deployment, and node placement constraints for the pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contour: Option<ContourDeploymentContour>,
    /// Envoy specifies deployment-time settings for the Envoy
    /// part of the installation, i.e. the xDS client/data plane
    /// and associated resources, including things like the workload
    /// type to use (DaemonSet or Deployment), node placement constraints
    /// for the pods, and various options for the Envoy service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub envoy: Option<ContourDeploymentEnvoy>,
    /// ResourceLabels is a set of labels to add to the provisioned Contour resources.
    /// Deprecated: use Gateway.Spec.Infrastructure.Labels instead. This field will be
    /// removed in a future release.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceLabels")]
    pub resource_labels: Option<BTreeMap<String, String>>,
    /// RuntimeSettings is a ContourConfiguration spec to be used when
    /// provisioning a Contour instance that will influence aspects of
    /// the Contour instance's runtime behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeSettings")]
    pub runtime_settings: Option<ContourDeploymentRuntimeSettings>,
}

/// Contour specifies deployment-time settings for the Contour
/// part of the installation, i.e. the xDS server/control plane
/// and associated resources, including things like replica count
/// for the Deployment, and node placement constraints for the pods.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentContour {
    /// Deployment describes the settings for running contour as a `Deployment`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<ContourDeploymentContourDeployment>,
    /// DisabledFeatures defines an array of resources that will be ignored by
    /// contour reconciler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disabledFeatures")]
    pub disabled_features: Option<Vec<String>>,
    /// KubernetesLogLevel Enable Kubernetes client debug logging with log level. If unset,
    /// defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesLogLevel")]
    pub kubernetes_log_level: Option<i64>,
    /// LogLevel sets the log level for Contour
    /// Allowed values are "info", "debug".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// NodePlacement describes node scheduling configuration of Contour pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePlacement")]
    pub node_placement: Option<ContourDeploymentContourNodePlacement>,
    /// PodAnnotations defines annotations to add to the Contour pods.
    /// the annotations for Prometheus will be appended or overwritten with predefined value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAnnotations")]
    pub pod_annotations: Option<BTreeMap<String, String>>,
    /// Deprecated: Use `DeploymentSettings.Replicas` instead.
    /// Replicas is the desired number of Contour replicas. If if unset,
    /// defaults to 2.
    /// if both `DeploymentSettings.Replicas` and this one is set, use `DeploymentSettings.Replicas`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Compute Resources required by contour container.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ContourDeploymentContourResources>,
    /// WatchNamespaces is an array of namespaces. Setting it will instruct the contour instance
    /// to only watch this subset of namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "watchNamespaces")]
    pub watch_namespaces: Option<Vec<String>>,
}

/// Deployment describes the settings for running contour as a `Deployment`.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentContourDeployment {
    /// Replicas is the desired number of replicas.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Strategy describes the deployment strategy to use to replace existing pods with new pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<ContourDeploymentContourDeploymentStrategy>,
}

/// Strategy describes the deployment strategy to use to replace existing pods with new pods.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentContourDeploymentStrategy {
    /// Rolling update config params. Present only if DeploymentStrategyType =
    /// RollingUpdate.
    /// ---
    /// TODO: Update this to follow our convention for oneOf, whatever we decide it
    /// to be.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<ContourDeploymentContourDeploymentStrategyRollingUpdate>,
    /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Rolling update config params. Present only if DeploymentStrategyType =
/// RollingUpdate.
/// ---
/// TODO: Update this to follow our convention for oneOf, whatever we decide it
/// to be.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentContourDeploymentStrategyRollingUpdate {
    /// The maximum number of pods that can be scheduled above the desired number of
    /// pods.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
    /// the rolling update starts, such that the total number of old and new pods do not exceed
    /// 130% of desired pods. Once old pods have been killed,
    /// new ReplicaSet can be scaled up further, ensuring that total number of pods running
    /// at any time during the update is at most 130% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// The maximum number of pods that can be unavailable during the update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// Absolute number is calculated from percentage by rounding down.
    /// This can not be 0 if MaxSurge is 0.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
    /// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
    /// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
    /// that the total number of pods available at all times during the update is at
    /// least 70% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// NodePlacement describes node scheduling configuration of Contour pods.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentContourNodePlacement {
    /// NodeSelector is the simplest recommended form of node selection constraint
    /// and specifies a map of key-value pairs. For the pod to be eligible
    /// to run on a node, the node must have each of the indicated key-value pairs
    /// as labels (it can have additional labels as well).
    /// If unset, the pod(s) will be scheduled to any available node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Tolerations work with taints to ensure that pods are not scheduled
    /// onto inappropriate nodes. One or more taints are applied to a node; this
    /// marks that the node should not accept any pods that do not tolerate the
    /// taints.
    /// The default is an empty list.
    /// See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    /// for additional details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<ContourDeploymentContourNodePlacementTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentContourNodePlacementTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Compute Resources required by contour container.
/// Cannot be updated.
/// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentContourResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ContourDeploymentContourResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentContourResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// Envoy specifies deployment-time settings for the Envoy
/// part of the installation, i.e. the xDS client/data plane
/// and associated resources, including things like the workload
/// type to use (DaemonSet or Deployment), node placement constraints
/// for the pods, and various options for the Envoy service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoy {
    /// The base ID to use when allocating shared memory regions.
    /// if Envoy needs to be run multiple times on the same machine, each running Envoy will need a unique base ID
    /// so that the shared memory regions do not conflict.
    /// defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "baseID")]
    pub base_id: Option<i32>,
    /// DaemonSet describes the settings for running envoy as a `DaemonSet`.
    /// if `WorkloadType` is `Deployment`,it's must be nil
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "daemonSet")]
    pub daemon_set: Option<ContourDeploymentEnvoyDaemonSet>,
    /// Deployment describes the settings for running envoy as a `Deployment`.
    /// if `WorkloadType` is `DaemonSet`,it's must be nil
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<ContourDeploymentEnvoyDeployment>,
    /// ExtraVolumeMounts holds the extra volume mounts to add (normally used with extraVolumes).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraVolumeMounts")]
    pub extra_volume_mounts: Option<Vec<ContourDeploymentEnvoyExtraVolumeMounts>>,
    /// ExtraVolumes holds the extra volumes to add.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraVolumes")]
    pub extra_volumes: Option<Vec<ContourDeploymentEnvoyExtraVolumes>>,
    /// LogLevel sets the log level for Envoy.
    /// Allowed values are "trace", "debug", "info", "warn", "error", "critical", "off".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// NetworkPublishing defines how to expose Envoy to a network.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPublishing")]
    pub network_publishing: Option<ContourDeploymentEnvoyNetworkPublishing>,
    /// NodePlacement describes node scheduling configuration of Envoy pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePlacement")]
    pub node_placement: Option<ContourDeploymentEnvoyNodePlacement>,
    /// OverloadMaxHeapSize defines the maximum heap memory of the envoy controlled by the overload manager.
    /// When the value is greater than 0, the overload manager is enabled,
    /// and when envoy reaches 95% of the maximum heap size, it performs a shrink heap operation,
    /// When it reaches 98% of the maximum heap size, Envoy Will stop accepting requests.
    /// More info: https://projectcontour.io/docs/main/config/overload-manager/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "overloadMaxHeapSize")]
    pub overload_max_heap_size: Option<i64>,
    /// PodAnnotations defines annotations to add to the Envoy pods.
    /// the annotations for Prometheus will be appended or overwritten with predefined value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAnnotations")]
    pub pod_annotations: Option<BTreeMap<String, String>>,
    /// Deprecated: Use `DeploymentSettings.Replicas` instead.
    /// Replicas is the desired number of Envoy replicas. If WorkloadType
    /// is not "Deployment", this field is ignored. Otherwise, if unset,
    /// defaults to 2.
    /// if both `DeploymentSettings.Replicas` and this one is set, use `DeploymentSettings.Replicas`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Compute Resources required by envoy container.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ContourDeploymentEnvoyResources>,
    /// WorkloadType is the type of workload to install Envoy
    /// as. Choices are DaemonSet and Deployment. If unset, defaults
    /// to DaemonSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadType")]
    pub workload_type: Option<String>,
}

/// DaemonSet describes the settings for running envoy as a `DaemonSet`.
/// if `WorkloadType` is `Deployment`,it's must be nil
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyDaemonSet {
    /// Strategy describes the deployment strategy to use to replace existing DaemonSet pods with new pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<ContourDeploymentEnvoyDaemonSetUpdateStrategy>,
}

/// Strategy describes the deployment strategy to use to replace existing DaemonSet pods with new pods.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyDaemonSetUpdateStrategy {
    /// Rolling update config params. Present only if type = "RollingUpdate".
    /// ---
    /// TODO: Update this to follow our convention for oneOf, whatever we decide it
    /// to be. Same as Deployment `strategy.rollingUpdate`.
    /// See https://github.com/kubernetes/kubernetes/issues/35345
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<ContourDeploymentEnvoyDaemonSetUpdateStrategyRollingUpdate>,
    /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Rolling update config params. Present only if type = "RollingUpdate".
/// ---
/// TODO: Update this to follow our convention for oneOf, whatever we decide it
/// to be. Same as Deployment `strategy.rollingUpdate`.
/// See https://github.com/kubernetes/kubernetes/issues/35345
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyDaemonSetUpdateStrategyRollingUpdate {
    /// The maximum number of nodes with an existing available DaemonSet pod that
    /// can have an updated DaemonSet pod during during an update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up to a minimum of 1.
    /// Default value is 0.
    /// Example: when this is set to 30%, at most 30% of the total number of nodes
    /// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
    /// can have their a new pod created before the old pod is marked as deleted.
    /// The update starts by launching new pods on 30% of nodes. Once an updated
    /// pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
    /// on that node is marked deleted. If the old pod becomes unavailable for any
    /// reason (Ready transitions to false, is evicted, or is drained) an updated
    /// pod is immediatedly created on that node without considering surge limits.
    /// Allowing surge implies the possibility that the resources consumed by the
    /// daemonset on any given node can double if the readiness check fails, and
    /// so resource intensive daemonsets should take into account that they may
    /// cause evictions during disruption.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// The maximum number of DaemonSet pods that can be unavailable during the
    /// update. Value can be an absolute number (ex: 5) or a percentage of total
    /// number of DaemonSet pods at the start of the update (ex: 10%). Absolute
    /// number is calculated from percentage by rounding up.
    /// This cannot be 0 if MaxSurge is 0
    /// Default value is 1.
    /// Example: when this is set to 30%, at most 30% of the total number of nodes
    /// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
    /// can have their pods stopped for an update at any given time. The update
    /// starts by stopping at most 30% of those DaemonSet pods and then brings
    /// up new DaemonSet pods in their place. Once the new pods are available,
    /// it then proceeds onto other DaemonSet pods, thus ensuring that at least
    /// 70% of original number of DaemonSet pods are available at all times during
    /// the update.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// Deployment describes the settings for running envoy as a `Deployment`.
/// if `WorkloadType` is `DaemonSet`,it's must be nil
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyDeployment {
    /// Replicas is the desired number of replicas.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Strategy describes the deployment strategy to use to replace existing pods with new pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<ContourDeploymentEnvoyDeploymentStrategy>,
}

/// Strategy describes the deployment strategy to use to replace existing pods with new pods.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyDeploymentStrategy {
    /// Rolling update config params. Present only if DeploymentStrategyType =
    /// RollingUpdate.
    /// ---
    /// TODO: Update this to follow our convention for oneOf, whatever we decide it
    /// to be.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<ContourDeploymentEnvoyDeploymentStrategyRollingUpdate>,
    /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Rolling update config params. Present only if DeploymentStrategyType =
/// RollingUpdate.
/// ---
/// TODO: Update this to follow our convention for oneOf, whatever we decide it
/// to be.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyDeploymentStrategyRollingUpdate {
    /// The maximum number of pods that can be scheduled above the desired number of
    /// pods.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
    /// the rolling update starts, such that the total number of old and new pods do not exceed
    /// 130% of desired pods. Once old pods have been killed,
    /// new ReplicaSet can be scaled up further, ensuring that total number of pods running
    /// at any time during the update is at most 130% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// The maximum number of pods that can be unavailable during the update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// Absolute number is calculated from percentage by rounding down.
    /// This can not be 0 if MaxSurge is 0.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
    /// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
    /// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
    /// that the total number of pods available at all times during the update is at
    /// least 70% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumes {
    /// awsElasticBlockStore represents an AWS Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsElasticBlockStore")]
    pub aws_elastic_block_store: Option<ContourDeploymentEnvoyExtraVolumesAwsElasticBlockStore>,
    /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureDisk")]
    pub azure_disk: Option<ContourDeploymentEnvoyExtraVolumesAzureDisk>,
    /// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureFile")]
    pub azure_file: Option<ContourDeploymentEnvoyExtraVolumesAzureFile>,
    /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephfs: Option<ContourDeploymentEnvoyExtraVolumesCephfs>,
    /// cinder represents a cinder volume attached and mounted on kubelets host machine.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cinder: Option<ContourDeploymentEnvoyExtraVolumesCinder>,
    /// configMap represents a configMap that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ContourDeploymentEnvoyExtraVolumesConfigMap>,
    /// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<ContourDeploymentEnvoyExtraVolumesCsi>,
    /// downwardAPI represents downward API about the pod that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ContourDeploymentEnvoyExtraVolumesDownwardApi>,
    /// emptyDir represents a temporary directory that shares a pod's lifetime.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<ContourDeploymentEnvoyExtraVolumesEmptyDir>,
    /// ephemeral represents a volume that is handled by a cluster storage driver.
    /// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    /// and deleted when the pod is removed.
    /// Use this if:
    /// a) the volume is only needed while the pod runs,
    /// b) features of normal volumes like restoring from snapshot or capacity
    ///    tracking are needed,
    /// c) the storage driver is specified through a storage class, and
    /// d) the storage driver supports dynamic volume provisioning through
    ///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
    ///    information on the connection between this volume type
    ///    and PersistentVolumeClaim).
    /// Use PersistentVolumeClaim or one of the vendor-specific
    /// APIs for volumes that persist for longer than the lifecycle
    /// of an individual pod.
    /// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    /// be used that way - see the documentation of the driver for
    /// more information.
    /// A pod can use both types of ephemeral volumes and
    /// persistent volumes at the same time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<ContourDeploymentEnvoyExtraVolumesEphemeral>,
    /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fc: Option<ContourDeploymentEnvoyExtraVolumesFc>,
    /// flexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flexVolume")]
    pub flex_volume: Option<ContourDeploymentEnvoyExtraVolumesFlexVolume>,
    /// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flocker: Option<ContourDeploymentEnvoyExtraVolumesFlocker>,
    /// gcePersistentDisk represents a GCE Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDisk")]
    pub gce_persistent_disk: Option<ContourDeploymentEnvoyExtraVolumesGcePersistentDisk>,
    /// gitRepo represents a git repository at a particular revision.
    /// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    /// into the Pod's container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitRepo")]
    pub git_repo: Option<ContourDeploymentEnvoyExtraVolumesGitRepo>,
    /// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glusterfs: Option<ContourDeploymentEnvoyExtraVolumesGlusterfs>,
    /// hostPath represents a pre-existing file or directory on the host
    /// machine that is directly exposed to the container. This is generally
    /// used for system agents or other privileged things that are allowed
    /// to see the host machine. Most containers will NOT need this.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    /// ---
    /// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
    /// mount host directories as read/write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<ContourDeploymentEnvoyExtraVolumesHostPath>,
    /// iscsi represents an ISCSI Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: https://examples.k8s.io/volumes/iscsi/README.md
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iscsi: Option<ContourDeploymentEnvoyExtraVolumesIscsi>,
    /// name of the volume.
    /// Must be a DNS_LABEL and unique within the pod.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    pub name: String,
    /// nfs represents an NFS mount on the host that shares a pod's lifetime
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nfs: Option<ContourDeploymentEnvoyExtraVolumesNfs>,
    /// persistentVolumeClaimVolumeSource represents a reference to a
    /// PersistentVolumeClaim in the same namespace.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<ContourDeploymentEnvoyExtraVolumesPersistentVolumeClaim>,
    /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "photonPersistentDisk")]
    pub photon_persistent_disk: Option<ContourDeploymentEnvoyExtraVolumesPhotonPersistentDisk>,
    /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portworxVolume")]
    pub portworx_volume: Option<ContourDeploymentEnvoyExtraVolumesPortworxVolume>,
    /// projected items for all in one resources secrets, configmaps, and downward API
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<ContourDeploymentEnvoyExtraVolumesProjected>,
    /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quobyte: Option<ContourDeploymentEnvoyExtraVolumesQuobyte>,
    /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbd: Option<ContourDeploymentEnvoyExtraVolumesRbd>,
    /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scaleIO")]
    pub scale_io: Option<ContourDeploymentEnvoyExtraVolumesScaleIo>,
    /// secret represents a secret that should populate this volume.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ContourDeploymentEnvoyExtraVolumesSecret>,
    /// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storageos: Option<ContourDeploymentEnvoyExtraVolumesStorageos>,
    /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vsphereVolume")]
    pub vsphere_volume: Option<ContourDeploymentEnvoyExtraVolumesVsphereVolume>,
}

/// awsElasticBlockStore represents an AWS Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesAwsElasticBlockStore {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// readOnly value true will force the readOnly setting in VolumeMounts.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesAzureDisk {
    /// cachingMode is the Host Caching mode: None, Read Only, Read Write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachingMode")]
    pub caching_mode: Option<String>,
    /// diskName is the Name of the data disk in the blob storage
    #[serde(rename = "diskName")]
    pub disk_name: String,
    /// diskURI is the URI of data disk in the blob storage
    #[serde(rename = "diskURI")]
    pub disk_uri: String,
    /// fsType is Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesAzureFile {
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretName is the  name of secret that contains Azure Storage Account Name and Key
    #[serde(rename = "secretName")]
    pub secret_name: String,
    /// shareName is the azure share Name
    #[serde(rename = "shareName")]
    pub share_name: String,
}

/// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesCephfs {
    /// monitors is Required: Monitors is a collection of Ceph monitors
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    pub monitors: Vec<String>,
    /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretFile")]
    pub secret_file: Option<String>,
    /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ContourDeploymentEnvoyExtraVolumesCephfsSecretRef>,
    /// user is optional: User is the rados user name, default is admin
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
/// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesCephfsSecretRef {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// cinder represents a cinder volume attached and mounted on kubelets host machine.
/// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesCinder {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is optional: points to a secret object containing parameters used to connect
    /// to OpenStack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ContourDeploymentEnvoyExtraVolumesCinderSecretRef>,
    /// volumeID used to identify the volume in cinder.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// secretRef is optional: points to a secret object containing parameters used to connect
/// to OpenStack.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesCinderSecretRef {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// configMap represents a configMap that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesConfigMap {
    /// defaultMode is optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ContourDeploymentEnvoyExtraVolumesConfigMapItems>>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesCsi {
    /// driver is the name of the CSI driver that handles this volume.
    /// Consult with your admin for the correct name as registered in the cluster.
    pub driver: String,
    /// fsType to mount. Ex. "ext4", "xfs", "ntfs".
    /// If not provided, the empty value is passed to the associated CSI driver
    /// which will determine the default filesystem to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// nodePublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// NodePublishVolume and NodeUnpublishVolume calls.
    /// This field is optional, and  may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secret references are passed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePublishSecretRef")]
    pub node_publish_secret_ref: Option<ContourDeploymentEnvoyExtraVolumesCsiNodePublishSecretRef>,
    /// readOnly specifies a read-only configuration for the volume.
    /// Defaults to false (read/write).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeAttributes stores driver-specific properties that are passed to the CSI
    /// driver. Consult your driver's documentation for supported values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributes")]
    pub volume_attributes: Option<BTreeMap<String, String>>,
}

/// nodePublishSecretRef is a reference to the secret object containing
/// sensitive information to pass to the CSI driver to complete the CSI
/// NodePublishVolume and NodeUnpublishVolume calls.
/// This field is optional, and  may be empty if no secret is required. If the
/// secret object contains more than one secret, all secret references are passed.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesCsiNodePublishSecretRef {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// downwardAPI represents downward API about the pod that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesDownwardApi {
    /// Optional: mode bits to use on created files by default. Must be a
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// Items is a list of downward API volume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ContourDeploymentEnvoyExtraVolumesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ContourDeploymentEnvoyExtraVolumesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ContourDeploymentEnvoyExtraVolumesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// emptyDir represents a temporary directory that shares a pod's lifetime.
/// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEmptyDir {
    /// medium represents what type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

/// ephemeral represents a volume that is handled by a cluster storage driver.
/// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
/// and deleted when the pod is removed.
/// Use this if:
/// a) the volume is only needed while the pod runs,
/// b) features of normal volumes like restoring from snapshot or capacity
///    tracking are needed,
/// c) the storage driver is specified through a storage class, and
/// d) the storage driver supports dynamic volume provisioning through
///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
///    information on the connection between this volume type
///    and PersistentVolumeClaim).
/// Use PersistentVolumeClaim or one of the vendor-specific
/// APIs for volumes that persist for longer than the lifecycle
/// of an individual pod.
/// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
/// be used that way - see the documentation of the driver for
/// more information.
/// A pod can use both types of ephemeral volumes and
/// persistent volumes at the same time.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEphemeral {
    /// Will be used to create a stand-alone PVC to provision the volume.
    /// The pod in which this EphemeralVolumeSource is embedded will be the
    /// owner of the PVC, i.e. the PVC will be deleted together with the
    /// pod.  The name of the PVC will be `<pod name>-<volume name>` where
    /// `<volume name>` is the name from the `PodSpec.Volumes` array
    /// entry. Pod validation will reject the pod if the concatenated name
    /// is not valid for a PVC (for example, too long).
    /// An existing PVC with that name that is not owned by the pod
    /// will *not* be used for the pod to avoid using an unrelated
    /// volume by mistake. Starting the pod is then blocked until
    /// the unrelated PVC is removed. If such a pre-created PVC is
    /// meant to be used by the pod, the PVC has to updated with an
    /// owner reference to the pod once the pod exists. Normally
    /// this should not be necessary, but it may be useful when
    /// manually reconstructing a broken cluster.
    /// This field is read-only and no changes will be made by Kubernetes
    /// to the PVC after it has been created.
    /// Required, must not be nil.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplate>,
}

/// Will be used to create a stand-alone PVC to provision the volume.
/// The pod in which this EphemeralVolumeSource is embedded will be the
/// owner of the PVC, i.e. the PVC will be deleted together with the
/// pod.  The name of the PVC will be `<pod name>-<volume name>` where
/// `<volume name>` is the name from the `PodSpec.Volumes` array
/// entry. Pod validation will reject the pod if the concatenated name
/// is not valid for a PVC (for example, too long).
/// An existing PVC with that name that is not owned by the pod
/// will *not* be used for the pod to avoid using an unrelated
/// volume by mistake. Starting the pod is then blocked until
/// the unrelated PVC is removed. If such a pre-created PVC is
/// meant to be used by the pod, the PVC has to updated with an
/// owner reference to the pod once the pod exists. Normally
/// this should not be necessary, but it may be useful when
/// manually reconstructing a broken cluster.
/// This field is read-only and no changes will be made by Kubernetes
/// to the PVC after it has been created.
/// Required, must not be nil.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplate {
    /// May contain labels and annotations that will be copied into the PVC
    /// when creating it. No other fields are allowed and will be rejected during
    /// validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateMetadata>,
    /// The specification for the PersistentVolumeClaim. The entire content is
    /// copied unchanged into the PVC that gets created from this
    /// template. The same fields as in a PersistentVolumeClaim
    /// are also valid here.
    pub spec: ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec,
}

/// May contain labels and annotations that will be copied into the PVC
/// when creating it. No other fields are allowed and will be rejected during
/// validation.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateMetadata {
}

/// The specification for the PersistentVolumeClaim. The entire content is
/// copied unchanged into the PVC that gets created from this
/// template. The same fields as in a PersistentVolumeClaim
/// are also valid here.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
    /// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesFc {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// lun is Optional: FC target lun number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lun: Option<i32>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// targetWWNs is Optional: FC target worldwide names (WWNs)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetWWNs")]
    pub target_ww_ns: Option<Vec<String>>,
    /// wwids Optional: FC volume world wide identifiers (wwids)
    /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wwids: Option<Vec<String>>,
}

/// flexVolume represents a generic volume resource that is
/// provisioned/attached using an exec based plugin.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesFlexVolume {
    /// driver is the name of the driver to use for this volume.
    pub driver: String,
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// options is Optional: this field holds extra command options if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<BTreeMap<String, String>>,
    /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is Optional: secretRef is reference to the secret object containing
    /// sensitive information to pass to the plugin scripts. This may be
    /// empty if no secret object is specified. If the secret object
    /// contains more than one secret, all secrets are passed to the plugin
    /// scripts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ContourDeploymentEnvoyExtraVolumesFlexVolumeSecretRef>,
}

/// secretRef is Optional: secretRef is reference to the secret object containing
/// sensitive information to pass to the plugin scripts. This may be
/// empty if no secret object is specified. If the secret object
/// contains more than one secret, all secrets are passed to the plugin
/// scripts.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesFlexVolumeSecretRef {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesFlocker {
    /// datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
    /// should be considered as deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetName")]
    pub dataset_name: Option<String>,
    /// datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetUUID")]
    pub dataset_uuid: Option<String>,
}

/// gcePersistentDisk represents a GCE Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesGcePersistentDisk {
    /// fsType is filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    #[serde(rename = "pdName")]
    pub pd_name: String,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// gitRepo represents a git repository at a particular revision.
/// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
/// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
/// into the Pod's container.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesGitRepo {
    /// directory is the target directory name.
    /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    /// git repository.  Otherwise, if specified, the volume will contain the git repository in
    /// the subdirectory with the given name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    /// repository is the URL
    pub repository: String,
    /// revision is the commit hash for the specified revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub revision: Option<String>,
}

/// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
/// More info: https://examples.k8s.io/volumes/glusterfs/README.md
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesGlusterfs {
    /// endpoints is the endpoint name that details Glusterfs topology.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    pub endpoints: String,
    /// path is the Glusterfs volume path.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    pub path: String,
    /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// hostPath represents a pre-existing file or directory on the host
/// machine that is directly exposed to the container. This is generally
/// used for system agents or other privileged things that are allowed
/// to see the host machine. Most containers will NOT need this.
/// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
/// ---
/// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
/// mount host directories as read/write.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesHostPath {
    /// path of the directory on the host.
    /// If the path is a symlink, it will follow the link to the real path.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    pub path: String,
    /// type for HostPath Volume
    /// Defaults to ""
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// iscsi represents an ISCSI Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: https://examples.k8s.io/volumes/iscsi/README.md
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesIscsi {
    /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthDiscovery")]
    pub chap_auth_discovery: Option<bool>,
    /// chapAuthSession defines whether support iSCSI Session CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthSession")]
    pub chap_auth_session: Option<bool>,
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// initiatorName is the custom iSCSI Initiator Name.
    /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    /// <target portal>:<volume name> will be created for the connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initiatorName")]
    pub initiator_name: Option<String>,
    /// iqn is the target iSCSI Qualified Name.
    pub iqn: String,
    /// iscsiInterface is the interface Name that uses an iSCSI transport.
    /// Defaults to 'default' (tcp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iscsiInterface")]
    pub iscsi_interface: Option<String>,
    /// lun represents iSCSI Target Lun number.
    pub lun: i32,
    /// portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub portals: Option<Vec<String>>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ContourDeploymentEnvoyExtraVolumesIscsiSecretRef>,
    /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(rename = "targetPortal")]
    pub target_portal: String,
}

/// secretRef is the CHAP Secret for iSCSI target and initiator authentication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesIscsiSecretRef {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// nfs represents an NFS mount on the host that shares a pod's lifetime
/// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesNfs {
    /// path that is exported by the NFS server.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    pub path: String,
    /// readOnly here will force the NFS export to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// server is the hostname or IP address of the NFS server.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    pub server: String,
}

/// persistentVolumeClaimVolumeSource represents a reference to a
/// PersistentVolumeClaim in the same namespace.
/// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesPersistentVolumeClaim {
    /// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    #[serde(rename = "claimName")]
    pub claim_name: String,
    /// readOnly Will force the ReadOnly setting in VolumeMounts.
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesPhotonPersistentDisk {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// pdID is the ID that identifies Photon Controller persistent disk
    #[serde(rename = "pdID")]
    pub pd_id: String,
}

/// portworxVolume represents a portworx volume attached and mounted on kubelets host machine
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesPortworxVolume {
    /// fSType represents the filesystem type to mount
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID uniquely identifies a Portworx volume
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// projected items for all in one resources secrets, configmaps, and downward API
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjected {
    /// defaultMode are the mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// sources is the list of volume projections
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ContourDeploymentEnvoyExtraVolumesProjectedSources>>,
}

/// Projection that may be projected along with other supported volume types
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSources {
    /// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
    /// of ClusterTrustBundle objects in an auto-updating file.
    /// Alpha, gated by the ClusterTrustBundleProjection feature gate.
    /// ClusterTrustBundle objects can either be selected by name, or by the
    /// combination of signer name and a label selector.
    /// Kubelet performs aggressive normalization of the PEM contents written
    /// into the pod filesystem.  Esoteric PEM features such as inter-block
    /// comments and block headers are stripped.  Certificates are deduplicated.
    /// The ordering of certificates within the file is arbitrary, and Kubelet
    /// may change the order over time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<ContourDeploymentEnvoyExtraVolumesProjectedSourcesClusterTrustBundle>,
    /// configMap information about the configMap data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ContourDeploymentEnvoyExtraVolumesProjectedSourcesConfigMap>,
    /// downwardAPI information about the downwardAPI data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ContourDeploymentEnvoyExtraVolumesProjectedSourcesDownwardApi>,
    /// secret information about the secret data to project
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ContourDeploymentEnvoyExtraVolumesProjectedSourcesSecret>,
    /// serviceAccountToken is information about the serviceAccountToken data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<ContourDeploymentEnvoyExtraVolumesProjectedSourcesServiceAccountToken>,
}

/// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
/// of ClusterTrustBundle objects in an auto-updating file.
/// Alpha, gated by the ClusterTrustBundleProjection feature gate.
/// ClusterTrustBundle objects can either be selected by name, or by the
/// combination of signer name and a label selector.
/// Kubelet performs aggressive normalization of the PEM contents written
/// into the pod filesystem.  Esoteric PEM features such as inter-block
/// comments and block headers are stripped.  Certificates are deduplicated.
/// The ordering of certificates within the file is arbitrary, and Kubelet
/// may change the order over time.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesClusterTrustBundle {
    /// Select all ClusterTrustBundles that match this label selector.  Only has
    /// effect if signerName is set.  Mutually-exclusive with name.  If unset,
    /// interpreted as "match nothing".  If set but empty, interpreted as "match
    /// everything".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ContourDeploymentEnvoyExtraVolumesProjectedSourcesClusterTrustBundleLabelSelector>,
    /// Select a single ClusterTrustBundle by object name.  Mutually-exclusive
    /// with signerName and labelSelector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// If true, don't block pod startup if the referenced ClusterTrustBundle(s)
    /// aren't available.  If using name, then the named ClusterTrustBundle is
    /// allowed not to exist.  If using signerName, then the combination of
    /// signerName and labelSelector is allowed to match zero
    /// ClusterTrustBundles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Relative path from the volume root to write the bundle.
    pub path: String,
    /// Select all ClusterTrustBundles that match this signer name.
    /// Mutually-exclusive with name.  The contents of all selected
    /// ClusterTrustBundles will be unified and deduplicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

/// Select all ClusterTrustBundles that match this label selector.  Only has
/// effect if signerName is set.  Mutually-exclusive with name.  If unset,
/// interpreted as "match nothing".  If set but empty, interpreted as "match
/// everything".
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesClusterTrustBundleLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ContourDeploymentEnvoyExtraVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// configMap information about the configMap data to project
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesConfigMap {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ContourDeploymentEnvoyExtraVolumesProjectedSourcesConfigMapItems>>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// downwardAPI information about the downwardAPI data to project
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesDownwardApi {
    /// Items is a list of DownwardAPIVolume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ContourDeploymentEnvoyExtraVolumesProjectedSourcesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ContourDeploymentEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ContourDeploymentEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// secret information about the secret data to project
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesSecret {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ContourDeploymentEnvoyExtraVolumesProjectedSourcesSecretItems>>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional field specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// serviceAccountToken is information about the serviceAccountToken data to project
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesProjectedSourcesServiceAccountToken {
    /// audience is the intended audience of the token. A recipient of a token
    /// must identify itself with an identifier specified in the audience of the
    /// token, and otherwise should reject the token. The audience defaults to the
    /// identifier of the apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// expirationSeconds is the requested duration of validity of the service
    /// account token. As the token approaches expiration, the kubelet volume
    /// plugin will proactively rotate the service account token. The kubelet will
    /// start trying to rotate the token if the token is older than 80 percent of
    /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
    /// and must be at least 10 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    /// path is the path relative to the mount point of the file to project the
    /// token into.
    pub path: String,
}

/// quobyte represents a Quobyte mount on the host that shares a pod's lifetime
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesQuobyte {
    /// group to map volume access to
    /// Default is no group
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// readOnly here will force the Quobyte volume to be mounted with read-only permissions.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// registry represents a single or multiple Quobyte Registry services
    /// specified as a string as host:port pair (multiple entries are separated with commas)
    /// which acts as the central registry for volumes
    pub registry: String,
    /// tenant owning the given Quobyte volume in the Backend
    /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant: Option<String>,
    /// user to map volume access to
    /// Defaults to serivceaccount user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// volume is a string that references an already created Quobyte volume by name.
    pub volume: String,
}

/// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
/// More info: https://examples.k8s.io/volumes/rbd/README.md
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesRbd {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// image is the rados image name.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    pub image: String,
    /// keyring is the path to key ring for RBDUser.
    /// Default is /etc/ceph/keyring.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyring: Option<String>,
    /// monitors is a collection of Ceph monitors.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    pub monitors: Vec<String>,
    /// pool is the rados pool name.
    /// Default is rbd.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is name of the authentication secret for RBDUser. If provided
    /// overrides keyring.
    /// Default is nil.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ContourDeploymentEnvoyExtraVolumesRbdSecretRef>,
    /// user is the rados user name.
    /// Default is admin.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is name of the authentication secret for RBDUser. If provided
/// overrides keyring.
/// Default is nil.
/// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesRbdSecretRef {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesScaleIo {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// Default is "xfs".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// gateway is the host address of the ScaleIO API Gateway.
    pub gateway: String,
    /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protectionDomain")]
    pub protection_domain: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef references to the secret for ScaleIO user and other
    /// sensitive information. If this is not provided, Login operation will fail.
    #[serde(rename = "secretRef")]
    pub secret_ref: ContourDeploymentEnvoyExtraVolumesScaleIoSecretRef,
    /// sslEnabled Flag enable/disable SSL communication with Gateway, default false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslEnabled")]
    pub ssl_enabled: Option<bool>,
    /// storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    /// Default is ThinProvisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageMode")]
    pub storage_mode: Option<String>,
    /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    /// system is the name of the storage system as configured in ScaleIO.
    pub system: String,
    /// volumeName is the name of a volume already created in the ScaleIO system
    /// that is associated with this volume source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// secretRef references to the secret for ScaleIO user and other
/// sensitive information. If this is not provided, Login operation will fail.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesScaleIoSecretRef {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// secret represents a secret that should populate this volume.
/// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesSecret {
    /// defaultMode is Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values
    /// for mode bits. Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items If unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ContourDeploymentEnvoyExtraVolumesSecretItems>>,
    /// optional field specify whether the Secret or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// secretName is the name of the secret in the pod's namespace to use.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesStorageos {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef specifies the secret to use for obtaining the StorageOS API
    /// credentials.  If not specified, default values will be attempted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ContourDeploymentEnvoyExtraVolumesStorageosSecretRef>,
    /// volumeName is the human-readable name of the StorageOS volume.  Volume
    /// names are only unique within a namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
    /// volumeNamespace specifies the scope of the volume within StorageOS.  If no
    /// namespace is specified then the Pod's namespace will be used.  This allows the
    /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    /// Set VolumeName to any name to override the default behaviour.
    /// Set to "default" if you are not using namespaces within StorageOS.
    /// Namespaces that do not pre-exist within StorageOS will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeNamespace")]
    pub volume_namespace: Option<String>,
}

/// secretRef specifies the secret to use for obtaining the StorageOS API
/// credentials.  If not specified, default values will be attempted.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesStorageosSecretRef {
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyExtraVolumesVsphereVolume {
    /// fsType is filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyID")]
    pub storage_policy_id: Option<String>,
    /// storagePolicyName is the storage Policy Based Management (SPBM) profile name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyName")]
    pub storage_policy_name: Option<String>,
    /// volumePath is the path that identifies vSphere volume vmdk
    #[serde(rename = "volumePath")]
    pub volume_path: String,
}

/// NetworkPublishing defines how to expose Envoy to a network.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyNetworkPublishing {
    /// ExternalTrafficPolicy describes how nodes distribute service traffic they
    /// receive on one of the Service's "externally-facing" addresses (NodePorts, ExternalIPs,
    /// and LoadBalancer IPs).
    /// If unset, defaults to "Local".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalTrafficPolicy")]
    pub external_traffic_policy: Option<String>,
    /// IPFamilyPolicy represents the dual-stack-ness requested or required by
    /// this Service. If there is no value provided, then this field will be set
    /// to SingleStack. Services can be "SingleStack" (a single IP family),
    /// "PreferDualStack" (two IP families on dual-stack configured clusters or
    /// a single IP family on single-stack clusters), or "RequireDualStack"
    /// (two IP families on dual-stack configured clusters, otherwise fail).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipFamilyPolicy")]
    pub ip_family_policy: Option<String>,
    /// ServiceAnnotations is the annotations to add to
    /// the provisioned Envoy service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAnnotations")]
    pub service_annotations: Option<BTreeMap<String, String>>,
    /// NetworkPublishingType is the type of publishing strategy to use. Valid values are:
    /// * LoadBalancerService
    /// In this configuration, network endpoints for Envoy use container networking.
    /// A Kubernetes LoadBalancer Service is created to publish Envoy network
    /// endpoints.
    /// See: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer
    /// * NodePortService
    /// Publishes Envoy network endpoints using a Kubernetes NodePort Service.
    /// In this configuration, Envoy network endpoints use container networking. A Kubernetes
    /// NodePort Service is created to publish the network endpoints.
    /// See: https://kubernetes.io/docs/concepts/services-networking/service/#nodeport
    /// NOTE:
    /// When provisioning an Envoy `NodePortService`, use Gateway Listeners' port numbers to populate
    /// the Service's node port values, there's no way to auto-allocate them.
    /// See: https://github.com/projectcontour/contour/issues/4499
    /// * ClusterIPService
    /// Publishes Envoy network endpoints using a Kubernetes ClusterIP Service.
    /// In this configuration, Envoy network endpoints use container networking. A Kubernetes
    /// ClusterIP Service is created to publish the network endpoints.
    /// See: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    /// If unset, defaults to LoadBalancerService.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// NodePlacement describes node scheduling configuration of Envoy pods.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyNodePlacement {
    /// NodeSelector is the simplest recommended form of node selection constraint
    /// and specifies a map of key-value pairs. For the pod to be eligible
    /// to run on a node, the node must have each of the indicated key-value pairs
    /// as labels (it can have additional labels as well).
    /// If unset, the pod(s) will be scheduled to any available node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Tolerations work with taints to ensure that pods are not scheduled
    /// onto inappropriate nodes. One or more taints are applied to a node; this
    /// marks that the node should not accept any pods that do not tolerate the
    /// taints.
    /// The default is an empty list.
    /// See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    /// for additional details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<ContourDeploymentEnvoyNodePlacementTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyNodePlacementTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Compute Resources required by envoy container.
/// Cannot be updated.
/// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ContourDeploymentEnvoyResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentEnvoyResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// RuntimeSettings is a ContourConfiguration spec to be used when
/// provisioning a Contour instance that will influence aspects of
/// the Contour instance's runtime behavior.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettings {
    /// Debug contains parameters to enable debug logging
    /// and debug interfaces inside Contour.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<ContourDeploymentRuntimeSettingsDebug>,
    /// EnableExternalNameService allows processing of ExternalNameServices
    /// Contour's default is false for security reasons.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableExternalNameService")]
    pub enable_external_name_service: Option<bool>,
    /// Envoy contains parameters for Envoy as well
    /// as how to optionally configure a managed Envoy fleet.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub envoy: Option<ContourDeploymentRuntimeSettingsEnvoy>,
    /// FeatureFlags defines toggle to enable new contour features.
    /// Available toggles are:
    /// useEndpointSlices - Configures contour to fetch endpoint data
    /// from k8s endpoint slices. defaults to true,
    /// If false then reads endpoint data from the k8s endpoints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "featureFlags")]
    pub feature_flags: Option<Vec<String>>,
    /// Gateway contains parameters for the gateway-api Gateway that Contour
    /// is configured to serve traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<ContourDeploymentRuntimeSettingsGateway>,
    /// GlobalExternalAuthorization allows envoys external authorization filter
    /// to be enabled for all virtual hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalExtAuth")]
    pub global_ext_auth: Option<ContourDeploymentRuntimeSettingsGlobalExtAuth>,
    /// Health defines the endpoints Contour uses to serve health checks.
    /// Contour's default is { address: "0.0.0.0", port: 8000 }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health: Option<ContourDeploymentRuntimeSettingsHealth>,
    /// HTTPProxy defines parameters on HTTPProxy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub httpproxy: Option<ContourDeploymentRuntimeSettingsHttpproxy>,
    /// Ingress contains parameters for ingress options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<ContourDeploymentRuntimeSettingsIngress>,
    /// Metrics defines the endpoint Contour uses to serve metrics.
    /// Contour's default is { address: "0.0.0.0", port: 8000 }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<ContourDeploymentRuntimeSettingsMetrics>,
    /// Policy specifies default policy applied if not overridden by the user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ContourDeploymentRuntimeSettingsPolicy>,
    /// RateLimitService optionally holds properties of the Rate Limit Service
    /// to be used for global rate limiting.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitService")]
    pub rate_limit_service: Option<ContourDeploymentRuntimeSettingsRateLimitService>,
    /// Tracing defines properties for exporting trace data to OpenTelemetry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tracing: Option<ContourDeploymentRuntimeSettingsTracing>,
    /// XDSServer contains parameters for the xDS server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "xdsServer")]
    pub xds_server: Option<ContourDeploymentRuntimeSettingsXdsServer>,
}

/// Debug contains parameters to enable debug logging
/// and debug interfaces inside Contour.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsDebug {
    /// Defines the Contour debug address interface.
    /// Contour's default is "127.0.0.1".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the Contour debug address port.
    /// Contour's default is 6060.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Envoy contains parameters for Envoy as well
/// as how to optionally configure a managed Envoy fleet.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoy {
    /// ClientCertificate defines the namespace/name of the Kubernetes
    /// secret containing the client certificate and private key
    /// to be used when establishing TLS connection to upstream
    /// cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<ContourDeploymentRuntimeSettingsEnvoyClientCertificate>,
    /// Cluster holds various configurable Envoy cluster values that can
    /// be set in the config file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<ContourDeploymentRuntimeSettingsEnvoyCluster>,
    /// DefaultHTTPVersions defines the default set of HTTPS
    /// versions the proxy should accept. HTTP versions are
    /// strings of the form "HTTP/xx". Supported versions are
    /// "HTTP/1.1" and "HTTP/2".
    /// Values: `HTTP/1.1`, `HTTP/2` (default: both).
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultHTTPVersions")]
    pub default_http_versions: Option<Vec<String>>,
    /// Health defines the endpoint Envoy uses to serve health checks.
    /// Contour's default is { address: "0.0.0.0", port: 8002 }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health: Option<ContourDeploymentRuntimeSettingsEnvoyHealth>,
    /// Defines the HTTP Listener for Envoy.
    /// Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ContourDeploymentRuntimeSettingsEnvoyHttp>,
    /// Defines the HTTPS Listener for Envoy.
    /// Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub https: Option<ContourDeploymentRuntimeSettingsEnvoyHttps>,
    /// Listener hold various configurable Envoy listener values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<ContourDeploymentRuntimeSettingsEnvoyListener>,
    /// Logging defines how Envoy's logs can be configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logging: Option<ContourDeploymentRuntimeSettingsEnvoyLogging>,
    /// Metrics defines the endpoint Envoy uses to serve metrics.
    /// Contour's default is { address: "0.0.0.0", port: 8002 }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<ContourDeploymentRuntimeSettingsEnvoyMetrics>,
    /// Network holds various configurable Envoy network values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<ContourDeploymentRuntimeSettingsEnvoyNetwork>,
    /// Service holds Envoy service parameters for setting Ingress status.
    /// Contour's default is { namespace: "projectcontour", name: "envoy" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<ContourDeploymentRuntimeSettingsEnvoyService>,
    /// Timeouts holds various configurable timeouts that can
    /// be set in the config file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeouts: Option<ContourDeploymentRuntimeSettingsEnvoyTimeouts>,
}

/// ClientCertificate defines the namespace/name of the Kubernetes
/// secret containing the client certificate and private key
/// to be used when establishing TLS connection to upstream
/// cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyClientCertificate {
    pub name: String,
    pub namespace: String,
}

/// Cluster holds various configurable Envoy cluster values that can
/// be set in the config file.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyCluster {
    /// GlobalCircuitBreakerDefaults specifies default circuit breaker budget across all services.
    /// If defined, this will be used as the default for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "circuitBreakers")]
    pub circuit_breakers: Option<ContourDeploymentRuntimeSettingsEnvoyClusterCircuitBreakers>,
    /// DNSLookupFamily defines how external names are looked up
    /// When configured as V4, the DNS resolver will only perform a lookup
    /// for addresses in the IPv4 family. If V6 is configured, the DNS resolver
    /// will only perform a lookup for addresses in the IPv6 family.
    /// If AUTO is configured, the DNS resolver will first perform a lookup
    /// for addresses in the IPv6 family and fallback to a lookup for addresses
    /// in the IPv4 family. If ALL is specified, the DNS resolver will perform a lookup for
    /// both IPv4 and IPv6 families, and return all resolved addresses.
    /// When this is used, Happy Eyeballs will be enabled for upstream connections.
    /// Refer to Happy Eyeballs Support for more information.
    /// Note: This only applies to externalName clusters.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily
    /// for more information.
    /// Values: `auto` (default), `v4`, `v6`, `all`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsLookupFamily")]
    pub dns_lookup_family: Option<String>,
    /// Defines the maximum requests for upstream connections. If not specified, there is no limit.
    /// see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-msg-config-core-v3-httpprotocoloptions
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    /// Defines the soft limit on size of the cluster’s new connection read and write buffers in bytes.
    /// If unspecified, an implementation defined default is applied (1MiB).
    /// see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-per-connection-buffer-limit-bytes
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "per-connection-buffer-limit-bytes")]
    pub per_connection_buffer_limit_bytes: Option<i32>,
    /// UpstreamTLS contains the TLS policy parameters for upstream connections
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upstreamTLS")]
    pub upstream_tls: Option<ContourDeploymentRuntimeSettingsEnvoyClusterUpstreamTls>,
}

/// GlobalCircuitBreakerDefaults specifies default circuit breaker budget across all services.
/// If defined, this will be used as the default for all services.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyClusterCircuitBreakers {
    /// The maximum number of connections that a single Envoy instance allows to the Kubernetes Service; defaults to 1024.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// The maximum number of pending requests that a single Envoy instance allows to the Kubernetes Service; defaults to 1024.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPendingRequests")]
    pub max_pending_requests: Option<i32>,
    /// The maximum parallel requests a single Envoy instance allows to the Kubernetes Service; defaults to 1024
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequests")]
    pub max_requests: Option<i32>,
    /// The maximum number of parallel retries a single Envoy instance allows to the Kubernetes Service; defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
}

/// UpstreamTLS contains the TLS policy parameters for upstream connections
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyClusterUpstreamTls {
    /// CipherSuites defines the TLS ciphers to be supported by Envoy TLS
    /// listeners when negotiating TLS 1.2. Ciphers are validated against the
    /// set that Envoy supports by default. This parameter should only be used
    /// by advanced users. Note that these will be ignored when TLS 1.3 is in
    /// use.
    /// This field is optional; when it is undefined, a Contour-managed ciphersuite list
    /// will be used, which may be updated to keep it secure.
    /// Contour's default list is:
    ///   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"
    ///   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"
    ///   - "ECDHE-ECDSA-AES256-GCM-SHA384"
    ///   - "ECDHE-RSA-AES256-GCM-SHA384"
    /// Ciphers provided are validated against the following list:
    ///   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"
    ///   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"
    ///   - "ECDHE-ECDSA-AES128-GCM-SHA256"
    ///   - "ECDHE-RSA-AES128-GCM-SHA256"
    ///   - "ECDHE-ECDSA-AES128-SHA"
    ///   - "ECDHE-RSA-AES128-SHA"
    ///   - "AES128-GCM-SHA256"
    ///   - "AES128-SHA"
    ///   - "ECDHE-ECDSA-AES256-GCM-SHA384"
    ///   - "ECDHE-RSA-AES256-GCM-SHA384"
    ///   - "ECDHE-ECDSA-AES256-SHA"
    ///   - "ECDHE-RSA-AES256-SHA"
    ///   - "AES256-GCM-SHA384"
    ///   - "AES256-SHA"
    /// Contour recommends leaving this undefined unless you are sure you must.
    /// See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters
    /// Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cipherSuites")]
    pub cipher_suites: Option<Vec<String>>,
    /// MaximumProtocolVersion is the maximum TLS version this vhost should
    /// negotiate.
    /// Values: `1.2`, `1.3`(default).
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumProtocolVersion")]
    pub maximum_protocol_version: Option<String>,
    /// MinimumProtocolVersion is the minimum TLS version this vhost should
    /// negotiate.
    /// Values: `1.2` (default), `1.3`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumProtocolVersion")]
    pub minimum_protocol_version: Option<String>,
}

/// Health defines the endpoint Envoy uses to serve health checks.
/// Contour's default is { address: "0.0.0.0", port: 8002 }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyHealth {
    /// Defines the health address interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the health port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Defines the HTTP Listener for Envoy.
/// Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyHttp {
    /// AccessLog defines where Envoy logs are outputted for this listener.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLog")]
    pub access_log: Option<String>,
    /// Defines an Envoy Listener Address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines an Envoy listener Port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Defines the HTTPS Listener for Envoy.
/// Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyHttps {
    /// AccessLog defines where Envoy logs are outputted for this listener.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLog")]
    pub access_log: Option<String>,
    /// Defines an Envoy Listener Address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines an Envoy listener Port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Listener hold various configurable Envoy listener values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyListener {
    /// ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig
    /// for more information.
    /// Values: (empty string): use the default ConnectionBalancer, `exact`: use the Exact ConnectionBalancer.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionBalancer")]
    pub connection_balancer: Option<String>,
    /// DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to
    /// strip the "Content-Length" header if "Transfer-Encoding: chunked" is
    /// also set. This is an emergency off-switch to revert back to Envoy's
    /// default behavior in case of failures. Please file an issue if failures
    /// are encountered.
    /// See: https://github.com/projectcontour/contour/issues/3221
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableAllowChunkedLength")]
    pub disable_allow_chunked_length: Option<bool>,
    /// DisableMergeSlashes disables Envoy's non-standard merge_slashes path transformation option
    /// which strips duplicate slashes from request URL paths.
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableMergeSlashes")]
    pub disable_merge_slashes: Option<bool>,
    /// Defines the value for SETTINGS_MAX_CONCURRENT_STREAMS Envoy will advertise in the
    /// SETTINGS frame in HTTP/2 connections and the limit for concurrent streams allowed
    /// for a peer on a single HTTP/2 connection. It is recommended to not set this lower
    /// than 100 but this field can be used to bound resource usage by HTTP/2 connections
    /// and mitigate attacks like CVE-2023-44487. The default value when this is not set is
    /// unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpMaxConcurrentStreams")]
    pub http_max_concurrent_streams: Option<i32>,
    /// Defines the limit on number of active connections to a listener. The limit is applied
    /// per listener. The default value when this is not set is unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionsPerListener")]
    pub max_connections_per_listener: Option<i32>,
    /// Defines the maximum requests for downstream connections. If not specified, there is no limit.
    /// see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-msg-config-core-v3-httpprotocoloptions
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    /// Defines the limit on number of HTTP requests that Envoy will process from a single
    /// connection in a single I/O cycle. Requests over this limit are processed in subsequent
    /// I/O cycles. Can be used as a mitigation for CVE-2023-44487 when abusive traffic is
    /// detected. Configures the http.max_requests_per_io_cycle Envoy runtime setting. The default
    /// value when this is not set is no limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerIOCycle")]
    pub max_requests_per_io_cycle: Option<i32>,
    /// Defines the soft limit on size of the listener’s new connection read and write buffers in bytes.
    /// If unspecified, an implementation defined default is applied (1MiB).
    /// see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#envoy-v3-api-field-config-listener-v3-listener-per-connection-buffer-limit-bytes
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "per-connection-buffer-limit-bytes")]
    pub per_connection_buffer_limit_bytes: Option<i32>,
    /// Defines the action to be applied to the Server header on the response path.
    /// When configured as overwrite, overwrites any Server header with "envoy".
    /// When configured as append_if_absent, if a Server header is present, pass it through, otherwise set it to "envoy".
    /// When configured as pass_through, pass through the value of the Server header, and do not append a header if none is present.
    /// Values: `overwrite` (default), `append_if_absent`, `pass_through`
    /// Other values will produce an error.
    /// Contour's default is overwrite.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverHeaderTransformation")]
    pub server_header_transformation: Option<String>,
    /// SocketOptions defines configurable socket options for the listeners.
    /// Single set of options are applied to all listeners.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "socketOptions")]
    pub socket_options: Option<ContourDeploymentRuntimeSettingsEnvoyListenerSocketOptions>,
    /// TLS holds various configurable Envoy TLS listener values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ContourDeploymentRuntimeSettingsEnvoyListenerTls>,
    /// Use PROXY protocol for all listeners.
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useProxyProtocol")]
    pub use_proxy_protocol: Option<bool>,
}

/// SocketOptions defines configurable socket options for the listeners.
/// Single set of options are applied to all listeners.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyListenerSocketOptions {
    /// Defines the value for IPv4 TOS field (including 6 bit DSCP field) for IP packets originating from Envoy listeners.
    /// Single value is applied to all listeners.
    /// If listeners are bound to IPv6-only addresses, setting this option will cause an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tos: Option<i32>,
    /// Defines the value for IPv6 Traffic Class field (including 6 bit DSCP field) for IP packets originating from the Envoy listeners.
    /// Single value is applied to all listeners.
    /// If listeners are bound to IPv4-only addresses, setting this option will cause an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trafficClass")]
    pub traffic_class: Option<i32>,
}

/// TLS holds various configurable Envoy TLS listener values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyListenerTls {
    /// CipherSuites defines the TLS ciphers to be supported by Envoy TLS
    /// listeners when negotiating TLS 1.2. Ciphers are validated against the
    /// set that Envoy supports by default. This parameter should only be used
    /// by advanced users. Note that these will be ignored when TLS 1.3 is in
    /// use.
    /// This field is optional; when it is undefined, a Contour-managed ciphersuite list
    /// will be used, which may be updated to keep it secure.
    /// Contour's default list is:
    ///   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"
    ///   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"
    ///   - "ECDHE-ECDSA-AES256-GCM-SHA384"
    ///   - "ECDHE-RSA-AES256-GCM-SHA384"
    /// Ciphers provided are validated against the following list:
    ///   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"
    ///   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"
    ///   - "ECDHE-ECDSA-AES128-GCM-SHA256"
    ///   - "ECDHE-RSA-AES128-GCM-SHA256"
    ///   - "ECDHE-ECDSA-AES128-SHA"
    ///   - "ECDHE-RSA-AES128-SHA"
    ///   - "AES128-GCM-SHA256"
    ///   - "AES128-SHA"
    ///   - "ECDHE-ECDSA-AES256-GCM-SHA384"
    ///   - "ECDHE-RSA-AES256-GCM-SHA384"
    ///   - "ECDHE-ECDSA-AES256-SHA"
    ///   - "ECDHE-RSA-AES256-SHA"
    ///   - "AES256-GCM-SHA384"
    ///   - "AES256-SHA"
    /// Contour recommends leaving this undefined unless you are sure you must.
    /// See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters
    /// Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cipherSuites")]
    pub cipher_suites: Option<Vec<String>>,
    /// MaximumProtocolVersion is the maximum TLS version this vhost should
    /// negotiate.
    /// Values: `1.2`, `1.3`(default).
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumProtocolVersion")]
    pub maximum_protocol_version: Option<String>,
    /// MinimumProtocolVersion is the minimum TLS version this vhost should
    /// negotiate.
    /// Values: `1.2` (default), `1.3`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumProtocolVersion")]
    pub minimum_protocol_version: Option<String>,
}

/// Logging defines how Envoy's logs can be configured.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyLogging {
    /// AccessLogFormat sets the global access log format.
    /// Values: `envoy` (default), `json`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLogFormat")]
    pub access_log_format: Option<String>,
    /// AccessLogFormatString sets the access log format when format is set to `envoy`.
    /// When empty, Envoy's default format is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLogFormatString")]
    pub access_log_format_string: Option<String>,
    /// AccessLogJSONFields sets the fields that JSON logging will
    /// output when AccessLogFormat is json.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLogJSONFields")]
    pub access_log_json_fields: Option<Vec<String>>,
    /// AccessLogLevel sets the verbosity level of the access log.
    /// Values: `info` (default, all requests are logged), `error` (all non-success requests, i.e. 300+ response code, are logged), `critical` (all 5xx requests are logged) and `disabled`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLogLevel")]
    pub access_log_level: Option<String>,
}

/// Metrics defines the endpoint Envoy uses to serve metrics.
/// Contour's default is { address: "0.0.0.0", port: 8002 }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyMetrics {
    /// Defines the metrics address interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the metrics port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// TLS holds TLS file config details.
    /// Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ContourDeploymentRuntimeSettingsEnvoyMetricsTls>,
}

/// TLS holds TLS file config details.
/// Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyMetricsTls {
    /// CA filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Client certificate filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Client key filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
}

/// Network holds various configurable Envoy network values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyNetwork {
    /// Configure the port used to access the Envoy Admin interface.
    /// If configured to port "0" then the admin interface is disabled.
    /// Contour's default is 9001.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminPort")]
    pub admin_port: Option<i64>,
    /// XffNumTrustedHops defines the number of additional ingress proxy hops from the
    /// right side of the x-forwarded-for HTTP header to trust when determining the origin
    /// client’s IP address.
    /// See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops
    /// for more information.
    /// Contour's default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numTrustedHops")]
    pub num_trusted_hops: Option<i32>,
}

/// Service holds Envoy service parameters for setting Ingress status.
/// Contour's default is { namespace: "projectcontour", name: "envoy" }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyService {
    pub name: String,
    pub namespace: String,
}

/// Timeouts holds various configurable timeouts that can
/// be set in the config file.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsEnvoyTimeouts {
    /// ConnectTimeout defines how long the proxy should wait when establishing connection to upstream service.
    /// If not set, a default value of 2 seconds will be used.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-connect-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// ConnectionIdleTimeout defines how long the proxy should wait while there are
    /// no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating
    /// an HTTP connection. Set to "infinity" to disable the timeout entirely.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionIdleTimeout")]
    pub connection_idle_timeout: Option<String>,
    /// ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an
    /// initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection.
    /// During this grace period, the proxy will continue to respond to new streams. After the final
    /// GOAWAY frame has been sent, the proxy will refuse new streams.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionShutdownGracePeriod")]
    pub connection_shutdown_grace_period: Option<String>,
    /// DelayedCloseTimeout defines how long envoy will wait, once connection
    /// close processing has been initiated, for the downstream peer to close
    /// the connection before Envoy closes the socket associated with the connection.
    /// Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0'
    /// in Envoy. Leaving it unset will result in the Envoy default value being used.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "delayedCloseTimeout")]
    pub delayed_close_timeout: Option<String>,
    /// MaxConnectionDuration defines the maximum period of time after an HTTP connection
    /// has been established from the client to the proxy before it is closed by the proxy,
    /// regardless of whether there has been activity or not. Omit or set to "infinity" for
    /// no max duration.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionDuration")]
    pub max_connection_duration: Option<String>,
    /// RequestTimeout sets the client request timeout globally for Contour. Note that
    /// this is a timeout for the entire request, not an idle timeout. Omit or set to
    /// "infinity" to disable the timeout entirely.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestTimeout")]
    pub request_timeout: Option<String>,
    /// StreamIdleTimeout defines how long the proxy should wait while there is no
    /// request activity (for HTTP/1.1) or stream activity (for HTTP/2) before
    /// terminating the HTTP request or stream. Set to "infinity" to disable the
    /// timeout entirely.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamIdleTimeout")]
    pub stream_idle_timeout: Option<String>,
}

/// Gateway contains parameters for the gateway-api Gateway that Contour
/// is configured to serve traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsGateway {
    /// GatewayRef defines the specific Gateway that this Contour
    /// instance corresponds to.
    #[serde(rename = "gatewayRef")]
    pub gateway_ref: ContourDeploymentRuntimeSettingsGatewayGatewayRef,
}

/// GatewayRef defines the specific Gateway that this Contour
/// instance corresponds to.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsGatewayGatewayRef {
    pub name: String,
    pub namespace: String,
}

/// GlobalExternalAuthorization allows envoys external authorization filter
/// to be enabled for all virtual hosts.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsGlobalExtAuth {
    /// AuthPolicy sets a default authorization policy for client requests.
    /// This policy will be used unless overridden by individual routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authPolicy")]
    pub auth_policy: Option<ContourDeploymentRuntimeSettingsGlobalExtAuthAuthPolicy>,
    /// ExtensionServiceRef specifies the extension resource that will authorize client requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extensionRef")]
    pub extension_ref: Option<ContourDeploymentRuntimeSettingsGlobalExtAuthExtensionRef>,
    /// If FailOpen is true, the client request is forwarded to the upstream service
    /// even if the authorization server fails to respond. This field should not be
    /// set in most cases. It is intended for use only while migrating applications
    /// from internal authorization to Contour external authorization.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOpen")]
    pub fail_open: Option<bool>,
    /// ResponseTimeout configures maximum time to wait for a check response from the authorization server.
    /// Timeout durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).
    /// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    /// The string "infinity" is also a valid input and specifies no timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseTimeout")]
    pub response_timeout: Option<String>,
    /// WithRequestBody specifies configuration for sending the client request's body to authorization server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withRequestBody")]
    pub with_request_body: Option<ContourDeploymentRuntimeSettingsGlobalExtAuthWithRequestBody>,
}

/// AuthPolicy sets a default authorization policy for client requests.
/// This policy will be used unless overridden by individual routes.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsGlobalExtAuthAuthPolicy {
    /// Context is a set of key/value pairs that are sent to the
    /// authentication server in the check request. If a context
    /// is provided at an enclosing scope, the entries are merged
    /// such that the inner scope overrides matching keys from the
    /// outer scope.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<BTreeMap<String, String>>,
    /// When true, this field disables client request authentication
    /// for the scope of the policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// ExtensionServiceRef specifies the extension resource that will authorize client requests.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsGlobalExtAuthExtensionRef {
    /// API version of the referent.
    /// If this field is not specified, the default "projectcontour.io/v1alpha1" will be used
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// If this field is not specifies, the namespace of the resource that targets the referent will be used.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// WithRequestBody specifies configuration for sending the client request's body to authorization server.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsGlobalExtAuthWithRequestBody {
    /// If AllowPartialMessage is true, then Envoy will buffer the body until MaxRequestBytes are reached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPartialMessage")]
    pub allow_partial_message: Option<bool>,
    /// MaxRequestBytes sets the maximum size of message body ExtAuthz filter will hold in-memory.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestBytes")]
    pub max_request_bytes: Option<i32>,
    /// If PackAsBytes is true, the body sent to Authorization Server is in raw bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "packAsBytes")]
    pub pack_as_bytes: Option<bool>,
}

/// Health defines the endpoints Contour uses to serve health checks.
/// Contour's default is { address: "0.0.0.0", port: 8000 }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsHealth {
    /// Defines the health address interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the health port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// HTTPProxy defines parameters on HTTPProxy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsHttpproxy {
    /// DisablePermitInsecure disables the use of the
    /// permitInsecure field in HTTPProxy.
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disablePermitInsecure")]
    pub disable_permit_insecure: Option<bool>,
    /// FallbackCertificate defines the namespace/name of the Kubernetes secret to
    /// use as fallback when a non-SNI request is received.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fallbackCertificate")]
    pub fallback_certificate: Option<ContourDeploymentRuntimeSettingsHttpproxyFallbackCertificate>,
    /// Restrict Contour to searching these namespaces for root ingress routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootNamespaces")]
    pub root_namespaces: Option<Vec<String>>,
}

/// FallbackCertificate defines the namespace/name of the Kubernetes secret to
/// use as fallback when a non-SNI request is received.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsHttpproxyFallbackCertificate {
    pub name: String,
    pub namespace: String,
}

/// Ingress contains parameters for ingress options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsIngress {
    /// Ingress Class Names Contour should use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classNames")]
    pub class_names: Option<Vec<String>>,
    /// Address to set in Ingress object status.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusAddress")]
    pub status_address: Option<String>,
}

/// Metrics defines the endpoint Contour uses to serve metrics.
/// Contour's default is { address: "0.0.0.0", port: 8000 }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsMetrics {
    /// Defines the metrics address interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the metrics port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// TLS holds TLS file config details.
    /// Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ContourDeploymentRuntimeSettingsMetricsTls>,
}

/// TLS holds TLS file config details.
/// Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsMetricsTls {
    /// CA filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Client certificate filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Client key filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
}

/// Policy specifies default policy applied if not overridden by the user
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsPolicy {
    /// ApplyToIngress determines if the Policies will apply to ingress objects
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applyToIngress")]
    pub apply_to_ingress: Option<bool>,
    /// RequestHeadersPolicy defines the request headers set/removed on all routes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaders")]
    pub request_headers: Option<ContourDeploymentRuntimeSettingsPolicyRequestHeaders>,
    /// ResponseHeadersPolicy defines the response headers set/removed on all routes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeaders")]
    pub response_headers: Option<ContourDeploymentRuntimeSettingsPolicyResponseHeaders>,
}

/// RequestHeadersPolicy defines the request headers set/removed on all routes
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsPolicyRequestHeaders {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<BTreeMap<String, String>>,
}

/// ResponseHeadersPolicy defines the response headers set/removed on all routes
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsPolicyResponseHeaders {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<BTreeMap<String, String>>,
}

/// RateLimitService optionally holds properties of the Rate Limit Service
/// to be used for global rate limiting.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitService {
    /// DefaultGlobalRateLimitPolicy allows setting a default global rate limit policy for every HTTPProxy.
    /// HTTPProxy can overwrite this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultGlobalRateLimitPolicy")]
    pub default_global_rate_limit_policy: Option<ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicy>,
    /// Domain is passed to the Rate Limit Service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    /// EnableResourceExhaustedCode enables translating error code 429 to
    /// grpc code RESOURCE_EXHAUSTED. When disabled it's translated to UNAVAILABLE
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableResourceExhaustedCode")]
    pub enable_resource_exhausted_code: Option<bool>,
    /// EnableXRateLimitHeaders defines whether to include the X-RateLimit
    /// headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset
    /// (as defined by the IETF Internet-Draft linked below), on responses
    /// to clients when the Rate Limit Service is consulted for a request.
    /// ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableXRateLimitHeaders")]
    pub enable_x_rate_limit_headers: Option<bool>,
    /// ExtensionService identifies the extension service defining the RLS.
    #[serde(rename = "extensionService")]
    pub extension_service: ContourDeploymentRuntimeSettingsRateLimitServiceExtensionService,
    /// FailOpen defines whether to allow requests to proceed when the
    /// Rate Limit Service fails to respond with a valid rate limit
    /// decision within the timeout defined on the extension service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOpen")]
    pub fail_open: Option<bool>,
}

/// DefaultGlobalRateLimitPolicy allows setting a default global rate limit policy for every HTTPProxy.
/// HTTPProxy can overwrite this configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicy {
    /// Descriptors defines the list of descriptors that will
    /// be generated and sent to the rate limit service. Each
    /// descriptor contains 1+ key-value pair entries.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub descriptors: Option<Vec<ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptors>>,
    /// Disabled configures the HTTPProxy to not use
    /// the default global rate limit policy defined by the Contour configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// RateLimitDescriptor defines a list of key-value pair generators.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptors {
    /// Entries is the list of key-value pair generators.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<Vec<ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntries>>,
}

/// RateLimitDescriptorEntry is a key-value pair generator. Exactly
/// one field on this struct must be non-nil.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntries {
    /// GenericKey defines a descriptor entry with a static key and value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "genericKey")]
    pub generic_key: Option<ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesGenericKey>,
    /// RemoteAddress defines a descriptor entry with a key of "remote_address"
    /// and a value equal to the client's IP address (from x-forwarded-for).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteAddress")]
    pub remote_address: Option<ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRemoteAddress>,
    /// RequestHeader defines a descriptor entry that's populated only if
    /// a given header is present on the request. The descriptor key is static,
    /// and the descriptor value is equal to the value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeader")]
    pub request_header: Option<ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeader>,
    /// RequestHeaderValueMatch defines a descriptor entry that's populated
    /// if the request's headers match a set of 1+ match criteria. The
    /// descriptor key is "header_match", and the descriptor value is static.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaderValueMatch")]
    pub request_header_value_match: Option<ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeaderValueMatch>,
}

/// GenericKey defines a descriptor entry with a static key and value.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesGenericKey {
    /// Key defines the key of the descriptor entry. If not set, the
    /// key is set to "generic_key".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value defines the value of the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// RemoteAddress defines a descriptor entry with a key of "remote_address"
/// and a value equal to the client's IP address (from x-forwarded-for).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRemoteAddress {
}

/// RequestHeader defines a descriptor entry that's populated only if
/// a given header is present on the request. The descriptor key is static,
/// and the descriptor value is equal to the value of the header.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeader {
    /// DescriptorKey defines the key to use on the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "descriptorKey")]
    pub descriptor_key: Option<String>,
    /// HeaderName defines the name of the header to look for on the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    pub header_name: Option<String>,
}

/// RequestHeaderValueMatch defines a descriptor entry that's populated
/// if the request's headers match a set of 1+ match criteria. The
/// descriptor key is "header_match", and the descriptor value is static.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeaderValueMatch {
    /// ExpectMatch defines whether the request must positively match the match
    /// criteria in order to generate a descriptor entry (i.e. true), or not
    /// match the match criteria in order to generate a descriptor entry (i.e. false).
    /// The default is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectMatch")]
    pub expect_match: Option<bool>,
    /// Headers is a list of 1+ match criteria to apply against the request
    /// to determine whether to populate the descriptor entry or not.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeaderValueMatchHeaders>>,
    /// Value defines the value of the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HeaderMatchCondition specifies how to conditionally match against HTTP
/// headers. The Name field is required, only one of Present, NotPresent,
/// Contains, NotContains, Exact, NotExact and Regex can be set.
/// For negative matching rules only (e.g. NotContains or NotExact) you can set
/// TreatMissingAsEmpty.
/// IgnoreCase has no effect for Regex.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeaderValueMatchHeaders {
    /// Contains specifies a substring that must be present in
    /// the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// Exact specifies a string that the header value must be equal to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// IgnoreCase specifies that string matching should be case insensitive.
    /// Note that this has no effect on the Regex parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    pub ignore_case: Option<bool>,
    /// Name is the name of the header to match against. Name is required.
    /// Header names are case insensitive.
    pub name: String,
    /// NotContains specifies a substring that must not be present
    /// in the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notcontains: Option<String>,
    /// NoExact specifies a string that the header value must not be
    /// equal to. The condition is true if the header has any other value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notexact: Option<String>,
    /// NotPresent specifies that condition is true when the named header
    /// is not present. Note that setting NotPresent to false does not
    /// make the condition true if the named header is present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notpresent: Option<bool>,
    /// Present specifies that condition is true when the named header
    /// is present, regardless of its value. Note that setting Present
    /// to false does not make the condition true if the named header
    /// is absent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub present: Option<bool>,
    /// Regex specifies a regular expression pattern that must match the header
    /// value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// TreatMissingAsEmpty specifies if the header match rule specified header
    /// does not exist, this header value will be treated as empty. Defaults to false.
    /// Unlike the underlying Envoy implementation this is **only** supported for
    /// negative matches (e.g. NotContains, NotExact).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "treatMissingAsEmpty")]
    pub treat_missing_as_empty: Option<bool>,
}

/// ExtensionService identifies the extension service defining the RLS.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsRateLimitServiceExtensionService {
    pub name: String,
    pub namespace: String,
}

/// Tracing defines properties for exporting trace data to OpenTelemetry.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsTracing {
    /// CustomTags defines a list of custom tags with unique tag name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customTags")]
    pub custom_tags: Option<Vec<ContourDeploymentRuntimeSettingsTracingCustomTags>>,
    /// ExtensionService identifies the extension service defining the otel-collector.
    #[serde(rename = "extensionService")]
    pub extension_service: ContourDeploymentRuntimeSettingsTracingExtensionService,
    /// IncludePodDetail defines a flag.
    /// If it is true, contour will add the pod name and namespace to the span of the trace.
    /// the default is true.
    /// Note: The Envoy pods MUST have the HOSTNAME and CONTOUR_NAMESPACE environment variables set for this to work properly.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includePodDetail")]
    pub include_pod_detail: Option<bool>,
    /// MaxPathTagLength defines maximum length of the request path
    /// to extract and include in the HttpUrl tag.
    /// contour's default is 256.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPathTagLength")]
    pub max_path_tag_length: Option<i32>,
    /// OverallSampling defines the sampling rate of trace data.
    /// contour's default is 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "overallSampling")]
    pub overall_sampling: Option<String>,
    /// ServiceName defines the name for the service.
    /// contour's default is contour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

/// CustomTag defines custom tags with unique tag name
/// to create tags for the active span.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsTracingCustomTags {
    /// Literal is a static custom tag value.
    /// Precisely one of Literal, RequestHeaderName must be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub literal: Option<String>,
    /// RequestHeaderName indicates which request header
    /// the label value is obtained from.
    /// Precisely one of Literal, RequestHeaderName must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaderName")]
    pub request_header_name: Option<String>,
    /// TagName is the unique name of the custom tag.
    #[serde(rename = "tagName")]
    pub tag_name: String,
}

/// ExtensionService identifies the extension service defining the otel-collector.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsTracingExtensionService {
    pub name: String,
    pub namespace: String,
}

/// XDSServer contains parameters for the xDS server.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsXdsServer {
    /// Defines the xDS gRPC API address which Contour will serve.
    /// Contour's default is "0.0.0.0".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the xDS gRPC API port which Contour will serve.
    /// Contour's default is 8001.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// TLS holds TLS file config details.
    /// Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ContourDeploymentRuntimeSettingsXdsServerTls>,
    /// Defines the XDSServer to use for `contour serve`.
    /// Values: `envoy` (default), `contour (deprecated)`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// TLS holds TLS file config details.
/// Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentRuntimeSettingsXdsServerTls {
    /// CA filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Client certificate filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Allow serving the xDS gRPC API without TLS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// Client key filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
}

/// ContourDeploymentStatus defines the observed state of a ContourDeployment resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourDeploymentStatus {
    /// Conditions describe the current conditions of the ContourDeployment resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

