// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/projectcontour/contour/projectcontour.io/v1alpha1/contourconfigurations.yaml --derive=PartialEq
// kopium version: 0.17.2

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;

/// ContourConfigurationSpec represents a configuration of a Contour controller.
/// It contains most of all the options that can be customized, the
/// other remaining options being command line flags.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "projectcontour.io", version = "v1alpha1", kind = "ContourConfiguration", plural = "contourconfigurations")]
#[kube(namespaced)]
#[kube(status = "ContourConfigurationStatus")]
#[kube(schema = "disabled")]
pub struct ContourConfigurationSpec {
    /// Debug contains parameters to enable debug logging
    /// and debug interfaces inside Contour.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debug: Option<ContourConfigurationDebug>,
    /// EnableExternalNameService allows processing of ExternalNameServices
    /// Contour's default is false for security reasons.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableExternalNameService")]
    pub enable_external_name_service: Option<bool>,
    /// Envoy contains parameters for Envoy as well
    /// as how to optionally configure a managed Envoy fleet.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub envoy: Option<ContourConfigurationEnvoy>,
    /// FeatureFlags defines toggle to enable new contour features.
    /// Available toggles are:
    /// useEndpointSlices - Configures contour to fetch endpoint data
    /// from k8s endpoint slices. defaults to true,
    /// If false then reads endpoint data from the k8s endpoints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "featureFlags")]
    pub feature_flags: Option<Vec<String>>,
    /// Gateway contains parameters for the gateway-api Gateway that Contour
    /// is configured to serve traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<ContourConfigurationGateway>,
    /// GlobalExternalAuthorization allows envoys external authorization filter
    /// to be enabled for all virtual hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalExtAuth")]
    pub global_ext_auth: Option<ContourConfigurationGlobalExtAuth>,
    /// Health defines the endpoints Contour uses to serve health checks.
    /// Contour's default is { address: "0.0.0.0", port: 8000 }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health: Option<ContourConfigurationHealth>,
    /// HTTPProxy defines parameters on HTTPProxy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub httpproxy: Option<ContourConfigurationHttpproxy>,
    /// Ingress contains parameters for ingress options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<ContourConfigurationIngress>,
    /// Metrics defines the endpoint Contour uses to serve metrics.
    /// Contour's default is { address: "0.0.0.0", port: 8000 }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<ContourConfigurationMetrics>,
    /// Policy specifies default policy applied if not overridden by the user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ContourConfigurationPolicy>,
    /// RateLimitService optionally holds properties of the Rate Limit Service
    /// to be used for global rate limiting.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitService")]
    pub rate_limit_service: Option<ContourConfigurationRateLimitService>,
    /// Tracing defines properties for exporting trace data to OpenTelemetry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tracing: Option<ContourConfigurationTracing>,
    /// XDSServer contains parameters for the xDS server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "xdsServer")]
    pub xds_server: Option<ContourConfigurationXdsServer>,
}

/// Debug contains parameters to enable debug logging
/// and debug interfaces inside Contour.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationDebug {
    /// Defines the Contour debug address interface.
    /// Contour's default is "127.0.0.1".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the Contour debug address port.
    /// Contour's default is 6060.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Envoy contains parameters for Envoy as well
/// as how to optionally configure a managed Envoy fleet.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoy {
    /// ClientCertificate defines the namespace/name of the Kubernetes
    /// secret containing the client certificate and private key
    /// to be used when establishing TLS connection to upstream
    /// cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificate")]
    pub client_certificate: Option<ContourConfigurationEnvoyClientCertificate>,
    /// Cluster holds various configurable Envoy cluster values that can
    /// be set in the config file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<ContourConfigurationEnvoyCluster>,
    /// DefaultHTTPVersions defines the default set of HTTPS
    /// versions the proxy should accept. HTTP versions are
    /// strings of the form "HTTP/xx". Supported versions are
    /// "HTTP/1.1" and "HTTP/2".
    /// Values: `HTTP/1.1`, `HTTP/2` (default: both).
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultHTTPVersions")]
    pub default_http_versions: Option<Vec<String>>,
    /// Health defines the endpoint Envoy uses to serve health checks.
    /// Contour's default is { address: "0.0.0.0", port: 8002 }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health: Option<ContourConfigurationEnvoyHealth>,
    /// Defines the HTTP Listener for Envoy.
    /// Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ContourConfigurationEnvoyHttp>,
    /// Defines the HTTPS Listener for Envoy.
    /// Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub https: Option<ContourConfigurationEnvoyHttps>,
    /// Listener hold various configurable Envoy listener values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<ContourConfigurationEnvoyListener>,
    /// Logging defines how Envoy's logs can be configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logging: Option<ContourConfigurationEnvoyLogging>,
    /// Metrics defines the endpoint Envoy uses to serve metrics.
    /// Contour's default is { address: "0.0.0.0", port: 8002 }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<ContourConfigurationEnvoyMetrics>,
    /// Network holds various configurable Envoy network values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network: Option<ContourConfigurationEnvoyNetwork>,
    /// Service holds Envoy service parameters for setting Ingress status.
    /// Contour's default is { namespace: "projectcontour", name: "envoy" }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<ContourConfigurationEnvoyService>,
    /// Timeouts holds various configurable timeouts that can
    /// be set in the config file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeouts: Option<ContourConfigurationEnvoyTimeouts>,
}

/// ClientCertificate defines the namespace/name of the Kubernetes
/// secret containing the client certificate and private key
/// to be used when establishing TLS connection to upstream
/// cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyClientCertificate {
    pub name: String,
    pub namespace: String,
}

/// Cluster holds various configurable Envoy cluster values that can
/// be set in the config file.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyCluster {
    /// GlobalCircuitBreakerDefaults specifies default circuit breaker budget across all services.
    /// If defined, this will be used as the default for all services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "circuitBreakers")]
    pub circuit_breakers: Option<ContourConfigurationEnvoyClusterCircuitBreakers>,
    /// DNSLookupFamily defines how external names are looked up
    /// When configured as V4, the DNS resolver will only perform a lookup
    /// for addresses in the IPv4 family. If V6 is configured, the DNS resolver
    /// will only perform a lookup for addresses in the IPv6 family.
    /// If AUTO is configured, the DNS resolver will first perform a lookup
    /// for addresses in the IPv6 family and fallback to a lookup for addresses
    /// in the IPv4 family. If ALL is specified, the DNS resolver will perform a lookup for
    /// both IPv4 and IPv6 families, and return all resolved addresses.
    /// When this is used, Happy Eyeballs will be enabled for upstream connections.
    /// Refer to Happy Eyeballs Support for more information.
    /// Note: This only applies to externalName clusters.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily
    /// for more information.
    /// Values: `auto` (default), `v4`, `v6`, `all`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsLookupFamily")]
    pub dns_lookup_family: Option<String>,
    /// Defines the maximum requests for upstream connections. If not specified, there is no limit.
    /// see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-msg-config-core-v3-httpprotocoloptions
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    /// Defines the soft limit on size of the cluster’s new connection read and write buffers in bytes.
    /// If unspecified, an implementation defined default is applied (1MiB).
    /// see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-per-connection-buffer-limit-bytes
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "per-connection-buffer-limit-bytes")]
    pub per_connection_buffer_limit_bytes: Option<i32>,
    /// UpstreamTLS contains the TLS policy parameters for upstream connections
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upstreamTLS")]
    pub upstream_tls: Option<ContourConfigurationEnvoyClusterUpstreamTls>,
}

/// GlobalCircuitBreakerDefaults specifies default circuit breaker budget across all services.
/// If defined, this will be used as the default for all services.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyClusterCircuitBreakers {
    /// The maximum number of connections that a single Envoy instance allows to the Kubernetes Service; defaults to 1024.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnections")]
    pub max_connections: Option<i32>,
    /// The maximum number of pending requests that a single Envoy instance allows to the Kubernetes Service; defaults to 1024.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPendingRequests")]
    pub max_pending_requests: Option<i32>,
    /// The maximum parallel requests a single Envoy instance allows to the Kubernetes Service; defaults to 1024
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequests")]
    pub max_requests: Option<i32>,
    /// The maximum number of parallel retries a single Envoy instance allows to the Kubernetes Service; defaults to 3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
}

/// UpstreamTLS contains the TLS policy parameters for upstream connections
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyClusterUpstreamTls {
    /// CipherSuites defines the TLS ciphers to be supported by Envoy TLS
    /// listeners when negotiating TLS 1.2. Ciphers are validated against the
    /// set that Envoy supports by default. This parameter should only be used
    /// by advanced users. Note that these will be ignored when TLS 1.3 is in
    /// use.
    /// This field is optional; when it is undefined, a Contour-managed ciphersuite list
    /// will be used, which may be updated to keep it secure.
    /// Contour's default list is:
    ///   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"
    ///   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"
    ///   - "ECDHE-ECDSA-AES256-GCM-SHA384"
    ///   - "ECDHE-RSA-AES256-GCM-SHA384"
    /// Ciphers provided are validated against the following list:
    ///   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"
    ///   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"
    ///   - "ECDHE-ECDSA-AES128-GCM-SHA256"
    ///   - "ECDHE-RSA-AES128-GCM-SHA256"
    ///   - "ECDHE-ECDSA-AES128-SHA"
    ///   - "ECDHE-RSA-AES128-SHA"
    ///   - "AES128-GCM-SHA256"
    ///   - "AES128-SHA"
    ///   - "ECDHE-ECDSA-AES256-GCM-SHA384"
    ///   - "ECDHE-RSA-AES256-GCM-SHA384"
    ///   - "ECDHE-ECDSA-AES256-SHA"
    ///   - "ECDHE-RSA-AES256-SHA"
    ///   - "AES256-GCM-SHA384"
    ///   - "AES256-SHA"
    /// Contour recommends leaving this undefined unless you are sure you must.
    /// See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters
    /// Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cipherSuites")]
    pub cipher_suites: Option<Vec<String>>,
    /// MaximumProtocolVersion is the maximum TLS version this vhost should
    /// negotiate.
    /// Values: `1.2`, `1.3`(default).
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumProtocolVersion")]
    pub maximum_protocol_version: Option<String>,
    /// MinimumProtocolVersion is the minimum TLS version this vhost should
    /// negotiate.
    /// Values: `1.2` (default), `1.3`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumProtocolVersion")]
    pub minimum_protocol_version: Option<String>,
}

/// Health defines the endpoint Envoy uses to serve health checks.
/// Contour's default is { address: "0.0.0.0", port: 8002 }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyHealth {
    /// Defines the health address interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the health port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Defines the HTTP Listener for Envoy.
/// Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyHttp {
    /// AccessLog defines where Envoy logs are outputted for this listener.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLog")]
    pub access_log: Option<String>,
    /// Defines an Envoy Listener Address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines an Envoy listener Port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Defines the HTTPS Listener for Envoy.
/// Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyHttps {
    /// AccessLog defines where Envoy logs are outputted for this listener.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLog")]
    pub access_log: Option<String>,
    /// Defines an Envoy Listener Address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines an Envoy listener Port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Listener hold various configurable Envoy listener values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyListener {
    /// ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig
    /// for more information.
    /// Values: (empty string): use the default ConnectionBalancer, `exact`: use the Exact ConnectionBalancer.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionBalancer")]
    pub connection_balancer: Option<String>,
    /// DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to
    /// strip the "Content-Length" header if "Transfer-Encoding: chunked" is
    /// also set. This is an emergency off-switch to revert back to Envoy's
    /// default behavior in case of failures. Please file an issue if failures
    /// are encountered.
    /// See: https://github.com/projectcontour/contour/issues/3221
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableAllowChunkedLength")]
    pub disable_allow_chunked_length: Option<bool>,
    /// DisableMergeSlashes disables Envoy's non-standard merge_slashes path transformation option
    /// which strips duplicate slashes from request URL paths.
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableMergeSlashes")]
    pub disable_merge_slashes: Option<bool>,
    /// Defines the value for SETTINGS_MAX_CONCURRENT_STREAMS Envoy will advertise in the
    /// SETTINGS frame in HTTP/2 connections and the limit for concurrent streams allowed
    /// for a peer on a single HTTP/2 connection. It is recommended to not set this lower
    /// than 100 but this field can be used to bound resource usage by HTTP/2 connections
    /// and mitigate attacks like CVE-2023-44487. The default value when this is not set is
    /// unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpMaxConcurrentStreams")]
    pub http_max_concurrent_streams: Option<i32>,
    /// Defines the limit on number of active connections to a listener. The limit is applied
    /// per listener. The default value when this is not set is unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionsPerListener")]
    pub max_connections_per_listener: Option<i32>,
    /// Defines the maximum requests for downstream connections. If not specified, there is no limit.
    /// see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-msg-config-core-v3-httpprotocoloptions
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerConnection")]
    pub max_requests_per_connection: Option<i32>,
    /// Defines the limit on number of HTTP requests that Envoy will process from a single
    /// connection in a single I/O cycle. Requests over this limit are processed in subsequent
    /// I/O cycles. Can be used as a mitigation for CVE-2023-44487 when abusive traffic is
    /// detected. Configures the http.max_requests_per_io_cycle Envoy runtime setting. The default
    /// value when this is not set is no limit.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestsPerIOCycle")]
    pub max_requests_per_io_cycle: Option<i32>,
    /// Defines the soft limit on size of the listener’s new connection read and write buffers in bytes.
    /// If unspecified, an implementation defined default is applied (1MiB).
    /// see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#envoy-v3-api-field-config-listener-v3-listener-per-connection-buffer-limit-bytes
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "per-connection-buffer-limit-bytes")]
    pub per_connection_buffer_limit_bytes: Option<i32>,
    /// Defines the action to be applied to the Server header on the response path.
    /// When configured as overwrite, overwrites any Server header with "envoy".
    /// When configured as append_if_absent, if a Server header is present, pass it through, otherwise set it to "envoy".
    /// When configured as pass_through, pass through the value of the Server header, and do not append a header if none is present.
    /// Values: `overwrite` (default), `append_if_absent`, `pass_through`
    /// Other values will produce an error.
    /// Contour's default is overwrite.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverHeaderTransformation")]
    pub server_header_transformation: Option<String>,
    /// SocketOptions defines configurable socket options for the listeners.
    /// Single set of options are applied to all listeners.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "socketOptions")]
    pub socket_options: Option<ContourConfigurationEnvoyListenerSocketOptions>,
    /// TLS holds various configurable Envoy TLS listener values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ContourConfigurationEnvoyListenerTls>,
    /// Use PROXY protocol for all listeners.
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useProxyProtocol")]
    pub use_proxy_protocol: Option<bool>,
}

/// SocketOptions defines configurable socket options for the listeners.
/// Single set of options are applied to all listeners.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyListenerSocketOptions {
    /// Defines the value for IPv4 TOS field (including 6 bit DSCP field) for IP packets originating from Envoy listeners.
    /// Single value is applied to all listeners.
    /// If listeners are bound to IPv6-only addresses, setting this option will cause an error.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tos: Option<i32>,
    /// Defines the value for IPv6 Traffic Class field (including 6 bit DSCP field) for IP packets originating from the Envoy listeners.
    /// Single value is applied to all listeners.
    /// If listeners are bound to IPv4-only addresses, setting this option will cause an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trafficClass")]
    pub traffic_class: Option<i32>,
}

/// TLS holds various configurable Envoy TLS listener values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyListenerTls {
    /// CipherSuites defines the TLS ciphers to be supported by Envoy TLS
    /// listeners when negotiating TLS 1.2. Ciphers are validated against the
    /// set that Envoy supports by default. This parameter should only be used
    /// by advanced users. Note that these will be ignored when TLS 1.3 is in
    /// use.
    /// This field is optional; when it is undefined, a Contour-managed ciphersuite list
    /// will be used, which may be updated to keep it secure.
    /// Contour's default list is:
    ///   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"
    ///   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"
    ///   - "ECDHE-ECDSA-AES256-GCM-SHA384"
    ///   - "ECDHE-RSA-AES256-GCM-SHA384"
    /// Ciphers provided are validated against the following list:
    ///   - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]"
    ///   - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]"
    ///   - "ECDHE-ECDSA-AES128-GCM-SHA256"
    ///   - "ECDHE-RSA-AES128-GCM-SHA256"
    ///   - "ECDHE-ECDSA-AES128-SHA"
    ///   - "ECDHE-RSA-AES128-SHA"
    ///   - "AES128-GCM-SHA256"
    ///   - "AES128-SHA"
    ///   - "ECDHE-ECDSA-AES256-GCM-SHA384"
    ///   - "ECDHE-RSA-AES256-GCM-SHA384"
    ///   - "ECDHE-ECDSA-AES256-SHA"
    ///   - "ECDHE-RSA-AES256-SHA"
    ///   - "AES256-GCM-SHA384"
    ///   - "AES256-SHA"
    /// Contour recommends leaving this undefined unless you are sure you must.
    /// See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters
    /// Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cipherSuites")]
    pub cipher_suites: Option<Vec<String>>,
    /// MaximumProtocolVersion is the maximum TLS version this vhost should
    /// negotiate.
    /// Values: `1.2`, `1.3`(default).
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumProtocolVersion")]
    pub maximum_protocol_version: Option<String>,
    /// MinimumProtocolVersion is the minimum TLS version this vhost should
    /// negotiate.
    /// Values: `1.2` (default), `1.3`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumProtocolVersion")]
    pub minimum_protocol_version: Option<String>,
}

/// Logging defines how Envoy's logs can be configured.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyLogging {
    /// AccessLogFormat sets the global access log format.
    /// Values: `envoy` (default), `json`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLogFormat")]
    pub access_log_format: Option<String>,
    /// AccessLogFormatString sets the access log format when format is set to `envoy`.
    /// When empty, Envoy's default format is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLogFormatString")]
    pub access_log_format_string: Option<String>,
    /// AccessLogJSONFields sets the fields that JSON logging will
    /// output when AccessLogFormat is json.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLogJSONFields")]
    pub access_log_json_fields: Option<Vec<String>>,
    /// AccessLogLevel sets the verbosity level of the access log.
    /// Values: `info` (default, all requests are logged), `error` (all non-success requests, i.e. 300+ response code, are logged), `critical` (all 5xx requests are logged) and `disabled`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessLogLevel")]
    pub access_log_level: Option<String>,
}

/// Metrics defines the endpoint Envoy uses to serve metrics.
/// Contour's default is { address: "0.0.0.0", port: 8002 }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyMetrics {
    /// Defines the metrics address interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the metrics port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// TLS holds TLS file config details.
    /// Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ContourConfigurationEnvoyMetricsTls>,
}

/// TLS holds TLS file config details.
/// Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyMetricsTls {
    /// CA filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Client certificate filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Client key filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
}

/// Network holds various configurable Envoy network values.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyNetwork {
    /// Configure the port used to access the Envoy Admin interface.
    /// If configured to port "0" then the admin interface is disabled.
    /// Contour's default is 9001.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "adminPort")]
    pub admin_port: Option<i64>,
    /// XffNumTrustedHops defines the number of additional ingress proxy hops from the
    /// right side of the x-forwarded-for HTTP header to trust when determining the origin
    /// client’s IP address.
    /// See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops
    /// for more information.
    /// Contour's default is 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numTrustedHops")]
    pub num_trusted_hops: Option<i32>,
}

/// Service holds Envoy service parameters for setting Ingress status.
/// Contour's default is { namespace: "projectcontour", name: "envoy" }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyService {
    pub name: String,
    pub namespace: String,
}

/// Timeouts holds various configurable timeouts that can
/// be set in the config file.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationEnvoyTimeouts {
    /// ConnectTimeout defines how long the proxy should wait when establishing connection to upstream service.
    /// If not set, a default value of 2 seconds will be used.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-connect-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// ConnectionIdleTimeout defines how long the proxy should wait while there are
    /// no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating
    /// an HTTP connection. Set to "infinity" to disable the timeout entirely.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionIdleTimeout")]
    pub connection_idle_timeout: Option<String>,
    /// ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an
    /// initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection.
    /// During this grace period, the proxy will continue to respond to new streams. After the final
    /// GOAWAY frame has been sent, the proxy will refuse new streams.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionShutdownGracePeriod")]
    pub connection_shutdown_grace_period: Option<String>,
    /// DelayedCloseTimeout defines how long envoy will wait, once connection
    /// close processing has been initiated, for the downstream peer to close
    /// the connection before Envoy closes the socket associated with the connection.
    /// Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0'
    /// in Envoy. Leaving it unset will result in the Envoy default value being used.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "delayedCloseTimeout")]
    pub delayed_close_timeout: Option<String>,
    /// MaxConnectionDuration defines the maximum period of time after an HTTP connection
    /// has been established from the client to the proxy before it is closed by the proxy,
    /// regardless of whether there has been activity or not. Omit or set to "infinity" for
    /// no max duration.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnectionDuration")]
    pub max_connection_duration: Option<String>,
    /// RequestTimeout sets the client request timeout globally for Contour. Note that
    /// this is a timeout for the entire request, not an idle timeout. Omit or set to
    /// "infinity" to disable the timeout entirely.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestTimeout")]
    pub request_timeout: Option<String>,
    /// StreamIdleTimeout defines how long the proxy should wait while there is no
    /// request activity (for HTTP/1.1) or stream activity (for HTTP/2) before
    /// terminating the HTTP request or stream. Set to "infinity" to disable the
    /// timeout entirely.
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamIdleTimeout")]
    pub stream_idle_timeout: Option<String>,
}

/// Gateway contains parameters for the gateway-api Gateway that Contour
/// is configured to serve traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationGateway {
    /// GatewayRef defines the specific Gateway that this Contour
    /// instance corresponds to.
    #[serde(rename = "gatewayRef")]
    pub gateway_ref: ContourConfigurationGatewayGatewayRef,
}

/// GatewayRef defines the specific Gateway that this Contour
/// instance corresponds to.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationGatewayGatewayRef {
    pub name: String,
    pub namespace: String,
}

/// GlobalExternalAuthorization allows envoys external authorization filter
/// to be enabled for all virtual hosts.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationGlobalExtAuth {
    /// AuthPolicy sets a default authorization policy for client requests.
    /// This policy will be used unless overridden by individual routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authPolicy")]
    pub auth_policy: Option<ContourConfigurationGlobalExtAuthAuthPolicy>,
    /// ExtensionServiceRef specifies the extension resource that will authorize client requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extensionRef")]
    pub extension_ref: Option<ContourConfigurationGlobalExtAuthExtensionRef>,
    /// If FailOpen is true, the client request is forwarded to the upstream service
    /// even if the authorization server fails to respond. This field should not be
    /// set in most cases. It is intended for use only while migrating applications
    /// from internal authorization to Contour external authorization.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOpen")]
    pub fail_open: Option<bool>,
    /// ResponseTimeout configures maximum time to wait for a check response from the authorization server.
    /// Timeout durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).
    /// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    /// The string "infinity" is also a valid input and specifies no timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseTimeout")]
    pub response_timeout: Option<String>,
    /// WithRequestBody specifies configuration for sending the client request's body to authorization server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withRequestBody")]
    pub with_request_body: Option<ContourConfigurationGlobalExtAuthWithRequestBody>,
}

/// AuthPolicy sets a default authorization policy for client requests.
/// This policy will be used unless overridden by individual routes.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationGlobalExtAuthAuthPolicy {
    /// Context is a set of key/value pairs that are sent to the
    /// authentication server in the check request. If a context
    /// is provided at an enclosing scope, the entries are merged
    /// such that the inner scope overrides matching keys from the
    /// outer scope.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<BTreeMap<String, String>>,
    /// When true, this field disables client request authentication
    /// for the scope of the policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// ExtensionServiceRef specifies the extension resource that will authorize client requests.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationGlobalExtAuthExtensionRef {
    /// API version of the referent.
    /// If this field is not specified, the default "projectcontour.io/v1alpha1" will be used
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// If this field is not specifies, the namespace of the resource that targets the referent will be used.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// WithRequestBody specifies configuration for sending the client request's body to authorization server.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationGlobalExtAuthWithRequestBody {
    /// If AllowPartialMessage is true, then Envoy will buffer the body until MaxRequestBytes are reached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPartialMessage")]
    pub allow_partial_message: Option<bool>,
    /// MaxRequestBytes sets the maximum size of message body ExtAuthz filter will hold in-memory.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestBytes")]
    pub max_request_bytes: Option<i32>,
    /// If PackAsBytes is true, the body sent to Authorization Server is in raw bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "packAsBytes")]
    pub pack_as_bytes: Option<bool>,
}

/// Health defines the endpoints Contour uses to serve health checks.
/// Contour's default is { address: "0.0.0.0", port: 8000 }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationHealth {
    /// Defines the health address interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the health port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// HTTPProxy defines parameters on HTTPProxy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationHttpproxy {
    /// DisablePermitInsecure disables the use of the
    /// permitInsecure field in HTTPProxy.
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disablePermitInsecure")]
    pub disable_permit_insecure: Option<bool>,
    /// FallbackCertificate defines the namespace/name of the Kubernetes secret to
    /// use as fallback when a non-SNI request is received.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fallbackCertificate")]
    pub fallback_certificate: Option<ContourConfigurationHttpproxyFallbackCertificate>,
    /// Restrict Contour to searching these namespaces for root ingress routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootNamespaces")]
    pub root_namespaces: Option<Vec<String>>,
}

/// FallbackCertificate defines the namespace/name of the Kubernetes secret to
/// use as fallback when a non-SNI request is received.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationHttpproxyFallbackCertificate {
    pub name: String,
    pub namespace: String,
}

/// Ingress contains parameters for ingress options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationIngress {
    /// Ingress Class Names Contour should use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "classNames")]
    pub class_names: Option<Vec<String>>,
    /// Address to set in Ingress object status.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusAddress")]
    pub status_address: Option<String>,
}

/// Metrics defines the endpoint Contour uses to serve metrics.
/// Contour's default is { address: "0.0.0.0", port: 8000 }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationMetrics {
    /// Defines the metrics address interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the metrics port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// TLS holds TLS file config details.
    /// Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ContourConfigurationMetricsTls>,
}

/// TLS holds TLS file config details.
/// Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationMetricsTls {
    /// CA filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Client certificate filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Client key filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
}

/// Policy specifies default policy applied if not overridden by the user
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationPolicy {
    /// ApplyToIngress determines if the Policies will apply to ingress objects
    /// Contour's default is false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applyToIngress")]
    pub apply_to_ingress: Option<bool>,
    /// RequestHeadersPolicy defines the request headers set/removed on all routes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaders")]
    pub request_headers: Option<ContourConfigurationPolicyRequestHeaders>,
    /// ResponseHeadersPolicy defines the response headers set/removed on all routes
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeaders")]
    pub response_headers: Option<ContourConfigurationPolicyResponseHeaders>,
}

/// RequestHeadersPolicy defines the request headers set/removed on all routes
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationPolicyRequestHeaders {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<BTreeMap<String, String>>,
}

/// ResponseHeadersPolicy defines the response headers set/removed on all routes
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationPolicyResponseHeaders {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<BTreeMap<String, String>>,
}

/// RateLimitService optionally holds properties of the Rate Limit Service
/// to be used for global rate limiting.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitService {
    /// DefaultGlobalRateLimitPolicy allows setting a default global rate limit policy for every HTTPProxy.
    /// HTTPProxy can overwrite this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultGlobalRateLimitPolicy")]
    pub default_global_rate_limit_policy: Option<ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicy>,
    /// Domain is passed to the Rate Limit Service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    /// EnableResourceExhaustedCode enables translating error code 429 to
    /// grpc code RESOURCE_EXHAUSTED. When disabled it's translated to UNAVAILABLE
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableResourceExhaustedCode")]
    pub enable_resource_exhausted_code: Option<bool>,
    /// EnableXRateLimitHeaders defines whether to include the X-RateLimit
    /// headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset
    /// (as defined by the IETF Internet-Draft linked below), on responses
    /// to clients when the Rate Limit Service is consulted for a request.
    /// ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableXRateLimitHeaders")]
    pub enable_x_rate_limit_headers: Option<bool>,
    /// ExtensionService identifies the extension service defining the RLS.
    #[serde(rename = "extensionService")]
    pub extension_service: ContourConfigurationRateLimitServiceExtensionService,
    /// FailOpen defines whether to allow requests to proceed when the
    /// Rate Limit Service fails to respond with a valid rate limit
    /// decision within the timeout defined on the extension service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOpen")]
    pub fail_open: Option<bool>,
}

/// DefaultGlobalRateLimitPolicy allows setting a default global rate limit policy for every HTTPProxy.
/// HTTPProxy can overwrite this configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicy {
    /// Descriptors defines the list of descriptors that will
    /// be generated and sent to the rate limit service. Each
    /// descriptor contains 1+ key-value pair entries.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub descriptors: Option<Vec<ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptors>>,
    /// Disabled configures the HTTPProxy to not use
    /// the default global rate limit policy defined by the Contour configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// RateLimitDescriptor defines a list of key-value pair generators.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptors {
    /// Entries is the list of key-value pair generators.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<Vec<ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntries>>,
}

/// RateLimitDescriptorEntry is a key-value pair generator. Exactly
/// one field on this struct must be non-nil.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntries {
    /// GenericKey defines a descriptor entry with a static key and value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "genericKey")]
    pub generic_key: Option<ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesGenericKey>,
    /// RemoteAddress defines a descriptor entry with a key of "remote_address"
    /// and a value equal to the client's IP address (from x-forwarded-for).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteAddress")]
    pub remote_address: Option<ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRemoteAddress>,
    /// RequestHeader defines a descriptor entry that's populated only if
    /// a given header is present on the request. The descriptor key is static,
    /// and the descriptor value is equal to the value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeader")]
    pub request_header: Option<ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeader>,
    /// RequestHeaderValueMatch defines a descriptor entry that's populated
    /// if the request's headers match a set of 1+ match criteria. The
    /// descriptor key is "header_match", and the descriptor value is static.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaderValueMatch")]
    pub request_header_value_match: Option<ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeaderValueMatch>,
}

/// GenericKey defines a descriptor entry with a static key and value.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesGenericKey {
    /// Key defines the key of the descriptor entry. If not set, the
    /// key is set to "generic_key".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value defines the value of the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// RemoteAddress defines a descriptor entry with a key of "remote_address"
/// and a value equal to the client's IP address (from x-forwarded-for).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRemoteAddress {
}

/// RequestHeader defines a descriptor entry that's populated only if
/// a given header is present on the request. The descriptor key is static,
/// and the descriptor value is equal to the value of the header.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeader {
    /// DescriptorKey defines the key to use on the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "descriptorKey")]
    pub descriptor_key: Option<String>,
    /// HeaderName defines the name of the header to look for on the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    pub header_name: Option<String>,
}

/// RequestHeaderValueMatch defines a descriptor entry that's populated
/// if the request's headers match a set of 1+ match criteria. The
/// descriptor key is "header_match", and the descriptor value is static.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeaderValueMatch {
    /// ExpectMatch defines whether the request must positively match the match
    /// criteria in order to generate a descriptor entry (i.e. true), or not
    /// match the match criteria in order to generate a descriptor entry (i.e. false).
    /// The default is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectMatch")]
    pub expect_match: Option<bool>,
    /// Headers is a list of 1+ match criteria to apply against the request
    /// to determine whether to populate the descriptor entry or not.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeaderValueMatchHeaders>>,
    /// Value defines the value of the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HeaderMatchCondition specifies how to conditionally match against HTTP
/// headers. The Name field is required, only one of Present, NotPresent,
/// Contains, NotContains, Exact, NotExact and Regex can be set.
/// For negative matching rules only (e.g. NotContains or NotExact) you can set
/// TreatMissingAsEmpty.
/// IgnoreCase has no effect for Regex.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitServiceDefaultGlobalRateLimitPolicyDescriptorsEntriesRequestHeaderValueMatchHeaders {
    /// Contains specifies a substring that must be present in
    /// the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// Exact specifies a string that the header value must be equal to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// IgnoreCase specifies that string matching should be case insensitive.
    /// Note that this has no effect on the Regex parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    pub ignore_case: Option<bool>,
    /// Name is the name of the header to match against. Name is required.
    /// Header names are case insensitive.
    pub name: String,
    /// NotContains specifies a substring that must not be present
    /// in the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notcontains: Option<String>,
    /// NoExact specifies a string that the header value must not be
    /// equal to. The condition is true if the header has any other value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notexact: Option<String>,
    /// NotPresent specifies that condition is true when the named header
    /// is not present. Note that setting NotPresent to false does not
    /// make the condition true if the named header is present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notpresent: Option<bool>,
    /// Present specifies that condition is true when the named header
    /// is present, regardless of its value. Note that setting Present
    /// to false does not make the condition true if the named header
    /// is absent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub present: Option<bool>,
    /// Regex specifies a regular expression pattern that must match the header
    /// value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// TreatMissingAsEmpty specifies if the header match rule specified header
    /// does not exist, this header value will be treated as empty. Defaults to false.
    /// Unlike the underlying Envoy implementation this is **only** supported for
    /// negative matches (e.g. NotContains, NotExact).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "treatMissingAsEmpty")]
    pub treat_missing_as_empty: Option<bool>,
}

/// ExtensionService identifies the extension service defining the RLS.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationRateLimitServiceExtensionService {
    pub name: String,
    pub namespace: String,
}

/// Tracing defines properties for exporting trace data to OpenTelemetry.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationTracing {
    /// CustomTags defines a list of custom tags with unique tag name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customTags")]
    pub custom_tags: Option<Vec<ContourConfigurationTracingCustomTags>>,
    /// ExtensionService identifies the extension service defining the otel-collector.
    #[serde(rename = "extensionService")]
    pub extension_service: ContourConfigurationTracingExtensionService,
    /// IncludePodDetail defines a flag.
    /// If it is true, contour will add the pod name and namespace to the span of the trace.
    /// the default is true.
    /// Note: The Envoy pods MUST have the HOSTNAME and CONTOUR_NAMESPACE environment variables set for this to work properly.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includePodDetail")]
    pub include_pod_detail: Option<bool>,
    /// MaxPathTagLength defines maximum length of the request path
    /// to extract and include in the HttpUrl tag.
    /// contour's default is 256.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPathTagLength")]
    pub max_path_tag_length: Option<i32>,
    /// OverallSampling defines the sampling rate of trace data.
    /// contour's default is 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "overallSampling")]
    pub overall_sampling: Option<String>,
    /// ServiceName defines the name for the service.
    /// contour's default is contour.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

/// CustomTag defines custom tags with unique tag name
/// to create tags for the active span.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationTracingCustomTags {
    /// Literal is a static custom tag value.
    /// Precisely one of Literal, RequestHeaderName must be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub literal: Option<String>,
    /// RequestHeaderName indicates which request header
    /// the label value is obtained from.
    /// Precisely one of Literal, RequestHeaderName must be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaderName")]
    pub request_header_name: Option<String>,
    /// TagName is the unique name of the custom tag.
    #[serde(rename = "tagName")]
    pub tag_name: String,
}

/// ExtensionService identifies the extension service defining the otel-collector.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationTracingExtensionService {
    pub name: String,
    pub namespace: String,
}

/// XDSServer contains parameters for the xDS server.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationXdsServer {
    /// Defines the xDS gRPC API address which Contour will serve.
    /// Contour's default is "0.0.0.0".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// Defines the xDS gRPC API port which Contour will serve.
    /// Contour's default is 8001.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// TLS holds TLS file config details.
    /// Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ContourConfigurationXdsServerTls>,
    /// Defines the XDSServer to use for `contour serve`.
    /// Values: `envoy` (default), `contour (deprecated)`.
    /// Other values will produce an error.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// TLS holds TLS file config details.
/// Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationXdsServerTls {
    /// CA filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Client certificate filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Allow serving the xDS gRPC API without TLS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// Client key filename.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
}

/// ContourConfigurationStatus defines the observed state of a ContourConfiguration resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ContourConfigurationStatus {
    /// Conditions contains the current status of the Contour resource.
    /// Contour will update a single condition, `Valid`, that is in normal-true polarity.
    /// Contour will not modify any other Conditions set in this block,
    /// in case some other controller wants to add a Condition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

