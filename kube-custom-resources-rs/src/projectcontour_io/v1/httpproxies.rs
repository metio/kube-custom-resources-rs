// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename=./crd-catalog/projectcontour/contour/projectcontour.io/v1/httpproxies.yaml --derive=PartialEq
// kopium version: 0.19.0

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// HTTPProxySpec defines the spec of the CRD.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "projectcontour.io", version = "v1", kind = "HTTPProxy", plural = "httpproxies")]
#[kube(namespaced)]
#[kube(status = "HTTPProxyStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct HTTPProxySpec {
    /// Includes allow for specific routing configuration to be included from another HTTPProxy,
    /// possibly in another namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub includes: Option<Vec<HTTPProxyIncludes>>,
    /// IngressClassName optionally specifies the ingress class to use for this
    /// HTTPProxy. This replaces the deprecated `kubernetes.io/ingress.class`
    /// annotation. For backwards compatibility, when that annotation is set, it
    /// is given precedence over this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Routes are the ingress routes. If TCPProxy is present, Routes is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routes: Option<Vec<HTTPProxyRoutes>>,
    /// TCPProxy holds TCP proxy information.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcpproxy: Option<HTTPProxyTcpproxy>,
    /// Virtualhost appears at most once. If it is present, the object is considered
    /// to be a "root" HTTPProxy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub virtualhost: Option<HTTPProxyVirtualhost>,
}

/// Include describes a set of policies that can be applied to an HTTPProxy in a namespace.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyIncludes {
    /// Conditions are a set of rules that are applied to included HTTPProxies.
    /// In effect, they are added onto the Conditions of included HTTPProxy Route
    /// structs.
    /// When applied, they are merged using AND, with one exception:
    /// There can be only one Prefix MatchCondition per Conditions slice.
    /// More than one Prefix, or contradictory Conditions, will make the
    /// include invalid. Exact and Regex match conditions are not allowed
    /// on includes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<HTTPProxyIncludesConditions>>,
    /// Name of the HTTPProxy
    pub name: String,
    /// Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// MatchCondition are a general holder for matching rules for HTTPProxies.
/// One of Prefix, Exact, Regex, Header or QueryParameter must be provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyIncludesConditions {
    /// Exact defines a exact match for a request.
    /// This field is not allowed in include match conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// Header specifies the header condition to match.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<HTTPProxyIncludesConditionsHeader>,
    /// Prefix defines a prefix match for a request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// QueryParameter specifies the query parameter condition to match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameter")]
    pub query_parameter: Option<HTTPProxyIncludesConditionsQueryParameter>,
    /// Regex defines a regex match for a request.
    /// This field is not allowed in include match conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

/// Header specifies the header condition to match.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyIncludesConditionsHeader {
    /// Contains specifies a substring that must be present in
    /// the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// Exact specifies a string that the header value must be equal to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// IgnoreCase specifies that string matching should be case insensitive.
    /// Note that this has no effect on the Regex parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    pub ignore_case: Option<bool>,
    /// Name is the name of the header to match against. Name is required.
    /// Header names are case insensitive.
    pub name: String,
    /// NotContains specifies a substring that must not be present
    /// in the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notcontains: Option<String>,
    /// NoExact specifies a string that the header value must not be
    /// equal to. The condition is true if the header has any other value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notexact: Option<String>,
    /// NotPresent specifies that condition is true when the named header
    /// is not present. Note that setting NotPresent to false does not
    /// make the condition true if the named header is present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notpresent: Option<bool>,
    /// Present specifies that condition is true when the named header
    /// is present, regardless of its value. Note that setting Present
    /// to false does not make the condition true if the named header
    /// is absent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub present: Option<bool>,
    /// Regex specifies a regular expression pattern that must match the header
    /// value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// TreatMissingAsEmpty specifies if the header match rule specified header
    /// does not exist, this header value will be treated as empty. Defaults to false.
    /// Unlike the underlying Envoy implementation this is **only** supported for
    /// negative matches (e.g. NotContains, NotExact).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "treatMissingAsEmpty")]
    pub treat_missing_as_empty: Option<bool>,
}

/// QueryParameter specifies the query parameter condition to match.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyIncludesConditionsQueryParameter {
    /// Contains specifies a substring that must be present in
    /// the query parameter value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// Exact specifies a string that the query parameter value must be equal to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// IgnoreCase specifies that string matching should be case insensitive.
    /// Note that this has no effect on the Regex parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    pub ignore_case: Option<bool>,
    /// Name is the name of the query parameter to match against. Name is required.
    /// Query parameter names are case insensitive.
    pub name: String,
    /// Prefix defines a prefix match for the query parameter value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// Present specifies that condition is true when the named query parameter
    /// is present, regardless of its value. Note that setting Present
    /// to false does not make the condition true if the named query parameter
    /// is absent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub present: Option<bool>,
    /// Regex specifies a regular expression pattern that must match the query
    /// parameter value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Suffix defines a suffix match for a query parameter value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suffix: Option<String>,
}

/// Route contains the set of routes for a virtual host.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutes {
    /// AuthPolicy updates the authorization policy that was set
    /// on the root HTTPProxy object for client requests that
    /// match this route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authPolicy")]
    pub auth_policy: Option<HTTPProxyRoutesAuthPolicy>,
    /// Conditions are a set of rules that are applied to a Route.
    /// When applied, they are merged using AND, with one exception:
    /// There can be only one Prefix, Exact or Regex MatchCondition
    /// per Conditions slice. More than one of these condition types,
    /// or contradictory Conditions, will make the route invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<HTTPProxyRoutesConditions>>,
    /// The policies for rewriting Set-Cookie header attributes. Note that
    /// rewritten cookie names must be unique in this list. Order rewrite
    /// policies are specified in does not matter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cookieRewritePolicies")]
    pub cookie_rewrite_policies: Option<Vec<HTTPProxyRoutesCookieRewritePolicies>>,
    /// DirectResponsePolicy returns an arbitrary HTTP response directly.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "directResponsePolicy")]
    pub direct_response_policy: Option<HTTPProxyRoutesDirectResponsePolicy>,
    /// Enables websocket support for the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableWebsockets")]
    pub enable_websockets: Option<bool>,
    /// The health check policy for this route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckPolicy")]
    pub health_check_policy: Option<HTTPProxyRoutesHealthCheckPolicy>,
    /// The policy to define when to handle redirects responses internally.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalRedirectPolicy")]
    pub internal_redirect_policy: Option<HTTPProxyRoutesInternalRedirectPolicy>,
    /// IPAllowFilterPolicy is a list of ipv4/6 filter rules for which matching
    /// requests should be allowed. All other requests will be denied.
    /// Only one of IPAllowFilterPolicy and IPDenyFilterPolicy can be defined.
    /// The rules defined here override any rules set on the root HTTPProxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAllowPolicy")]
    pub ip_allow_policy: Option<Vec<HTTPProxyRoutesIpAllowPolicy>>,
    /// IPDenyFilterPolicy is a list of ipv4/6 filter rules for which matching
    /// requests should be denied. All other requests will be allowed.
    /// Only one of IPAllowFilterPolicy and IPDenyFilterPolicy can be defined.
    /// The rules defined here override any rules set on the root HTTPProxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipDenyPolicy")]
    pub ip_deny_policy: Option<Vec<HTTPProxyRoutesIpDenyPolicy>>,
    /// The policy for verifying JWTs for requests to this route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtVerificationPolicy")]
    pub jwt_verification_policy: Option<HTTPProxyRoutesJwtVerificationPolicy>,
    /// The load balancing policy for this route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerPolicy")]
    pub load_balancer_policy: Option<HTTPProxyRoutesLoadBalancerPolicy>,
    /// The policy for rewriting the path of the request URL
    /// after the request has been routed to a Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRewritePolicy")]
    pub path_rewrite_policy: Option<HTTPProxyRoutesPathRewritePolicy>,
    /// Allow this path to respond to insecure requests over HTTP which are normally
    /// not permitted when a `virtualhost.tls` block is present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "permitInsecure")]
    pub permit_insecure: Option<bool>,
    /// The policy for rate limiting on the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitPolicy")]
    pub rate_limit_policy: Option<HTTPProxyRoutesRateLimitPolicy>,
    /// The policy for managing request headers during proxying.
    /// You may dynamically rewrite the Host header to be forwarded
    /// upstream to the content of a request header using
    /// the below format "%REQ(X-Header-Name)%". If the value of the header
    /// is empty, it is ignored.
    /// *NOTE: Pay attention to the potential security implications of using this option.
    /// Provided header must come from trusted source.
    /// **NOTE: The header rewrite is only done while forwarding and has no bearing
    /// on the routing decision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersPolicy")]
    pub request_headers_policy: Option<HTTPProxyRoutesRequestHeadersPolicy>,
    /// RequestRedirectPolicy defines an HTTP redirection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestRedirectPolicy")]
    pub request_redirect_policy: Option<HTTPProxyRoutesRequestRedirectPolicy>,
    /// The policy for managing response headers during proxying.
    /// Rewriting the 'Host' header is not supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersPolicy")]
    pub response_headers_policy: Option<HTTPProxyRoutesResponseHeadersPolicy>,
    /// The retry policy for this route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<HTTPProxyRoutesRetryPolicy>,
    /// Services are the services to proxy traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<HTTPProxyRoutesServices>>,
    /// The timeout policy for this route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutPolicy")]
    pub timeout_policy: Option<HTTPProxyRoutesTimeoutPolicy>,
}

/// AuthPolicy updates the authorization policy that was set
/// on the root HTTPProxy object for client requests that
/// match this route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesAuthPolicy {
    /// Context is a set of key/value pairs that are sent to the
    /// authentication server in the check request. If a context
    /// is provided at an enclosing scope, the entries are merged
    /// such that the inner scope overrides matching keys from the
    /// outer scope.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<BTreeMap<String, String>>,
    /// When true, this field disables client request authentication
    /// for the scope of the policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// MatchCondition are a general holder for matching rules for HTTPProxies.
/// One of Prefix, Exact, Regex, Header or QueryParameter must be provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesConditions {
    /// Exact defines a exact match for a request.
    /// This field is not allowed in include match conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// Header specifies the header condition to match.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub header: Option<HTTPProxyRoutesConditionsHeader>,
    /// Prefix defines a prefix match for a request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// QueryParameter specifies the query parameter condition to match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameter")]
    pub query_parameter: Option<HTTPProxyRoutesConditionsQueryParameter>,
    /// Regex defines a regex match for a request.
    /// This field is not allowed in include match conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
}

/// Header specifies the header condition to match.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesConditionsHeader {
    /// Contains specifies a substring that must be present in
    /// the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// Exact specifies a string that the header value must be equal to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// IgnoreCase specifies that string matching should be case insensitive.
    /// Note that this has no effect on the Regex parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    pub ignore_case: Option<bool>,
    /// Name is the name of the header to match against. Name is required.
    /// Header names are case insensitive.
    pub name: String,
    /// NotContains specifies a substring that must not be present
    /// in the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notcontains: Option<String>,
    /// NoExact specifies a string that the header value must not be
    /// equal to. The condition is true if the header has any other value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notexact: Option<String>,
    /// NotPresent specifies that condition is true when the named header
    /// is not present. Note that setting NotPresent to false does not
    /// make the condition true if the named header is present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notpresent: Option<bool>,
    /// Present specifies that condition is true when the named header
    /// is present, regardless of its value. Note that setting Present
    /// to false does not make the condition true if the named header
    /// is absent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub present: Option<bool>,
    /// Regex specifies a regular expression pattern that must match the header
    /// value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// TreatMissingAsEmpty specifies if the header match rule specified header
    /// does not exist, this header value will be treated as empty. Defaults to false.
    /// Unlike the underlying Envoy implementation this is **only** supported for
    /// negative matches (e.g. NotContains, NotExact).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "treatMissingAsEmpty")]
    pub treat_missing_as_empty: Option<bool>,
}

/// QueryParameter specifies the query parameter condition to match.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesConditionsQueryParameter {
    /// Contains specifies a substring that must be present in
    /// the query parameter value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// Exact specifies a string that the query parameter value must be equal to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// IgnoreCase specifies that string matching should be case insensitive.
    /// Note that this has no effect on the Regex parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    pub ignore_case: Option<bool>,
    /// Name is the name of the query parameter to match against. Name is required.
    /// Query parameter names are case insensitive.
    pub name: String,
    /// Prefix defines a prefix match for the query parameter value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// Present specifies that condition is true when the named query parameter
    /// is present, regardless of its value. Note that setting Present
    /// to false does not make the condition true if the named query parameter
    /// is absent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub present: Option<bool>,
    /// Regex specifies a regular expression pattern that must match the query
    /// parameter value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Suffix defines a suffix match for a query parameter value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suffix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesCookieRewritePolicies {
    /// DomainRewrite enables rewriting the Set-Cookie Domain element.
    /// If not set, Domain will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainRewrite")]
    pub domain_rewrite: Option<HTTPProxyRoutesCookieRewritePoliciesDomainRewrite>,
    /// Name is the name of the cookie for which attributes will be rewritten.
    pub name: String,
    /// PathRewrite enables rewriting the Set-Cookie Path element.
    /// If not set, Path will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRewrite")]
    pub path_rewrite: Option<HTTPProxyRoutesCookieRewritePoliciesPathRewrite>,
    /// SameSite enables rewriting the Set-Cookie SameSite element.
    /// If not set, SameSite attribute will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sameSite")]
    pub same_site: Option<HTTPProxyRoutesCookieRewritePoliciesSameSite>,
    /// Secure enables rewriting the Set-Cookie Secure element.
    /// If not set, Secure attribute will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<bool>,
}

/// DomainRewrite enables rewriting the Set-Cookie Domain element.
/// If not set, Domain will not be rewritten.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesCookieRewritePoliciesDomainRewrite {
    /// Value is the value to rewrite the Domain attribute to.
    /// For now this is required.
    pub value: String,
}

/// PathRewrite enables rewriting the Set-Cookie Path element.
/// If not set, Path will not be rewritten.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesCookieRewritePoliciesPathRewrite {
    /// Value is the value to rewrite the Path attribute to.
    /// For now this is required.
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyRoutesCookieRewritePoliciesSameSite {
    Strict,
    Lax,
    None,
}

/// DirectResponsePolicy returns an arbitrary HTTP response directly.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesDirectResponsePolicy {
    /// Body is the content of the response body.
    /// If this setting is omitted, no body is included in the generated response.
    /// Note: Body is not recommended to set too long
    /// otherwise it can have significant resource usage impacts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// StatusCode is the HTTP response status to be returned.
    #[serde(rename = "statusCode")]
    pub status_code: i64,
}

/// The health check policy for this route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesHealthCheckPolicy {
    /// The ranges of HTTP response statuses considered healthy. Follow half-open
    /// semantics, i.e. for each range the start is inclusive and the end is exclusive.
    /// Must be within the range [100,600). If not specified, only a 200 response status
    /// is considered healthy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectedStatuses")]
    pub expected_statuses: Option<Vec<HTTPProxyRoutesHealthCheckPolicyExpectedStatuses>>,
    /// The number of healthy health checks required before a host is marked healthy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthyThresholdCount")]
    pub healthy_threshold_count: Option<i64>,
    /// The value of the host header in the HTTP health check request.
    /// If left empty (default value), the name "contour-envoy-healthcheck"
    /// will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The interval (seconds) between health checks
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSeconds")]
    pub interval_seconds: Option<i64>,
    /// HTTP endpoint used to perform health checks on upstream service
    pub path: String,
    /// The time to wait (seconds) for a health check response
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i64>,
    /// The number of unhealthy health checks required before a host is marked unhealthy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyThresholdCount")]
    pub unhealthy_threshold_count: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesHealthCheckPolicyExpectedStatuses {
    /// The end (exclusive) of a range of HTTP status codes.
    pub end: i64,
    /// The start (inclusive) of a range of HTTP status codes.
    pub start: i64,
}

/// The policy to define when to handle redirects responses internally.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesInternalRedirectPolicy {
    /// AllowCrossSchemeRedirect Allow internal redirect to follow a target URI with a different scheme
    /// than the value of x-forwarded-proto.
    /// SafeOnly allows same scheme redirect and safe cross scheme redirect, which means if the downstream
    /// scheme is HTTPS, both HTTPS and HTTP redirect targets are allowed, but if the downstream scheme
    /// is HTTP, only HTTP redirect targets are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCrossSchemeRedirect")]
    pub allow_cross_scheme_redirect: Option<HTTPProxyRoutesInternalRedirectPolicyAllowCrossSchemeRedirect>,
    /// If DenyRepeatedRouteRedirect is true, rejects redirect targets that are pointing to a route that has
    /// been followed by a previous redirect from the current route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyRepeatedRouteRedirect")]
    pub deny_repeated_route_redirect: Option<bool>,
    /// MaxInternalRedirects An internal redirect is not handled, unless the number of previous internal
    /// redirects that a downstream request has encountered is lower than this value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInternalRedirects")]
    pub max_internal_redirects: Option<i32>,
    /// RedirectResponseCodes If unspecified, only 302 will be treated as internal redirect.
    /// Only 301, 302, 303, 307 and 308 are valid values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redirectResponseCodes")]
    pub redirect_response_codes: Option<Vec<i64>>,
}

/// The policy to define when to handle redirects responses internally.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyRoutesInternalRedirectPolicyAllowCrossSchemeRedirect {
    Always,
    Never,
    SafeOnly,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesIpAllowPolicy {
    /// CIDR is a CIDR block of ipv4 or ipv6 addresses to filter on. This can also be
    /// a bare IP address (without a mask) to filter on exactly one address.
    pub cidr: String,
    /// Source indicates how to determine the ip address to filter on, and can be
    /// one of two values:
    ///  - `Remote` filters on the ip address of the client, accounting for PROXY and
    ///    X-Forwarded-For as needed.
    ///  - `Peer` filters on the ip of the network request, ignoring PROXY and
    ///    X-Forwarded-For.
    pub source: HTTPProxyRoutesIpAllowPolicySource,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyRoutesIpAllowPolicySource {
    Peer,
    Remote,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesIpDenyPolicy {
    /// CIDR is a CIDR block of ipv4 or ipv6 addresses to filter on. This can also be
    /// a bare IP address (without a mask) to filter on exactly one address.
    pub cidr: String,
    /// Source indicates how to determine the ip address to filter on, and can be
    /// one of two values:
    ///  - `Remote` filters on the ip address of the client, accounting for PROXY and
    ///    X-Forwarded-For as needed.
    ///  - `Peer` filters on the ip of the network request, ignoring PROXY and
    ///    X-Forwarded-For.
    pub source: HTTPProxyRoutesIpDenyPolicySource,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyRoutesIpDenyPolicySource {
    Peer,
    Remote,
}

/// The policy for verifying JWTs for requests to this route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesJwtVerificationPolicy {
    /// Disabled defines whether to disable all JWT verification for this
    /// route. This can be used to opt specific routes out of the default
    /// JWT provider for the HTTPProxy. At most one of this field or the
    /// "require" field can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// Require names a specific JWT provider (defined in the virtual host)
    /// to require for the route. If specified, this field overrides the
    /// default provider if one exists. If this field is not specified,
    /// the default provider will be required if one exists. At most one of
    /// this field or the "disabled" field can be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub require: Option<String>,
}

/// The load balancing policy for this route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesLoadBalancerPolicy {
    /// RequestHashPolicies contains a list of hash policies to apply when the
    /// `RequestHash` load balancing strategy is chosen. If an element of the
    /// supplied list of hash policies is invalid, it will be ignored. If the
    /// list of hash policies is empty after validation, the load balancing
    /// strategy will fall back to the default `RoundRobin`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHashPolicies")]
    pub request_hash_policies: Option<Vec<HTTPProxyRoutesLoadBalancerPolicyRequestHashPolicies>>,
    /// Strategy specifies the policy used to balance requests
    /// across the pool of backend pods. Valid policy names are
    /// `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`,
    /// and `RequestHash`. If an unknown strategy name is specified
    /// or no policy is supplied, the default `RoundRobin` policy
    /// is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<String>,
}

/// RequestHashPolicy contains configuration for an individual hash policy
/// on a request attribute.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesLoadBalancerPolicyRequestHashPolicies {
    /// HashSourceIP should be set to true when request source IP hash based
    /// load balancing is desired. It must be the only hash option field set,
    /// otherwise this request hash policy object will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashSourceIP")]
    pub hash_source_ip: Option<bool>,
    /// HeaderHashOptions should be set when request header hash based load
    /// balancing is desired. It must be the only hash option field set,
    /// otherwise this request hash policy object will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerHashOptions")]
    pub header_hash_options: Option<HTTPProxyRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions>,
    /// QueryParameterHashOptions should be set when request query parameter hash based load
    /// balancing is desired. It must be the only hash option field set,
    /// otherwise this request hash policy object will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameterHashOptions")]
    pub query_parameter_hash_options: Option<HTTPProxyRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions>,
    /// Terminal is a flag that allows for short-circuiting computing of a hash
    /// for a given request. If set to true, and the request attribute specified
    /// in the attribute hash options is present, no further hash policies will
    /// be used to calculate a hash for the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub terminal: Option<bool>,
}

/// HeaderHashOptions should be set when request header hash based load
/// balancing is desired. It must be the only hash option field set,
/// otherwise this request hash policy object will be ignored.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions {
    /// HeaderName is the name of the HTTP request header that will be used to
    /// calculate the hash key. If the header specified is not present on a
    /// request, no hash will be produced.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    pub header_name: Option<String>,
}

/// QueryParameterHashOptions should be set when request query parameter hash based load
/// balancing is desired. It must be the only hash option field set,
/// otherwise this request hash policy object will be ignored.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions {
    /// ParameterName is the name of the HTTP request query parameter that will be used to
    /// calculate the hash key. If the query parameter specified is not present on a
    /// request, no hash will be produced.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parameterName")]
    pub parameter_name: Option<String>,
}

/// The policy for rewriting the path of the request URL
/// after the request has been routed to a Service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesPathRewritePolicy {
    /// ReplacePrefix describes how the path prefix should be replaced.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replacePrefix")]
    pub replace_prefix: Option<Vec<HTTPProxyRoutesPathRewritePolicyReplacePrefix>>,
}

/// ReplacePrefix describes a path prefix replacement.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesPathRewritePolicyReplacePrefix {
    /// Prefix specifies the URL path prefix to be replaced.
    /// If Prefix is specified, it must exactly match the MatchCondition
    /// prefix that is rendered by the chain of including HTTPProxies
    /// and only that path prefix will be replaced by Replacement.
    /// This allows HTTPProxies that are included through multiple
    /// roots to only replace specific path prefixes, leaving others
    /// unmodified.
    /// If Prefix is not specified, all routing prefixes rendered
    /// by the include chain will be replaced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// Replacement is the string that the routing path prefix
    /// will be replaced with. This must not be empty.
    pub replacement: String,
}

/// The policy for rate limiting on the route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicy {
    /// Global defines global rate limiting parameters, i.e. parameters
    /// defining descriptors that are sent to an external rate limit
    /// service (RLS) for a rate limit decision on each request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<HTTPProxyRoutesRateLimitPolicyGlobal>,
    /// Local defines local rate limiting parameters, i.e. parameters
    /// for rate limiting that occurs within each Envoy pod as requests
    /// are handled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub local: Option<HTTPProxyRoutesRateLimitPolicyLocal>,
}

/// Global defines global rate limiting parameters, i.e. parameters
/// defining descriptors that are sent to an external rate limit
/// service (RLS) for a rate limit decision on each request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyGlobal {
    /// Descriptors defines the list of descriptors that will
    /// be generated and sent to the rate limit service. Each
    /// descriptor contains 1+ key-value pair entries.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub descriptors: Option<Vec<HTTPProxyRoutesRateLimitPolicyGlobalDescriptors>>,
    /// Disabled configures the HTTPProxy to not use
    /// the default global rate limit policy defined by the Contour configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// RateLimitDescriptor defines a list of key-value pair generators.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyGlobalDescriptors {
    /// Entries is the list of key-value pair generators.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<Vec<HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntries>>,
}

/// RateLimitDescriptorEntry is a key-value pair generator. Exactly
/// one field on this struct must be non-nil.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntries {
    /// GenericKey defines a descriptor entry with a static key and value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "genericKey")]
    pub generic_key: Option<HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey>,
    /// RemoteAddress defines a descriptor entry with a key of "remote_address"
    /// and a value equal to the client's IP address (from x-forwarded-for).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteAddress")]
    pub remote_address: Option<HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesRemoteAddress>,
    /// RequestHeader defines a descriptor entry that's populated only if
    /// a given header is present on the request. The descriptor key is static,
    /// and the descriptor value is equal to the value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeader")]
    pub request_header: Option<HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader>,
    /// RequestHeaderValueMatch defines a descriptor entry that's populated
    /// if the request's headers match a set of 1+ match criteria. The
    /// descriptor key is "header_match", and the descriptor value is static.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaderValueMatch")]
    pub request_header_value_match: Option<HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch>,
}

/// GenericKey defines a descriptor entry with a static key and value.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey {
    /// Key defines the key of the descriptor entry. If not set, the
    /// key is set to "generic_key".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value defines the value of the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// RemoteAddress defines a descriptor entry with a key of "remote_address"
/// and a value equal to the client's IP address (from x-forwarded-for).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesRemoteAddress {
}

/// RequestHeader defines a descriptor entry that's populated only if
/// a given header is present on the request. The descriptor key is static,
/// and the descriptor value is equal to the value of the header.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader {
    /// DescriptorKey defines the key to use on the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "descriptorKey")]
    pub descriptor_key: Option<String>,
    /// HeaderName defines the name of the header to look for on the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    pub header_name: Option<String>,
}

/// RequestHeaderValueMatch defines a descriptor entry that's populated
/// if the request's headers match a set of 1+ match criteria. The
/// descriptor key is "header_match", and the descriptor value is static.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch {
    /// ExpectMatch defines whether the request must positively match the match
    /// criteria in order to generate a descriptor entry (i.e. true), or not
    /// match the match criteria in order to generate a descriptor entry (i.e. false).
    /// The default is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectMatch")]
    pub expect_match: Option<bool>,
    /// Headers is a list of 1+ match criteria to apply against the request
    /// to determine whether to populate the descriptor entry or not.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders>>,
    /// Value defines the value of the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HeaderMatchCondition specifies how to conditionally match against HTTP
/// headers. The Name field is required, only one of Present, NotPresent,
/// Contains, NotContains, Exact, NotExact and Regex can be set.
/// For negative matching rules only (e.g. NotContains or NotExact) you can set
/// TreatMissingAsEmpty.
/// IgnoreCase has no effect for Regex.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders {
    /// Contains specifies a substring that must be present in
    /// the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// Exact specifies a string that the header value must be equal to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// IgnoreCase specifies that string matching should be case insensitive.
    /// Note that this has no effect on the Regex parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    pub ignore_case: Option<bool>,
    /// Name is the name of the header to match against. Name is required.
    /// Header names are case insensitive.
    pub name: String,
    /// NotContains specifies a substring that must not be present
    /// in the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notcontains: Option<String>,
    /// NoExact specifies a string that the header value must not be
    /// equal to. The condition is true if the header has any other value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notexact: Option<String>,
    /// NotPresent specifies that condition is true when the named header
    /// is not present. Note that setting NotPresent to false does not
    /// make the condition true if the named header is present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notpresent: Option<bool>,
    /// Present specifies that condition is true when the named header
    /// is present, regardless of its value. Note that setting Present
    /// to false does not make the condition true if the named header
    /// is absent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub present: Option<bool>,
    /// Regex specifies a regular expression pattern that must match the header
    /// value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// TreatMissingAsEmpty specifies if the header match rule specified header
    /// does not exist, this header value will be treated as empty. Defaults to false.
    /// Unlike the underlying Envoy implementation this is **only** supported for
    /// negative matches (e.g. NotContains, NotExact).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "treatMissingAsEmpty")]
    pub treat_missing_as_empty: Option<bool>,
}

/// Local defines local rate limiting parameters, i.e. parameters
/// for rate limiting that occurs within each Envoy pod as requests
/// are handled.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyLocal {
    /// Burst defines the number of requests above the requests per
    /// unit that should be allowed within a short period of time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub burst: Option<i32>,
    /// Requests defines how many requests per unit of time should
    /// be allowed before rate limiting occurs.
    pub requests: i32,
    /// ResponseHeadersToAdd is an optional list of response headers to
    /// set when a request is rate-limited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    pub response_headers_to_add: Option<Vec<HTTPProxyRoutesRateLimitPolicyLocalResponseHeadersToAdd>>,
    /// ResponseStatusCode is the HTTP status code to use for responses
    /// to rate-limited requests. Codes must be in the 400-599 range
    /// (inclusive). If not specified, the Envoy default of 429 (Too
    /// Many Requests) is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseStatusCode")]
    pub response_status_code: Option<i32>,
    /// Unit defines the period of time within which requests
    /// over the limit will be rate limited. Valid values are
    /// "second", "minute" and "hour".
    pub unit: HTTPProxyRoutesRateLimitPolicyLocalUnit,
}

/// HeaderValue represents a header name/value pair
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRateLimitPolicyLocalResponseHeadersToAdd {
    /// Name represents a key of a header
    pub name: String,
    /// Value represents the value of a header specified by a key
    pub value: String,
}

/// Local defines local rate limiting parameters, i.e. parameters
/// for rate limiting that occurs within each Envoy pod as requests
/// are handled.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyRoutesRateLimitPolicyLocalUnit {
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
}

/// The policy for managing request headers during proxying.
/// You may dynamically rewrite the Host header to be forwarded
/// upstream to the content of a request header using
/// the below format "%REQ(X-Header-Name)%". If the value of the header
/// is empty, it is ignored.
/// *NOTE: Pay attention to the potential security implications of using this option.
/// Provided header must come from trusted source.
/// **NOTE: The header rewrite is only done while forwarding and has no bearing
/// on the routing decision.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRequestHeadersPolicy {
    /// Remove specifies a list of HTTP header names to remove.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    /// Set specifies a list of HTTP header values that will be set in the HTTP header.
    /// If the header does not exist it will be added, otherwise it will be overwritten with the new value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<HTTPProxyRoutesRequestHeadersPolicySet>>,
}

/// HeaderValue represents a header name/value pair
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRequestHeadersPolicySet {
    /// Name represents a key of a header
    pub name: String,
    /// Value represents the value of a header specified by a key
    pub value: String,
}

/// RequestRedirectPolicy defines an HTTP redirection.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRequestRedirectPolicy {
    /// Hostname is the precise hostname to be used in the value of the `Location`
    /// header in the response.
    /// When empty, the hostname of the request is used.
    /// No wildcards are allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// Path allows for redirection to a different path from the
    /// original on the request. The path must start with a
    /// leading slash.
    /// Note: Only one of Path or Prefix can be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Port is the port to be used in the value of the `Location`
    /// header in the response.
    /// When empty, port (if specified) of the request is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Prefix defines the value to swap the matched prefix or path with.
    /// The prefix must start with a leading slash.
    /// Note: Only one of Path or Prefix can be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// Scheme is the scheme to be used in the value of the `Location`
    /// header in the response.
    /// When empty, the scheme of the request is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<HTTPProxyRoutesRequestRedirectPolicyScheme>,
    /// StatusCode is the HTTP status code to be used in response.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusCode")]
    pub status_code: Option<i64>,
}

/// RequestRedirectPolicy defines an HTTP redirection.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyRoutesRequestRedirectPolicyScheme {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

/// RequestRedirectPolicy defines an HTTP redirection.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyRoutesRequestRedirectPolicyStatusCode {
    #[serde(rename = "301")]
    r#_301,
    #[serde(rename = "302")]
    r#_302,
}

/// The policy for managing response headers during proxying.
/// Rewriting the 'Host' header is not supported.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesResponseHeadersPolicy {
    /// Remove specifies a list of HTTP header names to remove.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    /// Set specifies a list of HTTP header values that will be set in the HTTP header.
    /// If the header does not exist it will be added, otherwise it will be overwritten with the new value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<HTTPProxyRoutesResponseHeadersPolicySet>>,
}

/// HeaderValue represents a header name/value pair
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesResponseHeadersPolicySet {
    /// Name represents a key of a header
    pub name: String,
    /// Value represents the value of a header specified by a key
    pub value: String,
}

/// The retry policy for this route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesRetryPolicy {
    /// NumRetries is maximum allowed number of retries.
    /// If set to -1, then retries are disabled.
    /// If set to 0 or not supplied, the value is set
    /// to the Envoy default of 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// PerTryTimeout specifies the timeout per retry attempt.
    /// Ignored if NumRetries is not supplied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perTryTimeout")]
    pub per_try_timeout: Option<String>,
    /// RetriableStatusCodes specifies the HTTP status codes that should be retried.
    /// This field is only respected when you include `retriable-status-codes` in the `RetryOn` field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retriableStatusCodes")]
    pub retriable_status_codes: Option<Vec<i64>>,
    /// RetryOn specifies the conditions on which to retry a request.
    /// Supported [HTTP conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on):
    /// - `5xx`
    /// - `gateway-error`
    /// - `reset`
    /// - `connect-failure`
    /// - `retriable-4xx`
    /// - `refused-stream`
    /// - `retriable-status-codes`
    /// - `retriable-headers`
    /// Supported [gRPC conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on):
    /// - `cancelled`
    /// - `deadline-exceeded`
    /// - `internal`
    /// - `resource-exhausted`
    /// - `unavailable`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryOn")]
    pub retry_on: Option<Vec<String>>,
}

/// Service defines an Kubernetes Service to proxy traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServices {
    /// The policies for rewriting Set-Cookie header attributes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cookieRewritePolicies")]
    pub cookie_rewrite_policies: Option<Vec<HTTPProxyRoutesServicesCookieRewritePolicies>>,
    /// HealthPort is the port for this service healthcheck.
    /// If not specified, Port is used for service healthchecks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthPort")]
    pub health_port: Option<i64>,
    /// If Mirror is true the Service will receive a read only mirror of the traffic for this route.
    /// If Mirror is true, then fractional mirroring can be enabled by optionally setting the Weight
    /// field. Legal values for Weight are 1-100. Omitting the Weight field will result in 100% mirroring.
    /// NOTE: Setting Weight explicitly to 0 will unexpectedly result in 100% traffic mirroring. This
    /// occurs since we cannot distinguish omitted fields from those explicitly set to their default
    /// values
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<bool>,
    /// Name is the name of Kubernetes service to proxy traffic.
    /// Names defined here will be used to look up corresponding endpoints which contain the ips to route.
    pub name: String,
    /// Port (defined as Integer) to proxy traffic to since a service can have multiple defined.
    pub port: i64,
    /// Protocol may be used to specify (or override) the protocol used to reach this Service.
    /// Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<HTTPProxyRoutesServicesProtocol>,
    /// The policy for managing request headers during proxying.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersPolicy")]
    pub request_headers_policy: Option<HTTPProxyRoutesServicesRequestHeadersPolicy>,
    /// The policy for managing response headers during proxying.
    /// Rewriting the 'Host' header is not supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersPolicy")]
    pub response_headers_policy: Option<HTTPProxyRoutesServicesResponseHeadersPolicy>,
    /// Slow start will gradually increase amount of traffic to a newly added endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slowStartPolicy")]
    pub slow_start_policy: Option<HTTPProxyRoutesServicesSlowStartPolicy>,
    /// UpstreamValidation defines how to verify the backend service's certificate
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validation: Option<HTTPProxyRoutesServicesValidation>,
    /// Weight defines percentage of traffic to balance traffic
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServicesCookieRewritePolicies {
    /// DomainRewrite enables rewriting the Set-Cookie Domain element.
    /// If not set, Domain will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainRewrite")]
    pub domain_rewrite: Option<HTTPProxyRoutesServicesCookieRewritePoliciesDomainRewrite>,
    /// Name is the name of the cookie for which attributes will be rewritten.
    pub name: String,
    /// PathRewrite enables rewriting the Set-Cookie Path element.
    /// If not set, Path will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRewrite")]
    pub path_rewrite: Option<HTTPProxyRoutesServicesCookieRewritePoliciesPathRewrite>,
    /// SameSite enables rewriting the Set-Cookie SameSite element.
    /// If not set, SameSite attribute will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sameSite")]
    pub same_site: Option<HTTPProxyRoutesServicesCookieRewritePoliciesSameSite>,
    /// Secure enables rewriting the Set-Cookie Secure element.
    /// If not set, Secure attribute will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<bool>,
}

/// DomainRewrite enables rewriting the Set-Cookie Domain element.
/// If not set, Domain will not be rewritten.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServicesCookieRewritePoliciesDomainRewrite {
    /// Value is the value to rewrite the Domain attribute to.
    /// For now this is required.
    pub value: String,
}

/// PathRewrite enables rewriting the Set-Cookie Path element.
/// If not set, Path will not be rewritten.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServicesCookieRewritePoliciesPathRewrite {
    /// Value is the value to rewrite the Path attribute to.
    /// For now this is required.
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyRoutesServicesCookieRewritePoliciesSameSite {
    Strict,
    Lax,
    None,
}

/// Service defines an Kubernetes Service to proxy traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyRoutesServicesProtocol {
    #[serde(rename = "h2")]
    H2,
    #[serde(rename = "h2c")]
    H2c,
    #[serde(rename = "tls")]
    Tls,
}

/// The policy for managing request headers during proxying.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServicesRequestHeadersPolicy {
    /// Remove specifies a list of HTTP header names to remove.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    /// Set specifies a list of HTTP header values that will be set in the HTTP header.
    /// If the header does not exist it will be added, otherwise it will be overwritten with the new value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<HTTPProxyRoutesServicesRequestHeadersPolicySet>>,
}

/// HeaderValue represents a header name/value pair
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServicesRequestHeadersPolicySet {
    /// Name represents a key of a header
    pub name: String,
    /// Value represents the value of a header specified by a key
    pub value: String,
}

/// The policy for managing response headers during proxying.
/// Rewriting the 'Host' header is not supported.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServicesResponseHeadersPolicy {
    /// Remove specifies a list of HTTP header names to remove.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    /// Set specifies a list of HTTP header values that will be set in the HTTP header.
    /// If the header does not exist it will be added, otherwise it will be overwritten with the new value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<HTTPProxyRoutesServicesResponseHeadersPolicySet>>,
}

/// HeaderValue represents a header name/value pair
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServicesResponseHeadersPolicySet {
    /// Name represents a key of a header
    pub name: String,
    /// Value represents the value of a header specified by a key
    pub value: String,
}

/// Slow start will gradually increase amount of traffic to a newly added endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServicesSlowStartPolicy {
    /// The speed of traffic increase over the slow start window.
    /// Defaults to 1.0, so that endpoint would get linearly increasing amount of traffic.
    /// When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
    /// The value of aggression parameter should be greater than 0.0.
    /// More info: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/slow_start
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aggression: Option<String>,
    /// The minimum or starting percentage of traffic to send to new endpoints.
    /// A non-zero value helps avoid a too small initial weight, which may cause endpoints in slow start mode to receive no traffic in the beginning of the slow start window.
    /// If not specified, the default is 10%.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minWeightPercent")]
    pub min_weight_percent: Option<i32>,
    /// The duration of slow start window.
    /// Duration is expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).
    /// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    pub window: String,
}

/// UpstreamValidation defines how to verify the backend service's certificate
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesServicesValidation {
    /// Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend.
    /// The secret must contain key named ca.crt.
    /// The name can be optionally prefixed with namespace "namespace/name".
    /// When cross-namespace reference is used, TLSCertificateDelegation resource must exist in the namespace to grant access to the secret.
    /// Max length should be the actual max possible length of a namespaced name (63 + 253 + 1 = 317)
    #[serde(rename = "caSecret")]
    pub ca_secret: String,
    /// Key which is expected to be present in the 'subjectAltName' of the presented certificate.
    /// Deprecated: migrate to using the plural field subjectNames.
    #[serde(rename = "subjectName")]
    pub subject_name: String,
    /// List of keys, of which at least one is expected to be present in the 'subjectAltName of the
    /// presented certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectNames")]
    pub subject_names: Option<Vec<String>>,
}

/// The timeout policy for this route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyRoutesTimeoutPolicy {
    /// Timeout for how long the proxy should wait while there is no activity during single request/response (for HTTP/1.1) or stream (for HTTP/2).
    /// Timeout will not trigger while HTTP/1.1 connection is idle between two consecutive requests.
    /// If not specified, there is no per-route idle timeout, though a connection manager-wide
    /// stream_idle_timeout default of 5m still applies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub idle: Option<String>,
    /// Timeout for how long connection from the proxy to the upstream service is kept when there are no active requests.
    /// If not supplied, Envoy's default value of 1h applies.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleConnection")]
    pub idle_connection: Option<String>,
    /// Timeout for receiving a response from the server after processing a request from client.
    /// If not supplied, Envoy's default value of 15s applies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<String>,
}

/// TCPProxy holds TCP proxy information.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxy {
    /// The health check policy for this tcp proxy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckPolicy")]
    pub health_check_policy: Option<HTTPProxyTcpproxyHealthCheckPolicy>,
    /// Include specifies that this tcpproxy should be delegated to another HTTPProxy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub include: Option<HTTPProxyTcpproxyInclude>,
    /// IncludesDeprecated allow for specific routing configuration to be appended to another HTTPProxy in another namespace.
    /// Exists due to a mistake when developing HTTPProxy and the field was marked plural
    /// when it should have been singular. This field should stay to not break backwards compatibility to v1 users.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub includes: Option<HTTPProxyTcpproxyIncludes>,
    /// The load balancing policy for the backend services. Note that the
    /// `Cookie` and `RequestHash` load balancing strategies cannot be used
    /// here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerPolicy")]
    pub load_balancer_policy: Option<HTTPProxyTcpproxyLoadBalancerPolicy>,
    /// Services are the services to proxy traffic
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<HTTPProxyTcpproxyServices>>,
}

/// The health check policy for this tcp proxy
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyHealthCheckPolicy {
    /// The number of healthy health checks required before a host is marked healthy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthyThresholdCount")]
    pub healthy_threshold_count: Option<i32>,
    /// The interval (seconds) between health checks
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSeconds")]
    pub interval_seconds: Option<i64>,
    /// The time to wait (seconds) for a health check response
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i64>,
    /// The number of unhealthy health checks required before a host is marked unhealthy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyThresholdCount")]
    pub unhealthy_threshold_count: Option<i32>,
}

/// Include specifies that this tcpproxy should be delegated to another HTTPProxy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyInclude {
    /// Name of the child HTTPProxy
    pub name: String,
    /// Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// IncludesDeprecated allow for specific routing configuration to be appended to another HTTPProxy in another namespace.
/// Exists due to a mistake when developing HTTPProxy and the field was marked plural
/// when it should have been singular. This field should stay to not break backwards compatibility to v1 users.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyIncludes {
    /// Name of the child HTTPProxy
    pub name: String,
    /// Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The load balancing policy for the backend services. Note that the
/// `Cookie` and `RequestHash` load balancing strategies cannot be used
/// here.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyLoadBalancerPolicy {
    /// RequestHashPolicies contains a list of hash policies to apply when the
    /// `RequestHash` load balancing strategy is chosen. If an element of the
    /// supplied list of hash policies is invalid, it will be ignored. If the
    /// list of hash policies is empty after validation, the load balancing
    /// strategy will fall back to the default `RoundRobin`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHashPolicies")]
    pub request_hash_policies: Option<Vec<HTTPProxyTcpproxyLoadBalancerPolicyRequestHashPolicies>>,
    /// Strategy specifies the policy used to balance requests
    /// across the pool of backend pods. Valid policy names are
    /// `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`,
    /// and `RequestHash`. If an unknown strategy name is specified
    /// or no policy is supplied, the default `RoundRobin` policy
    /// is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<String>,
}

/// RequestHashPolicy contains configuration for an individual hash policy
/// on a request attribute.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyLoadBalancerPolicyRequestHashPolicies {
    /// HashSourceIP should be set to true when request source IP hash based
    /// load balancing is desired. It must be the only hash option field set,
    /// otherwise this request hash policy object will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashSourceIP")]
    pub hash_source_ip: Option<bool>,
    /// HeaderHashOptions should be set when request header hash based load
    /// balancing is desired. It must be the only hash option field set,
    /// otherwise this request hash policy object will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerHashOptions")]
    pub header_hash_options: Option<HTTPProxyTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions>,
    /// QueryParameterHashOptions should be set when request query parameter hash based load
    /// balancing is desired. It must be the only hash option field set,
    /// otherwise this request hash policy object will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParameterHashOptions")]
    pub query_parameter_hash_options: Option<HTTPProxyTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions>,
    /// Terminal is a flag that allows for short-circuiting computing of a hash
    /// for a given request. If set to true, and the request attribute specified
    /// in the attribute hash options is present, no further hash policies will
    /// be used to calculate a hash for the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub terminal: Option<bool>,
}

/// HeaderHashOptions should be set when request header hash based load
/// balancing is desired. It must be the only hash option field set,
/// otherwise this request hash policy object will be ignored.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions {
    /// HeaderName is the name of the HTTP request header that will be used to
    /// calculate the hash key. If the header specified is not present on a
    /// request, no hash will be produced.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    pub header_name: Option<String>,
}

/// QueryParameterHashOptions should be set when request query parameter hash based load
/// balancing is desired. It must be the only hash option field set,
/// otherwise this request hash policy object will be ignored.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions {
    /// ParameterName is the name of the HTTP request query parameter that will be used to
    /// calculate the hash key. If the query parameter specified is not present on a
    /// request, no hash will be produced.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parameterName")]
    pub parameter_name: Option<String>,
}

/// Service defines an Kubernetes Service to proxy traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServices {
    /// The policies for rewriting Set-Cookie header attributes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cookieRewritePolicies")]
    pub cookie_rewrite_policies: Option<Vec<HTTPProxyTcpproxyServicesCookieRewritePolicies>>,
    /// HealthPort is the port for this service healthcheck.
    /// If not specified, Port is used for service healthchecks.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthPort")]
    pub health_port: Option<i64>,
    /// If Mirror is true the Service will receive a read only mirror of the traffic for this route.
    /// If Mirror is true, then fractional mirroring can be enabled by optionally setting the Weight
    /// field. Legal values for Weight are 1-100. Omitting the Weight field will result in 100% mirroring.
    /// NOTE: Setting Weight explicitly to 0 will unexpectedly result in 100% traffic mirroring. This
    /// occurs since we cannot distinguish omitted fields from those explicitly set to their default
    /// values
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<bool>,
    /// Name is the name of Kubernetes service to proxy traffic.
    /// Names defined here will be used to look up corresponding endpoints which contain the ips to route.
    pub name: String,
    /// Port (defined as Integer) to proxy traffic to since a service can have multiple defined.
    pub port: i64,
    /// Protocol may be used to specify (or override) the protocol used to reach this Service.
    /// Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<HTTPProxyTcpproxyServicesProtocol>,
    /// The policy for managing request headers during proxying.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeadersPolicy")]
    pub request_headers_policy: Option<HTTPProxyTcpproxyServicesRequestHeadersPolicy>,
    /// The policy for managing response headers during proxying.
    /// Rewriting the 'Host' header is not supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersPolicy")]
    pub response_headers_policy: Option<HTTPProxyTcpproxyServicesResponseHeadersPolicy>,
    /// Slow start will gradually increase amount of traffic to a newly added endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slowStartPolicy")]
    pub slow_start_policy: Option<HTTPProxyTcpproxyServicesSlowStartPolicy>,
    /// UpstreamValidation defines how to verify the backend service's certificate
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validation: Option<HTTPProxyTcpproxyServicesValidation>,
    /// Weight defines percentage of traffic to balance traffic
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServicesCookieRewritePolicies {
    /// DomainRewrite enables rewriting the Set-Cookie Domain element.
    /// If not set, Domain will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainRewrite")]
    pub domain_rewrite: Option<HTTPProxyTcpproxyServicesCookieRewritePoliciesDomainRewrite>,
    /// Name is the name of the cookie for which attributes will be rewritten.
    pub name: String,
    /// PathRewrite enables rewriting the Set-Cookie Path element.
    /// If not set, Path will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathRewrite")]
    pub path_rewrite: Option<HTTPProxyTcpproxyServicesCookieRewritePoliciesPathRewrite>,
    /// SameSite enables rewriting the Set-Cookie SameSite element.
    /// If not set, SameSite attribute will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sameSite")]
    pub same_site: Option<HTTPProxyTcpproxyServicesCookieRewritePoliciesSameSite>,
    /// Secure enables rewriting the Set-Cookie Secure element.
    /// If not set, Secure attribute will not be rewritten.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<bool>,
}

/// DomainRewrite enables rewriting the Set-Cookie Domain element.
/// If not set, Domain will not be rewritten.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServicesCookieRewritePoliciesDomainRewrite {
    /// Value is the value to rewrite the Domain attribute to.
    /// For now this is required.
    pub value: String,
}

/// PathRewrite enables rewriting the Set-Cookie Path element.
/// If not set, Path will not be rewritten.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServicesCookieRewritePoliciesPathRewrite {
    /// Value is the value to rewrite the Path attribute to.
    /// For now this is required.
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyTcpproxyServicesCookieRewritePoliciesSameSite {
    Strict,
    Lax,
    None,
}

/// Service defines an Kubernetes Service to proxy traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyTcpproxyServicesProtocol {
    #[serde(rename = "h2")]
    H2,
    #[serde(rename = "h2c")]
    H2c,
    #[serde(rename = "tls")]
    Tls,
}

/// The policy for managing request headers during proxying.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServicesRequestHeadersPolicy {
    /// Remove specifies a list of HTTP header names to remove.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    /// Set specifies a list of HTTP header values that will be set in the HTTP header.
    /// If the header does not exist it will be added, otherwise it will be overwritten with the new value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<HTTPProxyTcpproxyServicesRequestHeadersPolicySet>>,
}

/// HeaderValue represents a header name/value pair
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServicesRequestHeadersPolicySet {
    /// Name represents a key of a header
    pub name: String,
    /// Value represents the value of a header specified by a key
    pub value: String,
}

/// The policy for managing response headers during proxying.
/// Rewriting the 'Host' header is not supported.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServicesResponseHeadersPolicy {
    /// Remove specifies a list of HTTP header names to remove.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<String>>,
    /// Set specifies a list of HTTP header values that will be set in the HTTP header.
    /// If the header does not exist it will be added, otherwise it will be overwritten with the new value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub set: Option<Vec<HTTPProxyTcpproxyServicesResponseHeadersPolicySet>>,
}

/// HeaderValue represents a header name/value pair
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServicesResponseHeadersPolicySet {
    /// Name represents a key of a header
    pub name: String,
    /// Value represents the value of a header specified by a key
    pub value: String,
}

/// Slow start will gradually increase amount of traffic to a newly added endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServicesSlowStartPolicy {
    /// The speed of traffic increase over the slow start window.
    /// Defaults to 1.0, so that endpoint would get linearly increasing amount of traffic.
    /// When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
    /// The value of aggression parameter should be greater than 0.0.
    /// More info: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/slow_start
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aggression: Option<String>,
    /// The minimum or starting percentage of traffic to send to new endpoints.
    /// A non-zero value helps avoid a too small initial weight, which may cause endpoints in slow start mode to receive no traffic in the beginning of the slow start window.
    /// If not specified, the default is 10%.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minWeightPercent")]
    pub min_weight_percent: Option<i32>,
    /// The duration of slow start window.
    /// Duration is expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).
    /// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    pub window: String,
}

/// UpstreamValidation defines how to verify the backend service's certificate
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyTcpproxyServicesValidation {
    /// Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend.
    /// The secret must contain key named ca.crt.
    /// The name can be optionally prefixed with namespace "namespace/name".
    /// When cross-namespace reference is used, TLSCertificateDelegation resource must exist in the namespace to grant access to the secret.
    /// Max length should be the actual max possible length of a namespaced name (63 + 253 + 1 = 317)
    #[serde(rename = "caSecret")]
    pub ca_secret: String,
    /// Key which is expected to be present in the 'subjectAltName' of the presented certificate.
    /// Deprecated: migrate to using the plural field subjectNames.
    #[serde(rename = "subjectName")]
    pub subject_name: String,
    /// List of keys, of which at least one is expected to be present in the 'subjectAltName of the
    /// presented certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectNames")]
    pub subject_names: Option<Vec<String>>,
}

/// Virtualhost appears at most once. If it is present, the object is considered
/// to be a "root" HTTPProxy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhost {
    /// This field configures an extension service to perform
    /// authorization for this virtual host. Authorization can
    /// only be configured on virtual hosts that have TLS enabled.
    /// If the TLS configuration requires client certificate
    /// validation, the client certificate is always included in the
    /// authentication check request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<HTTPProxyVirtualhostAuthorization>,
    /// Specifies the cross-origin policy to apply to the VirtualHost.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsPolicy")]
    pub cors_policy: Option<HTTPProxyVirtualhostCorsPolicy>,
    /// The fully qualified domain name of the root of the ingress tree
    /// all leaves of the DAG rooted at this object relate to the fqdn.
    pub fqdn: String,
    /// IPAllowFilterPolicy is a list of ipv4/6 filter rules for which matching
    /// requests should be allowed. All other requests will be denied.
    /// Only one of IPAllowFilterPolicy and IPDenyFilterPolicy can be defined.
    /// The rules defined here may be overridden in a Route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAllowPolicy")]
    pub ip_allow_policy: Option<Vec<HTTPProxyVirtualhostIpAllowPolicy>>,
    /// IPDenyFilterPolicy is a list of ipv4/6 filter rules for which matching
    /// requests should be denied. All other requests will be allowed.
    /// Only one of IPAllowFilterPolicy and IPDenyFilterPolicy can be defined.
    /// The rules defined here may be overridden in a Route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipDenyPolicy")]
    pub ip_deny_policy: Option<Vec<HTTPProxyVirtualhostIpDenyPolicy>>,
    /// Providers to use for verifying JSON Web Tokens (JWTs) on the virtual host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtProviders")]
    pub jwt_providers: Option<Vec<HTTPProxyVirtualhostJwtProviders>>,
    /// The policy for rate limiting on the virtual host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitPolicy")]
    pub rate_limit_policy: Option<HTTPProxyVirtualhostRateLimitPolicy>,
    /// If present the fields describes TLS properties of the virtual
    /// host. The SNI names that will be matched on are described in fqdn,
    /// the tls.secretName secret must contain a certificate that itself
    /// contains a name that matches the FQDN.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<HTTPProxyVirtualhostTls>,
}

/// This field configures an extension service to perform
/// authorization for this virtual host. Authorization can
/// only be configured on virtual hosts that have TLS enabled.
/// If the TLS configuration requires client certificate
/// validation, the client certificate is always included in the
/// authentication check request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostAuthorization {
    /// AuthPolicy sets a default authorization policy for client requests.
    /// This policy will be used unless overridden by individual routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authPolicy")]
    pub auth_policy: Option<HTTPProxyVirtualhostAuthorizationAuthPolicy>,
    /// ExtensionServiceRef specifies the extension resource that will authorize client requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extensionRef")]
    pub extension_ref: Option<HTTPProxyVirtualhostAuthorizationExtensionRef>,
    /// If FailOpen is true, the client request is forwarded to the upstream service
    /// even if the authorization server fails to respond. This field should not be
    /// set in most cases. It is intended for use only while migrating applications
    /// from internal authorization to Contour external authorization.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOpen")]
    pub fail_open: Option<bool>,
    /// ResponseTimeout configures maximum time to wait for a check response from the authorization server.
    /// Timeout durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).
    /// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    /// The string "infinity" is also a valid input and specifies no timeout.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseTimeout")]
    pub response_timeout: Option<String>,
    /// WithRequestBody specifies configuration for sending the client request's body to authorization server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withRequestBody")]
    pub with_request_body: Option<HTTPProxyVirtualhostAuthorizationWithRequestBody>,
}

/// AuthPolicy sets a default authorization policy for client requests.
/// This policy will be used unless overridden by individual routes.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostAuthorizationAuthPolicy {
    /// Context is a set of key/value pairs that are sent to the
    /// authentication server in the check request. If a context
    /// is provided at an enclosing scope, the entries are merged
    /// such that the inner scope overrides matching keys from the
    /// outer scope.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub context: Option<BTreeMap<String, String>>,
    /// When true, this field disables client request authentication
    /// for the scope of the policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// ExtensionServiceRef specifies the extension resource that will authorize client requests.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostAuthorizationExtensionRef {
    /// API version of the referent.
    /// If this field is not specified, the default "projectcontour.io/v1alpha1" will be used
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// If this field is not specifies, the namespace of the resource that targets the referent will be used.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// WithRequestBody specifies configuration for sending the client request's body to authorization server.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostAuthorizationWithRequestBody {
    /// If AllowPartialMessage is true, then Envoy will buffer the body until MaxRequestBytes are reached.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPartialMessage")]
    pub allow_partial_message: Option<bool>,
    /// MaxRequestBytes sets the maximum size of message body ExtAuthz filter will hold in-memory.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRequestBytes")]
    pub max_request_bytes: Option<i32>,
    /// If PackAsBytes is true, the body sent to Authorization Server is in raw bytes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "packAsBytes")]
    pub pack_as_bytes: Option<bool>,
}

/// Specifies the cross-origin policy to apply to the VirtualHost.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostCorsPolicy {
    /// Specifies whether the resource allows credentials.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    pub allow_credentials: Option<bool>,
    /// AllowHeaders specifies the content for the *access-control-allow-headers* header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    pub allow_headers: Option<Vec<String>>,
    /// AllowMethods specifies the content for the *access-control-allow-methods* header.
    #[serde(rename = "allowMethods")]
    pub allow_methods: Vec<String>,
    /// AllowOrigin specifies the origins that will be allowed to do CORS requests.
    /// Allowed values include "*" which signifies any origin is allowed, an exact
    /// origin of the form "scheme://host[:port]" (where port is optional), or a valid
    /// regex pattern.
    /// Note that regex patterns are validated and a simple "glob" pattern (e.g. *.foo.com)
    /// will be rejected or produce unexpected matches when applied as a regex.
    #[serde(rename = "allowOrigin")]
    pub allow_origin: Vec<String>,
    /// AllowPrivateNetwork specifies whether to allow private network requests.
    /// See https://developer.chrome.com/blog/private-network-access-preflight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivateNetwork")]
    pub allow_private_network: Option<bool>,
    /// ExposeHeaders Specifies the content for the *access-control-expose-headers* header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    pub expose_headers: Option<Vec<String>>,
    /// MaxAge indicates for how long the results of a preflight request can be cached.
    /// MaxAge durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).
    /// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    /// Only positive values are allowed while 0 disables the cache requiring a preflight OPTIONS
    /// check for all cross-origin requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    pub max_age: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostIpAllowPolicy {
    /// CIDR is a CIDR block of ipv4 or ipv6 addresses to filter on. This can also be
    /// a bare IP address (without a mask) to filter on exactly one address.
    pub cidr: String,
    /// Source indicates how to determine the ip address to filter on, and can be
    /// one of two values:
    ///  - `Remote` filters on the ip address of the client, accounting for PROXY and
    ///    X-Forwarded-For as needed.
    ///  - `Peer` filters on the ip of the network request, ignoring PROXY and
    ///    X-Forwarded-For.
    pub source: HTTPProxyVirtualhostIpAllowPolicySource,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyVirtualhostIpAllowPolicySource {
    Peer,
    Remote,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostIpDenyPolicy {
    /// CIDR is a CIDR block of ipv4 or ipv6 addresses to filter on. This can also be
    /// a bare IP address (without a mask) to filter on exactly one address.
    pub cidr: String,
    /// Source indicates how to determine the ip address to filter on, and can be
    /// one of two values:
    ///  - `Remote` filters on the ip address of the client, accounting for PROXY and
    ///    X-Forwarded-For as needed.
    ///  - `Peer` filters on the ip of the network request, ignoring PROXY and
    ///    X-Forwarded-For.
    pub source: HTTPProxyVirtualhostIpDenyPolicySource,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyVirtualhostIpDenyPolicySource {
    Peer,
    Remote,
}

/// JWTProvider defines how to verify JWTs on requests.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostJwtProviders {
    /// Audiences that JWTs are allowed to have in the "aud" field.
    /// If not provided, JWT audiences are not checked.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// Whether the provider should apply to all
    /// routes in the HTTPProxy/its includes by
    /// default. At most one provider can be marked
    /// as the default. If no provider is marked
    /// as the default, individual routes must explicitly
    /// identify the provider they require.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<bool>,
    /// Whether the JWT should be forwarded to the backend
    /// service after successful verification. By default,
    /// the JWT is not forwarded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardJWT")]
    pub forward_jwt: Option<bool>,
    /// Issuer that JWTs are required to have in the "iss" field.
    /// If not provided, JWT issuers are not checked.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issuer: Option<String>,
    /// Unique name for the provider.
    pub name: String,
    /// Remote JWKS to use for verifying JWT signatures.
    #[serde(rename = "remoteJWKS")]
    pub remote_jwks: HTTPProxyVirtualhostJwtProvidersRemoteJwks,
}

/// Remote JWKS to use for verifying JWT signatures.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostJwtProvidersRemoteJwks {
    /// How long to cache the JWKS locally. If not specified,
    /// Envoy's default of 5m applies.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cacheDuration")]
    pub cache_duration: Option<String>,
    /// The DNS IP address resolution policy for the JWKS URI.
    /// When configured as "v4", the DNS resolver will only perform a lookup
    /// for addresses in the IPv4 family. If "v6" is configured, the DNS resolver
    /// will only perform a lookup for addresses in the IPv6 family.
    /// If "all" is configured, the DNS resolver
    /// will perform a lookup for addresses in both the IPv4 and IPv6 family.
    /// If "auto" is configured, the DNS resolver will first perform a lookup
    /// for addresses in the IPv6 family and fallback to a lookup for addresses
    /// in the IPv4 family. If not specified, the Contour-wide setting defined
    /// in the config file or ContourConfiguration applies (defaults to "auto").
    /// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsLookupFamily")]
    pub dns_lookup_family: Option<HTTPProxyVirtualhostJwtProvidersRemoteJwksDnsLookupFamily>,
    /// How long to wait for a response from the URI.
    /// If not specified, a default of 1s applies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
    /// The URI for the JWKS.
    pub uri: String,
    /// UpstreamValidation defines how to verify the JWKS's TLS certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validation: Option<HTTPProxyVirtualhostJwtProvidersRemoteJwksValidation>,
}

/// Remote JWKS to use for verifying JWT signatures.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyVirtualhostJwtProvidersRemoteJwksDnsLookupFamily {
    #[serde(rename = "auto")]
    Auto,
    #[serde(rename = "v4")]
    V4,
    #[serde(rename = "v6")]
    V6,
}

/// UpstreamValidation defines how to verify the JWKS's TLS certificate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostJwtProvidersRemoteJwksValidation {
    /// Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend.
    /// The secret must contain key named ca.crt.
    /// The name can be optionally prefixed with namespace "namespace/name".
    /// When cross-namespace reference is used, TLSCertificateDelegation resource must exist in the namespace to grant access to the secret.
    /// Max length should be the actual max possible length of a namespaced name (63 + 253 + 1 = 317)
    #[serde(rename = "caSecret")]
    pub ca_secret: String,
    /// Key which is expected to be present in the 'subjectAltName' of the presented certificate.
    /// Deprecated: migrate to using the plural field subjectNames.
    #[serde(rename = "subjectName")]
    pub subject_name: String,
    /// List of keys, of which at least one is expected to be present in the 'subjectAltName of the
    /// presented certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectNames")]
    pub subject_names: Option<Vec<String>>,
}

/// The policy for rate limiting on the virtual host.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicy {
    /// Global defines global rate limiting parameters, i.e. parameters
    /// defining descriptors that are sent to an external rate limit
    /// service (RLS) for a rate limit decision on each request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<HTTPProxyVirtualhostRateLimitPolicyGlobal>,
    /// Local defines local rate limiting parameters, i.e. parameters
    /// for rate limiting that occurs within each Envoy pod as requests
    /// are handled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub local: Option<HTTPProxyVirtualhostRateLimitPolicyLocal>,
}

/// Global defines global rate limiting parameters, i.e. parameters
/// defining descriptors that are sent to an external rate limit
/// service (RLS) for a rate limit decision on each request.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyGlobal {
    /// Descriptors defines the list of descriptors that will
    /// be generated and sent to the rate limit service. Each
    /// descriptor contains 1+ key-value pair entries.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub descriptors: Option<Vec<HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptors>>,
    /// Disabled configures the HTTPProxy to not use
    /// the default global rate limit policy defined by the Contour configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

/// RateLimitDescriptor defines a list of key-value pair generators.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptors {
    /// Entries is the list of key-value pair generators.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<Vec<HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntries>>,
}

/// RateLimitDescriptorEntry is a key-value pair generator. Exactly
/// one field on this struct must be non-nil.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntries {
    /// GenericKey defines a descriptor entry with a static key and value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "genericKey")]
    pub generic_key: Option<HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey>,
    /// RemoteAddress defines a descriptor entry with a key of "remote_address"
    /// and a value equal to the client's IP address (from x-forwarded-for).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteAddress")]
    pub remote_address: Option<HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRemoteAddress>,
    /// RequestHeader defines a descriptor entry that's populated only if
    /// a given header is present on the request. The descriptor key is static,
    /// and the descriptor value is equal to the value of the header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeader")]
    pub request_header: Option<HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader>,
    /// RequestHeaderValueMatch defines a descriptor entry that's populated
    /// if the request's headers match a set of 1+ match criteria. The
    /// descriptor key is "header_match", and the descriptor value is static.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestHeaderValueMatch")]
    pub request_header_value_match: Option<HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch>,
}

/// GenericKey defines a descriptor entry with a static key and value.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey {
    /// Key defines the key of the descriptor entry. If not set, the
    /// key is set to "generic_key".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Value defines the value of the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// RemoteAddress defines a descriptor entry with a key of "remote_address"
/// and a value equal to the client's IP address (from x-forwarded-for).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRemoteAddress {
}

/// RequestHeader defines a descriptor entry that's populated only if
/// a given header is present on the request. The descriptor key is static,
/// and the descriptor value is equal to the value of the header.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader {
    /// DescriptorKey defines the key to use on the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "descriptorKey")]
    pub descriptor_key: Option<String>,
    /// HeaderName defines the name of the header to look for on the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerName")]
    pub header_name: Option<String>,
}

/// RequestHeaderValueMatch defines a descriptor entry that's populated
/// if the request's headers match a set of 1+ match criteria. The
/// descriptor key is "header_match", and the descriptor value is static.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch {
    /// ExpectMatch defines whether the request must positively match the match
    /// criteria in order to generate a descriptor entry (i.e. true), or not
    /// match the match criteria in order to generate a descriptor entry (i.e. false).
    /// The default is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expectMatch")]
    pub expect_match: Option<bool>,
    /// Headers is a list of 1+ match criteria to apply against the request
    /// to determine whether to populate the descriptor entry or not.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders>>,
    /// Value defines the value of the descriptor entry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// HeaderMatchCondition specifies how to conditionally match against HTTP
/// headers. The Name field is required, only one of Present, NotPresent,
/// Contains, NotContains, Exact, NotExact and Regex can be set.
/// For negative matching rules only (e.g. NotContains or NotExact) you can set
/// TreatMissingAsEmpty.
/// IgnoreCase has no effect for Regex.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders {
    /// Contains specifies a substring that must be present in
    /// the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// Exact specifies a string that the header value must be equal to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exact: Option<String>,
    /// IgnoreCase specifies that string matching should be case insensitive.
    /// Note that this has no effect on the Regex parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreCase")]
    pub ignore_case: Option<bool>,
    /// Name is the name of the header to match against. Name is required.
    /// Header names are case insensitive.
    pub name: String,
    /// NotContains specifies a substring that must not be present
    /// in the header value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notcontains: Option<String>,
    /// NoExact specifies a string that the header value must not be
    /// equal to. The condition is true if the header has any other value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notexact: Option<String>,
    /// NotPresent specifies that condition is true when the named header
    /// is not present. Note that setting NotPresent to false does not
    /// make the condition true if the named header is present.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notpresent: Option<bool>,
    /// Present specifies that condition is true when the named header
    /// is present, regardless of its value. Note that setting Present
    /// to false does not make the condition true if the named header
    /// is absent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub present: Option<bool>,
    /// Regex specifies a regular expression pattern that must match the header
    /// value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// TreatMissingAsEmpty specifies if the header match rule specified header
    /// does not exist, this header value will be treated as empty. Defaults to false.
    /// Unlike the underlying Envoy implementation this is **only** supported for
    /// negative matches (e.g. NotContains, NotExact).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "treatMissingAsEmpty")]
    pub treat_missing_as_empty: Option<bool>,
}

/// Local defines local rate limiting parameters, i.e. parameters
/// for rate limiting that occurs within each Envoy pod as requests
/// are handled.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyLocal {
    /// Burst defines the number of requests above the requests per
    /// unit that should be allowed within a short period of time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub burst: Option<i32>,
    /// Requests defines how many requests per unit of time should
    /// be allowed before rate limiting occurs.
    pub requests: i32,
    /// ResponseHeadersToAdd is an optional list of response headers to
    /// set when a request is rate-limited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseHeadersToAdd")]
    pub response_headers_to_add: Option<Vec<HTTPProxyVirtualhostRateLimitPolicyLocalResponseHeadersToAdd>>,
    /// ResponseStatusCode is the HTTP status code to use for responses
    /// to rate-limited requests. Codes must be in the 400-599 range
    /// (inclusive). If not specified, the Envoy default of 429 (Too
    /// Many Requests) is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "responseStatusCode")]
    pub response_status_code: Option<i32>,
    /// Unit defines the period of time within which requests
    /// over the limit will be rate limited. Valid values are
    /// "second", "minute" and "hour".
    pub unit: HTTPProxyVirtualhostRateLimitPolicyLocalUnit,
}

/// HeaderValue represents a header name/value pair
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostRateLimitPolicyLocalResponseHeadersToAdd {
    /// Name represents a key of a header
    pub name: String,
    /// Value represents the value of a header specified by a key
    pub value: String,
}

/// Local defines local rate limiting parameters, i.e. parameters
/// for rate limiting that occurs within each Envoy pod as requests
/// are handled.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum HTTPProxyVirtualhostRateLimitPolicyLocalUnit {
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
}

/// If present the fields describes TLS properties of the virtual
/// host. The SNI names that will be matched on are described in fqdn,
/// the tls.secretName secret must contain a certificate that itself
/// contains a name that matches the FQDN.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostTls {
    /// ClientValidation defines how to verify the client certificate
    /// when an external client establishes a TLS connection to Envoy.
    /// This setting:
    /// 1. Enables TLS client certificate validation.
    /// 2. Specifies how the client certificate will be validated (i.e.
    ///    validation required or skipped).
    /// Note: Setting client certificate validation to be skipped should
    /// be only used in conjunction with an external authorization server that
    /// performs client validation as Contour will ensure client certificates
    /// are passed along.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientValidation")]
    pub client_validation: Option<HTTPProxyVirtualhostTlsClientValidation>,
    /// EnableFallbackCertificate defines if the vhost should allow a default certificate to
    /// be applied which handles all requests which don't match the SNI defined in this vhost.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableFallbackCertificate")]
    pub enable_fallback_certificate: Option<bool>,
    /// MaximumProtocolVersion is the maximum TLS version this vhost should
    /// negotiate. Valid options are `1.2` and `1.3` (default). Any other value
    /// defaults to TLS 1.3.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maximumProtocolVersion")]
    pub maximum_protocol_version: Option<String>,
    /// MinimumProtocolVersion is the minimum TLS version this vhost should
    /// negotiate. Valid options are `1.2` (default) and `1.3`. Any other value
    /// defaults to TLS 1.2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minimumProtocolVersion")]
    pub minimum_protocol_version: Option<String>,
    /// Passthrough defines whether the encrypted TLS handshake will be
    /// passed through to the backing cluster. Either Passthrough or
    /// SecretName must be specified, but not both.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub passthrough: Option<bool>,
    /// SecretName is the name of a TLS secret.
    /// Either SecretName or Passthrough must be specified, but not both.
    /// If specified, the named secret must contain a matching certificate
    /// for the virtual host's FQDN.
    /// The name can be optionally prefixed with namespace "namespace/name".
    /// When cross-namespace reference is used, TLSCertificateDelegation resource must exist in the namespace to grant access to the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// ClientValidation defines how to verify the client certificate
/// when an external client establishes a TLS connection to Envoy.
/// This setting:
/// 1. Enables TLS client certificate validation.
/// 2. Specifies how the client certificate will be validated (i.e.
///    validation required or skipped).
/// Note: Setting client certificate validation to be skipped should
/// be only used in conjunction with an external authorization server that
/// performs client validation as Contour will ensure client certificates
/// are passed along.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostTlsClientValidation {
    /// Name of a Kubernetes secret that contains a CA certificate bundle.
    /// The secret must contain key named ca.crt.
    /// The client certificate must validate against the certificates in the bundle.
    /// If specified and SkipClientCertValidation is true, client certificates will
    /// be required on requests.
    /// The name can be optionally prefixed with namespace "namespace/name".
    /// When cross-namespace reference is used, TLSCertificateDelegation resource must exist in the namespace to grant access to the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caSecret")]
    pub ca_secret: Option<String>,
    /// If this option is set to true, only the certificate at the end of the
    /// certificate chain will be subject to validation by CRL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crlOnlyVerifyLeafCert")]
    pub crl_only_verify_leaf_cert: Option<bool>,
    /// Name of a Kubernetes opaque secret that contains a concatenated list of PEM encoded CRLs.
    /// The secret must contain key named crl.pem.
    /// This field will be used to verify that a client certificate has not been revoked.
    /// CRLs must be available from all CAs, unless crlOnlyVerifyLeafCert is true.
    /// Large CRL lists are not supported since individual secrets are limited to 1MiB in size.
    /// The name can be optionally prefixed with namespace "namespace/name".
    /// When cross-namespace reference is used, TLSCertificateDelegation resource must exist in the namespace to grant access to the secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "crlSecret")]
    pub crl_secret: Option<String>,
    /// ForwardClientCertificate adds the selected data from the passed client TLS certificate
    /// to the x-forwarded-client-cert header.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardClientCertificate")]
    pub forward_client_certificate: Option<HTTPProxyVirtualhostTlsClientValidationForwardClientCertificate>,
    /// OptionalClientCertificate when set to true will request a client certificate
    /// but allow the connection to continue if the client does not provide one.
    /// If a client certificate is sent, it will be verified according to the
    /// other properties, which includes disabling validation if
    /// SkipClientCertValidation is set. Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "optionalClientCertificate")]
    pub optional_client_certificate: Option<bool>,
    /// SkipClientCertValidation disables downstream client certificate
    /// validation. Defaults to false. This field is intended to be used in
    /// conjunction with external authorization in order to enable the external
    /// authorization server to validate client certificates. When this field
    /// is set to true, client certificates are requested but not verified by
    /// Envoy. If CACertificate is specified, client certificates are required on
    /// requests, but not verified. If external authorization is in use, they are
    /// presented to the external authorization server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipClientCertValidation")]
    pub skip_client_cert_validation: Option<bool>,
}

/// ForwardClientCertificate adds the selected data from the passed client TLS certificate
/// to the x-forwarded-client-cert header.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyVirtualhostTlsClientValidationForwardClientCertificate {
    /// Client cert in URL encoded PEM format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<bool>,
    /// Client cert chain (including the leaf cert) in URL encoded PEM format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub chain: Option<bool>,
    /// DNS type Subject Alternative Names of the client cert.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<bool>,
    /// Subject of the client cert.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<bool>,
    /// URI type Subject Alternative Name of the client cert.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uri: Option<bool>,
}

/// Status is a container for computed information about the HTTPProxy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyStatus {
    /// Conditions contains information about the current status of the HTTPProxy,
    /// in an upstream-friendly container.
    /// Contour will update a single condition, `Valid`, that is in normal-true polarity.
    /// That is, when `currentStatus` is `valid`, the `Valid` condition will be `status: true`,
    /// and vice versa.
    /// Contour will leave untouched any other Conditions set in this block,
    /// in case some other controller wants to add a Condition.
    /// If you are another controller owner and wish to add a condition, you *should*
    /// namespace your condition with a label, like `controller.domain.com/ConditionName`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentStatus")]
    pub current_status: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// LoadBalancer contains the current status of the load balancer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<HTTPProxyStatusLoadBalancer>,
}

/// LoadBalancer contains the current status of the load balancer.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyStatusLoadBalancer {
    /// Ingress is a list containing ingress points for the load-balancer.
    /// Traffic intended for the service should be sent to these ingress points.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<Vec<HTTPProxyStatusLoadBalancerIngress>>,
}

/// LoadBalancerIngress represents the status of a load-balancer ingress point:
/// traffic intended for the service should be sent to an ingress point.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyStatusLoadBalancerIngress {
    /// Hostname is set for load-balancer ingress points that are DNS based
    /// (typically AWS load-balancers)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// IP is set for load-balancer ingress points that are IP based
    /// (typically GCE or OpenStack load-balancers)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
    /// IPMode specifies how the load-balancer IP behaves, and may only be specified when the ip field is specified.
    /// Setting this to "VIP" indicates that traffic is delivered to the node with
    /// the destination set to the load-balancer's IP and port.
    /// Setting this to "Proxy" indicates that traffic is delivered to the node or pod with
    /// the destination set to the node's IP and node port or the pod's IP and port.
    /// Service implementations may use this information to adjust traffic routing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipMode")]
    pub ip_mode: Option<String>,
    /// Ports is a list of records of service ports
    /// If used, every port defined in the service should have an entry in it
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<HTTPProxyStatusLoadBalancerIngressPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct HTTPProxyStatusLoadBalancerIngressPorts {
    /// Error is to record the problem with the service port
    /// The format of the error shall comply with the following rules:
    /// - built-in error values shall be specified in this file and those shall use
    ///   CamelCase names
    /// - cloud provider specific error values must have names that comply with the
    ///   format foo.example.com/CamelCase.
    /// ---
    /// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    /// Port is the port number of the service port of which status is recorded here
    pub port: i32,
    /// Protocol is the protocol of the service port of which status is recorded here
    /// The supported values are: "TCP", "UDP", "SCTP"
    pub protocol: String,
}

