// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/opensearch-project/opensearch-k8s-operator/opensearch.opster.io/v1/opensearchismpolicies.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
}
use self::prelude::*;

/// ISMPolicySpec is the specification for the ISM policy for OS.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "opensearch.opster.io", version = "v1", kind = "OpenSearchISMPolicy", plural = "opensearchismpolicies")]
#[kube(namespaced)]
#[kube(status = "OpenSearchIsmPolicyStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct OpenSearchIsmPolicySpec {
    /// If true, apply the policy to existing indices that match the index patterns in the ISM template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applyToExistingIndices")]
    pub apply_to_existing_indices: Option<bool>,
    /// The default starting state for each index that uses this policy.
    #[serde(rename = "defaultState")]
    pub default_state: String,
    /// A human-readable description of the policy.
    pub description: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorNotification")]
    pub error_notification: Option<OpenSearchIsmPolicyErrorNotification>,
    /// Specify an ISM template pattern that matches the index to apply the policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ismTemplate")]
    pub ism_template: Option<OpenSearchIsmPolicyIsmTemplate>,
    /// LocalObjectReference contains enough information to let you locate the
    /// referenced object inside the same namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "opensearchCluster")]
    pub opensearch_cluster: Option<OpenSearchIsmPolicyOpensearchCluster>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "policyId")]
    pub policy_id: Option<String>,
    /// The states that you define in the policy.
    pub states: Vec<OpenSearchIsmPolicyStates>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyErrorNotification {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
    /// The destination URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub destination: Option<OpenSearchIsmPolicyErrorNotificationDestination>,
    /// The text of the message
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageTemplate")]
    pub message_template: Option<OpenSearchIsmPolicyErrorNotificationMessageTemplate>,
}

/// The destination URL.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyErrorNotificationDestination {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amazon: Option<OpenSearchIsmPolicyErrorNotificationDestinationAmazon>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub chime: Option<OpenSearchIsmPolicyErrorNotificationDestinationChime>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customWebhook")]
    pub custom_webhook: Option<OpenSearchIsmPolicyErrorNotificationDestinationCustomWebhook>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slack: Option<OpenSearchIsmPolicyErrorNotificationDestinationSlack>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyErrorNotificationDestinationAmazon {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyErrorNotificationDestinationChime {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyErrorNotificationDestinationCustomWebhook {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyErrorNotificationDestinationSlack {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// The text of the message
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyErrorNotificationMessageTemplate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// Specify an ISM template pattern that matches the index to apply the policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyIsmTemplate {
    /// Index patterns on which this policy has to be applied
    #[serde(rename = "indexPatterns")]
    pub index_patterns: Vec<String>,
    /// Priority of the template, defaults to 0
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyOpensearchCluster {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStates {
    /// The actions to execute after entering a state.
    pub actions: Vec<OpenSearchIsmPolicyStatesActions>,
    /// The name of the state.
    pub name: String,
    /// The next states and the conditions required to transition to those states. If no transitions exist, the policy assumes that it’s complete and can now stop managing the index
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transitions: Option<Vec<OpenSearchIsmPolicyStatesTransitions>>,
}

/// Actions are the steps that the policy sequentially executes on entering a specific state.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alias: Option<OpenSearchIsmPolicyStatesActionsAlias>,
    /// Allocate the index to a node with a specific attribute set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allocation: Option<OpenSearchIsmPolicyStatesActionsAllocation>,
    /// Closes the managed index.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub close: Option<OpenSearchIsmPolicyStatesActionsClose>,
    /// Deletes a managed index.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delete: Option<OpenSearchIsmPolicyStatesActionsDelete>,
    /// Reduces the number of Lucene segments by merging the segments of individual shards.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceMerge")]
    pub force_merge: Option<OpenSearchIsmPolicyStatesActionsForceMerge>,
    /// Set the priority for the index in a specific state.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "indexPriority")]
    pub index_priority: Option<OpenSearchIsmPolicyStatesActionsIndexPriority>,
    /// Name          string        `json:"name,omitempty"`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notification: Option<OpenSearchIsmPolicyStatesActionsNotification>,
    /// Opens a managed index.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub open: Option<OpenSearchIsmPolicyStatesActionsOpen>,
    /// Sets a managed index to be read only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<OpenSearchIsmPolicyStatesActionsReadOnly>,
    /// Sets a managed index to be writeable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readWrite")]
    pub read_write: Option<OpenSearchIsmPolicyStatesActionsReadWrite>,
    /// Sets the number of replicas to assign to an index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaCount")]
    pub replica_count: Option<OpenSearchIsmPolicyStatesActionsReplicaCount>,
    /// The retry configuration for the action.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry: Option<OpenSearchIsmPolicyStatesActionsRetry>,
    /// Rolls an alias over to a new index when the managed index meets one of the rollover conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollover: Option<OpenSearchIsmPolicyStatesActionsRollover>,
    /// Periodically reduce data granularity by rolling up old data into summarized indexes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollup: Option<OpenSearchIsmPolicyStatesActionsRollup>,
    /// Allows you to reduce the number of primary shards in your indexes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shrink: Option<OpenSearchIsmPolicyStatesActionsShrink>,
    /// Back up your cluster’s indexes and state
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub snapshot: Option<OpenSearchIsmPolicyStatesActionsSnapshot>,
    /// The timeout period for the action. Accepts time units for minutes, hours, and days.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsAlias {
    /// Allocate the index to a node with a specified attribute.
    pub actions: Vec<OpenSearchIsmPolicyStatesActionsAliasActions>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsAliasActions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<OpenSearchIsmPolicyStatesActionsAliasActionsAdd>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<OpenSearchIsmPolicyStatesActionsAliasActionsRemove>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsAliasActionsAdd {
    /// The name of the alias.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    /// The name of the index that the alias points to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// Specify the index that accepts any write operations to the alias.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isWriteIndex")]
    pub is_write_index: Option<bool>,
    /// Limit search to an associated shard value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routing: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsAliasActionsRemove {
    /// The name of the alias.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    /// The name of the index that the alias points to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<String>,
    /// Specify the index that accepts any write operations to the alias.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isWriteIndex")]
    pub is_write_index: Option<bool>,
    /// Limit search to an associated shard value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routing: Option<String>,
}

/// Allocate the index to a node with a specific attribute set
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsAllocation {
    /// Allocate the index to a node with a specified attribute.
    pub exclude: String,
    /// Allocate the index to a node with any of the specified attributes.
    pub include: String,
    /// Don’t allocate the index to a node with any of the specified attributes.
    pub require: String,
    /// Wait for the policy to execute before allocating the index to a node with a specified attribute.
    #[serde(rename = "waitFor")]
    pub wait_for: String,
}

/// Closes the managed index.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsClose {
}

/// Deletes a managed index.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsDelete {
}

/// Reduces the number of Lucene segments by merging the segments of individual shards.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsForceMerge {
    /// The number of segments to reduce the shard to.
    #[serde(rename = "maxNumSegments")]
    pub max_num_segments: i64,
}

/// Set the priority for the index in a specific state.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsIndexPriority {
    /// The priority for the index as soon as it enters a state.
    pub priority: i64,
}

/// Name          string        `json:"name,omitempty"`
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsNotification {
    pub destination: String,
    #[serde(rename = "messageTemplate")]
    pub message_template: OpenSearchIsmPolicyStatesActionsNotificationMessageTemplate,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsNotificationMessageTemplate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// Opens a managed index.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsOpen {
}

/// Sets a managed index to be read only.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsReadOnly {
}

/// Sets a managed index to be writeable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsReadWrite {
}

/// Sets the number of replicas to assign to an index.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsReplicaCount {
    #[serde(rename = "numberOfReplicas")]
    pub number_of_replicas: i64,
}

/// The retry configuration for the action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsRetry {
    /// The backoff policy type to use when retrying.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backoff: Option<String>,
    /// The number of retry counts.
    pub count: i64,
    /// The time to wait between retries.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delay: Option<String>,
}

/// Rolls an alias over to a new index when the managed index meets one of the rollover conditions.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsRollover {
    /// The minimum number of documents required to roll over the index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDocCount")]
    pub min_doc_count: Option<i64>,
    /// The minimum age required to roll over the index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minIndexAge")]
    pub min_index_age: Option<String>,
    /// The minimum storage size of a single primary shard required to roll over the index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minPrimaryShardSize")]
    pub min_primary_shard_size: Option<String>,
    /// The minimum size of the total primary shard storage (not counting replicas) required to roll over the index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minSize")]
    pub min_size: Option<String>,
}

/// Periodically reduce data granularity by rolling up old data into summarized indexes.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsRollup {
}

/// Allows you to reduce the number of primary shards in your indexes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsShrink {
    /// If true, executes the shrink action even if there are no replicas.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceUnsafe")]
    pub force_unsafe: Option<bool>,
    /// The maximum size in bytes of a shard for the target index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxShardSize")]
    pub max_shard_size: Option<String>,
    /// The maximum number of primary shards in the shrunken index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numNewShards")]
    pub num_new_shards: Option<i64>,
    /// Percentage of the number of original primary shards to shrink.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "percentageOfSourceShards")]
    pub percentage_of_source_shards: Option<i64>,
    /// The name of the shrunken index.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetIndexNameTemplate")]
    pub target_index_name_template: Option<String>,
}

/// Back up your cluster’s indexes and state
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesActionsSnapshot {
    /// The repository name that you register through the native snapshot API operations.
    pub repository: String,
    /// The name of the snapshot.
    pub snapshot: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesTransitions {
    /// conditions for the transition.
    pub conditions: OpenSearchIsmPolicyStatesTransitionsConditions,
    /// The name of the state to transition to if the conditions are met.
    #[serde(rename = "stateName")]
    pub state_name: String,
}

/// conditions for the transition.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesTransitionsConditions {
    /// The cron job that triggers the transition if no other transition happens first.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cron: Option<OpenSearchIsmPolicyStatesTransitionsConditionsCron>,
    /// The minimum document count of the index required to transition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDocCount")]
    pub min_doc_count: Option<i64>,
    /// The minimum age of the index required to transition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minIndexAge")]
    pub min_index_age: Option<String>,
    /// The minimum age required after a rollover has occurred to transition to the next state.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minRolloverAge")]
    pub min_rollover_age: Option<String>,
    /// The minimum size of the total primary shard storage (not counting replicas) required to transition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minSize")]
    pub min_size: Option<String>,
}

/// The cron job that triggers the transition if no other transition happens first.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesTransitionsConditionsCron {
    /// A wrapper for the cron job that triggers the transition if no other transition happens first. This wrapper is here to adhere to the OpenSearch API.
    pub cron: OpenSearchIsmPolicyStatesTransitionsConditionsCronCron,
}

/// A wrapper for the cron job that triggers the transition if no other transition happens first. This wrapper is here to adhere to the OpenSearch API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatesTransitionsConditionsCronCron {
    /// The cron expression that triggers the transition.
    pub expression: String,
    /// The timezone that triggers the transition.
    pub timezone: String,
}

/// OpensearchISMPolicyStatus defines the observed state of OpensearchISMPolicy
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct OpenSearchIsmPolicyStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "existingISMPolicy")]
    pub existing_ism_policy: Option<bool>,
    /// UID is a type that holds unique ID values, including UUIDs.  Because we
    /// don't ONLY use UUIDs, this is an alias to string.  Being a type captures
    /// intent and helps make sure that UIDs and names do not get conflated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedCluster")]
    pub managed_cluster: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "policyId")]
    pub policy_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

