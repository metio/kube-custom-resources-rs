// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/external-secrets/external-secrets/generators.external-secrets.io/v1alpha1/clustergenerators.yaml
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "generators.external-secrets.io", version = "v1alpha1", kind = "ClusterGenerator", plural = "clustergenerators")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct ClusterGeneratorSpec {
    /// Generator the spec for this generator, must match the kind.
    pub generator: ClusterGeneratorGenerator,
    /// Kind the kind of this generator.
    pub kind: ClusterGeneratorKind,
}

/// Generator the spec for this generator, must match the kind.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGenerator {
    /// ACRAccessTokenSpec defines how to generate the access token
    /// e.g. how to authenticate and which registry to use.
    /// see: <https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md#overview>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "acrAccessTokenSpec")]
    pub acr_access_token_spec: Option<ClusterGeneratorGeneratorAcrAccessTokenSpec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ecrAuthorizationTokenSpec")]
    pub ecr_authorization_token_spec: Option<ClusterGeneratorGeneratorEcrAuthorizationTokenSpec>,
    /// FakeSpec contains the static data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fakeSpec")]
    pub fake_spec: Option<ClusterGeneratorGeneratorFakeSpec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcrAccessTokenSpec")]
    pub gcr_access_token_spec: Option<ClusterGeneratorGeneratorGcrAccessTokenSpec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "githubAccessTokenSpec")]
    pub github_access_token_spec: Option<ClusterGeneratorGeneratorGithubAccessTokenSpec>,
    /// GrafanaSpec controls the behavior of the grafana generator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "grafanaSpec")]
    pub grafana_spec: Option<ClusterGeneratorGeneratorGrafanaSpec>,
    /// MFASpec controls the behavior of the mfa generator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mfaSpec")]
    pub mfa_spec: Option<ClusterGeneratorGeneratorMfaSpec>,
    /// PasswordSpec controls the behavior of the password generator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordSpec")]
    pub password_spec: Option<ClusterGeneratorGeneratorPasswordSpec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "quayAccessTokenSpec")]
    pub quay_access_token_spec: Option<ClusterGeneratorGeneratorQuayAccessTokenSpec>,
    /// SSHKeySpec controls the behavior of the ssh key generator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sshKeySpec")]
    pub ssh_key_spec: Option<ClusterGeneratorGeneratorSshKeySpec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stsSessionTokenSpec")]
    pub sts_session_token_spec: Option<ClusterGeneratorGeneratorStsSessionTokenSpec>,
    /// UUIDSpec controls the behavior of the uuid generator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "uuidSpec")]
    pub uuid_spec: Option<ClusterGeneratorGeneratorUuidSpec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vaultDynamicSecretSpec")]
    pub vault_dynamic_secret_spec: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpec>,
    /// WebhookSpec controls the behavior of the external generator. Any body parameters should be passed to the server through the parameters field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookSpec")]
    pub webhook_spec: Option<ClusterGeneratorGeneratorWebhookSpec>,
}

/// ACRAccessTokenSpec defines how to generate the access token
/// e.g. how to authenticate and which registry to use.
/// see: <https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md#overview>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorAcrAccessTokenSpec {
    pub auth: ClusterGeneratorGeneratorAcrAccessTokenSpecAuth,
    /// EnvironmentType specifies the Azure cloud environment endpoints to use for
    /// connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint.
    /// The following endpoints are available, also see here: <https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152>
    /// PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "environmentType")]
    pub environment_type: Option<ClusterGeneratorGeneratorAcrAccessTokenSpecEnvironmentType>,
    /// the domain name of the ACR registry
    /// e.g. foobarexample.azurecr.io
    pub registry: String,
    /// Define the scope for the access token, e.g. pull/push access for a repository.
    /// if not provided it will return a refresh token that has full scope.
    /// Note: you need to pin it down to the repository level, there is no wildcard available.
    /// 
    /// examples:
    /// repository:my-repository:pull,push
    /// repository:my-repository:pull
    /// 
    /// see docs for details: <https://docs.docker.com/registry/spec/auth/scope/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
    /// TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantId")]
    pub tenant_id: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorAcrAccessTokenSpecAuth {
    /// ManagedIdentity uses Azure Managed Identity to authenticate with Azure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedIdentity")]
    pub managed_identity: Option<ClusterGeneratorGeneratorAcrAccessTokenSpecAuthManagedIdentity>,
    /// ServicePrincipal uses Azure Service Principal credentials to authenticate with Azure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "servicePrincipal")]
    pub service_principal: Option<ClusterGeneratorGeneratorAcrAccessTokenSpecAuthServicePrincipal>,
    /// WorkloadIdentity uses Azure Workload Identity to authenticate with Azure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadIdentity")]
    pub workload_identity: Option<ClusterGeneratorGeneratorAcrAccessTokenSpecAuthWorkloadIdentity>,
}

/// ManagedIdentity uses Azure Managed Identity to authenticate with Azure.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorAcrAccessTokenSpecAuthManagedIdentity {
    /// If multiple Managed Identity is assigned to the pod, you can select the one to be used
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityId")]
    pub identity_id: Option<String>,
}

/// ServicePrincipal uses Azure Service Principal credentials to authenticate with Azure.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorAcrAccessTokenSpecAuthServicePrincipal {
    /// Configuration used to authenticate with Azure using static
    /// credentials stored in a Kind=Secret.
    #[serde(rename = "secretRef")]
    pub secret_ref: ClusterGeneratorGeneratorAcrAccessTokenSpecAuthServicePrincipalSecretRef,
}

/// Configuration used to authenticate with Azure using static
/// credentials stored in a Kind=Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorAcrAccessTokenSpecAuthServicePrincipalSecretRef {
    /// The Azure clientId of the service principle used for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientId")]
    pub client_id: Option<ClusterGeneratorGeneratorAcrAccessTokenSpecAuthServicePrincipalSecretRefClientId>,
    /// The Azure ClientSecret of the service principle used for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientSecret")]
    pub client_secret: Option<ClusterGeneratorGeneratorAcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret>,
}

/// The Azure clientId of the service principle used for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorAcrAccessTokenSpecAuthServicePrincipalSecretRefClientId {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The Azure ClientSecret of the service principle used for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorAcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// WorkloadIdentity uses Azure Workload Identity to authenticate with Azure.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorAcrAccessTokenSpecAuthWorkloadIdentity {
    /// ServiceAccountRef specified the service account
    /// that should be used when authenticating with WorkloadIdentity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    pub service_account_ref: Option<ClusterGeneratorGeneratorAcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef>,
}

/// ServiceAccountRef specified the service account
/// that should be used when authenticating with WorkloadIdentity.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorAcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef {
    /// Audience specifies the `aud` claim for the service account token
    /// If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
    /// then this audiences will be appended to the list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// The name of the ServiceAccount resource being referred to.
    pub name: String,
    /// Namespace of the resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ACRAccessTokenSpec defines how to generate the access token
/// e.g. how to authenticate and which registry to use.
/// see: <https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md#overview>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterGeneratorGeneratorAcrAccessTokenSpecEnvironmentType {
    PublicCloud,
    #[serde(rename = "USGovernmentCloud")]
    UsGovernmentCloud,
    ChinaCloud,
    GermanCloud,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorEcrAuthorizationTokenSpec {
    /// Auth defines how to authenticate with AWS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuth>,
    /// Region specifies the region to operate in.
    pub region: String,
    /// You can assume a role before making calls to the
    /// desired AWS service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Scope specifies the ECR service scope.
    /// Valid options are private and public.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// Auth defines how to authenticate with AWS
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuth {
    /// Authenticate against AWS using service account tokens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthJwt>,
    /// AWSAuthSecretRef holds secret references for AWS credentials
    /// both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthSecretRef>,
}

/// Authenticate against AWS using service account tokens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthJwt {
    /// A reference to a ServiceAccount resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    pub service_account_ref: Option<ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthJwtServiceAccountRef>,
}

/// A reference to a ServiceAccount resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthJwtServiceAccountRef {
    /// Audience specifies the `aud` claim for the service account token
    /// If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
    /// then this audiences will be appended to the list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// The name of the ServiceAccount resource being referred to.
    pub name: String,
    /// Namespace of the resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// AWSAuthSecretRef holds secret references for AWS credentials
/// both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthSecretRef {
    /// The AccessKeyID is used for authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessKeyIDSecretRef")]
    pub access_key_id_secret_ref: Option<ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef>,
    /// The SecretAccessKey is used for authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretAccessKeySecretRef")]
    pub secret_access_key_secret_ref: Option<ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef>,
    /// The SessionToken used for authentication
    /// This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
    /// see: <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionTokenSecretRef")]
    pub session_token_secret_ref: Option<ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef>,
}

/// The AccessKeyID is used for authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The SecretAccessKey is used for authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The SessionToken used for authentication
/// This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
/// see: <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorEcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// FakeSpec contains the static data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorFakeSpec {
    /// Used to select the correct ESO controller (think: ingress.ingressClassName)
    /// The ESO controller is instantiated with a specific controller name and filters VDS based on this property
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub controller: Option<String>,
    /// Data defines the static data returned
    /// by this generator.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGcrAccessTokenSpec {
    /// Auth defines the means for authenticating with GCP
    pub auth: ClusterGeneratorGeneratorGcrAccessTokenSpecAuth,
    /// ProjectID defines which project to use to authenticate with
    #[serde(rename = "projectID")]
    pub project_id: String,
}

/// Auth defines the means for authenticating with GCP
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGcrAccessTokenSpecAuth {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterGeneratorGeneratorGcrAccessTokenSpecAuthSecretRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadIdentity")]
    pub workload_identity: Option<ClusterGeneratorGeneratorGcrAccessTokenSpecAuthWorkloadIdentity>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGcrAccessTokenSpecAuthSecretRef {
    /// The SecretAccessKey is used for authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretAccessKeySecretRef")]
    pub secret_access_key_secret_ref: Option<ClusterGeneratorGeneratorGcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef>,
}

/// The SecretAccessKey is used for authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGcrAccessTokenSpecAuthWorkloadIdentity {
    #[serde(rename = "clusterLocation")]
    pub cluster_location: String,
    #[serde(rename = "clusterName")]
    pub cluster_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterProjectID")]
    pub cluster_project_id: Option<String>,
    /// A reference to a ServiceAccount resource.
    #[serde(rename = "serviceAccountRef")]
    pub service_account_ref: ClusterGeneratorGeneratorGcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef,
}

/// A reference to a ServiceAccount resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef {
    /// Audience specifies the `aud` claim for the service account token
    /// If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
    /// then this audiences will be appended to the list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// The name of the ServiceAccount resource being referred to.
    pub name: String,
    /// Namespace of the resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGithubAccessTokenSpec {
    #[serde(rename = "appID")]
    pub app_id: String,
    /// Auth configures how ESO authenticates with a Github instance.
    pub auth: ClusterGeneratorGeneratorGithubAccessTokenSpecAuth,
    #[serde(rename = "installID")]
    pub install_id: String,
    /// Map of permissions the token will have. If omitted, defaults to all permissions the GitHub App has.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<BTreeMap<String, String>>,
    /// List of repositories the token will have access to. If omitted, defaults to all repositories the GitHub App
    /// is installed to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repositories: Option<Vec<String>>,
    /// URL configures the Github instance URL. Defaults to <https://github.com/.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Auth configures how ESO authenticates with a Github instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGithubAccessTokenSpecAuth {
    #[serde(rename = "privateKey")]
    pub private_key: ClusterGeneratorGeneratorGithubAccessTokenSpecAuthPrivateKey,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGithubAccessTokenSpecAuthPrivateKey {
    /// A reference to a specific 'key' within a Secret resource.
    /// In some instances, `key` is a required field.
    #[serde(rename = "secretRef")]
    pub secret_ref: ClusterGeneratorGeneratorGithubAccessTokenSpecAuthPrivateKeySecretRef,
}

/// A reference to a specific 'key' within a Secret resource.
/// In some instances, `key` is a required field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGithubAccessTokenSpecAuthPrivateKeySecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// GrafanaSpec controls the behavior of the grafana generator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGrafanaSpec {
    /// Auth is the authentication configuration to authenticate
    /// against the Grafana instance.
    pub auth: ClusterGeneratorGeneratorGrafanaSpecAuth,
    /// ServiceAccount is the configuration for the service account that
    /// is supposed to be generated by the generator.
    #[serde(rename = "serviceAccount")]
    pub service_account: ClusterGeneratorGeneratorGrafanaSpecServiceAccount,
    /// URL is the URL of the Grafana instance.
    pub url: String,
}

/// Auth is the authentication configuration to authenticate
/// against the Grafana instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGrafanaSpecAuth {
    /// Basic auth credentials used to authenticate against the Grafana instance.
    /// Note: you need a token which has elevated permissions to create service accounts.
    /// See here for the documentation on basic roles offered by Grafana:
    /// <https://grafana.com/docs/grafana/latest/administration/roles-and-permissions/access-control/rbac-fixed-basic-role-definitions/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic: Option<ClusterGeneratorGeneratorGrafanaSpecAuthBasic>,
    /// A service account token used to authenticate against the Grafana instance.
    /// Note: you need a token which has elevated permissions to create service accounts.
    /// See here for the documentation on basic roles offered by Grafana:
    /// <https://grafana.com/docs/grafana/latest/administration/roles-and-permissions/access-control/rbac-fixed-basic-role-definitions/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<ClusterGeneratorGeneratorGrafanaSpecAuthToken>,
}

/// Basic auth credentials used to authenticate against the Grafana instance.
/// Note: you need a token which has elevated permissions to create service accounts.
/// See here for the documentation on basic roles offered by Grafana:
/// <https://grafana.com/docs/grafana/latest/administration/roles-and-permissions/access-control/rbac-fixed-basic-role-definitions/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGrafanaSpecAuthBasic {
    /// A basic auth password used to authenticate against the Grafana instance.
    pub password: ClusterGeneratorGeneratorGrafanaSpecAuthBasicPassword,
    /// A basic auth username used to authenticate against the Grafana instance.
    pub username: String,
}

/// A basic auth password used to authenticate against the Grafana instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGrafanaSpecAuthBasicPassword {
    /// The key where the token is found.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// A service account token used to authenticate against the Grafana instance.
/// Note: you need a token which has elevated permissions to create service accounts.
/// See here for the documentation on basic roles offered by Grafana:
/// <https://grafana.com/docs/grafana/latest/administration/roles-and-permissions/access-control/rbac-fixed-basic-role-definitions/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGrafanaSpecAuthToken {
    /// The key where the token is found.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ServiceAccount is the configuration for the service account that
/// is supposed to be generated by the generator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorGrafanaSpecServiceAccount {
    /// Name is the name of the service account that will be created by ESO.
    pub name: String,
    /// Role is the role of the service account.
    /// See here for the documentation on basic roles offered by Grafana:
    /// <https://grafana.com/docs/grafana/latest/administration/roles-and-permissions/access-control/rbac-fixed-basic-role-definitions/>
    pub role: String,
}

/// MFASpec controls the behavior of the mfa generator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorMfaSpec {
    /// Algorithm to use for encoding. Defaults to SHA1 as per the RFC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<String>,
    /// Length defines the token length. Defaults to 6 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub length: Option<i64>,
    /// Secret is a secret selector to a secret containing the seed secret to generate the TOTP value from.
    pub secret: ClusterGeneratorGeneratorMfaSpecSecret,
    /// TimePeriod defines how long the token can be active. Defaults to 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timePeriod")]
    pub time_period: Option<i64>,
    /// When defines a time parameter that can be used to pin the origin time of the generated token.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<String>,
}

/// Secret is a secret selector to a secret containing the seed secret to generate the TOTP value from.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorMfaSpecSecret {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// PasswordSpec controls the behavior of the password generator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorPasswordSpec {
    /// set AllowRepeat to true to allow repeating characters.
    #[serde(rename = "allowRepeat")]
    pub allow_repeat: bool,
    /// Digits specifies the number of digits in the generated
    /// password. If omitted it defaults to 25% of the length of the password
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub digits: Option<i64>,
    /// Length of the password to be generated.
    /// Defaults to 24
    pub length: i64,
    /// Set NoUpper to disable uppercase characters
    #[serde(rename = "noUpper")]
    pub no_upper: bool,
    /// SymbolCharacters specifies the special characters that should be used
    /// in the generated password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "symbolCharacters")]
    pub symbol_characters: Option<String>,
    /// Symbols specifies the number of symbol characters in the generated
    /// password. If omitted it defaults to 25% of the length of the password
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorQuayAccessTokenSpec {
    /// Name of the robot account you are federating with
    #[serde(rename = "robotAccount")]
    pub robot_account: String,
    /// Name of the service account you are federating with
    #[serde(rename = "serviceAccountRef")]
    pub service_account_ref: ClusterGeneratorGeneratorQuayAccessTokenSpecServiceAccountRef,
    /// URL configures the Quay instance URL. Defaults to quay.io.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Name of the service account you are federating with
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorQuayAccessTokenSpecServiceAccountRef {
    /// Audience specifies the `aud` claim for the service account token
    /// If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
    /// then this audiences will be appended to the list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// The name of the ServiceAccount resource being referred to.
    pub name: String,
    /// Namespace of the resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// SSHKeySpec controls the behavior of the ssh key generator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorSshKeySpec {
    /// Comment specifies an optional comment for the SSH key
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// KeySize specifies the key size for RSA keys (default: 2048)
    /// For RSA keys: 2048, 3072, 4096
    /// Ignored for ed25519 keys
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySize")]
    pub key_size: Option<i64>,
    /// KeyType specifies the SSH key type (rsa, ed25519)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyType")]
    pub key_type: Option<ClusterGeneratorGeneratorSshKeySpecKeyType>,
}

/// SSHKeySpec controls the behavior of the ssh key generator.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterGeneratorGeneratorSshKeySpecKeyType {
    #[serde(rename = "rsa")]
    Rsa,
    #[serde(rename = "ed25519")]
    Ed25519,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorStsSessionTokenSpec {
    /// Auth defines how to authenticate with AWS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<ClusterGeneratorGeneratorStsSessionTokenSpecAuth>,
    /// Region specifies the region to operate in.
    pub region: String,
    /// RequestParameters contains parameters that can be passed to the STS service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestParameters")]
    pub request_parameters: Option<ClusterGeneratorGeneratorStsSessionTokenSpecRequestParameters>,
    /// You can assume a role before making calls to the
    /// desired AWS service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
}

/// Auth defines how to authenticate with AWS
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorStsSessionTokenSpecAuth {
    /// Authenticate against AWS using service account tokens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<ClusterGeneratorGeneratorStsSessionTokenSpecAuthJwt>,
    /// AWSAuthSecretRef holds secret references for AWS credentials
    /// both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterGeneratorGeneratorStsSessionTokenSpecAuthSecretRef>,
}

/// Authenticate against AWS using service account tokens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorStsSessionTokenSpecAuthJwt {
    /// A reference to a ServiceAccount resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    pub service_account_ref: Option<ClusterGeneratorGeneratorStsSessionTokenSpecAuthJwtServiceAccountRef>,
}

/// A reference to a ServiceAccount resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorStsSessionTokenSpecAuthJwtServiceAccountRef {
    /// Audience specifies the `aud` claim for the service account token
    /// If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
    /// then this audiences will be appended to the list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// The name of the ServiceAccount resource being referred to.
    pub name: String,
    /// Namespace of the resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// AWSAuthSecretRef holds secret references for AWS credentials
/// both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorStsSessionTokenSpecAuthSecretRef {
    /// The AccessKeyID is used for authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessKeyIDSecretRef")]
    pub access_key_id_secret_ref: Option<ClusterGeneratorGeneratorStsSessionTokenSpecAuthSecretRefAccessKeyIdSecretRef>,
    /// The SecretAccessKey is used for authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretAccessKeySecretRef")]
    pub secret_access_key_secret_ref: Option<ClusterGeneratorGeneratorStsSessionTokenSpecAuthSecretRefSecretAccessKeySecretRef>,
    /// The SessionToken used for authentication
    /// This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
    /// see: <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionTokenSecretRef")]
    pub session_token_secret_ref: Option<ClusterGeneratorGeneratorStsSessionTokenSpecAuthSecretRefSessionTokenSecretRef>,
}

/// The AccessKeyID is used for authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorStsSessionTokenSpecAuthSecretRefAccessKeyIdSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The SecretAccessKey is used for authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorStsSessionTokenSpecAuthSecretRefSecretAccessKeySecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The SessionToken used for authentication
/// This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
/// see: <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorStsSessionTokenSpecAuthSecretRefSessionTokenSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// RequestParameters contains parameters that can be passed to the STS service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorStsSessionTokenSpecRequestParameters {
    /// SerialNumber is the identification number of the MFA device that is associated with the IAM user who is making
    /// the GetSessionToken call.
    /// Possible values: hardware device (such as GAHT12345678) or an Amazon Resource Name (ARN) for a virtual device
    /// (such as arn:aws:iam::123456789012:mfa/user)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serialNumber")]
    pub serial_number: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionDuration")]
    pub session_duration: Option<i32>,
    /// TokenCode is the value provided by the MFA device, if MFA is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenCode")]
    pub token_code: Option<String>,
}

/// UUIDSpec controls the behavior of the uuid generator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorUuidSpec {
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpec {
    /// Do not fail if no secrets are found. Useful for requests where no data is expected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowEmptyResponse")]
    pub allow_empty_response: Option<bool>,
    /// Used to select the correct ESO controller (think: ingress.ingressClassName)
    /// The ESO controller is instantiated with a specific controller name and filters VDS based on this property
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub controller: Option<String>,
    /// Vault API method to use (GET/POST/other)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Parameters to pass to Vault write (for non-GET methods)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Value>,
    /// Vault path to obtain the dynamic secret from
    pub path: String,
    /// Vault provider common spec
    pub provider: ClusterGeneratorGeneratorVaultDynamicSecretSpecProvider,
    /// Result type defines which data is returned from the generator.
    /// By default it is the "data" section of the Vault API response.
    /// When using e.g. /auth/token/create the "data" section is empty but
    /// the "auth" section contains the generated token.
    /// Please refer to the vault docs regarding the result data structure.
    /// Additionally, accessing the raw response is possibly by using "Raw" result type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resultType")]
    pub result_type: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecResultType>,
    /// Used to configure http retries if failed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retrySettings")]
    pub retry_settings: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecRetrySettings>,
}

/// Vault provider common spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProvider {
    /// Auth configures how secret-manager authenticates with the Vault server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuth>,
    /// PEM encoded CA bundle used to validate Vault server certificate. Only used
    /// if the Server URL is using HTTPS protocol. This parameter is ignored for
    /// plain HTTP protocol connection. If not set the system root certificates
    /// are used to validate the TLS connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caBundle")]
    pub ca_bundle: Option<String>,
    /// The provider for the CA bundle to use to validate Vault server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caProvider")]
    pub ca_provider: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderCaProvider>,
    /// ForwardInconsistent tells Vault to forward read-after-write requests to the Vault
    /// leader instead of simply retrying within a loop. This can increase performance if
    /// the option is enabled serverside.
    /// <https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forwardInconsistent")]
    pub forward_inconsistent: Option<bool>,
    /// Headers to be added in Vault request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, String>>,
    /// Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows
    /// Vault environments to support Secure Multi-tenancy. e.g: "ns1".
    /// More about namespaces can be found here <https://www.vaultproject.io/docs/enterprise/namespaces>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Path is the mount path of the Vault KV backend endpoint, e.g:
    /// "secret". The v2 KV secret engine version specific "/data" path suffix
    /// for fetching secrets from Vault is optional and will be appended
    /// if not present in specified path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// ReadYourWrites ensures isolated read-after-write semantics by
    /// providing discovered cluster replication states in each request.
    /// More information about eventual consistency in Vault can be found here
    /// <https://www.vaultproject.io/docs/enterprise/consistency>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readYourWrites")]
    pub read_your_writes: Option<bool>,
    /// Server is the connection address for the Vault server, e.g: "<https://vault.example.com:8200".>
    pub server: String,
    /// The configuration used for client side related TLS communication, when the Vault server
    /// requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
    /// This parameter is ignored for plain HTTP protocol connection.
    /// It's worth noting this configuration is different from the "TLS certificates auth method",
    /// which is available under the `auth.cert` section.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderTls>,
    /// Version is the Vault KV secret engine version. This can be either "v1" or
    /// "v2". Version defaults to "v2".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderVersion>,
}

/// Auth configures how secret-manager authenticates with the Vault server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuth {
    /// AppRole authenticates with Vault using the App Role auth mechanism,
    /// with the role and secret stored in a Kubernetes Secret resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appRole")]
    pub app_role: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthAppRole>,
    /// Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
    /// Cert authentication method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthCert>,
    /// Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
    /// AWS IAM authentication method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iam: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIam>,
    /// Jwt authenticates with Vault by passing role and JWT token using the
    /// JWT/OIDC authentication method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthJwt>,
    /// Kubernetes authenticates with Vault by passing the ServiceAccount
    /// token stored in the named Secret resource to the Vault server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kubernetes: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthKubernetes>,
    /// Ldap authenticates with Vault by passing username/password pair using
    /// the LDAP authentication method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ldap: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthLdap>,
    /// Name of the vault namespace to authenticate to. This can be different than the namespace your secret is in.
    /// Namespaces is a set of features within Vault Enterprise that allows
    /// Vault environments to support Secure Multi-tenancy. e.g: "ns1".
    /// More about namespaces can be found here <https://www.vaultproject.io/docs/enterprise/namespaces>
    /// This will default to Vault.Namespace field if set, or empty otherwise
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// TokenSecretRef authenticates with Vault by presenting a token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenSecretRef")]
    pub token_secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthTokenSecretRef>,
    /// UserPass authenticates with Vault by passing username/password pair
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userPass")]
    pub user_pass: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthUserPass>,
}

/// AppRole authenticates with Vault using the App Role auth mechanism,
/// with the role and secret stored in a Kubernetes Secret resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthAppRole {
    /// Path where the App Role authentication backend is mounted
    /// in Vault, e.g: "approle"
    pub path: String,
    /// RoleID configured in the App Role authentication backend when setting
    /// up the authentication backend in Vault.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleId")]
    pub role_id: Option<String>,
    /// Reference to a key in a Secret that contains the App Role ID used
    /// to authenticate with Vault.
    /// The `key` field must be specified and denotes which entry within the Secret
    /// resource is used as the app role id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleRef")]
    pub role_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthAppRoleRoleRef>,
    /// Reference to a key in a Secret that contains the App Role secret used
    /// to authenticate with Vault.
    /// The `key` field must be specified and denotes which entry within the Secret
    /// resource is used as the app role secret.
    #[serde(rename = "secretRef")]
    pub secret_ref: ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthAppRoleSecretRef,
}

/// Reference to a key in a Secret that contains the App Role ID used
/// to authenticate with Vault.
/// The `key` field must be specified and denotes which entry within the Secret
/// resource is used as the app role id.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthAppRoleRoleRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Reference to a key in a Secret that contains the App Role secret used
/// to authenticate with Vault.
/// The `key` field must be specified and denotes which entry within the Secret
/// resource is used as the app role secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthAppRoleSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate
/// Cert authentication method
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthCert {
    /// ClientCert is a certificate to authenticate using the Cert Vault
    /// authentication method
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCert")]
    pub client_cert: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthCertClientCert>,
    /// SecretRef to a key in a Secret resource containing client private key to
    /// authenticate with Vault using the Cert authentication method
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthCertSecretRef>,
}

/// ClientCert is a certificate to authenticate using the Cert Vault
/// authentication method
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthCertClientCert {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// SecretRef to a key in a Secret resource containing client private key to
/// authenticate with Vault using the Cert authentication method
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthCertSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials
/// AWS IAM authentication method
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIam {
    /// AWS External ID set on assumed IAM roles
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalID")]
    pub external_id: Option<String>,
    /// Specify a service account with IRSA enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamJwt>,
    /// Path where the AWS auth method is enabled in Vault, e.g: "aws"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// AWS region
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// This is the AWS role to be assumed before talking to vault
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Specify credentials in a Secret object
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamSecretRef>,
    /// X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: <https://developer.hashicorp.com/vault/docs/auth/aws>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vaultAwsIamServerID")]
    pub vault_aws_iam_server_id: Option<String>,
    /// Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
    #[serde(rename = "vaultRole")]
    pub vault_role: String,
}

/// Specify a service account with IRSA enabled
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamJwt {
    /// A reference to a ServiceAccount resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    pub service_account_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef>,
}

/// A reference to a ServiceAccount resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef {
    /// Audience specifies the `aud` claim for the service account token
    /// If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
    /// then this audiences will be appended to the list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// The name of the ServiceAccount resource being referred to.
    pub name: String,
    /// Namespace of the resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Specify credentials in a Secret object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamSecretRef {
    /// The AccessKeyID is used for authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessKeyIDSecretRef")]
    pub access_key_id_secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef>,
    /// The SecretAccessKey is used for authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretAccessKeySecretRef")]
    pub secret_access_key_secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef>,
    /// The SessionToken used for authentication
    /// This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
    /// see: <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionTokenSecretRef")]
    pub session_token_secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef>,
}

/// The AccessKeyID is used for authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The SecretAccessKey is used for authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The SessionToken used for authentication
/// This must be defined if AccessKeyID and SecretAccessKey are temporary credentials
/// see: <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Jwt authenticates with Vault by passing role and JWT token using the
/// JWT/OIDC authentication method
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthJwt {
    /// Optional ServiceAccountToken specifies the Kubernetes service account for which to request
    /// a token for with the `TokenRequest` API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesServiceAccountToken")]
    pub kubernetes_service_account_token: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken>,
    /// Path where the JWT authentication backend is mounted
    /// in Vault, e.g: "jwt"
    pub path: String,
    /// Role is a JWT role to authenticate using the JWT/OIDC Vault
    /// authentication method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Optional SecretRef that refers to a key in a Secret resource containing JWT token to
    /// authenticate with Vault using the JWT/OIDC authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthJwtSecretRef>,
}

/// Optional ServiceAccountToken specifies the Kubernetes service account for which to request
/// a token for with the `TokenRequest` API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken {
    /// Optional audiences field that will be used to request a temporary Kubernetes service
    /// account token for the service account referenced by `serviceAccountRef`.
    /// Defaults to a single audience `vault` it not specified.
    /// Deprecated: use serviceAccountRef.Audiences instead
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// Optional expiration time in seconds that will be used to request a temporary
    /// Kubernetes service account token for the service account referenced by
    /// `serviceAccountRef`.
    /// Deprecated: this will be removed in the future.
    /// Defaults to 10 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    /// Service account field containing the name of a kubernetes ServiceAccount.
    #[serde(rename = "serviceAccountRef")]
    pub service_account_ref: ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef,
}

/// Service account field containing the name of a kubernetes ServiceAccount.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
    /// Audience specifies the `aud` claim for the service account token
    /// If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
    /// then this audiences will be appended to the list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// The name of the ServiceAccount resource being referred to.
    pub name: String,
    /// Namespace of the resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Optional SecretRef that refers to a key in a Secret resource containing JWT token to
/// authenticate with Vault using the JWT/OIDC authentication method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthJwtSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Kubernetes authenticates with Vault by passing the ServiceAccount
/// token stored in the named Secret resource to the Vault server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthKubernetes {
    /// Path where the Kubernetes authentication backend is mounted in Vault, e.g:
    /// "kubernetes"
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// A required field containing the Vault Role to assume. A Role binds a
    /// Kubernetes ServiceAccount with a set of Vault policies.
    pub role: String,
    /// Optional secret field containing a Kubernetes ServiceAccount JWT used
    /// for authenticating with Vault. If a name is specified without a key,
    /// `token` is the default. If one is not specified, the one bound to
    /// the controller will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthKubernetesSecretRef>,
    /// Optional service account field containing the name of a kubernetes ServiceAccount.
    /// If the service account is specified, the service account secret token JWT will be used
    /// for authenticating with Vault. If the service account selector is not supplied,
    /// the secretRef will be used instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountRef")]
    pub service_account_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef>,
}

/// Optional secret field containing a Kubernetes ServiceAccount JWT used
/// for authenticating with Vault. If a name is specified without a key,
/// `token` is the default. If one is not specified, the one bound to
/// the controller will be used.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthKubernetesSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Optional service account field containing the name of a kubernetes ServiceAccount.
/// If the service account is specified, the service account secret token JWT will be used
/// for authenticating with Vault. If the service account selector is not supplied,
/// the secretRef will be used instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef {
    /// Audience specifies the `aud` claim for the service account token
    /// If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity
    /// then this audiences will be appended to the list
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
    /// The name of the ServiceAccount resource being referred to.
    pub name: String,
    /// Namespace of the resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Ldap authenticates with Vault by passing username/password pair using
/// the LDAP authentication method
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthLdap {
    /// Path where the LDAP authentication backend is mounted
    /// in Vault, e.g: "ldap"
    pub path: String,
    /// SecretRef to a key in a Secret resource containing password for the LDAP
    /// user used to authenticate with Vault using the LDAP authentication
    /// method
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthLdapSecretRef>,
    /// Username is an LDAP username used to authenticate using the LDAP Vault
    /// authentication method
    pub username: String,
}

/// SecretRef to a key in a Secret resource containing password for the LDAP
/// user used to authenticate with Vault using the LDAP authentication
/// method
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthLdapSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// TokenSecretRef authenticates with Vault by presenting a token.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthTokenSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// UserPass authenticates with Vault by passing username/password pair
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthUserPass {
    /// Path where the UserPassword authentication backend is mounted
    /// in Vault, e.g: "userpass"
    pub path: String,
    /// SecretRef to a key in a Secret resource containing password for the
    /// user used to authenticate with Vault using the UserPass authentication
    /// method
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthUserPassSecretRef>,
    /// Username is a username used to authenticate using the UserPass Vault
    /// authentication method
    pub username: String,
}

/// SecretRef to a key in a Secret resource containing password for the
/// user used to authenticate with Vault using the UserPass authentication
/// method
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderAuthUserPassSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The provider for the CA bundle to use to validate Vault server certificate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderCaProvider {
    /// The key where the CA certificate can be found in the Secret or ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the object located at the provider type.
    pub name: String,
    /// The namespace the Provider type is in.
    /// Can only be defined when used in a ClusterSecretStore.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The type of provider to use such as "Secret", or "ConfigMap".
    #[serde(rename = "type")]
    pub r#type: ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderCaProviderType,
}

/// The provider for the CA bundle to use to validate Vault server certificate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderCaProviderType {
    Secret,
    ConfigMap,
}

/// The configuration used for client side related TLS communication, when the Vault server
/// requires mutual authentication. Only used if the Server URL is using HTTPS protocol.
/// This parameter is ignored for plain HTTP protocol connection.
/// It's worth noting this configuration is different from the "TLS certificates auth method",
/// which is available under the `auth.cert` section.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderTls {
    /// CertSecretRef is a certificate added to the transport layer
    /// when communicating with the Vault server.
    /// If no key for the Secret is specified, external-secret will default to 'tls.crt'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certSecretRef")]
    pub cert_secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderTlsCertSecretRef>,
    /// KeySecretRef to a key in a Secret resource containing client private key
    /// added to the transport layer when communicating with the Vault server.
    /// If no key for the Secret is specified, external-secret will default to 'tls.key'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecretRef")]
    pub key_secret_ref: Option<ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderTlsKeySecretRef>,
}

/// CertSecretRef is a certificate added to the transport layer
/// when communicating with the Vault server.
/// If no key for the Secret is specified, external-secret will default to 'tls.crt'.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderTlsCertSecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// KeySecretRef to a key in a Secret resource containing client private key
/// added to the transport layer when communicating with the Vault server.
/// If no key for the Secret is specified, external-secret will default to 'tls.key'.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderTlsKeySecretRef {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Vault provider common spec
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterGeneratorGeneratorVaultDynamicSecretSpecProviderVersion {
    #[serde(rename = "v1")]
    V1,
    #[serde(rename = "v2")]
    V2,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterGeneratorGeneratorVaultDynamicSecretSpecResultType {
    Data,
    Auth,
    Raw,
}

/// Used to configure http retries if failed
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorVaultDynamicSecretSpecRetrySettings {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<String>,
}

/// WebhookSpec controls the behavior of the external generator. Any body parameters should be passed to the server through the parameters field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorWebhookSpec {
    /// Auth specifies a authorization protocol. Only one protocol may be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<ClusterGeneratorGeneratorWebhookSpecAuth>,
    /// Body
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// PEM encoded CA bundle used to validate webhook server certificate. Only used
    /// if the Server URL is using HTTPS protocol. This parameter is ignored for
    /// plain HTTP protocol connection. If not set the system root certificates
    /// are used to validate the TLS connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caBundle")]
    pub ca_bundle: Option<String>,
    /// The provider for the CA bundle to use to validate webhook server certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caProvider")]
    pub ca_provider: Option<ClusterGeneratorGeneratorWebhookSpecCaProvider>,
    /// Headers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, String>>,
    /// Webhook Method
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    /// Result formatting
    pub result: ClusterGeneratorGeneratorWebhookSpecResult,
    /// Secrets to fill in templates
    /// These secrets will be passed to the templating function as key value pairs under the given name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<ClusterGeneratorGeneratorWebhookSpecSecrets>>,
    /// Timeout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
    /// Webhook url to call
    pub url: String,
}

/// Auth specifies a authorization protocol. Only one protocol may be set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorWebhookSpecAuth {
    /// NTLMProtocol configures the store to use NTLM for auth
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ntlm: Option<ClusterGeneratorGeneratorWebhookSpecAuthNtlm>,
}

/// NTLMProtocol configures the store to use NTLM for auth
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorWebhookSpecAuthNtlm {
    /// A reference to a specific 'key' within a Secret resource.
    /// In some instances, `key` is a required field.
    #[serde(rename = "passwordSecret")]
    pub password_secret: ClusterGeneratorGeneratorWebhookSpecAuthNtlmPasswordSecret,
    /// A reference to a specific 'key' within a Secret resource.
    /// In some instances, `key` is a required field.
    #[serde(rename = "usernameSecret")]
    pub username_secret: ClusterGeneratorGeneratorWebhookSpecAuthNtlmUsernameSecret,
}

/// A reference to a specific 'key' within a Secret resource.
/// In some instances, `key` is a required field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorWebhookSpecAuthNtlmPasswordSecret {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// A reference to a specific 'key' within a Secret resource.
/// In some instances, `key` is a required field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorWebhookSpecAuthNtlmUsernameSecret {
    /// A key in the referenced Secret.
    /// Some instances of this field may be defaulted, in others it may be required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Secret resource being referred to.
    /// Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The provider for the CA bundle to use to validate webhook server certificate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterGeneratorGeneratorWebhookSpecCaProvider {
    /// The key where the CA certificate can be found in the Secret or ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the object located at the provider type.
    pub name: String,
    /// The namespace the Provider type is in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The type of provider to use such as "Secret", or "ConfigMap".
    #[serde(rename = "type")]
    pub r#type: ClusterGeneratorGeneratorWebhookSpecCaProviderType,
}

/// The provider for the CA bundle to use to validate webhook server certificate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterGeneratorGeneratorWebhookSpecCaProviderType {
    Secret,
    ConfigMap,
}

/// Result formatting
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorWebhookSpecResult {
    /// Json path of return value
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPath")]
    pub json_path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorWebhookSpecSecrets {
    /// Name of this secret in templates
    pub name: String,
    /// Secret ref to fill in credentials
    #[serde(rename = "secretRef")]
    pub secret_ref: ClusterGeneratorGeneratorWebhookSpecSecretsSecretRef,
}

/// Secret ref to fill in credentials
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterGeneratorGeneratorWebhookSpecSecretsSecretRef {
    /// The key where the token is found.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The name of the Secret resource being referred to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterGeneratorKind {
    #[serde(rename = "ACRAccessToken")]
    AcrAccessToken,
    #[serde(rename = "ECRAuthorizationToken")]
    EcrAuthorizationToken,
    Fake,
    #[serde(rename = "GCRAccessToken")]
    GcrAccessToken,
    GithubAccessToken,
    QuayAccessToken,
    Password,
    #[serde(rename = "SSHKey")]
    SshKey,
    #[serde(rename = "STSSessionToken")]
    StsSessionToken,
    #[serde(rename = "UUID")]
    Uuid,
    VaultDynamicSecret,
    Webhook,
    Grafana,
}

