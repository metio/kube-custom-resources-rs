// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/maistra/istio-workspace/workspace.maistra.io/v1alpha1/sessions.yaml
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// Spec defines the desired state
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "workspace.maistra.io", version = "v1alpha1", kind = "Session", plural = "sessions")]
#[kube(namespaced)]
#[kube(status = "SessionStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct SessionSpec {
    /// Who should participate in the given session
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ref")]
    pub r#ref: Option<Vec<SessionRef>>,
    /// How to route the given Session. A header based route using x-workspace-route with the Session name as value will be used if not provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<SessionRoute>,
}

/// Ref defines how to target a single Deployment or DeploymentConfig.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SessionRef {
    /// Additional arguments to the given strategy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<BTreeMap<String, String>>,
    /// Deployment or DeploymentConfig name, could optionally contain [Kind/]Name to be specific
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// How this deployment should be handled, e.g. telepresence or prepared-image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<String>,
}

/// How to route the given Session. A header based route using x-workspace-route with the Session name as value will be used if not provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SessionRoute {
    /// Name of the key, e.g. http header
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The type of route to use, e.g. header
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// The value to use for routing
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Status defines the current status of the State
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SessionStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "_refNames")]
    pub ref_names: Option<Vec<String>>,
    /// RouteExpression represents the Route object as single string expression
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "_routeExp")]
    pub route_exp: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "_strategies")]
    pub strategies: Option<Vec<String>>,
    /// The combined log of changes across all refs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub readiness: Option<SessionStatusReadiness>,
    /// The current configured route
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<SessionStatusRoute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SessionStatusReadiness {
    /// Status of resources deployed/modified by this Session resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<SessionStatusReadinessComponents>,
}

/// Status of resources deployed/modified by this Session resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SessionStatusReadinessComponents {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pending: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ready: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unready: Option<Vec<String>>,
}

/// The current configured route
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SessionStatusRoute {
    /// Name of the key, e.g. http header
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The type of route to use, e.g. header
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// The value to use for routing
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

