// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/VictoriaMetrics/operator/operator.victoriametrics.com/v1beta1/vmscrapeconfigs.yaml
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// VMScrapeConfigSpec defines the desired state of VMScrapeConfig
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "operator.victoriametrics.com", version = "v1beta1", kind = "VMScrapeConfig", plural = "vmscrapeconfigs")]
#[kube(namespaced)]
#[kube(status = "VMScrapeConfigStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct VMScrapeConfigSpec {
    /// Authorization with http header Authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<VMScrapeConfigAuthorization>,
    /// AzureSDConfigs defines a list of Azure service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureSDConfigs")]
    pub azure_sd_configs: Option<Vec<VMScrapeConfigAzureSdConfigs>>,
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<VMScrapeConfigBasicAuth>,
    /// File to read bearer token for scraping targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenFile")]
    pub bearer_token_file: Option<String>,
    /// Secret to mount to read bearer token for scraping targets. The secret
    /// needs to be in the same namespace as the scrape object and accessible by
    /// the victoria-metrics operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<VMScrapeConfigBearerTokenSecret>,
    /// ConsulSDConfigs defines a list of Consul service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consulSDConfigs")]
    pub consul_sd_configs: Option<Vec<VMScrapeConfigConsulSdConfigs>>,
    /// DigitalOceanSDConfigs defines a list of DigitalOcean service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "digitalOceanSDConfigs")]
    pub digital_ocean_sd_configs: Option<Vec<VMScrapeConfigDigitalOceanSdConfigs>>,
    /// DNSSDConfigs defines a list of DNS service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsSDConfigs")]
    pub dns_sd_configs: Option<Vec<VMScrapeConfigDnsSdConfigs>>,
    /// EC2SDConfigs defines a list of EC2 service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ec2SDConfigs")]
    pub ec2_sd_configs: Option<Vec<VMScrapeConfigEc2SdConfigs>>,
    /// FileSDConfigs defines a list of file service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSDConfigs")]
    pub file_sd_configs: Option<Vec<VMScrapeConfigFileSdConfigs>>,
    /// FollowRedirects controls redirects for scraping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub follow_redirects: Option<bool>,
    /// GCESDConfigs defines a list of GCE service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gceSDConfigs")]
    pub gce_sd_configs: Option<Vec<VMScrapeConfigGceSdConfigs>>,
    /// HonorLabels chooses the metric's labels on collisions with target labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorLabels")]
    pub honor_labels: Option<bool>,
    /// HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorTimestamps")]
    pub honor_timestamps: Option<bool>,
    /// HTTPSDConfigs defines a list of HTTP service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSDConfigs")]
    pub http_sd_configs: Option<Vec<VMScrapeConfigHttpSdConfigs>>,
    /// Interval at which metrics should be scraped
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// KubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSDConfigs")]
    pub kubernetes_sd_configs: Option<Vec<VMScrapeConfigKubernetesSdConfigs>>,
    /// MaxScrapeSize defines a maximum size of scraped data for a job
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_scrape_size: Option<String>,
    /// MetricRelabelConfigs to apply to samples after scrapping.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelConfigs")]
    pub metric_relabel_configs: Option<Vec<VMScrapeConfigMetricRelabelConfigs>>,
    /// OAuth2 defines auth configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<VMScrapeConfigOauth2>,
    /// OpenStackSDConfigs defines a list of OpenStack service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openstackSDConfigs")]
    pub openstack_sd_configs: Option<Vec<VMScrapeConfigOpenstackSdConfigs>>,
    /// Optional HTTP URL parameters
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, String>>,
    /// HTTP path to scrape for metrics.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// ProxyURL eg <http://proxyserver:2195> Directs scrapes to proxy through this endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// RelabelConfigs to apply to samples during service discovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relabelConfigs")]
    pub relabel_configs: Option<Vec<VMScrapeConfigRelabelConfigs>>,
    /// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// HTTP scheme to use for scraping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<VMScrapeConfigScheme>,
    /// Timeout after which the scrape is ended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// ScrapeInterval is the same as Interval and has priority over it.
    /// one of scrape_interval or interval can be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_interval: Option<String>,
    /// SeriesLimit defines per-scrape limit on number of unique time series
    /// a single target can expose during all the scrapes on the time window of 24h.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seriesLimit")]
    pub series_limit: Option<i64>,
    /// StaticConfigs defines a list of static targets with a common label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticConfigs")]
    pub static_configs: Option<Vec<VMScrapeConfigStaticConfigs>>,
    /// TLSConfig configuration to use when scraping the endpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VMScrapeConfigTlsConfig>,
    /// VMScrapeParams defines VictoriaMetrics specific scrape parameters
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vm_scrape_params: Option<VMScrapeConfigVmScrapeParams>,
}

/// Authorization with http header Authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigAuthorization {
    /// Reference to the secret with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<VMScrapeConfigAuthorizationCredentials>,
    /// File with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsFile")]
    pub credentials_file: Option<String>,
    /// Type of authorization, default to bearer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to the secret with value for authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// AzureSDConfig allow retrieving scrape targets from Azure VMs.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#azure_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigAzureSdConfigs {
    /// # The authentication method, either OAuth or ManagedIdentity.
    /// See <https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authenticationMethod")]
    pub authentication_method: Option<VMScrapeConfigAzureSdConfigsAuthenticationMethod>,
    /// Optional client ID. Only required with the OAuth authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    /// Optional client secret. Only required with the OAuth authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientSecret")]
    pub client_secret: Option<VMScrapeConfigAzureSdConfigsClientSecret>,
    /// The Azure environment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environment: Option<String>,
    /// The port to scrape metrics from. If using the public IP address, this must
    /// instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// Optional resource group name. Limits discovery to this resource group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceGroup")]
    pub resource_group: Option<String>,
    /// The subscription ID. Always required.
    #[serde(rename = "subscriptionID")]
    pub subscription_id: String,
    /// Optional tenant ID. Only required with the OAuth authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantID")]
    pub tenant_id: Option<String>,
}

/// AzureSDConfig allow retrieving scrape targets from Azure VMs.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#azure_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VMScrapeConfigAzureSdConfigsAuthenticationMethod {
    OAuth,
    ManagedIdentity,
}

/// Optional client secret. Only required with the OAuth authentication method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigAzureSdConfigsClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMScrapeConfigBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret to mount to read bearer token for scraping targets. The secret
/// needs to be in the same namespace as the scrape object and accessible by
/// the victoria-metrics operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConsulSDConfig defines a Consul service discovery configuration.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#consul_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigs {
    /// Allow stale Consul results (see <https://developer.hashicorp.com/consul/api-docs/features/consistency> ). Will reduce load on Consul.
    /// If unset, use its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStale")]
    pub allow_stale: Option<bool>,
    /// Authorization header to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<VMScrapeConfigConsulSdConfigsAuthorization>,
    /// BasicAuth information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<VMScrapeConfigConsulSdConfigsBasicAuth>,
    /// Consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datacenter: Option<String>,
    /// Filter defines filter for /v1/catalog/services requests
    /// See <https://developer.hashicorp.com/consul/api-docs/features/filtering>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// Configure whether HTTP requests follow HTTP 3xx redirects.
    /// If unset, use its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// Namespaces are only supported in Consul Enterprise.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Node metadata key/value pairs to filter nodes for a given service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeMeta")]
    pub node_meta: Option<BTreeMap<String, String>>,
    /// OAuth2 defines auth configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<VMScrapeConfigConsulSdConfigsOauth2>,
    /// Admin Partitions are only supported in Consul Enterprise.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// ProxyURL eg <http://proxyserver:2195> Directs scrapes to proxy through this endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// ProxyClientConfig configures proxy auth settings for scraping
    /// See [feature description](<https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_client_config: Option<VMScrapeConfigConsulSdConfigsProxyClientConfig>,
    /// HTTP Scheme default "http"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<VMScrapeConfigConsulSdConfigsScheme>,
    /// A valid string consisting of a hostname or IP followed by an optional port number.
    pub server: String,
    /// A list of services for which targets are retrieved. If omitted, all services are scraped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<String>>,
    /// The string by which Consul tags are joined into the tag label.
    /// If unset, use its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSeparator")]
    pub tag_separator: Option<String>,
    /// An optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// TLS configuration to use on every scrape request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VMScrapeConfigConsulSdConfigsTlsConfig>,
    /// Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenRef")]
    pub token_ref: Option<VMScrapeConfigConsulSdConfigsTokenRef>,
}

/// Authorization header to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsAuthorization {
    /// Reference to the secret with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<VMScrapeConfigConsulSdConfigsAuthorizationCredentials>,
    /// File with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsFile")]
    pub credentials_file: Option<String>,
    /// Type of authorization, default to bearer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to the secret with value for authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigConsulSdConfigsBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMScrapeConfigConsulSdConfigsBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OAuth2 defines auth configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsOauth2 {
    /// The secret or configmap containing the OAuth2 client id
    pub client_id: VMScrapeConfigConsulSdConfigsOauth2ClientId,
    /// The secret containing the OAuth2 client secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<VMScrapeConfigConsulSdConfigsOauth2ClientSecret>,
    /// ClientSecretFile defines path for client secret file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret_file: Option<String>,
    /// Parameters to append to the token URL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// The proxy URL for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_url: Option<String>,
    /// OAuth2 scopes used for the token request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// TLSConfig for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
    /// The URL to fetch the token from
    pub token_url: String,
}

/// The secret or configmap containing the OAuth2 client id
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigConsulSdConfigsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigConsulSdConfigsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret containing the OAuth2 client secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ProxyClientConfig configures proxy auth settings for scraping
/// See [feature description](<https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsProxyClientConfig {
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMScrapeConfigConsulSdConfigsProxyClientConfigBasicAuth>,
    /// SecretKeySelector selects a key of a Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token: Option<VMScrapeConfigConsulSdConfigsProxyClientConfigBearerToken>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsProxyClientConfigBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigConsulSdConfigsProxyClientConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMScrapeConfigConsulSdConfigsProxyClientConfigBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsProxyClientConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsProxyClientConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsProxyClientConfigBearerToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConsulSDConfig defines a Consul service discovery configuration.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#consul_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VMScrapeConfigConsulSdConfigsScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsTlsConfig {
    /// Struct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMScrapeConfigConsulSdConfigsTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMScrapeConfigConsulSdConfigsTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMScrapeConfigConsulSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Struct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigConsulSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigConsulSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigConsulSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigConsulSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigConsulSdConfigsTokenRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// DigitalOceanSDConfig allow retrieving scrape targets from DigitalOcean's Droplets API.
/// This service discovery uses the public IPv4 address by default, by that can be changed with relabeling.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#digitalocean_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigs {
    /// Authorization header to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<VMScrapeConfigDigitalOceanSdConfigsAuthorization>,
    /// Configure whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// OAuth2 defines auth configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<VMScrapeConfigDigitalOceanSdConfigsOauth2>,
    /// The port to scrape metrics from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// ProxyURL eg <http://proxyserver:2195> Directs scrapes to proxy through this endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// ProxyClientConfig configures proxy auth settings for scraping
    /// See [feature description](<https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_client_config: Option<VMScrapeConfigDigitalOceanSdConfigsProxyClientConfig>,
    /// TLS configuration to use on every scrape request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VMScrapeConfigDigitalOceanSdConfigsTlsConfig>,
}

/// Authorization header to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsAuthorization {
    /// Reference to the secret with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<VMScrapeConfigDigitalOceanSdConfigsAuthorizationCredentials>,
    /// File with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsFile")]
    pub credentials_file: Option<String>,
    /// Type of authorization, default to bearer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to the secret with value for authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OAuth2 defines auth configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsOauth2 {
    /// The secret or configmap containing the OAuth2 client id
    pub client_id: VMScrapeConfigDigitalOceanSdConfigsOauth2ClientId,
    /// The secret containing the OAuth2 client secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<VMScrapeConfigDigitalOceanSdConfigsOauth2ClientSecret>,
    /// ClientSecretFile defines path for client secret file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret_file: Option<String>,
    /// Parameters to append to the token URL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// The proxy URL for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_url: Option<String>,
    /// OAuth2 scopes used for the token request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// TLSConfig for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
    /// The URL to fetch the token from
    pub token_url: String,
}

/// The secret or configmap containing the OAuth2 client id
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigDigitalOceanSdConfigsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigDigitalOceanSdConfigsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret containing the OAuth2 client secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ProxyClientConfig configures proxy auth settings for scraping
/// See [feature description](<https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsProxyClientConfig {
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMScrapeConfigDigitalOceanSdConfigsProxyClientConfigBasicAuth>,
    /// SecretKeySelector selects a key of a Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token: Option<VMScrapeConfigDigitalOceanSdConfigsProxyClientConfigBearerToken>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsProxyClientConfigBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMScrapeConfigDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsProxyClientConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsProxyClientConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsProxyClientConfigBearerToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsTlsConfig {
    /// Struct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMScrapeConfigDigitalOceanSdConfigsTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMScrapeConfigDigitalOceanSdConfigsTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMScrapeConfigDigitalOceanSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Struct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigDigitalOceanSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigDigitalOceanSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigDigitalOceanSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigDigitalOceanSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDigitalOceanSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets.
/// The DNS servers to be contacted are read from /etc/resolv.conf.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#dns_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigDnsSdConfigs {
    /// A list of DNS domain names to be queried.
    pub names: Vec<String>,
    /// The port number used if the query type is not SRV
    /// Ignored for SRV records
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<VMScrapeConfigDnsSdConfigsType>,
}

/// DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets.
/// The DNS servers to be contacted are read from /etc/resolv.conf.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#dns_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VMScrapeConfigDnsSdConfigsType {
    #[serde(rename = "SRV")]
    Srv,
    A,
    #[serde(rename = "AAAA")]
    Aaaa,
    #[serde(rename = "MX")]
    Mx,
}

/// EC2SDConfig allow retrieving scrape targets from AWS EC2 instances.
/// The private IP address is used by default, but may be changed to the public IP address with relabeling.
/// The IAM credentials used must have the ec2:DescribeInstances permission to discover scrape targets.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#ec2_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigEc2SdConfigs {
    /// AccessKey is the AWS API key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessKey")]
    pub access_key: Option<VMScrapeConfigEc2SdConfigsAccessKey>,
    /// Filters can be used optionally to filter the instance list by other criteria.
    /// Available filter criteria can be found here:
    /// <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html>
    /// Filter API documentation: <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filters: Option<Vec<VMScrapeConfigEc2SdConfigsFilters>>,
    /// The port to scrape metrics from. If using the public IP address, this must
    /// instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// The AWS region
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// AWS Role ARN, an alternative to using AWS API keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleARN")]
    pub role_arn: Option<String>,
    /// SecretKey is the AWS API secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKey")]
    pub secret_key: Option<VMScrapeConfigEc2SdConfigsSecretKey>,
}

/// AccessKey is the AWS API key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigEc2SdConfigsAccessKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EC2Filter is the configuration for filtering EC2 instances.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigEc2SdConfigsFilters {
    pub name: String,
    pub values: Vec<String>,
}

/// SecretKey is the AWS API secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigEc2SdConfigsSecretKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// FileSDConfig defines a file service discovery configuration.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#file_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigFileSdConfigs {
    /// List of files to be used for file discovery.
    pub files: Vec<String>,
}

/// GCESDConfig configures scrape targets from GCP GCE instances.
/// The private IP address is used by default, but may be changed to
/// the public IP address with relabeling.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#gce_sd_configs)>
/// 
/// The GCE service discovery will load the Google Cloud credentials
/// from the file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.
/// See <https://cloud.google.com/kubernetes-engine/docs/tutorials/authenticating-to-cloud-platform>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigGceSdConfigs {
    /// Filter can be used optionally to filter the instance list by other criteria
    /// Syntax of this filter is described in the filter query parameter section:
    /// <https://cloud.google.com/compute/docs/reference/latest/instances/list>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// The port to scrape metrics from. If using the public IP address, this must
    /// instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// The Google Cloud Project ID
    pub project: String,
    /// The tag separator is used to separate the tags on concatenation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSeparator")]
    pub tag_separator: Option<String>,
    /// The zone of the scrape targets. If you need multiple zones use multiple GCESDConfigs.
    pub zone: serde_json::Value,
}

/// HTTPSDConfig defines a HTTP service discovery configuration.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#http_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigs {
    /// Authorization header to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<VMScrapeConfigHttpSdConfigsAuthorization>,
    /// BasicAuth information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<VMScrapeConfigHttpSdConfigsBasicAuth>,
    /// ProxyURL eg <http://proxyserver:2195> Directs scrapes to proxy through this endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// ProxyClientConfig configures proxy auth settings for scraping
    /// See [feature description](<https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_client_config: Option<VMScrapeConfigHttpSdConfigsProxyClientConfig>,
    /// TLS configuration to use on every scrape request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VMScrapeConfigHttpSdConfigsTlsConfig>,
    /// URL from which the targets are fetched.
    pub url: String,
}

/// Authorization header to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsAuthorization {
    /// Reference to the secret with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<VMScrapeConfigHttpSdConfigsAuthorizationCredentials>,
    /// File with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsFile")]
    pub credentials_file: Option<String>,
    /// Type of authorization, default to bearer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to the secret with value for authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigHttpSdConfigsBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMScrapeConfigHttpSdConfigsBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ProxyClientConfig configures proxy auth settings for scraping
/// See [feature description](<https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsProxyClientConfig {
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMScrapeConfigHttpSdConfigsProxyClientConfigBasicAuth>,
    /// SecretKeySelector selects a key of a Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token: Option<VMScrapeConfigHttpSdConfigsProxyClientConfigBearerToken>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsProxyClientConfigBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigHttpSdConfigsProxyClientConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMScrapeConfigHttpSdConfigsProxyClientConfigBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsProxyClientConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsProxyClientConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsProxyClientConfigBearerToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsTlsConfig {
    /// Struct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMScrapeConfigHttpSdConfigsTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMScrapeConfigHttpSdConfigsTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMScrapeConfigHttpSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Struct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigHttpSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigHttpSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigHttpSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigHttpSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigHttpSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#kubernetes_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigs {
    /// The API server address consisting of a hostname or IP address followed
    /// by an optional port number.
    /// If left empty, assuming process is running inside
    /// of the cluster. It will discover API servers automatically and use the pod's
    /// CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServer")]
    pub api_server: Option<String>,
    /// AttachMetadata configures metadata attaching from service discovery
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attach_metadata: Option<VMScrapeConfigKubernetesSdConfigsAttachMetadata>,
    /// Authorization header to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<VMScrapeConfigKubernetesSdConfigsAuthorization>,
    /// BasicAuth information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<VMScrapeConfigKubernetesSdConfigsBasicAuth>,
    /// Configure whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// Optional namespace discovery. If omitted, discover targets across all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<VMScrapeConfigKubernetesSdConfigsNamespaces>,
    /// OAuth2 defines auth configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<VMScrapeConfigKubernetesSdConfigsOauth2>,
    /// ProxyURL eg <http://proxyserver:2195> Directs scrapes to proxy through this endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// ProxyClientConfig configures proxy auth settings for scraping
    /// See [feature description](<https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_client_config: Option<VMScrapeConfigKubernetesSdConfigsProxyClientConfig>,
    /// Role of the Kubernetes entities that should be discovered.
    pub role: String,
    /// Selector to select objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selectors: Option<Vec<VMScrapeConfigKubernetesSdConfigsSelectors>>,
    /// TLS configuration to use on every scrape request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VMScrapeConfigKubernetesSdConfigsTlsConfig>,
}

/// AttachMetadata configures metadata attaching from service discovery
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsAttachMetadata {
    /// Node instructs vmagent to add node specific metadata from service discovery
    /// Valid for roles: pod, endpoints, endpointslice.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<bool>,
}

/// Authorization header to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsAuthorization {
    /// Reference to the secret with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<VMScrapeConfigKubernetesSdConfigsAuthorizationCredentials>,
    /// File with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsFile")]
    pub credentials_file: Option<String>,
    /// Type of authorization, default to bearer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to the secret with value for authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigKubernetesSdConfigsBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMScrapeConfigKubernetesSdConfigsBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional namespace discovery. If omitted, discover targets across all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsNamespaces {
    /// List of namespaces where to watch for resources.
    /// If empty and `ownNamespace` isn't true, watch for resources in all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// Includes the namespace in which the pod exists to the list of watched namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownNamespace")]
    pub own_namespace: Option<bool>,
}

/// OAuth2 defines auth configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsOauth2 {
    /// The secret or configmap containing the OAuth2 client id
    pub client_id: VMScrapeConfigKubernetesSdConfigsOauth2ClientId,
    /// The secret containing the OAuth2 client secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<VMScrapeConfigKubernetesSdConfigsOauth2ClientSecret>,
    /// ClientSecretFile defines path for client secret file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret_file: Option<String>,
    /// Parameters to append to the token URL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// The proxy URL for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_url: Option<String>,
    /// OAuth2 scopes used for the token request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// TLSConfig for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
    /// The URL to fetch the token from
    pub token_url: String,
}

/// The secret or configmap containing the OAuth2 client id
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigKubernetesSdConfigsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigKubernetesSdConfigsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret containing the OAuth2 client secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ProxyClientConfig configures proxy auth settings for scraping
/// See [feature description](<https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsProxyClientConfig {
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMScrapeConfigKubernetesSdConfigsProxyClientConfigBasicAuth>,
    /// SecretKeySelector selects a key of a Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token: Option<VMScrapeConfigKubernetesSdConfigsProxyClientConfigBearerToken>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsProxyClientConfigBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigKubernetesSdConfigsProxyClientConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMScrapeConfigKubernetesSdConfigsProxyClientConfigBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsProxyClientConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsProxyClientConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsProxyClientConfigBearerToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// K8SSelectorConfig is Kubernetes Selector Config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsSelectors {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    pub role: String,
}

/// TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsTlsConfig {
    /// Struct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMScrapeConfigKubernetesSdConfigsTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMScrapeConfigKubernetesSdConfigsTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMScrapeConfigKubernetesSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Struct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigKubernetesSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigKubernetesSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigKubernetesSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigKubernetesSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigKubernetesSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigMetricRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// OAuth2 defines auth configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOauth2 {
    /// The secret or configmap containing the OAuth2 client id
    pub client_id: VMScrapeConfigOauth2ClientId,
    /// The secret containing the OAuth2 client secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<VMScrapeConfigOauth2ClientSecret>,
    /// ClientSecretFile defines path for client secret file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret_file: Option<String>,
    /// Parameters to append to the token URL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// The proxy URL for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_url: Option<String>,
    /// OAuth2 scopes used for the token request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// TLSConfig for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
    /// The URL to fetch the token from
    pub token_url: String,
}

/// The secret or configmap containing the OAuth2 client id
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret containing the OAuth2 client secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#openstack_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigs {
    /// Whether the service discovery should list all instances for all projects.
    /// It is only relevant for the 'instance' role and usually requires admin permissions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allTenants")]
    pub all_tenants: Option<bool>,
    /// ApplicationCredentialID
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationCredentialId")]
    pub application_credential_id: Option<String>,
    /// The ApplicationCredentialID or ApplicationCredentialName fields are
    /// required if using an application credential to authenticate. Some providers
    /// allow you to create an application credential to authenticate rather than a
    /// password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationCredentialName")]
    pub application_credential_name: Option<String>,
    /// The applicationCredentialSecret field is required if using an application
    /// credential to authenticate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationCredentialSecret")]
    pub application_credential_secret: Option<VMScrapeConfigOpenstackSdConfigsApplicationCredentialSecret>,
    /// Availability of the endpoint to connect to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub availability: Option<VMScrapeConfigOpenstackSdConfigsAvailability>,
    /// DomainID
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainID")]
    pub domain_id: Option<String>,
    /// At most one of domainId and domainName must be provided if using username
    /// with Identity V3. Otherwise, either are optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    pub domain_name: Option<String>,
    /// IdentityEndpoint specifies the HTTP endpoint that is required to work with
    /// the Identity API of the appropriate version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityEndpoint")]
    pub identity_endpoint: Option<String>,
    /// Password for the Identity V2 and V3 APIs. Consult with your provider's
    /// control panel to discover your account's preferred method of authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigOpenstackSdConfigsPassword>,
    /// The port to scrape metrics from. If using the public IP address, this must
    /// instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    ///  ProjectID
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectID")]
    pub project_id: Option<String>,
    /// The ProjectId and ProjectName fields are optional for the Identity V2 API.
    /// Some providers allow you to specify a ProjectName instead of the ProjectId.
    /// Some require both. Your provider's authentication policies will determine
    /// how these fields influence authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectName")]
    pub project_name: Option<String>,
    /// The OpenStack Region.
    pub region: String,
    /// The OpenStack role of entities that should be discovered.
    pub role: VMScrapeConfigOpenstackSdConfigsRole,
    /// TLS configuration to use on every scrape request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VMScrapeConfigOpenstackSdConfigsTlsConfig>,
    /// UserID
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub userid: Option<String>,
    /// Username is required if using Identity V2 API. Consult with your provider's
    /// control panel to discover your account's username.
    /// In Identity V3, either userid or a combination of username
    /// and domainId or domainName are needed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// The applicationCredentialSecret field is required if using an application
/// credential to authenticate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsApplicationCredentialSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#openstack_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VMScrapeConfigOpenstackSdConfigsAvailability {
    Public,
    #[serde(rename = "public")]
    PublicX,
    Admin,
    #[serde(rename = "admin")]
    AdminX,
    Internal,
    #[serde(rename = "internal")]
    InternalX,
}

/// Password for the Identity V2 and V3 APIs. Consult with your provider's
/// control panel to discover your account's preferred method of authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#openstack_sd_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VMScrapeConfigOpenstackSdConfigsRole {
    Instance,
    #[serde(rename = "instance")]
    InstanceX,
    Hypervisor,
    #[serde(rename = "hypervisor")]
    HypervisorX,
}

/// TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsTlsConfig {
    /// Struct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMScrapeConfigOpenstackSdConfigsTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMScrapeConfigOpenstackSdConfigsTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMScrapeConfigOpenstackSdConfigsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Struct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigOpenstackSdConfigsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigOpenstackSdConfigsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigOpenstackSdConfigsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigOpenstackSdConfigsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigOpenstackSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// VMScrapeConfigSpec defines the desired state of VMScrapeConfig
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VMScrapeConfigScheme {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
    #[serde(rename = "HTTPS")]
    HttpsX,
    #[serde(rename = "HTTP")]
    HttpX,
}

/// StaticConfig defines a static configuration.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/sd_configs/#static_configs)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigStaticConfigs {
    /// Labels assigned to all metrics scraped from the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// List of targets for this static configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// TLSConfig configuration to use when scraping the endpoint
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigTlsConfig {
    /// Struct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VMScrapeConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VMScrapeConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VMScrapeConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Struct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VMScrapeConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VMScrapeConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// VMScrapeParams defines VictoriaMetrics specific scrape parameters
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigVmScrapeParams {
    /// DisableCompression
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable_compression: Option<bool>,
    /// disable_keepalive allows disabling HTTP keep-alive when scraping targets.
    /// By default, HTTP keep-alive is enabled, so TCP connections to scrape targets
    /// could be reused.
    /// See <https://docs.victoriametrics.com/victoriametrics/vmagent#scrape_config-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable_keep_alive: Option<bool>,
    /// Headers allows sending custom headers to scrape targets
    /// must be in of semicolon separated header with it's value
    /// eg:
    /// headerName: headerValue
    /// vmagent supports since 1.79.0 version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub no_stale_markers: Option<bool>,
    /// ProxyClientConfig configures proxy auth settings for scraping
    /// See feature description <https://docs.victoriametrics.com/victoriametrics/vmagent#scraping-targets-via-a-proxy>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_client_config: Option<VMScrapeConfigVmScrapeParamsProxyClientConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_align_interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_offset: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stream_parse: Option<bool>,
}

/// ProxyClientConfig configures proxy auth settings for scraping
/// See feature description <https://docs.victoriametrics.com/victoriametrics/vmagent#scraping-targets-via-a-proxy>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigVmScrapeParamsProxyClientConfig {
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<VMScrapeConfigVmScrapeParamsProxyClientConfigBasicAuth>,
    /// SecretKeySelector selects a key of a Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token: Option<VMScrapeConfigVmScrapeParamsProxyClientConfigBearerToken>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigVmScrapeParamsProxyClientConfigBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VMScrapeConfigVmScrapeParamsProxyClientConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VMScrapeConfigVmScrapeParamsProxyClientConfigBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigVmScrapeParamsProxyClientConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigVmScrapeParamsProxyClientConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigVmScrapeParamsProxyClientConfigBearerToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ScrapeObjectStatus defines the observed state of ScrapeObjects
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VMScrapeConfigStatus {
    /// Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration defines current generation picked by operator for the
    /// reconcile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// Reason defines human readable error reason
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// UpdateStatus defines a status for update rollout
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStatus")]
    pub update_status: Option<String>,
}

