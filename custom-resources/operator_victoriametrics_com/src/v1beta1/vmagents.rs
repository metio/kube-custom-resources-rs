// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/VictoriaMetrics/operator/operator.victoriametrics.com/v1beta1/vmagents.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// VMAgentSpec defines the desired state of VMAgent
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "operator.victoriametrics.com", version = "v1beta1", kind = "VMAgent", plural = "vmagents")]
#[kube(namespaced)]
#[kube(status = "VmAgentStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct VmAgentSpec {
    /// APIServerConfig allows specifying a host and auth methods to access apiserver.
    /// If left empty, VMAgent is assumed to run inside of the cluster
    /// and will discover API servers automatically and use the pod's CA certificate
    /// and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
    /// aPIServerConfig is deprecated use apiServerConfig instead
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aPIServerConfig")]
    pub a_pi_server_config: Option<BTreeMap<String, serde_json::Value>>,
    /// AdditionalScrapeConfigs As scrape configs are appended, the user is responsible to make sure it
    /// is valid. Note that using this feature may expose the possibility to
    /// break upgrades of VMAgent. It is advised to review VMAgent release
    /// notes to ensure that no incompatible scrape configs are going to break
    /// VMAgent after the upgrade.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalScrapeConfigs")]
    pub additional_scrape_configs: Option<VmAgentAdditionalScrapeConfigs>,
    /// Affinity If specified, the pod's scheduling constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<BTreeMap<String, serde_json::Value>>,
    /// APIServerConfig allows specifying a host and auth methods to access apiserver.
    /// If left empty, VMAgent is assumed to run inside of the cluster
    /// and will discover API servers automatically and use the pod's CA certificate
    /// and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServerConfig")]
    pub api_server_config: Option<VmAgentApiServerConfig>,
    /// ArbitraryFSAccessThroughSMs configures whether configuration
    /// based on EndpointAuth can access arbitrary files on the file system
    /// of the VMAgent container e.g. bearer token files, basic auth, tls certs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "arbitraryFSAccessThroughSMs")]
    pub arbitrary_fs_access_through_s_ms: Option<VmAgentArbitraryFsAccessThroughSMs>,
    /// ClaimTemplates allows adding additional VolumeClaimTemplates for VMAgent in StatefulMode
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "claimTemplates")]
    pub claim_templates: Option<Vec<VmAgentClaimTemplates>>,
    /// ConfigMaps is a list of ConfigMaps in the same namespace as the Application
    /// object, which shall be mounted into the Application container
    /// at /etc/vm/configs/CONFIGMAP_NAME folder
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMaps")]
    pub config_maps: Option<Vec<String>>,
    /// ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
    /// Given secret reference will be added to the application and vm-config-reloader as volume
    /// available since v0.57.0 version
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configReloadAuthKeySecret")]
    pub config_reload_auth_key_secret: Option<VmAgentConfigReloadAuthKeySecret>,
    /// ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container
    /// for example resyncInterval: "30s"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configReloaderExtraArgs")]
    pub config_reloader_extra_args: Option<BTreeMap<String, String>>,
    /// ConfigReloaderImageTag defines image:tag for config-reloader container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configReloaderImageTag")]
    pub config_reloader_image_tag: Option<String>,
    /// ConfigReloaderResources config-reloader container resource request and limits, <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    /// if not defined default resources from operator config will be used
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configReloaderResources")]
    pub config_reloader_resources: Option<VmAgentConfigReloaderResources>,
    /// Containers property allows to inject additions sidecars or to patch existing containers.
    /// It can be useful for proxies, backup, etc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// DaemonSetMode enables DaemonSet deployment mode instead of Deployment.
    /// Supports only VMPodScrape
    /// (available from v0.55.0).
    /// Cannot be used with statefulMode
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "daemonSetMode")]
    pub daemon_set_mode: Option<bool>,
    /// DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
    /// Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
    /// For example, vmagent and vm-config-reloader requires k8s API access.
    /// Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
    /// And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableAutomountServiceAccountToken")]
    pub disable_automount_service_account_token: Option<bool>,
    /// DisableSelfServiceScrape controls creation of VMServiceScrape by operator
    /// for the application.
    /// Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableSelfServiceScrape")]
    pub disable_self_service_scrape: Option<bool>,
    /// Specifies the DNS parameters of a pod.
    /// Parameters specified here will be merged to the generated DNS
    /// configuration based on DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<VmAgentDnsConfig>,
    /// DNSPolicy sets DNS policy for the pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsPolicy")]
    pub dns_policy: Option<String>,
    /// EnableKubernetesAPISelectors instructs vmagent to use CRD scrape objects spec.selectors for
    /// Kubernetes API list and watch requests.
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#list-and-watch-filtering>
    /// It could be useful to reduce Kubernetes API server resource usage for serving less than 100 CRD scrape objects in total.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableKubernetesAPISelectors")]
    pub enable_kubernetes_api_selectors: Option<bool>,
    /// EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
    /// and metric that is user created. The label value will always be the namespace of the object that is
    /// being created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enforcedNamespaceLabel")]
    pub enforced_namespace_label: Option<String>,
    /// ExternalLabels The labels to add to any time series scraped by vmagent.
    /// it doesn't affect metrics ingested directly by push API's
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalLabels")]
    pub external_labels: Option<BTreeMap<String, String>>,
    /// ExtraArgs that will be passed to the application container
    /// for example remoteWrite.tmpDataPath: /tmp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraArgs")]
    pub extra_args: Option<BTreeMap<String, String>>,
    /// ExtraEnvs that will be passed to the application container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvs")]
    pub extra_envs: Option<Vec<VmAgentExtraEnvs>>,
    /// ExtraEnvsFrom defines source of env variables for the application container
    /// could either be secret or configmap
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvsFrom")]
    pub extra_envs_from: Option<Vec<VmAgentExtraEnvsFrom>>,
    /// GlobalScrapeMetricRelabelConfigs is a global metric relabel configuration, which is applied to each scrape job.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalScrapeMetricRelabelConfigs")]
    pub global_scrape_metric_relabel_configs: Option<Vec<VmAgentGlobalScrapeMetricRelabelConfigs>>,
    /// GlobalScrapeRelabelConfigs is a global relabel configuration, which is applied to each samples of each scrape job during service discovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalScrapeRelabelConfigs")]
    pub global_scrape_relabel_configs: Option<Vec<VmAgentGlobalScrapeRelabelConfigs>>,
    /// HostAliases provides mapping for ip and hostname,
    /// that would be propagated to pod,
    /// cannot be used with HostNetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostAliases")]
    pub host_aliases: Option<Vec<VmAgentHostAliases>>,
    /// HostNetwork controls whether the pod may use the node network namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// HostAliasesUnderScore provides mapping for ip and hostname,
    /// that would be propagated to pod,
    /// cannot be used with HostNetwork.
    /// Has Priority over hostAliases field
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "host_aliases")]
    pub host_aliases_x: Option<Vec<VmAgentHostAliases>>,
    /// IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector settings from
    /// scrape objects, and they will only discover endpoints
    /// within their current namespace.  Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreNamespaceSelectors")]
    pub ignore_namespace_selectors: Option<bool>,
    /// Image - docker image settings
    /// if no specified operator uses default version from operator config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<VmAgentImage>,
    /// ImagePullSecrets An optional list of references to secrets in the same namespace
    /// to use for pulling images from registries
    /// see <https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecrets")]
    pub image_pull_secrets: Option<Vec<VmAgentImagePullSecrets>>,
    /// IngestOnlyMode switches vmagent into unmanaged mode
    /// it disables any config generation for scraping
    /// Currently it prevents vmagent from managing tls and auth options for remote write
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingestOnlyMode")]
    pub ingest_only_mode: Option<bool>,
    /// InitContainers allows adding initContainers to the pod definition.
    /// Any errors during the execution of an initContainer will lead to a restart of the Pod.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/init-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// InlineRelabelConfig - defines GlobalRelabelConfig for vmagent, can be defined directly at CRD.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inlineRelabelConfig")]
    pub inline_relabel_config: Option<Vec<VmAgentInlineRelabelConfig>>,
    /// InlineScrapeConfig As scrape configs are appended, the user is responsible to make sure it
    /// is valid. Note that using this feature may expose the possibility to
    /// break upgrades of VMAgent. It is advised to review VMAgent release
    /// notes to ensure that no incompatible scrape configs are going to break
    /// VMAgent after the upgrade.
    /// it should be defined as single yaml file.
    /// inlineScrapeConfig: |
    ///     - job_name: "prometheus"
    ///       static_configs:
    ///       - targets: ["localhost:9090"]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inlineScrapeConfig")]
    pub inline_scrape_config: Option<String>,
    /// InsertPorts - additional listen ports for data ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insertPorts")]
    pub insert_ports: Option<VmAgentInsertPorts>,
    /// License allows to configure license key to be used for enterprise features.
    /// Using license key is supported starting from VictoriaMetrics v1.94.0.
    /// See [here](<https://docs.victoriametrics.com/victoriametrics/enterprise/)>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub license: Option<VmAgentLicense>,
    /// LivenessProbe that will be added CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// LogFormat for VMAgent to be configured with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    pub log_format: Option<VmAgentLogFormat>,
    /// LogLevel for VMAgent to be configured with.
    /// INFO, WARN, ERROR, FATAL, PANIC
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<VmAgentLogLevel>,
    /// ManagedMetadata defines metadata that will be added to the all objects
    /// created by operator for the given CustomResource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedMetadata")]
    pub managed_metadata: Option<VmAgentManagedMetadata>,
    /// MaxScrapeInterval allows limiting maximum scrape interval for VMServiceScrape, VMPodScrape and other scrapes
    /// If interval is higher than defined limit, `maxScrapeInterval` will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxScrapeInterval")]
    pub max_scrape_interval: Option<String>,
    /// MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
    /// if previous in healthy state
    /// Has no effect for VLogs and VMSingle
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// MinScrapeInterval allows limiting minimal scrape interval for VMServiceScrape, VMPodScrape and other scrapes
    /// If interval is lower than defined limit, `minScrapeInterval` will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minScrapeInterval")]
    pub min_scrape_interval: Option<String>,
    /// NodeScrapeNamespaceSelector defines Namespaces to be selected for VMNodeScrape discovery.
    /// Works in combination with Selector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeScrapeNamespaceSelector")]
    pub node_scrape_namespace_selector: Option<VmAgentNodeScrapeNamespaceSelector>,
    /// NodeScrapeRelabelTemplate defines relabel config, that will be added to each VMNodeScrape.
    /// it's useful for adding specific labels to all targets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeScrapeRelabelTemplate")]
    pub node_scrape_relabel_template: Option<Vec<VmAgentNodeScrapeRelabelTemplate>>,
    /// NodeScrapeSelector defines VMNodeScrape to be selected for scraping.
    /// Works in combination with NamespaceSelector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeScrapeSelector")]
    pub node_scrape_selector: Option<VmAgentNodeScrapeSelector>,
    /// NodeSelector Define which Nodes the Pods are scheduled on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// OverrideHonorLabels if set to true overrides all user configured honor_labels.
    /// If HonorLabels is set in scrape objects  to true, this overrides honor_labels to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "overrideHonorLabels")]
    pub override_honor_labels: Option<bool>,
    /// OverrideHonorTimestamps allows to globally enforce honoring timestamps in all scrape configs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "overrideHonorTimestamps")]
    pub override_honor_timestamps: Option<bool>,
    /// Paused If set to true all actions on the underlying managed objects are not
    /// going to be performed, except for delete actions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    /// PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaimRetentionPolicy")]
    pub persistent_volume_claim_retention_policy: Option<VmAgentPersistentVolumeClaimRetentionPolicy>,
    /// PodDisruptionBudget created by operator
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podDisruptionBudget")]
    pub pod_disruption_budget: Option<VmAgentPodDisruptionBudget>,
    /// PodMetadata configures Labels and Annotations which are propagated to the vmagent pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podMetadata")]
    pub pod_metadata: Option<VmAgentPodMetadata>,
    /// PodScrapeNamespaceSelector defines Namespaces to be selected for VMPodScrape discovery.
    /// Works in combination with Selector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podScrapeNamespaceSelector")]
    pub pod_scrape_namespace_selector: Option<VmAgentPodScrapeNamespaceSelector>,
    /// PodScrapeRelabelTemplate defines relabel config, that will be added to each VMPodScrape.
    /// it's useful for adding specific labels to all targets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podScrapeRelabelTemplate")]
    pub pod_scrape_relabel_template: Option<Vec<VmAgentPodScrapeRelabelTemplate>>,
    /// PodScrapeSelector defines PodScrapes to be selected for target discovery.
    /// Works in combination with NamespaceSelector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podScrapeSelector")]
    pub pod_scrape_selector: Option<VmAgentPodScrapeSelector>,
    /// Port listen address
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// PriorityClassName class assigned to the Pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// ProbeNamespaceSelector defines Namespaces to be selected for VMProbe discovery.
    /// Works in combination with Selector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "probeNamespaceSelector")]
    pub probe_namespace_selector: Option<VmAgentProbeNamespaceSelector>,
    /// ProbeScrapeRelabelTemplate defines relabel config, that will be added to each VMProbeScrape.
    /// it's useful for adding specific labels to all targets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "probeScrapeRelabelTemplate")]
    pub probe_scrape_relabel_template: Option<Vec<VmAgentProbeScrapeRelabelTemplate>>,
    /// ProbeSelector defines VMProbe to be selected for target probing.
    /// Works in combination with NamespaceSelector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "probeSelector")]
    pub probe_selector: Option<VmAgentProbeSelector>,
    /// ReadinessGates defines pod readiness gates
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<VmAgentReadinessGates>>,
    /// ReadinessProbe that will be added CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// RelabelConfig ConfigMap with global relabel config -remoteWrite.relabelConfig
    /// This relabeling is applied to all the collected metrics before sending them to remote storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relabelConfig")]
    pub relabel_config: Option<VmAgentRelabelConfig>,
    /// RemoteWrite list of victoria metrics /some other remote write system
    /// for vm it must looks like: <http://victoria-metrics-single:8428/api/v1/write>
    /// or for cluster different url
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#splitting-data-streams-among-multiple-systems>
    #[serde(rename = "remoteWrite")]
    pub remote_write: Vec<VmAgentRemoteWrite>,
    /// RemoteWriteSettings defines global settings for all remoteWrite urls.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteWriteSettings")]
    pub remote_write_settings: Option<VmAgentRemoteWriteSettings>,
    /// ReplicaCount is the expected size of the Application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaCount")]
    pub replica_count: Option<i32>,
    /// Resources container resource request and limits, <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    /// if not defined default resources from operator config will be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<VmAgentResources>,
    /// The number of old ReplicaSets to retain to allow rollback in deployment or
    /// maximum number of revisions that will be maintained in the Deployment revision history.
    /// Has no effect at StatefulSets
    /// Defaults to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "revisionHistoryLimitCount")]
    pub revision_history_limit_count: Option<i32>,
    /// RollingUpdate - overrides deployment update params.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<VmAgentRollingUpdate>,
    /// RuntimeClassName - defines runtime class for kubernetes pod.
    /// <https://kubernetes.io/docs/concepts/containers/runtime-class/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeClassName")]
    pub runtime_class_name: Option<String>,
    /// SchedulerName - defines kubernetes scheduler name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    /// ScrapeConfigNamespaceSelector defines Namespaces to be selected for VMScrapeConfig discovery.
    /// Works in combination with Selector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeConfigNamespaceSelector")]
    pub scrape_config_namespace_selector: Option<VmAgentScrapeConfigNamespaceSelector>,
    /// ScrapeConfigRelabelTemplate defines relabel config, that will be added to each VMScrapeConfig.
    /// it's useful for adding specific labels to all targets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeConfigRelabelTemplate")]
    pub scrape_config_relabel_template: Option<Vec<VmAgentScrapeConfigRelabelTemplate>>,
    /// ScrapeConfigSelector defines VMScrapeConfig to be selected for target discovery.
    /// Works in combination with NamespaceSelector.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeConfigSelector")]
    pub scrape_config_selector: Option<VmAgentScrapeConfigSelector>,
    /// ScrapeInterval defines how often scrape targets by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeInterval")]
    pub scrape_interval: Option<String>,
    /// ScrapeTimeout defines global timeout for targets scrape
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// Secrets is a list of Secrets in the same namespace as the Application
    /// object, which shall be mounted into the Application container
    /// at /etc/vm/secrets/SECRET_NAME folder
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
    /// SecurityContext holds pod-level security attributes and common container settings.
    /// This defaults to the default PodSecurityContext.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<BTreeMap<String, serde_json::Value>>,
    /// SelectAllByDefault changes default behavior for empty CRD selectors, such ServiceScrapeSelector.
    /// with selectAllByDefault: true and empty serviceScrapeSelector and ServiceScrapeNamespaceSelector
    /// Operator selects all exist serviceScrapes
    /// with selectAllByDefault: false - selects nothing
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selectAllByDefault")]
    pub select_all_by_default: Option<bool>,
    /// ServiceAccountName is the name of the ServiceAccount to use to run the pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountName")]
    pub service_account_name: Option<String>,
    /// ServiceScrapeNamespaceSelector Namespaces to be selected for VMServiceScrape discovery.
    /// Works in combination with Selector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceScrapeNamespaceSelector")]
    pub service_scrape_namespace_selector: Option<VmAgentServiceScrapeNamespaceSelector>,
    /// ServiceScrapeRelabelTemplate defines relabel config, that will be added to each VMServiceScrape.
    /// it's useful for adding specific labels to all targets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceScrapeRelabelTemplate")]
    pub service_scrape_relabel_template: Option<Vec<VmAgentServiceScrapeRelabelTemplate>>,
    /// ServiceScrapeSelector defines ServiceScrapes to be selected for target discovery.
    /// Works in combination with NamespaceSelector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceScrapeSelector")]
    pub service_scrape_selector: Option<VmAgentServiceScrapeSelector>,
    /// ServiceScrapeSpec that will be added to vmagent VMServiceScrape spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceScrapeSpec")]
    pub service_scrape_spec: Option<BTreeMap<String, serde_json::Value>>,
    /// ServiceSpec that will be added to vmagent service spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSpec")]
    pub service_spec: Option<VmAgentServiceSpec>,
    /// ShardCount - numbers of shards of VMAgent
    /// in this case operator will use 1 deployment/sts per shard with
    /// replicas count according to spec.replicas,
    /// see [here](<https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-big-number-of-targets)>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardCount")]
    pub shard_count: Option<i64>,
    /// StartupProbe that will be added to CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// StatefulMode enables StatefulSet for `VMAgent` instead of Deployment
    /// it allows using persistent storage for vmagent's persistentQueue
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulMode")]
    pub stateful_mode: Option<bool>,
    /// StatefulRollingUpdateStrategy allows configuration for strategyType
    /// set it to RollingUpdate for disabling operator statefulSet rollingUpdate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulRollingUpdateStrategy")]
    pub stateful_rolling_update_strategy: Option<String>,
    /// StatefulStorage configures storage for StatefulSet
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulStorage")]
    pub stateful_storage: Option<VmAgentStatefulStorage>,
    /// StaticScrapeNamespaceSelector defines Namespaces to be selected for VMStaticScrape discovery.
    /// Works in combination with NamespaceSelector.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    /// If both nil - behaviour controlled by selectAllByDefault
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticScrapeNamespaceSelector")]
    pub static_scrape_namespace_selector: Option<VmAgentStaticScrapeNamespaceSelector>,
    /// StaticScrapeRelabelTemplate defines relabel config, that will be added to each VMStaticScrape.
    /// it's useful for adding specific labels to all targets
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticScrapeRelabelTemplate")]
    pub static_scrape_relabel_template: Option<Vec<VmAgentStaticScrapeRelabelTemplate>>,
    /// StaticScrapeSelector defines VMStaticScrape to be selected for target discovery.
    /// Works in combination with NamespaceSelector.
    /// If both nil - match everything.
    /// NamespaceSelector nil - only objects at VMAgent namespace.
    /// Selector nil - only objects at NamespaceSelector namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticScrapeSelector")]
    pub static_scrape_selector: Option<VmAgentStaticScrapeSelector>,
    /// StreamAggrConfig defines global stream aggregation configuration for VMAgent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamAggrConfig")]
    pub stream_aggr_config: Option<VmAgentStreamAggrConfig>,
    /// TerminationGracePeriodSeconds period for container graceful termination
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Tolerations If specified, the pod's tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<VmAgentTolerations>>,
    /// TopologySpreadConstraints embedded kubernetes pod configuration option,
    /// controls how pods are spread across your cluster among failure-domains
    /// such as regions, zones, nodes, and other user-defined topology domains
    /// <https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// UpdateStrategy - overrides default update strategy.
    /// works only for deployments, statefulset always use OnDelete.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<VmAgentUpdateStrategy>,
    /// UseDefaultResources controls resource settings
    /// By default, operator sets built-in resource requirements
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDefaultResources")]
    pub use_default_resources: Option<bool>,
    /// UseStrictSecurity enables strict security mode for component
    /// it restricts disk writes access
    /// uses non-root user out of the box
    /// drops not needed security permissions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useStrictSecurity")]
    pub use_strict_security: Option<bool>,
    /// UseVMConfigReloader replaces prometheus-like config-reloader
    /// with vm one. It uses secrets watch instead of file watch
    /// which greatly increases speed of config updates
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useVMConfigReloader")]
    pub use_vm_config_reloader: Option<bool>,
    /// VMAgentExternalLabelName Name of vmAgent external label used to denote vmAgent instance
    /// name. Defaults to the value of `prometheus`. External label will
    /// _not_ be added when value is set to empty string (`""`).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vmAgentExternalLabelName")]
    pub vm_agent_external_label_name: Option<String>,
    /// VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
    /// VolumeMounts specified will be appended to other VolumeMounts in the Application container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<VmAgentVolumeMounts>>,
    /// Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
    /// Volumes specified will be appended to other volumes that are generated.
    /// / +optional
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<BTreeMap<String, serde_json::Value>>>,
}

/// AdditionalScrapeConfigs As scrape configs are appended, the user is responsible to make sure it
/// is valid. Note that using this feature may expose the possibility to
/// break upgrades of VMAgent. It is advised to review VMAgent release
/// notes to ensure that no incompatible scrape configs are going to break
/// VMAgent after the upgrade.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentAdditionalScrapeConfigs {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// APIServerConfig allows specifying a host and auth methods to access apiserver.
/// If left empty, VMAgent is assumed to run inside of the cluster
/// and will discover API servers automatically and use the pod's CA certificate
/// and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfig {
    /// Authorization configures generic authorization params
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<VmAgentApiServerConfigAuthorization>,
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<VmAgentApiServerConfigBasicAuth>,
    /// Bearer token for accessing apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerToken")]
    pub bearer_token: Option<String>,
    /// File to read bearer token for accessing apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenFile")]
    pub bearer_token_file: Option<String>,
    /// Host of apiserver.
    /// A valid string consisting of a hostname or IP followed by an optional port number
    pub host: String,
    /// TLSConfig Config to use for accessing apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VmAgentApiServerConfigTlsConfig>,
}

/// Authorization configures generic authorization params
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigAuthorization {
    /// Reference to the secret with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<VmAgentApiServerConfigAuthorizationCredentials>,
    /// File with value for authorization
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsFile")]
    pub credentials_file: Option<String>,
    /// Type of authorization, default to bearer
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Reference to the secret with value for authorization
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VmAgentApiServerConfigBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VmAgentApiServerConfigBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLSConfig Config to use for accessing apiserver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigTlsConfig {
    /// Struct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VmAgentApiServerConfigTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VmAgentApiServerConfigTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VmAgentApiServerConfigTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Struct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VmAgentApiServerConfigTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VmAgentApiServerConfigTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VmAgentApiServerConfigTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VmAgentApiServerConfigTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentApiServerConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ArbitraryFSAccessThroughSMs configures whether configuration
/// based on EndpointAuth can access arbitrary files on the file system
/// of the VMAgent container e.g. bearer token files, basic auth, tls certs
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentArbitraryFsAccessThroughSMs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deny: Option<bool>,
}

/// PersistentVolumeClaim is a user's request for and claim to a persistent volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentClaimTemplates {
    /// APIVersion defines the versioned schema of this representation of an object.
    /// Servers should convert recognized schemas to the latest internal value, and
    /// may reject unrecognized values.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Kind is a string value representing the REST resource this object represents.
    /// Servers may infer this from the endpoint the client submits requests to.
    /// Cannot be updated.
    /// In CamelCase.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, serde_json::Value>>,
    /// spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<VmAgentClaimTemplatesSpec>,
    /// status represents the current information/status of a persistent volume claim.
    /// Read-only.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<VmAgentClaimTemplatesStatus>,
}

/// spec defines the desired characteristics of a volume requested by a pod author.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentClaimTemplatesSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<VmAgentClaimTemplatesSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<VmAgentClaimTemplatesSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<VmAgentClaimTemplatesSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<VmAgentClaimTemplatesSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    /// (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentClaimTemplatesSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentClaimTemplatesSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentClaimTemplatesSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentClaimTemplatesSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentClaimTemplatesSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentClaimTemplatesSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// status represents the current information/status of a persistent volume claim.
/// Read-only.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentClaimTemplatesStatus {
    /// accessModes contains the actual access modes the volume backing the PVC has.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// allocatedResourceStatuses stores status of resource being resized for the given PVC.
    /// Key names follow standard Kubernetes label syntax. Valid values are either:
    /// 	* Un-prefixed keys:
    /// 		- storage - the capacity of the volume.
    /// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    /// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    /// reserved and hence may not be used.
    /// 
    /// ClaimResourceStatus can be in any of following states:
    /// 	- ControllerResizeInProgress:
    /// 		State set when resize controller starts resizing the volume in control-plane.
    /// 	- ControllerResizeFailed:
    /// 		State set when resize has failed in resize controller with a terminal error.
    /// 	- NodeResizePending:
    /// 		State set when resize controller has finished resizing the volume but further resizing of
    /// 		volume is needed on the node.
    /// 	- NodeResizeInProgress:
    /// 		State set when kubelet starts resizing the volume.
    /// 	- NodeResizeFailed:
    /// 		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
    /// 		NodeResizeFailed.
    /// For example: if expanding a PVC for more capacity - this field can be one of the following states:
    /// 	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
    /// When this field is not set, it means that no resize operation is in progress for the given PVC.
    /// 
    /// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
    /// should ignore the update for the purpose it was designed. For example - a controller that
    /// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    /// resources associated with PVC.
    /// 
    /// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocatedResourceStatuses")]
    pub allocated_resource_statuses: Option<BTreeMap<String, String>>,
    /// allocatedResources tracks the resources allocated to a PVC including its capacity.
    /// Key names follow standard Kubernetes label syntax. Valid values are either:
    /// 	* Un-prefixed keys:
    /// 		- storage - the capacity of the volume.
    /// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    /// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    /// reserved and hence may not be used.
    /// 
    /// Capacity reported here may be larger than the actual capacity when a volume expansion operation
    /// is requested.
    /// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
    /// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
    /// If a volume expansion capacity request is lowered, allocatedResources is only
    /// lowered if there are no expansion operations in progress and if the actual volume capacity
    /// is equal or lower than the requested capacity.
    /// 
    /// A controller that receives PVC update with previously unknown resourceName
    /// should ignore the update for the purpose it was designed. For example - a controller that
    /// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    /// resources associated with PVC.
    /// 
    /// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocatedResources")]
    pub allocated_resources: Option<BTreeMap<String, IntOrString>>,
    /// capacity represents the actual resources of the underlying volume.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capacity: Option<BTreeMap<String, IntOrString>>,
    /// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
    /// resized then the Condition will be set to 'Resizing'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
    /// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
    /// This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentVolumeAttributesClassName")]
    pub current_volume_attributes_class_name: Option<String>,
    /// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
    /// When this is unset, there is no ModifyVolume operation being attempted.
    /// This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modifyVolumeStatus")]
    pub modify_volume_status: Option<VmAgentClaimTemplatesStatusModifyVolumeStatus>,
    /// phase represents the current phase of PersistentVolumeClaim.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
}

/// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
/// When this is unset, there is no ModifyVolume operation being attempted.
/// This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentClaimTemplatesStatusModifyVolumeStatus {
    /// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
    ///  - Pending
    ///    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
    ///    the specified VolumeAttributesClass not existing.
    ///  - InProgress
    ///    InProgress indicates that the volume is being modified.
    ///  - Infeasible
    ///   Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
    /// 	  resolve the error, a valid VolumeAttributesClass needs to be specified.
    /// Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
    pub status: String,
    /// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetVolumeAttributesClassName")]
    pub target_volume_attributes_class_name: Option<String>,
}

/// ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.
/// Given secret reference will be added to the application and vm-config-reloader as volume
/// available since v0.57.0 version
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentConfigReloadAuthKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConfigReloaderResources config-reloader container resource request and limits, <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
/// if not defined default resources from operator config will be used
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentConfigReloaderResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<VmAgentConfigReloaderResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentConfigReloaderResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Specifies the DNS parameters of a pod.
/// Parameters specified here will be merged to the generated DNS
/// configuration based on DNSPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentDnsConfig {
    /// A list of DNS name server IP addresses.
    /// This will be appended to the base nameservers generated from DNSPolicy.
    /// Duplicated nameservers will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nameservers: Option<Vec<String>>,
    /// A list of DNS resolver options.
    /// This will be merged with the base options generated from DNSPolicy.
    /// Duplicated entries will be removed. Resolution options given in Options
    /// will override those that appear in the base DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<VmAgentDnsConfigOptions>>,
    /// A list of DNS search domains for host-name lookup.
    /// This will be appended to the base search paths generated from DNSPolicy.
    /// Duplicated search paths will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub searches: Option<Vec<String>>,
}

/// PodDNSConfigOption defines DNS resolver options of a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentDnsConfigOptions {
    /// Name is this DNS resolver option's name.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Value is this DNS resolver option's value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentExtraEnvs {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// EnvFromSource represents the source of a set of ConfigMaps
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentExtraEnvsFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<VmAgentExtraEnvsFromConfigMapRef>,
    /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<VmAgentExtraEnvsFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentExtraEnvsFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentExtraEnvsFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentGlobalScrapeMetricRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentGlobalScrapeRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentHostAliases {
    /// Hostnames for the above IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// IP address of the host file entry.
    pub ip: String,
}

/// Image - docker image settings
/// if no specified operator uses default version from operator config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentImage {
    /// PullPolicy describes how to pull docker image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// Repository contains name of docker image + it's repository if needed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    /// Tag contains desired docker image version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentImagePullSecrets {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentInlineRelabelConfig {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// InsertPorts - additional listen ports for data ingestion.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentInsertPorts {
    /// GraphitePort listen port
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "graphitePort")]
    pub graphite_port: Option<String>,
    /// InfluxPort listen port
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "influxPort")]
    pub influx_port: Option<String>,
    /// OpenTSDBHTTPPort for http connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openTSDBHTTPPort")]
    pub open_tsdbhttp_port: Option<String>,
    /// OpenTSDBPort for tcp and udp listen
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openTSDBPort")]
    pub open_tsdb_port: Option<String>,
}

/// License allows to configure license key to be used for enterprise features.
/// Using license key is supported starting from VictoriaMetrics v1.94.0.
/// See [here](<https://docs.victoriametrics.com/victoriametrics/enterprise/)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentLicense {
    /// Enforce offline verification of the license key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceOffline")]
    pub force_offline: Option<bool>,
    /// Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](<https://docs.victoriametrics.com/victoriametrics/enterprise/).>
    /// To request a trial license, [go to](<https://victoriametrics.com/products/enterprise/trial)>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// KeyRef is reference to secret with license key for enterprise features.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyRef")]
    pub key_ref: Option<VmAgentLicenseKeyRef>,
    /// Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reloadInterval")]
    pub reload_interval: Option<String>,
}

/// KeyRef is reference to secret with license key for enterprise features.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentLicenseKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// VMAgentSpec defines the desired state of VMAgent
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VmAgentLogFormat {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "json")]
    Json,
}

/// VMAgentSpec defines the desired state of VMAgent
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VmAgentLogLevel {
    #[serde(rename = "INFO")]
    Info,
    #[serde(rename = "WARN")]
    Warn,
    #[serde(rename = "ERROR")]
    Error,
    #[serde(rename = "FATAL")]
    Fatal,
    #[serde(rename = "PANIC")]
    Panic,
}

/// ManagedMetadata defines metadata that will be added to the all objects
/// created by operator for the given CustomResource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentManagedMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// NodeScrapeNamespaceSelector defines Namespaces to be selected for VMNodeScrape discovery.
/// Works in combination with Selector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentNodeScrapeNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentNodeScrapeNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentNodeScrapeNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentNodeScrapeRelabelTemplate {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// NodeScrapeSelector defines VMNodeScrape to be selected for scraping.
/// Works in combination with NamespaceSelector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentNodeScrapeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentNodeScrapeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentNodeScrapeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentPersistentVolumeClaimRetentionPolicy {
    /// WhenDeleted specifies what happens to PVCs created from StatefulSet
    /// VolumeClaimTemplates when the StatefulSet is deleted. The default policy
    /// of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
    /// `Delete` policy causes those PVCs to be deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whenDeleted")]
    pub when_deleted: Option<String>,
    /// WhenScaled specifies what happens to PVCs created from StatefulSet
    /// VolumeClaimTemplates when the StatefulSet is scaled down. The default
    /// policy of `Retain` causes PVCs to not be affected by a scaledown. The
    /// `Delete` policy causes the associated PVCs for any excess pods above
    /// the replica count to be deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whenScaled")]
    pub when_scaled: Option<String>,
}

/// PodDisruptionBudget created by operator
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentPodDisruptionBudget {
    /// An eviction is allowed if at most "maxUnavailable" pods selected by
    /// "selector" are unavailable after the eviction, i.e. even in absence of
    /// the evicted pod. For example, one can prevent all voluntary evictions
    /// by specifying 0. This is a mutually exclusive setting with "minAvailable".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
    /// An eviction is allowed if at least "minAvailable" pods selected by
    /// "selector" will still be available after the eviction, i.e. even in the
    /// absence of the evicted pod.  So for example you can prevent all voluntary
    /// evictions by specifying "100%".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minAvailable")]
    pub min_available: Option<IntOrString>,
    /// replaces default labels selector generated by operator
    /// it's useful when you need to create custom budget
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selectorLabels")]
    pub selector_labels: Option<BTreeMap<String, String>>,
}

/// PodMetadata configures Labels and Annotations which are propagated to the vmagent pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentPodMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name must be unique within a namespace. Is required when creating resources, although
    /// some resources may allow a client to request the generation of an appropriate name
    /// automatically. Name is primarily intended for creation idempotence and configuration
    /// definition.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// PodScrapeNamespaceSelector defines Namespaces to be selected for VMPodScrape discovery.
/// Works in combination with Selector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentPodScrapeNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentPodScrapeNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentPodScrapeNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentPodScrapeRelabelTemplate {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// PodScrapeSelector defines PodScrapes to be selected for target discovery.
/// Works in combination with NamespaceSelector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentPodScrapeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentPodScrapeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentPodScrapeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ProbeNamespaceSelector defines Namespaces to be selected for VMProbe discovery.
/// Works in combination with Selector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentProbeNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentProbeNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentProbeNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentProbeScrapeRelabelTemplate {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// ProbeSelector defines VMProbe to be selected for target probing.
/// Works in combination with NamespaceSelector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentProbeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentProbeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentProbeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// PodReadinessGate contains the reference to a pod condition
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentReadinessGates {
    /// ConditionType refers to a condition in the pod's condition list with matching type.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
}

/// RelabelConfig ConfigMap with global relabel config -remoteWrite.relabelConfig
/// This relabeling is applied to all the collected metrics before sending them to remote storage.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRelabelConfig {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// VMAgentRemoteWriteSpec defines the remote storage configuration for VmAgent
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWrite {
    /// AWS describes params specific to AWS cloud
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<VmAgentRemoteWriteAws>,
    /// BasicAuth allow an endpoint to authenticate over basic authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<VmAgentRemoteWriteBasicAuth>,
    /// Optional bearer auth token to use for -remoteWrite.url
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<VmAgentRemoteWriteBearerTokenSecret>,
    /// ForceVMProto forces using VictoriaMetrics protocol for sending data to -remoteWrite.url
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "forceVMProto")]
    pub force_vm_proto: Option<bool>,
    /// Headers allow configuring custom http headers
    /// Must be in form of semicolon separated header with value
    /// e.g.
    /// headerName: headerValue
    /// vmagent supports since 1.79.0 version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    /// InlineUrlRelabelConfig defines relabeling config for remoteWriteURL, it can be defined at crd spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inlineUrlRelabelConfig")]
    pub inline_url_relabel_config: Option<Vec<VmAgentRemoteWriteInlineUrlRelabelConfig>>,
    /// MaxDiskUsage defines the maximum file-based buffer size in bytes for the given remoteWrite
    /// It overrides global configuration defined at remoteWriteSettings.maxDiskUsagePerURL
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDiskUsage")]
    pub max_disk_usage: Option<serde_json::Value>,
    /// OAuth2 defines auth configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<VmAgentRemoteWriteOauth2>,
    /// ProxyURL for -remoteWrite.url. Supported proxies: http, https, socks5. Example: socks5://proxy:1234
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// Timeout for sending a single block of data to -remoteWrite.url (default 1m0s)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendTimeout")]
    pub send_timeout: Option<String>,
    /// StreamAggrConfig defines stream aggregation configuration for VMAgent for -remoteWrite.url
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamAggrConfig")]
    pub stream_aggr_config: Option<VmAgentRemoteWriteStreamAggrConfig>,
    /// TLSConfig describes tls configuration for remote write target
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VmAgentRemoteWriteTlsConfig>,
    /// URL of the endpoint to send samples to.
    pub url: String,
    /// ConfigMap with relabeling config which is applied to metrics before sending them to the corresponding -remoteWrite.url
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlRelabelConfig")]
    pub url_relabel_config: Option<VmAgentRemoteWriteUrlRelabelConfig>,
}

/// AWS describes params specific to AWS cloud
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteAws {
    /// EC2Endpoint is an optional AWS EC2 API endpoint to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ec2Endpoint")]
    pub ec2_endpoint: Option<String>,
    /// Region is an optional AWS region to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// RoleARN is an optional AWS region to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleARN")]
    pub role_arn: Option<String>,
    /// Service is an optional AWS Service to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    /// STSEndpoint is an optional AWS STS API endpoint to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stsEndpoint")]
    pub sts_endpoint: Option<String>,
    /// UseSigv4 enables SigV4 request signing for the corresponding -remoteWrite.url
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useSigv4")]
    pub use_sigv4: Option<bool>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteBasicAuth {
    /// Password defines reference for secret with password value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<VmAgentRemoteWriteBasicAuthPassword>,
    /// PasswordFile defines path to password file at disk
    /// must be pre-mounted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// Username defines reference for secret with username value
    /// The secret needs to be in the same namespace as scrape object
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<VmAgentRemoteWriteBasicAuthUsername>,
}

/// Password defines reference for secret with password value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Username defines reference for secret with username value
/// The secret needs to be in the same namespace as scrape object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Optional bearer auth token to use for -remoteWrite.url
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteInlineUrlRelabelConfig {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// OAuth2 defines auth configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteOauth2 {
    /// The secret or configmap containing the OAuth2 client id
    pub client_id: VmAgentRemoteWriteOauth2ClientId,
    /// The secret containing the OAuth2 client secret
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<VmAgentRemoteWriteOauth2ClientSecret>,
    /// ClientSecretFile defines path for client secret file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret_file: Option<String>,
    /// Parameters to append to the token URL
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// The proxy URL for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy_url: Option<String>,
    /// OAuth2 scopes used for the token request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// TLSConfig for token_url connection
    /// ( available from v0.55.0).
    /// Is only supported by Scrape objects family
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<serde_json::Value>,
    /// The URL to fetch the token from
    pub token_url: String,
}

/// The secret or configmap containing the OAuth2 client id
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VmAgentRemoteWriteOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VmAgentRemoteWriteOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret containing the OAuth2 client secret
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// StreamAggrConfig defines stream aggregation configuration for VMAgent for -remoteWrite.url
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteStreamAggrConfig {
    /// ConfigMap with stream aggregation rules
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configmap: Option<VmAgentRemoteWriteStreamAggrConfigConfigmap>,
    /// Allows setting different de-duplication intervals per each configured remote storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dedupInterval")]
    pub dedup_interval: Option<String>,
    /// Allow drop all the input samples after the aggregation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropInput")]
    pub drop_input: Option<bool>,
    /// labels to drop from samples for aggregator before stream de-duplication and aggregation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropInputLabels")]
    pub drop_input_labels: Option<Vec<String>>,
    /// EnableWindows enables aggregating data in separate windows ( available from v0.54.0).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableWindows")]
    pub enable_windows: Option<bool>,
    /// IgnoreFirstIntervals instructs to ignore first interval
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreFirstIntervals")]
    pub ignore_first_intervals: Option<i64>,
    /// IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreFirstSampleInterval")]
    pub ignore_first_sample_interval: Option<String>,
    /// IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreOldSamples")]
    pub ignore_old_samples: Option<bool>,
    /// Allows writing both raw and aggregate data
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepInput")]
    pub keep_input: Option<bool>,
    /// Stream aggregation rules
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<VmAgentRemoteWriteStreamAggrConfigRules>>,
}

/// ConfigMap with stream aggregation rules
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteStreamAggrConfigConfigmap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// StreamAggrRule defines the rule in stream aggregation config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteStreamAggrConfigRules {
    /// By is an optional list of labels for grouping input series.
    /// 
    /// See also Without.
    /// 
    /// If neither By nor Without are set, then the Outputs are calculated
    /// individually per each input time series.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub by: Option<Vec<String>>,
    /// DedupInterval is an optional interval for deduplication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dedup_interval: Option<String>,
    /// DropInputLabels is an optional list with labels, which must be dropped before further processing of input samples.
    /// 
    /// Labels are dropped before de-duplication and aggregation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop_input_labels: Option<Vec<String>>,
    /// EnableWindows enables aggregating data in separate windows
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable_windows: Option<bool>,
    /// FlushOnShutdown defines whether to flush the aggregation state on process termination
    /// or config reload. Is `false` by default.
    /// It is not recommended changing this setting, unless unfinished aggregations states
    /// are preferred to missing data points.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flush_on_shutdown: Option<bool>,
    /// IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreFirstSampleInterval")]
    pub ignore_first_sample_interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore_first_intervals: Option<i64>,
    /// IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore_old_samples: Option<bool>,
    /// InputRelabelConfigs is an optional relabeling rules, which are applied on the input
    /// before aggregation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input_relabel_configs: Option<Vec<VmAgentRemoteWriteStreamAggrConfigRulesInputRelabelConfigs>>,
    /// Interval is the interval between aggregations.
    pub interval: String,
    /// KeepMetricNames instructs to leave metric names as is for the output time series without adding any suffix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keep_metric_names: Option<bool>,
    /// Match is a label selector (or list of label selectors) for filtering time series for the given selector.
    /// 
    /// If the match isn't set, then all the input time series are processed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<serde_json::Value>,
    /// NoAlignFlushToInterval disables aligning of flushes to multiples of Interval.
    /// By default flushes are aligned to Interval.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub no_align_flush_to_interval: Option<bool>,
    /// OutputRelabelConfigs is an optional relabeling rules, which are applied
    /// on the aggregated output before being sent to remote storage.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_relabel_configs: Option<Vec<VmAgentRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs>>,
    /// Outputs is a list of output aggregate functions to produce.
    /// 
    /// The following names are allowed:
    /// 
    /// - total - aggregates input counters
    /// - increase - counts the increase over input counters
    /// - count_series - counts the input series
    /// - count_samples - counts the input samples
    /// - sum_samples - sums the input samples
    /// - last - the last biggest sample value
    /// - min - the minimum sample value
    /// - max - the maximum sample value
    /// - avg - the average value across all the samples
    /// - stddev - standard deviation across all the samples
    /// - stdvar - standard variance across all the samples
    /// - histogram_bucket - creates VictoriaMetrics histogram for input samples
    /// - quantiles(phi1, ..., phiN) - quantiles' estimation for phi in the range [0..1]
    /// 
    /// The output time series will have the following names:
    /// 
    ///   input_name:aggr_<interval>_<output>
    pub outputs: Vec<String>,
    /// Staleness interval is interval after which the series state will be reset if no samples have been sent during it.
    /// The parameter is only relevant for outputs: total, total_prometheus, increase, increase_prometheus and histogram_bucket.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub staleness_interval: Option<String>,
    /// Without is an optional list of labels, which must be excluded when grouping input series.
    /// 
    /// See also By.
    /// 
    /// If neither By nor Without are set, then the Outputs are calculated
    /// individually per each input time series.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub without: Option<Vec<String>>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteStreamAggrConfigRulesInputRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteStreamAggrConfigRulesOutputRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// TLSConfig describes tls configuration for remote write target
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteTlsConfig {
    /// Struct containing the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<VmAgentRemoteWriteTlsConfigCa>,
    /// Path to the CA cert in the container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Struct containing the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<VmAgentRemoteWriteTlsConfigCert>,
    /// Path to the client cert file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VmAgentRemoteWriteTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Struct containing the CA cert to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VmAgentRemoteWriteTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VmAgentRemoteWriteTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Struct containing the client cert file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<VmAgentRemoteWriteTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<VmAgentRemoteWriteTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConfigMap with relabeling config which is applied to metrics before sending them to the corresponding -remoteWrite.url
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteUrlRelabelConfig {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RemoteWriteSettings defines global settings for all remoteWrite urls.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRemoteWriteSettings {
    /// Interval for flushing the data to remote storage. (default 1s)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushInterval")]
    pub flush_interval: Option<String>,
    /// Labels in the form 'name=value' to add to all the metrics before sending them. This overrides the label if it already exists.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<BTreeMap<String, String>>,
    /// The maximum size in bytes of unpacked request to send to remote storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBlockSize")]
    pub max_block_size: Option<i32>,
    /// The maximum file-based buffer size in bytes at -remoteWrite.tmpDataPath
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDiskUsagePerURL")]
    pub max_disk_usage_per_url: Option<serde_json::Value>,
    /// The number of concurrent queues
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queues: Option<i32>,
    /// Whether to show -remoteWrite.url in the exported metrics. It is hidden by default, since it can contain sensitive auth info
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "showURL")]
    pub show_url: Option<bool>,
    /// Path to directory where temporary data for remote write component is stored (default vmagent-remotewrite-data)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tmpDataPath")]
    pub tmp_data_path: Option<String>,
    /// Configures vmagent accepting data via the same multitenant endpoints as vminsert at VictoriaMetrics cluster does,
    /// see [here](<https://docs.victoriametrics.com/victoriametrics/vmagent/#multitenancy).>
    /// it's global setting and affects all remote storage configurations
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useMultiTenantMode")]
    pub use_multi_tenant_mode: Option<bool>,
}

/// Resources container resource request and limits, <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
/// if not defined default resources from operator config will be used
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<VmAgentResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// RollingUpdate - overrides deployment update params.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentRollingUpdate {
    /// The maximum number of pods that can be scheduled above the desired number of
    /// pods.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
    /// the rolling update starts, such that the total number of old and new pods do not exceed
    /// 130% of desired pods. Once old pods have been killed,
    /// new ReplicaSet can be scaled up further, ensuring that total number of pods running
    /// at any time during the update is at most 130% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// The maximum number of pods that can be unavailable during the update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// Absolute number is calculated from percentage by rounding down.
    /// This can not be 0 if MaxSurge is 0.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
    /// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
    /// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
    /// that the total number of pods available at all times during the update is at
    /// least 70% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// ScrapeConfigNamespaceSelector defines Namespaces to be selected for VMScrapeConfig discovery.
/// Works in combination with Selector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentScrapeConfigNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentScrapeConfigNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentScrapeConfigNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentScrapeConfigRelabelTemplate {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// ScrapeConfigSelector defines VMScrapeConfig to be selected for target discovery.
/// Works in combination with NamespaceSelector.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentScrapeConfigSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentScrapeConfigSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentScrapeConfigSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ServiceScrapeNamespaceSelector Namespaces to be selected for VMServiceScrape discovery.
/// Works in combination with Selector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentServiceScrapeNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentServiceScrapeNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentServiceScrapeNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentServiceScrapeRelabelTemplate {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// ServiceScrapeSelector defines ServiceScrapes to be selected for target discovery.
/// Works in combination with NamespaceSelector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentServiceScrapeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentServiceScrapeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentServiceScrapeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ServiceSpec that will be added to vmagent service spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentServiceSpec {
    /// EmbeddedObjectMetadata defines objectMeta for additional service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<VmAgentServiceSpecMetadata>,
    /// ServiceSpec describes the attributes that a user creates on a service.
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/>
    pub spec: BTreeMap<String, serde_json::Value>,
    /// UseAsDefault applies changes from given service definition to the main object Service
    /// Changing from headless service to clusterIP or loadbalancer may break cross-component communication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useAsDefault")]
    pub use_as_default: Option<bool>,
}

/// EmbeddedObjectMetadata defines objectMeta for additional service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentServiceSpecMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name must be unique within a namespace. Is required when creating resources, although
    /// some resources may allow a client to request the generation of an appropriate name
    /// automatically. Name is primarily intended for creation idempotence and configuration
    /// definition.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// StatefulStorage configures storage for StatefulSet
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorage {
    /// Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
    /// DisableMountSubPath allows to remove any subPath usage in volume mounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableMountSubPath")]
    pub disable_mount_sub_path: Option<bool>,
    /// EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
    /// info: <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<VmAgentStatefulStorageEmptyDir>,
    /// A PVC spec to be used by the StatefulSets/Deployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<VmAgentStatefulStorageVolumeClaimTemplate>,
}

/// EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
/// info: <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageEmptyDir {
    /// medium represents what type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

/// A PVC spec to be used by the StatefulSets/Deployments.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplate {
    /// APIVersion defines the versioned schema of this representation of an object.
    /// Servers should convert recognized schemas to the latest internal value, and
    /// may reject unrecognized values.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Kind is a string value representing the REST resource this object represents.
    /// Servers may infer this from the endpoint the client submits requests to.
    /// Cannot be updated.
    /// In CamelCase.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<VmAgentStatefulStorageVolumeClaimTemplateMetadata>,
    /// Spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<VmAgentStatefulStorageVolumeClaimTemplateSpec>,
    /// Status represents the current information/status of a persistent volume claim.
    /// Read-only.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<VmAgentStatefulStorageVolumeClaimTemplateStatus>,
}

/// EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name must be unique within a namespace. Is required when creating resources, although
    /// some resources may allow a client to request the generation of an appropriate name
    /// automatically. Name is primarily intended for creation idempotence and configuration
    /// definition.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Spec defines the desired characteristics of a volume requested by a pod author.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<VmAgentStatefulStorageVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<VmAgentStatefulStorageVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<VmAgentStatefulStorageVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<VmAgentStatefulStorageVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    /// (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Status represents the current information/status of a persistent volume claim.
/// Read-only.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplateStatus {
    /// accessModes contains the actual access modes the volume backing the PVC has.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// allocatedResourceStatuses stores status of resource being resized for the given PVC.
    /// Key names follow standard Kubernetes label syntax. Valid values are either:
    /// 	* Un-prefixed keys:
    /// 		- storage - the capacity of the volume.
    /// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    /// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    /// reserved and hence may not be used.
    /// 
    /// ClaimResourceStatus can be in any of following states:
    /// 	- ControllerResizeInProgress:
    /// 		State set when resize controller starts resizing the volume in control-plane.
    /// 	- ControllerResizeFailed:
    /// 		State set when resize has failed in resize controller with a terminal error.
    /// 	- NodeResizePending:
    /// 		State set when resize controller has finished resizing the volume but further resizing of
    /// 		volume is needed on the node.
    /// 	- NodeResizeInProgress:
    /// 		State set when kubelet starts resizing the volume.
    /// 	- NodeResizeFailed:
    /// 		State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
    /// 		NodeResizeFailed.
    /// For example: if expanding a PVC for more capacity - this field can be one of the following states:
    /// 	- pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
    ///      - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
    /// When this field is not set, it means that no resize operation is in progress for the given PVC.
    /// 
    /// A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
    /// should ignore the update for the purpose it was designed. For example - a controller that
    /// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    /// resources associated with PVC.
    /// 
    /// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocatedResourceStatuses")]
    pub allocated_resource_statuses: Option<BTreeMap<String, String>>,
    /// allocatedResources tracks the resources allocated to a PVC including its capacity.
    /// Key names follow standard Kubernetes label syntax. Valid values are either:
    /// 	* Un-prefixed keys:
    /// 		- storage - the capacity of the volume.
    /// 	* Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    /// Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    /// reserved and hence may not be used.
    /// 
    /// Capacity reported here may be larger than the actual capacity when a volume expansion operation
    /// is requested.
    /// For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
    /// If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
    /// If a volume expansion capacity request is lowered, allocatedResources is only
    /// lowered if there are no expansion operations in progress and if the actual volume capacity
    /// is equal or lower than the requested capacity.
    /// 
    /// A controller that receives PVC update with previously unknown resourceName
    /// should ignore the update for the purpose it was designed. For example - a controller that
    /// only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    /// resources associated with PVC.
    /// 
    /// This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocatedResources")]
    pub allocated_resources: Option<BTreeMap<String, IntOrString>>,
    /// capacity represents the actual resources of the underlying volume.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capacity: Option<BTreeMap<String, IntOrString>>,
    /// conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
    /// resized then the Condition will be set to 'Resizing'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
    /// When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
    /// This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentVolumeAttributesClassName")]
    pub current_volume_attributes_class_name: Option<String>,
    /// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
    /// When this is unset, there is no ModifyVolume operation being attempted.
    /// This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modifyVolumeStatus")]
    pub modify_volume_status: Option<VmAgentStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus>,
    /// phase represents the current phase of PersistentVolumeClaim.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
}

/// ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
/// When this is unset, there is no ModifyVolume operation being attempted.
/// This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus {
    /// status is the status of the ControllerModifyVolume operation. It can be in any of following states:
    ///  - Pending
    ///    Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
    ///    the specified VolumeAttributesClass not existing.
    ///  - InProgress
    ///    InProgress indicates that the volume is being modified.
    ///  - Infeasible
    ///   Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
    /// 	  resolve the error, a valid VolumeAttributesClass needs to be specified.
    /// Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
    pub status: String,
    /// targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetVolumeAttributesClassName")]
    pub target_volume_attributes_class_name: Option<String>,
}

/// StaticScrapeNamespaceSelector defines Namespaces to be selected for VMStaticScrape discovery.
/// Works in combination with NamespaceSelector.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
/// If both nil - behaviour controlled by selectAllByDefault
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStaticScrapeNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentStaticScrapeNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStaticScrapeNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStaticScrapeRelabelTemplate {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// StaticScrapeSelector defines VMStaticScrape to be selected for target discovery.
/// Works in combination with NamespaceSelector.
/// If both nil - match everything.
/// NamespaceSelector nil - only objects at VMAgent namespace.
/// Selector nil - only objects at NamespaceSelector namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStaticScrapeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<VmAgentStaticScrapeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStaticScrapeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// StreamAggrConfig defines global stream aggregation configuration for VMAgent
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStreamAggrConfig {
    /// ConfigMap with stream aggregation rules
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configmap: Option<VmAgentStreamAggrConfigConfigmap>,
    /// Allows setting different de-duplication intervals per each configured remote storage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dedupInterval")]
    pub dedup_interval: Option<String>,
    /// Allow drop all the input samples after the aggregation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropInput")]
    pub drop_input: Option<bool>,
    /// labels to drop from samples for aggregator before stream de-duplication and aggregation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dropInputLabels")]
    pub drop_input_labels: Option<Vec<String>>,
    /// EnableWindows enables aggregating data in separate windows ( available from v0.54.0).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableWindows")]
    pub enable_windows: Option<bool>,
    /// IgnoreFirstIntervals instructs to ignore first interval
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreFirstIntervals")]
    pub ignore_first_intervals: Option<i64>,
    /// IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreFirstSampleInterval")]
    pub ignore_first_sample_interval: Option<String>,
    /// IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreOldSamples")]
    pub ignore_old_samples: Option<bool>,
    /// Allows writing both raw and aggregate data
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepInput")]
    pub keep_input: Option<bool>,
    /// Stream aggregation rules
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<VmAgentStreamAggrConfigRules>>,
}

/// ConfigMap with stream aggregation rules
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStreamAggrConfigConfigmap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// StreamAggrRule defines the rule in stream aggregation config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStreamAggrConfigRules {
    /// By is an optional list of labels for grouping input series.
    /// 
    /// See also Without.
    /// 
    /// If neither By nor Without are set, then the Outputs are calculated
    /// individually per each input time series.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub by: Option<Vec<String>>,
    /// DedupInterval is an optional interval for deduplication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dedup_interval: Option<String>,
    /// DropInputLabels is an optional list with labels, which must be dropped before further processing of input samples.
    /// 
    /// Labels are dropped before de-duplication and aggregation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop_input_labels: Option<Vec<String>>,
    /// EnableWindows enables aggregating data in separate windows
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable_windows: Option<bool>,
    /// FlushOnShutdown defines whether to flush the aggregation state on process termination
    /// or config reload. Is `false` by default.
    /// It is not recommended changing this setting, unless unfinished aggregations states
    /// are preferred to missing data points.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flush_on_shutdown: Option<bool>,
    /// IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreFirstSampleInterval")]
    pub ignore_first_sample_interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore_first_intervals: Option<i64>,
    /// IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore_old_samples: Option<bool>,
    /// InputRelabelConfigs is an optional relabeling rules, which are applied on the input
    /// before aggregation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input_relabel_configs: Option<Vec<VmAgentStreamAggrConfigRulesInputRelabelConfigs>>,
    /// Interval is the interval between aggregations.
    pub interval: String,
    /// KeepMetricNames instructs to leave metric names as is for the output time series without adding any suffix.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keep_metric_names: Option<bool>,
    /// Match is a label selector (or list of label selectors) for filtering time series for the given selector.
    /// 
    /// If the match isn't set, then all the input time series are processed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<serde_json::Value>,
    /// NoAlignFlushToInterval disables aligning of flushes to multiples of Interval.
    /// By default flushes are aligned to Interval.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub no_align_flush_to_interval: Option<bool>,
    /// OutputRelabelConfigs is an optional relabeling rules, which are applied
    /// on the aggregated output before being sent to remote storage.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_relabel_configs: Option<Vec<VmAgentStreamAggrConfigRulesOutputRelabelConfigs>>,
    /// Outputs is a list of output aggregate functions to produce.
    /// 
    /// The following names are allowed:
    /// 
    /// - total - aggregates input counters
    /// - increase - counts the increase over input counters
    /// - count_series - counts the input series
    /// - count_samples - counts the input samples
    /// - sum_samples - sums the input samples
    /// - last - the last biggest sample value
    /// - min - the minimum sample value
    /// - max - the maximum sample value
    /// - avg - the average value across all the samples
    /// - stddev - standard deviation across all the samples
    /// - stdvar - standard variance across all the samples
    /// - histogram_bucket - creates VictoriaMetrics histogram for input samples
    /// - quantiles(phi1, ..., phiN) - quantiles' estimation for phi in the range [0..1]
    /// 
    /// The output time series will have the following names:
    /// 
    ///   input_name:aggr_<interval>_<output>
    pub outputs: Vec<String>,
    /// Staleness interval is interval after which the series state will be reset if no samples have been sent during it.
    /// The parameter is only relevant for outputs: total, total_prometheus, increase, increase_prometheus and histogram_bucket.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub staleness_interval: Option<String>,
    /// Without is an optional list of labels, which must be excluded when grouping input series.
    /// 
    /// See also By.
    /// 
    /// If neither By nor Without are set, then the Outputs are calculated
    /// individually per each input time series.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub without: Option<Vec<String>>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStreamAggrConfigRulesInputRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set
/// More info: <https://docs.victoriametrics.com/victoriametrics/#relabeling>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStreamAggrConfigRulesOutputRelabelConfigs {
    /// Action to perform based on regex matching. Default is 'replace'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// If represents metricsQL match expression (or list of expressions): '{__name__=~"foo_.*"}'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "if")]
    pub r#if: Option<serde_json::Value>,
    /// Labels is used together with Match for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Match is used together with Labels for `action: graphite`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<String>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    /// victoriaMetrics supports multiline regex joined with |
    /// <https://docs.victoriametrics.com/victoriametrics/vmagent/#relabeling-enhancements>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<serde_json::Value>,
    /// Replacement value against which a regex replace is performed if the
    /// regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated
    /// using the configured separator and matched against the configured regular expression
    /// for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// UnderScoreSourceLabels - additional form of source labels source_labels
    /// for compatibility with original relabel config.
    /// if set  both sourceLabels and source_labels, sourceLabels has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "source_labels")]
    pub source_labels_x: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action.
    /// It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
    /// UnderScoreTargetLabel - additional form of target label - target_label
    /// for compatibility with original relabel config.
    /// if set  both targetLabel and target_label, targetLabel has priority.
    /// for details <https://github.com/VictoriaMetrics/operator/issues/131>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "target_label")]
    pub target_label_x: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// VMAgentSpec defines the desired state of VMAgent
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VmAgentUpdateStrategy {
    Recreate,
    RollingUpdate,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// VMAgentStatus defines the observed state of VMAgent
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VmAgentStatus {
    /// Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration defines current generation picked by operator for the
    /// reconcile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// Reason defines human readable error reason
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// ReplicaCount Total number of pods targeted by this VMAgent
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Selector string form of label value set for autoscaling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Shards represents total number of vmagent deployments with uniq scrape targets
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shards: Option<i32>,
    /// UpdateStatus defines a status for update rollout
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStatus")]
    pub update_status: Option<String>,
}

