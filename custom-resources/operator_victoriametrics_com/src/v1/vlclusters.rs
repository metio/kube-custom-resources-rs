// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/VictoriaMetrics/operator/operator.victoriametrics.com/v1/vlclusters.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// VLClusterSpec defines the desired state of VLCluster
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "operator.victoriametrics.com", version = "v1", kind = "VLCluster", plural = "vlclusters")]
#[kube(namespaced)]
#[kube(status = "VLClusterStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct VLClusterSpec {
    /// ClusterDomainName defines domain name suffix for in-cluster dns addresses
    /// aka .cluster.local
    /// used by vlinsert and vlselect to build vlstorage address
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterDomainName")]
    pub cluster_domain_name: Option<String>,
    /// ClusterVersion defines default images tag for all components.
    /// it can be overwritten with component specific image.tag value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterVersion")]
    pub cluster_version: Option<String>,
    /// ImagePullSecrets An optional list of references to secrets in the same namespace
    /// to use for pulling images from registries
    /// see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecrets")]
    pub image_pull_secrets: Option<Vec<VLClusterImagePullSecrets>>,
    /// ManagedMetadata defines metadata that will be added to the all objects
    /// created by operator for the given CustomResource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedMetadata")]
    pub managed_metadata: Option<VLClusterManagedMetadata>,
    /// Paused If set to true all actions on the underlying managed objects are not
    /// going to be performed, except for delete actions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    /// RequestsLoadBalancer configures load-balancing for vlinsert and vlselect requests.
    /// It helps to evenly spread load across pods.
    /// Usually it's not possible with Kubernetes TCP-based services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requestsLoadBalancer")]
    pub requests_load_balancer: Option<VLClusterRequestsLoadBalancer>,
    /// ServiceAccountName is the name of the ServiceAccount to use to run the
    /// VLSelect, VLInsert and VLStorage Pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountName")]
    pub service_account_name: Option<String>,
    /// UseStrictSecurity enables strict security mode for component
    /// it restricts disk writes access
    /// uses non-root user out of the box
    /// drops not needed security permissions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useStrictSecurity")]
    pub use_strict_security: Option<bool>,
    /// VLInsert defines vlinsert component configuration at victoria-logs cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vlinsert: Option<VLClusterVlinsert>,
    /// VLSelect defines vlselect component configuration at victoria-logs cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vlselect: Option<VLClusterVlselect>,
    /// VLStorage defines vlstorage component configuration at victoria-logs cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vlstorage: Option<VLClusterVlstorage>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterImagePullSecrets {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// ManagedMetadata defines metadata that will be added to the all objects
/// created by operator for the given CustomResource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterManagedMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// RequestsLoadBalancer configures load-balancing for vlinsert and vlselect requests.
/// It helps to evenly spread load across pods.
/// Usually it's not possible with Kubernetes TCP-based services.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterRequestsLoadBalancer {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableInsertBalancing")]
    pub disable_insert_balancing: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableSelectBalancing")]
    pub disable_select_balancing: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// VMAuthLoadBalancerSpec defines configuration spec for VMAuth used as load-balancer
    /// for VMCluster component
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

/// VLInsert defines vlinsert component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsert {
    /// Affinity If specified, the pod's scheduling constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<BTreeMap<String, serde_json::Value>>,
    /// ConfigMaps is a list of ConfigMaps in the same namespace as the Application
    /// object, which shall be mounted into the Application container
    /// at /etc/vm/configs/CONFIGMAP_NAME folder
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMaps")]
    pub config_maps: Option<Vec<String>>,
    /// Containers property allows to inject additions sidecars or to patch existing containers.
    /// It can be useful for proxies, backup, etc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub containers: Option<Vec<VLClusterVlinsertContainers>>,
    /// DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
    /// Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
    /// For example, vmagent and vm-config-reloader requires k8s API access.
    /// Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
    /// And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableAutomountServiceAccountToken")]
    pub disable_automount_service_account_token: Option<bool>,
    /// DisableSelfServiceScrape controls creation of VMServiceScrape by operator
    /// for the application.
    /// Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableSelfServiceScrape")]
    pub disable_self_service_scrape: Option<bool>,
    /// Specifies the DNS parameters of a pod.
    /// Parameters specified here will be merged to the generated DNS
    /// configuration based on DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<VLClusterVlinsertDnsConfig>,
    /// DNSPolicy sets DNS policy for the pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsPolicy")]
    pub dns_policy: Option<String>,
    /// ExtraArgs that will be passed to the application container
    /// for example remoteWrite.tmpDataPath: /tmp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraArgs")]
    pub extra_args: Option<BTreeMap<String, String>>,
    /// ExtraEnvs that will be passed to the application container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvs")]
    pub extra_envs: Option<Vec<VLClusterVlinsertExtraEnvs>>,
    /// ExtraEnvsFrom defines source of env variables for the application container
    /// could either be secret or configmap
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvsFrom")]
    pub extra_envs_from: Option<Vec<VLClusterVlinsertExtraEnvsFrom>>,
    /// HostAliases provides mapping for ip and hostname,
    /// that would be propagated to pod,
    /// cannot be used with HostNetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostAliases")]
    pub host_aliases: Option<Vec<VLClusterVlinsertHostAliases>>,
    /// HostNetwork controls whether the pod may use the node network namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// HostAliasesUnderScore provides mapping for ip and hostname,
    /// that would be propagated to pod,
    /// cannot be used with HostNetwork.
    /// Has Priority over hostAliases field
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "host_aliases")]
    pub host_aliases_x: Option<Vec<VLClusterVlinsertHostAliases>>,
    /// Configures horizontal pod autoscaling.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hpa: Option<BTreeMap<String, serde_json::Value>>,
    /// Image - docker image settings
    /// if no specified operator uses default version from operator config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<VLClusterVlinsertImage>,
    /// ImagePullSecrets An optional list of references to secrets in the same namespace
    /// to use for pulling images from registries
    /// see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecrets")]
    pub image_pull_secrets: Option<Vec<VLClusterVlinsertImagePullSecrets>>,
    /// InitContainers allows adding initContainers to the pod definition.
    /// Any errors during the execution of an initContainer will lead to a restart of the Pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<VLClusterVlinsertInitContainers>>,
    /// LivenessProbe that will be added CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// LogFormat for VLSelect to be configured with.
    /// default or json
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    pub log_format: Option<VLClusterVlinsertLogFormat>,
    /// LogLevel for VLSelect to be configured with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<VLClusterVlinsertLogLevel>,
    /// MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
    /// if previous in healthy state
    /// Has no effect for VLogs and VMSingle
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// NodeSelector Define which Nodes the Pods are scheduled on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Paused If set to true all actions on the underlying managed objects are not
    /// going to be performed, except for delete actions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    /// PodDisruptionBudget created by operator
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podDisruptionBudget")]
    pub pod_disruption_budget: Option<VLClusterVlinsertPodDisruptionBudget>,
    /// PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podMetadata")]
    pub pod_metadata: Option<VLClusterVlinsertPodMetadata>,
    /// Port listen address
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// PriorityClassName class assigned to the Pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// ReadinessGates defines pod readiness gates
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<VLClusterVlinsertReadinessGates>>,
    /// ReadinessProbe that will be added CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// ReplicaCount is the expected size of the Application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaCount")]
    pub replica_count: Option<i32>,
    /// Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    /// if not defined default resources from operator config will be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<VLClusterVlinsertResources>,
    /// The number of old ReplicaSets to retain to allow rollback in deployment or
    /// maximum number of revisions that will be maintained in the Deployment revision history.
    /// Has no effect at StatefulSets
    /// Defaults to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "revisionHistoryLimitCount")]
    pub revision_history_limit_count: Option<i32>,
    /// RollingUpdate - overrides deployment update params.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<VLClusterVlinsertRollingUpdate>,
    /// RuntimeClassName - defines runtime class for kubernetes pod.
    /// https://kubernetes.io/docs/concepts/containers/runtime-class/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeClassName")]
    pub runtime_class_name: Option<String>,
    /// SchedulerName - defines kubernetes scheduler name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    /// Secrets is a list of Secrets in the same namespace as the Application
    /// object, which shall be mounted into the Application container
    /// at /etc/vm/secrets/SECRET_NAME folder
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
    /// SecurityContext holds pod-level security attributes and common container settings.
    /// This defaults to the default PodSecurityContext.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<BTreeMap<String, serde_json::Value>>,
    /// ServiceScrapeSpec that will be added to vlselect VMServiceScrape spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceScrapeSpec")]
    pub service_scrape_spec: Option<BTreeMap<String, serde_json::Value>>,
    /// ServiceSpec that will be added to vlselect service spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSpec")]
    pub service_spec: Option<VLClusterVlinsertServiceSpec>,
    /// StartupProbe that will be added to CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// SyslogSpec defines syslog listener configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "syslogSpec")]
    pub syslog_spec: Option<VLClusterVlinsertSyslogSpec>,
    /// TerminationGracePeriodSeconds period for container graceful termination
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Tolerations If specified, the pod's tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<VLClusterVlinsertTolerations>>,
    /// TopologySpreadConstraints embedded kubernetes pod configuration option,
    /// controls how pods are spread across your cluster among failure-domains
    /// such as regions, zones, nodes, and other user-defined topology domains
    /// https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<VLClusterVlinsertTopologySpreadConstraints>>,
    /// UpdateStrategy - overrides default update strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<VLClusterVlinsertUpdateStrategy>,
    /// UseDefaultResources controls resource settings
    /// By default, operator sets built-in resource requirements
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDefaultResources")]
    pub use_default_resources: Option<bool>,
    /// UseStrictSecurity enables strict security mode for component
    /// it restricts disk writes access
    /// uses non-root user out of the box
    /// drops not needed security permissions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useStrictSecurity")]
    pub use_strict_security: Option<bool>,
    /// VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
    /// VolumeMounts specified will be appended to other VolumeMounts in the Application container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<VLClusterVlinsertVolumeMounts>>,
    /// Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
    /// Volumes specified will be appended to other volumes that are generated.
    /// / +optional
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<VLClusterVlinsertVolumes>>,
}

/// Specifies the DNS parameters of a pod.
/// Parameters specified here will be merged to the generated DNS
/// configuration based on DNSPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertDnsConfig {
    /// A list of DNS name server IP addresses.
    /// This will be appended to the base nameservers generated from DNSPolicy.
    /// Duplicated nameservers will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nameservers: Option<Vec<String>>,
    /// A list of DNS resolver options.
    /// This will be merged with the base options generated from DNSPolicy.
    /// Duplicated entries will be removed. Resolution options given in Options
    /// will override those that appear in the base DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<VLClusterVlinsertDnsConfigOptions>>,
    /// A list of DNS search domains for host-name lookup.
    /// This will be appended to the base search paths generated from DNSPolicy.
    /// Duplicated search paths will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub searches: Option<Vec<String>>,
}

/// PodDNSConfigOption defines DNS resolver options of a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertDnsConfigOptions {
    /// Name is this DNS resolver option's name.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Value is this DNS resolver option's value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertExtraEnvs {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// EnvFromSource represents the source of a set of ConfigMaps
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertExtraEnvsFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<VLClusterVlinsertExtraEnvsFromConfigMapRef>,
    /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<VLClusterVlinsertExtraEnvsFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertExtraEnvsFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertExtraEnvsFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertHostAliases {
    /// Hostnames for the above IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// IP address of the host file entry.
    pub ip: String,
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertHostAliases {
    /// Hostnames for the above IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// IP address of the host file entry.
    pub ip: String,
}

/// Image - docker image settings
/// if no specified operator uses default version from operator config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertImage {
    /// PullPolicy describes how to pull docker image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// Repository contains name of docker image + it's repository if needed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    /// Tag contains desired docker image version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertImagePullSecrets {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// VLInsert defines vlinsert component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VLClusterVlinsertLogFormat {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "json")]
    Json,
}

/// VLInsert defines vlinsert component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VLClusterVlinsertLogLevel {
    #[serde(rename = "INFO")]
    Info,
    #[serde(rename = "WARN")]
    Warn,
    #[serde(rename = "ERROR")]
    Error,
    #[serde(rename = "FATAL")]
    Fatal,
    #[serde(rename = "PANIC")]
    Panic,
}

/// PodDisruptionBudget created by operator
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertPodDisruptionBudget {
    /// An eviction is allowed if at most "maxUnavailable" pods selected by
    /// "selector" are unavailable after the eviction, i.e. even in absence of
    /// the evicted pod. For example, one can prevent all voluntary evictions
    /// by specifying 0. This is a mutually exclusive setting with "minAvailable".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
    /// An eviction is allowed if at least "minAvailable" pods selected by
    /// "selector" will still be available after the eviction, i.e. even in the
    /// absence of the evicted pod.  So for example you can prevent all voluntary
    /// evictions by specifying "100%".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minAvailable")]
    pub min_available: Option<IntOrString>,
    /// replaces default labels selector generated by operator
    /// it's useful when you need to create custom budget
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selectorLabels")]
    pub selector_labels: Option<BTreeMap<String, String>>,
}

/// PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertPodMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name must be unique within a namespace. Is required when creating resources, although
    /// some resources may allow a client to request the generation of an appropriate name
    /// automatically. Name is primarily intended for creation idempotence and configuration
    /// definition.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// PodReadinessGate contains the reference to a pod condition
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertReadinessGates {
    /// ConditionType refers to a condition in the pod's condition list with matching type.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
}

/// Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
/// if not defined default resources from operator config will be used
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<VLClusterVlinsertResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// RollingUpdate - overrides deployment update params.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertRollingUpdate {
    /// The maximum number of pods that can be scheduled above the desired number of
    /// pods.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
    /// the rolling update starts, such that the total number of old and new pods do not exceed
    /// 130% of desired pods. Once old pods have been killed,
    /// new ReplicaSet can be scaled up further, ensuring that total number of pods running
    /// at any time during the update is at most 130% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// The maximum number of pods that can be unavailable during the update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// Absolute number is calculated from percentage by rounding down.
    /// This can not be 0 if MaxSurge is 0.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
    /// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
    /// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
    /// that the total number of pods available at all times during the update is at
    /// least 70% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// ServiceSpec that will be added to vlselect service spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertServiceSpec {
    /// EmbeddedObjectMetadata defines objectMeta for additional service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<VLClusterVlinsertServiceSpecMetadata>,
    /// ServiceSpec describes the attributes that a user creates on a service.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/
    pub spec: BTreeMap<String, serde_json::Value>,
    /// UseAsDefault applies changes from given service definition to the main object Service
    /// Changing from headless service to clusterIP or loadbalancer may break cross-component communication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useAsDefault")]
    pub use_as_default: Option<bool>,
}

/// EmbeddedObjectMetadata defines objectMeta for additional service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertServiceSpecMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name must be unique within a namespace. Is required when creating resources, although
    /// some resources may allow a client to request the generation of an appropriate name
    /// automatically. Name is primarily intended for creation idempotence and configuration
    /// definition.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// SyslogSpec defines syslog listener configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertSyslogSpec {
    /// TCPListeners defines syslog server TCP listener configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpListeners")]
    pub tcp_listeners: Option<Vec<VLClusterVlinsertSyslogSpecTcpListeners>>,
    /// UDPListeners defines syslog server UDP listener configuration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "udpListeners")]
    pub udp_listeners: Option<Vec<VLClusterVlinsertSyslogSpecUdpListeners>>,
}

/// SyslogTCPListener defines configuration for TCP syslog server listen
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertSyslogSpecTcpListeners {
    /// CompressMethod for syslog messages
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressMethod")]
    pub compress_method: Option<String>,
    /// DecolorizeFields to remove ANSI color codes across logs
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "decolorizeFields")]
    pub decolorize_fields: Option<String>,
    /// IgnoreFields to ignore at logs
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreFields")]
    pub ignore_fields: Option<String>,
    /// ListenPort defines listen port
    #[serde(rename = "listenPort")]
    pub listen_port: i32,
    /// StreamFields to use as log stream labels
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamFields")]
    pub stream_fields: Option<String>,
    /// TenantID for logs ingested in form of accountID:projectID
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantID")]
    pub tenant_id: Option<String>,
    /// TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<VLClusterVlinsertSyslogSpecTcpListenersTlsConfig>,
}

/// TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertSyslogSpecTcpListenersTlsConfig {
    /// CertFile defines path to the pre-mounted file with certificate
    /// mutually exclusive with CertSecretRef
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// CertSecretRef defines reference for secret with certificate content under given key
    /// mutually exclusive with CertFile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certSecret")]
    pub cert_secret: Option<VLClusterVlinsertSyslogSpecTcpListenersTlsConfigCertSecret>,
    /// KeyFile defines path to the pre-mounted file with certificate key
    /// mutually exclusive with KeySecretRef
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Key defines reference for secret with certificate key content under given key
    /// mutually exclusive with KeyFile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<VLClusterVlinsertSyslogSpecTcpListenersTlsConfigKeySecret>,
}

/// CertSecretRef defines reference for secret with certificate content under given key
/// mutually exclusive with CertFile
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertSyslogSpecTcpListenersTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Key defines reference for secret with certificate key content under given key
/// mutually exclusive with KeyFile
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertSyslogSpecTcpListenersTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SyslogUDPListener defines configuration for UDP syslog server listen
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertSyslogSpecUdpListeners {
    /// CompressMethod for syslog messages
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressMethod")]
    pub compress_method: Option<String>,
    /// DecolorizeFields to remove ANSI color codes across logs
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "decolorizeFields")]
    pub decolorize_fields: Option<String>,
    /// IgnoreFields to ignore at logs
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreFields")]
    pub ignore_fields: Option<String>,
    /// ListenPort defines listen port
    #[serde(rename = "listenPort")]
    pub listen_port: i32,
    /// StreamFields to use as log stream labels
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamFields")]
    pub stream_fields: Option<String>,
    /// TenantID for logs ingested in form of accountID:projectID
    /// see https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantID")]
    pub tenant_id: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// VLInsert defines vlinsert component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VLClusterVlinsertUpdateStrategy {
    Recreate,
    RollingUpdate,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlinsertVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// VLSelect defines vlselect component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselect {
    /// Affinity If specified, the pod's scheduling constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<BTreeMap<String, serde_json::Value>>,
    /// ConfigMaps is a list of ConfigMaps in the same namespace as the Application
    /// object, which shall be mounted into the Application container
    /// at /etc/vm/configs/CONFIGMAP_NAME folder
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMaps")]
    pub config_maps: Option<Vec<String>>,
    /// Containers property allows to inject additions sidecars or to patch existing containers.
    /// It can be useful for proxies, backup, etc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub containers: Option<Vec<VLClusterVlselectContainers>>,
    /// DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
    /// Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
    /// For example, vmagent and vm-config-reloader requires k8s API access.
    /// Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
    /// And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableAutomountServiceAccountToken")]
    pub disable_automount_service_account_token: Option<bool>,
    /// DisableSelfServiceScrape controls creation of VMServiceScrape by operator
    /// for the application.
    /// Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableSelfServiceScrape")]
    pub disable_self_service_scrape: Option<bool>,
    /// Specifies the DNS parameters of a pod.
    /// Parameters specified here will be merged to the generated DNS
    /// configuration based on DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<VLClusterVlselectDnsConfig>,
    /// DNSPolicy sets DNS policy for the pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsPolicy")]
    pub dns_policy: Option<String>,
    /// ExtraArgs that will be passed to the application container
    /// for example remoteWrite.tmpDataPath: /tmp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraArgs")]
    pub extra_args: Option<BTreeMap<String, String>>,
    /// ExtraEnvs that will be passed to the application container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvs")]
    pub extra_envs: Option<Vec<VLClusterVlselectExtraEnvs>>,
    /// ExtraEnvsFrom defines source of env variables for the application container
    /// could either be secret or configmap
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvsFrom")]
    pub extra_envs_from: Option<Vec<VLClusterVlselectExtraEnvsFrom>>,
    /// HostAliases provides mapping for ip and hostname,
    /// that would be propagated to pod,
    /// cannot be used with HostNetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostAliases")]
    pub host_aliases: Option<Vec<VLClusterVlselectHostAliases>>,
    /// HostNetwork controls whether the pod may use the node network namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// HostAliasesUnderScore provides mapping for ip and hostname,
    /// that would be propagated to pod,
    /// cannot be used with HostNetwork.
    /// Has Priority over hostAliases field
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "host_aliases")]
    pub host_aliases_x: Option<Vec<VLClusterVlselectHostAliases>>,
    /// Configures horizontal pod autoscaling.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hpa: Option<BTreeMap<String, serde_json::Value>>,
    /// Image - docker image settings
    /// if no specified operator uses default version from operator config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<VLClusterVlselectImage>,
    /// ImagePullSecrets An optional list of references to secrets in the same namespace
    /// to use for pulling images from registries
    /// see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecrets")]
    pub image_pull_secrets: Option<Vec<VLClusterVlselectImagePullSecrets>>,
    /// InitContainers allows adding initContainers to the pod definition.
    /// Any errors during the execution of an initContainer will lead to a restart of the Pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<VLClusterVlselectInitContainers>>,
    /// LivenessProbe that will be added CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// LogFormat for VLSelect to be configured with.
    /// default or json
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    pub log_format: Option<VLClusterVlselectLogFormat>,
    /// LogLevel for VLSelect to be configured with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<VLClusterVlselectLogLevel>,
    /// MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
    /// if previous in healthy state
    /// Has no effect for VLogs and VMSingle
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// NodeSelector Define which Nodes the Pods are scheduled on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Paused If set to true all actions on the underlying managed objects are not
    /// going to be performed, except for delete actions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    /// PodDisruptionBudget created by operator
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podDisruptionBudget")]
    pub pod_disruption_budget: Option<VLClusterVlselectPodDisruptionBudget>,
    /// PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podMetadata")]
    pub pod_metadata: Option<VLClusterVlselectPodMetadata>,
    /// Port listen address
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// PriorityClassName class assigned to the Pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// ReadinessGates defines pod readiness gates
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<VLClusterVlselectReadinessGates>>,
    /// ReadinessProbe that will be added CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// ReplicaCount is the expected size of the Application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaCount")]
    pub replica_count: Option<i32>,
    /// Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    /// if not defined default resources from operator config will be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<VLClusterVlselectResources>,
    /// The number of old ReplicaSets to retain to allow rollback in deployment or
    /// maximum number of revisions that will be maintained in the Deployment revision history.
    /// Has no effect at StatefulSets
    /// Defaults to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "revisionHistoryLimitCount")]
    pub revision_history_limit_count: Option<i32>,
    /// RollingUpdate - overrides deployment update params.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<VLClusterVlselectRollingUpdate>,
    /// RuntimeClassName - defines runtime class for kubernetes pod.
    /// https://kubernetes.io/docs/concepts/containers/runtime-class/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeClassName")]
    pub runtime_class_name: Option<String>,
    /// SchedulerName - defines kubernetes scheduler name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    /// Secrets is a list of Secrets in the same namespace as the Application
    /// object, which shall be mounted into the Application container
    /// at /etc/vm/secrets/SECRET_NAME folder
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
    /// SecurityContext holds pod-level security attributes and common container settings.
    /// This defaults to the default PodSecurityContext.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<BTreeMap<String, serde_json::Value>>,
    /// ServiceScrapeSpec that will be added to vlselect VMServiceScrape spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceScrapeSpec")]
    pub service_scrape_spec: Option<BTreeMap<String, serde_json::Value>>,
    /// ServiceSpec that will be added to vlselect service spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSpec")]
    pub service_spec: Option<VLClusterVlselectServiceSpec>,
    /// StartupProbe that will be added to CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// TerminationGracePeriodSeconds period for container graceful termination
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Tolerations If specified, the pod's tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<VLClusterVlselectTolerations>>,
    /// TopologySpreadConstraints embedded kubernetes pod configuration option,
    /// controls how pods are spread across your cluster among failure-domains
    /// such as regions, zones, nodes, and other user-defined topology domains
    /// https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<VLClusterVlselectTopologySpreadConstraints>>,
    /// UpdateStrategy - overrides default update strategy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<VLClusterVlselectUpdateStrategy>,
    /// UseDefaultResources controls resource settings
    /// By default, operator sets built-in resource requirements
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDefaultResources")]
    pub use_default_resources: Option<bool>,
    /// UseStrictSecurity enables strict security mode for component
    /// it restricts disk writes access
    /// uses non-root user out of the box
    /// drops not needed security permissions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useStrictSecurity")]
    pub use_strict_security: Option<bool>,
    /// VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
    /// VolumeMounts specified will be appended to other VolumeMounts in the Application container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<VLClusterVlselectVolumeMounts>>,
    /// Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
    /// Volumes specified will be appended to other volumes that are generated.
    /// / +optional
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<VLClusterVlselectVolumes>>,
}

/// Specifies the DNS parameters of a pod.
/// Parameters specified here will be merged to the generated DNS
/// configuration based on DNSPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectDnsConfig {
    /// A list of DNS name server IP addresses.
    /// This will be appended to the base nameservers generated from DNSPolicy.
    /// Duplicated nameservers will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nameservers: Option<Vec<String>>,
    /// A list of DNS resolver options.
    /// This will be merged with the base options generated from DNSPolicy.
    /// Duplicated entries will be removed. Resolution options given in Options
    /// will override those that appear in the base DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<VLClusterVlselectDnsConfigOptions>>,
    /// A list of DNS search domains for host-name lookup.
    /// This will be appended to the base search paths generated from DNSPolicy.
    /// Duplicated search paths will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub searches: Option<Vec<String>>,
}

/// PodDNSConfigOption defines DNS resolver options of a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectDnsConfigOptions {
    /// Name is this DNS resolver option's name.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Value is this DNS resolver option's value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectExtraEnvs {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// EnvFromSource represents the source of a set of ConfigMaps
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectExtraEnvsFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<VLClusterVlselectExtraEnvsFromConfigMapRef>,
    /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<VLClusterVlselectExtraEnvsFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectExtraEnvsFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectExtraEnvsFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectHostAliases {
    /// Hostnames for the above IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// IP address of the host file entry.
    pub ip: String,
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectHostAliases {
    /// Hostnames for the above IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// IP address of the host file entry.
    pub ip: String,
}

/// Image - docker image settings
/// if no specified operator uses default version from operator config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectImage {
    /// PullPolicy describes how to pull docker image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// Repository contains name of docker image + it's repository if needed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    /// Tag contains desired docker image version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectImagePullSecrets {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// VLSelect defines vlselect component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VLClusterVlselectLogFormat {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "json")]
    Json,
}

/// VLSelect defines vlselect component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VLClusterVlselectLogLevel {
    #[serde(rename = "INFO")]
    Info,
    #[serde(rename = "WARN")]
    Warn,
    #[serde(rename = "ERROR")]
    Error,
    #[serde(rename = "FATAL")]
    Fatal,
    #[serde(rename = "PANIC")]
    Panic,
}

/// PodDisruptionBudget created by operator
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectPodDisruptionBudget {
    /// An eviction is allowed if at most "maxUnavailable" pods selected by
    /// "selector" are unavailable after the eviction, i.e. even in absence of
    /// the evicted pod. For example, one can prevent all voluntary evictions
    /// by specifying 0. This is a mutually exclusive setting with "minAvailable".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
    /// An eviction is allowed if at least "minAvailable" pods selected by
    /// "selector" will still be available after the eviction, i.e. even in the
    /// absence of the evicted pod.  So for example you can prevent all voluntary
    /// evictions by specifying "100%".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minAvailable")]
    pub min_available: Option<IntOrString>,
    /// replaces default labels selector generated by operator
    /// it's useful when you need to create custom budget
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selectorLabels")]
    pub selector_labels: Option<BTreeMap<String, String>>,
}

/// PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectPodMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name must be unique within a namespace. Is required when creating resources, although
    /// some resources may allow a client to request the generation of an appropriate name
    /// automatically. Name is primarily intended for creation idempotence and configuration
    /// definition.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// PodReadinessGate contains the reference to a pod condition
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectReadinessGates {
    /// ConditionType refers to a condition in the pod's condition list with matching type.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
}

/// Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
/// if not defined default resources from operator config will be used
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<VLClusterVlselectResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// RollingUpdate - overrides deployment update params.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectRollingUpdate {
    /// The maximum number of pods that can be scheduled above the desired number of
    /// pods.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
    /// the rolling update starts, such that the total number of old and new pods do not exceed
    /// 130% of desired pods. Once old pods have been killed,
    /// new ReplicaSet can be scaled up further, ensuring that total number of pods running
    /// at any time during the update is at most 130% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// The maximum number of pods that can be unavailable during the update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
    /// Absolute number is calculated from percentage by rounding down.
    /// This can not be 0 if MaxSurge is 0.
    /// Defaults to 25%.
    /// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
    /// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
    /// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
    /// that the total number of pods available at all times during the update is at
    /// least 70% of desired pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// ServiceSpec that will be added to vlselect service spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectServiceSpec {
    /// EmbeddedObjectMetadata defines objectMeta for additional service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<VLClusterVlselectServiceSpecMetadata>,
    /// ServiceSpec describes the attributes that a user creates on a service.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/
    pub spec: BTreeMap<String, serde_json::Value>,
    /// UseAsDefault applies changes from given service definition to the main object Service
    /// Changing from headless service to clusterIP or loadbalancer may break cross-component communication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useAsDefault")]
    pub use_as_default: Option<bool>,
}

/// EmbeddedObjectMetadata defines objectMeta for additional service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectServiceSpecMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name must be unique within a namespace. Is required when creating resources, although
    /// some resources may allow a client to request the generation of an appropriate name
    /// automatically. Name is primarily intended for creation idempotence and configuration
    /// definition.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// VLSelect defines vlselect component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VLClusterVlselectUpdateStrategy {
    Recreate,
    RollingUpdate,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlselectVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// VLStorage defines vlstorage component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorage {
    /// Affinity If specified, the pod's scheduling constraints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<BTreeMap<String, serde_json::Value>>,
    /// ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "claimTemplates")]
    pub claim_templates: Option<Vec<VLClusterVlstorageClaimTemplates>>,
    /// ConfigMaps is a list of ConfigMaps in the same namespace as the Application
    /// object, which shall be mounted into the Application container
    /// at /etc/vm/configs/CONFIGMAP_NAME folder
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMaps")]
    pub config_maps: Option<Vec<String>>,
    /// Containers property allows to inject additions sidecars or to patch existing containers.
    /// It can be useful for proxies, backup, etc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub containers: Option<Vec<VLClusterVlstorageContainers>>,
    /// DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).
    /// Operator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.
    /// For example, vmagent and vm-config-reloader requires k8s API access.
    /// Operator creates volumes with name: "kube-api-access", which can be used as volumeMount for extraContainers if needed.
    /// And also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableAutomountServiceAccountToken")]
    pub disable_automount_service_account_token: Option<bool>,
    /// DisableSelfServiceScrape controls creation of VMServiceScrape by operator
    /// for the application.
    /// Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableSelfServiceScrape")]
    pub disable_self_service_scrape: Option<bool>,
    /// Specifies the DNS parameters of a pod.
    /// Parameters specified here will be merged to the generated DNS
    /// configuration based on DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<VLClusterVlstorageDnsConfig>,
    /// DNSPolicy sets DNS policy for the pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsPolicy")]
    pub dns_policy: Option<String>,
    /// ExtraArgs that will be passed to the application container
    /// for example remoteWrite.tmpDataPath: /tmp
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraArgs")]
    pub extra_args: Option<BTreeMap<String, String>>,
    /// ExtraEnvs that will be passed to the application container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvs")]
    pub extra_envs: Option<Vec<VLClusterVlstorageExtraEnvs>>,
    /// ExtraEnvsFrom defines source of env variables for the application container
    /// could either be secret or configmap
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvsFrom")]
    pub extra_envs_from: Option<Vec<VLClusterVlstorageExtraEnvsFrom>>,
    /// FutureRetention for the stored logs
    /// Log entries with timestamps bigger than now+futureRetention are rejected during data ingestion; see https://docs.victoriametrics.com/victorialogs/#retention
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "futureRetention")]
    pub future_retention: Option<String>,
    /// HostAliases provides mapping for ip and hostname,
    /// that would be propagated to pod,
    /// cannot be used with HostNetwork.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostAliases")]
    pub host_aliases: Option<Vec<VLClusterVlstorageHostAliases>>,
    /// HostNetwork controls whether the pod may use the node network namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// HostAliasesUnderScore provides mapping for ip and hostname,
    /// that would be propagated to pod,
    /// cannot be used with HostNetwork.
    /// Has Priority over hostAliases field
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "host_aliases")]
    pub host_aliases_x: Option<Vec<VLClusterVlstorageHostAliases>>,
    /// Image - docker image settings
    /// if no specified operator uses default version from operator config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<VLClusterVlstorageImage>,
    /// ImagePullSecrets An optional list of references to secrets in the same namespace
    /// to use for pulling images from registries
    /// see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecrets")]
    pub image_pull_secrets: Option<Vec<VLClusterVlstorageImagePullSecrets>>,
    /// InitContainers allows adding initContainers to the pod definition.
    /// Any errors during the execution of an initContainer will lead to a restart of the Pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<VLClusterVlstorageInitContainers>>,
    /// LivenessProbe that will be added CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// LogFormat for VLStorage to be configured with.
    /// default or json
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    pub log_format: Option<VLClusterVlstorageLogFormat>,
    /// Whether to log all the ingested log entries; this can be useful for debugging of data ingestion; see https://docs.victoriametrics.com/victorialogs/data-ingestion/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logIngestedRows")]
    pub log_ingested_rows: Option<bool>,
    /// LogLevel for VLStorage to be configured with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<VLClusterVlstorageLogLevel>,
    /// LogNewStreams Whether to log creation of new streams; this can be useful for debugging of high cardinality issues with log streams; see https://docs.victoriametrics.com/victorialogs/keyconcepts/#stream-fields
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logNewStreams")]
    pub log_new_streams: Option<bool>,
    /// MaintenanceInsertNodeIDs - excludes given node ids from insert requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.
    /// lets say, you have pod-0, pod-1, pod-2, pod-3. to exclude pod-0 and pod-3 from insert routing, define nodeIDs: [0,3].
    /// Useful at storage expanding, when you want to rebalance some data at cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceInsertNodeIDs")]
    pub maintenance_insert_node_i_ds: Option<Vec<i64>>,
    /// MaintenanceInsertNodeIDs - excludes given node ids from select requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceSelectNodeIDs")]
    pub maintenance_select_node_i_ds: Option<Vec<i64>>,
    /// MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
    /// if previous in healthy state
    /// Has no effect for VLogs and VMSingle
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// NodeSelector Define which Nodes the Pods are scheduled on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Paused If set to true all actions on the underlying managed objects are not
    /// going to be performed, except for delete actions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    /// PodDisruptionBudget created by operator
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podDisruptionBudget")]
    pub pod_disruption_budget: Option<VLClusterVlstoragePodDisruptionBudget>,
    /// PodMetadata configures Labels and Annotations which are propagated to the VLStorage pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podMetadata")]
    pub pod_metadata: Option<VLClusterVlstoragePodMetadata>,
    /// Port listen address
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// PriorityClassName class assigned to the Pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// ReadinessGates defines pod readiness gates
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<VLClusterVlstorageReadinessGates>>,
    /// ReadinessProbe that will be added CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// ReplicaCount is the expected size of the Application.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaCount")]
    pub replica_count: Option<i32>,
    /// Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    /// if not defined default resources from operator config will be used
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<VLClusterVlstorageResources>,
    /// RetentionMaxDiskSpaceUsageBytes for the stored logs
    /// VictoriaLogs keeps at least two last days of data in order to guarantee that the logs for the last day can be returned in queries.
    /// This means that the total disk space usage may exceed the -retention.maxDiskSpaceUsageBytes,
    /// if the size of the last two days of data exceeds the -retention.maxDiskSpaceUsageBytes.
    /// https://docs.victoriametrics.com/victorialogs/#retention-by-disk-space-usage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionMaxDiskSpaceUsageBytes")]
    pub retention_max_disk_space_usage_bytes: Option<String>,
    /// RetentionPeriod for the stored logs
    /// https://docs.victoriametrics.com/victorialogs/#retention
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retentionPeriod")]
    pub retention_period: Option<String>,
    /// The number of old ReplicaSets to retain to allow rollback in deployment or
    /// maximum number of revisions that will be maintained in the Deployment revision history.
    /// Has no effect at StatefulSets
    /// Defaults to 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "revisionHistoryLimitCount")]
    pub revision_history_limit_count: Option<i32>,
    /// RollingUpdateStrategy defines strategy for application updates
    /// Default is OnDelete, in this case operator handles update process
    /// Can be changed for RollingUpdate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdateStrategy")]
    pub rolling_update_strategy: Option<String>,
    /// RuntimeClassName - defines runtime class for kubernetes pod.
    /// https://kubernetes.io/docs/concepts/containers/runtime-class/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeClassName")]
    pub runtime_class_name: Option<String>,
    /// SchedulerName - defines kubernetes scheduler name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    /// Secrets is a list of Secrets in the same namespace as the Application
    /// object, which shall be mounted into the Application container
    /// at /etc/vm/secrets/SECRET_NAME folder
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
    /// SecurityContext holds pod-level security attributes and common container settings.
    /// This defaults to the default PodSecurityContext.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<BTreeMap<String, serde_json::Value>>,
    /// ServiceScrapeSpec that will be added to vlselect VMServiceScrape spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceScrapeSpec")]
    pub service_scrape_spec: Option<BTreeMap<String, serde_json::Value>>,
    /// ServiceSpec that will be added to vlselect service spec
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSpec")]
    pub service_spec: Option<VLClusterVlstorageServiceSpec>,
    /// StartupProbe that will be added to CRD pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<BTreeMap<String, serde_json::Value>>,
    /// Storage configures persistent volume for VLStorage
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<VLClusterVlstorageStorage>,
    /// StorageDataPath - path to storage data
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageDataPath")]
    pub storage_data_path: Option<String>,
    /// TerminationGracePeriodSeconds period for container graceful termination
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Tolerations If specified, the pod's tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<VLClusterVlstorageTolerations>>,
    /// TopologySpreadConstraints embedded kubernetes pod configuration option,
    /// controls how pods are spread across your cluster among failure-domains
    /// such as regions, zones, nodes, and other user-defined topology domains
    /// https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<VLClusterVlstorageTopologySpreadConstraints>>,
    /// UseDefaultResources controls resource settings
    /// By default, operator sets built-in resource requirements
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDefaultResources")]
    pub use_default_resources: Option<bool>,
    /// UseStrictSecurity enables strict security mode for component
    /// it restricts disk writes access
    /// uses non-root user out of the box
    /// drops not needed security permissions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useStrictSecurity")]
    pub use_strict_security: Option<bool>,
    /// VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
    /// VolumeMounts specified will be appended to other VolumeMounts in the Application container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<VLClusterVlstorageVolumeMounts>>,
    /// Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
    /// Volumes specified will be appended to other volumes that are generated.
    /// / +optional
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<VLClusterVlstorageVolumes>>,
}

/// Specifies the DNS parameters of a pod.
/// Parameters specified here will be merged to the generated DNS
/// configuration based on DNSPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageDnsConfig {
    /// A list of DNS name server IP addresses.
    /// This will be appended to the base nameservers generated from DNSPolicy.
    /// Duplicated nameservers will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nameservers: Option<Vec<String>>,
    /// A list of DNS resolver options.
    /// This will be merged with the base options generated from DNSPolicy.
    /// Duplicated entries will be removed. Resolution options given in Options
    /// will override those that appear in the base DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<VLClusterVlstorageDnsConfigOptions>>,
    /// A list of DNS search domains for host-name lookup.
    /// This will be appended to the base search paths generated from DNSPolicy.
    /// Duplicated search paths will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub searches: Option<Vec<String>>,
}

/// PodDNSConfigOption defines DNS resolver options of a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageDnsConfigOptions {
    /// Name is this DNS resolver option's name.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Value is this DNS resolver option's value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageExtraEnvs {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// EnvFromSource represents the source of a set of ConfigMaps
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageExtraEnvsFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<VLClusterVlstorageExtraEnvsFromConfigMapRef>,
    /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<VLClusterVlstorageExtraEnvsFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageExtraEnvsFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageExtraEnvsFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageHostAliases {
    /// Hostnames for the above IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// IP address of the host file entry.
    pub ip: String,
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageHostAliases {
    /// Hostnames for the above IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// IP address of the host file entry.
    pub ip: String,
}

/// Image - docker image settings
/// if no specified operator uses default version from operator config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageImage {
    /// PullPolicy describes how to pull docker image
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// Repository contains name of docker image + it's repository if needed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    /// Tag contains desired docker image version
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageImagePullSecrets {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// VLStorage defines vlstorage component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VLClusterVlstorageLogFormat {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "json")]
    Json,
}

/// VLStorage defines vlstorage component configuration at victoria-logs cluster
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VLClusterVlstorageLogLevel {
    #[serde(rename = "INFO")]
    Info,
    #[serde(rename = "WARN")]
    Warn,
    #[serde(rename = "ERROR")]
    Error,
    #[serde(rename = "FATAL")]
    Fatal,
    #[serde(rename = "PANIC")]
    Panic,
}

/// PodDisruptionBudget created by operator
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstoragePodDisruptionBudget {
    /// An eviction is allowed if at most "maxUnavailable" pods selected by
    /// "selector" are unavailable after the eviction, i.e. even in absence of
    /// the evicted pod. For example, one can prevent all voluntary evictions
    /// by specifying 0. This is a mutually exclusive setting with "minAvailable".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
    /// An eviction is allowed if at least "minAvailable" pods selected by
    /// "selector" will still be available after the eviction, i.e. even in the
    /// absence of the evicted pod.  So for example you can prevent all voluntary
    /// evictions by specifying "100%".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minAvailable")]
    pub min_available: Option<IntOrString>,
    /// replaces default labels selector generated by operator
    /// it's useful when you need to create custom budget
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selectorLabels")]
    pub selector_labels: Option<BTreeMap<String, String>>,
}

/// PodMetadata configures Labels and Annotations which are propagated to the VLStorage pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstoragePodMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name must be unique within a namespace. Is required when creating resources, although
    /// some resources may allow a client to request the generation of an appropriate name
    /// automatically. Name is primarily intended for creation idempotence and configuration
    /// definition.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// PodReadinessGate contains the reference to a pod condition
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageReadinessGates {
    /// ConditionType refers to a condition in the pod's condition list with matching type.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
}

/// Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
/// if not defined default resources from operator config will be used
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<VLClusterVlstorageResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// ServiceSpec that will be added to vlselect service spec
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageServiceSpec {
    /// EmbeddedObjectMetadata defines objectMeta for additional service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<VLClusterVlstorageServiceSpecMetadata>,
    /// ServiceSpec describes the attributes that a user creates on a service.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/
    pub spec: BTreeMap<String, serde_json::Value>,
    /// UseAsDefault applies changes from given service definition to the main object Service
    /// Changing from headless service to clusterIP or loadbalancer may break cross-component communication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useAsDefault")]
    pub use_as_default: Option<bool>,
}

/// EmbeddedObjectMetadata defines objectMeta for additional service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageServiceSpecMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Labels Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name must be unique within a namespace. Is required when creating resources, although
    /// some resources may allow a client to request the generation of an appropriate name
    /// automatically. Name is primarily intended for creation idempotence and configuration
    /// definition.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Storage configures persistent volume for VLStorage
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageStorage {
    /// Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
    /// DisableMountSubPath allows to remove any subPath usage in volume mounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableMountSubPath")]
    pub disable_mount_sub_path: Option<bool>,
    /// EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
    /// info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<VLClusterVlstorageStorageEmptyDir>,
    /// A PVC spec to be used by the VMAlertManager StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<BTreeMap<String, serde_json::Value>>,
}

/// EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
/// info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageStorageEmptyDir {
    /// medium represents what type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterVlstorageVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// VLClusterStatus defines the observed state of VLCluster
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VLClusterStatus {
    /// Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration defines current generation picked by operator for the
    /// reconcile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// Reason defines human readable error reason
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// UpdateStatus defines a status for update rollout
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStatus")]
    pub update_status: Option<String>,
}

