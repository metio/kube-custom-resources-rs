// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/prometheus-operator/prometheus-operator/monitoring.coreos.com/v1alpha1/scrapeconfigs.yaml
// kopium version: 0.22.4

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// spec defines the specification of ScrapeConfigSpec.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "monitoring.coreos.com", version = "v1alpha1", kind = "ScrapeConfig", plural = "scrapeconfigs")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ScrapeConfigSpec {
    /// authorization defines the header to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigAuthorization>,
    /// azureSDConfigs defines a list of Azure service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureSDConfigs")]
    pub azure_sd_configs: Option<Vec<ScrapeConfigAzureSdConfigs>>,
    /// basicAuth defines information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigBasicAuth>,
    /// consulSDConfigs defines a list of Consul service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consulSDConfigs")]
    pub consul_sd_configs: Option<Vec<ScrapeConfigConsulSdConfigs>>,
    /// convertClassicHistogramsToNHCB defines whether to convert all scraped classic histograms into a native histogram with custom buckets.
    /// It requires Prometheus >= v3.0.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "convertClassicHistogramsToNHCB")]
    pub convert_classic_histograms_to_nhcb: Option<bool>,
    /// digitalOceanSDConfigs defines a list of DigitalOcean service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "digitalOceanSDConfigs")]
    pub digital_ocean_sd_configs: Option<Vec<ScrapeConfigDigitalOceanSdConfigs>>,
    /// dnsSDConfigs defines a list of DNS service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsSDConfigs")]
    pub dns_sd_configs: Option<Vec<ScrapeConfigDnsSdConfigs>>,
    /// dockerSDConfigs defines a list of Docker service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerSDConfigs")]
    pub docker_sd_configs: Option<Vec<ScrapeConfigDockerSdConfigs>>,
    /// dockerSwarmSDConfigs defines a list of Dockerswarm service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerSwarmSDConfigs")]
    pub docker_swarm_sd_configs: Option<Vec<ScrapeConfigDockerSwarmSdConfigs>>,
    /// ec2SDConfigs defines a list of EC2 service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ec2SDConfigs")]
    pub ec2_sd_configs: Option<Vec<ScrapeConfigEc2SdConfigs>>,
    /// enableCompression when false, Prometheus will request uncompressed response from the scraped target.
    /// 
    /// It requires Prometheus >= v2.49.0.
    /// 
    /// If unset, Prometheus uses true by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableCompression")]
    pub enable_compression: Option<bool>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// eurekaSDConfigs defines a list of Eureka service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eurekaSDConfigs")]
    pub eureka_sd_configs: Option<Vec<ScrapeConfigEurekaSdConfigs>>,
    /// fallbackScrapeProtocol defines the protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.
    /// 
    /// It requires Prometheus >= v3.0.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fallbackScrapeProtocol")]
    pub fallback_scrape_protocol: Option<ScrapeConfigFallbackScrapeProtocol>,
    /// fileSDConfigs defines a list of file service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fileSDConfigs")]
    pub file_sd_configs: Option<Vec<ScrapeConfigFileSdConfigs>>,
    /// gceSDConfigs defines a list of GCE service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gceSDConfigs")]
    pub gce_sd_configs: Option<Vec<ScrapeConfigGceSdConfigs>>,
    /// hetznerSDConfigs defines a list of Hetzner service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hetznerSDConfigs")]
    pub hetzner_sd_configs: Option<Vec<ScrapeConfigHetznerSdConfigs>>,
    /// honorLabels defines when true the metric's labels when they collide
    /// with the target's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorLabels")]
    pub honor_labels: Option<bool>,
    /// honorTimestamps defines whether Prometheus preserves the timestamps
    /// when exposed by the target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorTimestamps")]
    pub honor_timestamps: Option<bool>,
    /// httpSDConfigs defines a list of HTTP service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpSDConfigs")]
    pub http_sd_configs: Option<Vec<ScrapeConfigHttpSdConfigs>>,
    /// ionosSDConfigs defines a list of IONOS service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ionosSDConfigs")]
    pub ionos_sd_configs: Option<Vec<ScrapeConfigIonosSdConfigs>>,
    /// jobName defines the value of the `job` label assigned to the scraped metrics by default.
    /// 
    /// The `job_name` field in the rendered scrape configuration is always controlled by the
    /// operator to prevent duplicate job names, which Prometheus does not allow. Instead the
    /// `job` label is set by means of relabeling configs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobName")]
    pub job_name: Option<String>,
    /// keepDroppedTargets defines the per-scrape limit on the number of targets dropped by relabeling
    /// that will be kept in memory. 0 means no limit.
    /// 
    /// It requires Prometheus >= v2.47.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepDroppedTargets")]
    pub keep_dropped_targets: Option<i64>,
    /// kubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSDConfigs")]
    pub kubernetes_sd_configs: Option<Vec<ScrapeConfigKubernetesSdConfigs>>,
    /// kumaSDConfigs defines a list of Kuma service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kumaSDConfigs")]
    pub kuma_sd_configs: Option<Vec<ScrapeConfigKumaSdConfigs>>,
    /// labelLimit defines the per-scrape limit on number of labels that will be accepted for a sample.
    /// Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelLimit")]
    pub label_limit: Option<i64>,
    /// labelNameLengthLimit defines the per-scrape limit on length of labels name that will be accepted for a sample.
    /// Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelNameLengthLimit")]
    pub label_name_length_limit: Option<i64>,
    /// labelValueLengthLimit defines the per-scrape limit on length of labels value that will be accepted for a sample.
    /// Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelValueLengthLimit")]
    pub label_value_length_limit: Option<i64>,
    /// lightSailSDConfigs defines a list of Lightsail service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lightSailSDConfigs")]
    pub light_sail_sd_configs: Option<Vec<ScrapeConfigLightSailSdConfigs>>,
    /// linodeSDConfigs defines a list of Linode service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linodeSDConfigs")]
    pub linode_sd_configs: Option<Vec<ScrapeConfigLinodeSdConfigs>>,
    /// metricRelabelings defines the metricRelabelings to apply to samples before ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelings")]
    pub metric_relabelings: Option<Vec<ScrapeConfigMetricRelabelings>>,
    /// metricsPath defines the HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g. /metrics).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricsPath")]
    pub metrics_path: Option<String>,
    /// nameEscapingScheme defines the metric name escaping mode to request through content negotiation.
    /// 
    /// It requires Prometheus >= v3.4.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameEscapingScheme")]
    pub name_escaping_scheme: Option<ScrapeConfigNameEscapingScheme>,
    /// nameValidationScheme defines the validation scheme for metric and label names.
    /// 
    /// It requires Prometheus >= v3.0.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameValidationScheme")]
    pub name_validation_scheme: Option<ScrapeConfigNameValidationScheme>,
    /// nativeHistogramBucketLimit defines ff there are more than this many buckets in a native histogram,
    /// buckets will be merged to stay within the limit.
    /// It requires Prometheus >= v2.45.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nativeHistogramBucketLimit")]
    pub native_histogram_bucket_limit: Option<i64>,
    /// nativeHistogramMinBucketFactor defines if the growth factor of one bucket to the next is smaller than this,
    /// buckets will be merged to increase the factor sufficiently.
    /// It requires Prometheus >= v2.50.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nativeHistogramMinBucketFactor")]
    pub native_histogram_min_bucket_factor: Option<IntOrString>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// nomadSDConfigs defines a list of Nomad service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nomadSDConfigs")]
    pub nomad_sd_configs: Option<Vec<ScrapeConfigNomadSdConfigs>>,
    /// oauth2 defines the configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigOauth2>,
    /// openstackSDConfigs defines a list of OpenStack service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openstackSDConfigs")]
    pub openstack_sd_configs: Option<Vec<ScrapeConfigOpenstackSdConfigs>>,
    /// ovhcloudSDConfigs defines a list of OVHcloud service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ovhcloudSDConfigs")]
    pub ovhcloud_sd_configs: Option<Vec<ScrapeConfigOvhcloudSdConfigs>>,
    /// params defines optional HTTP URL parameters
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, Vec<String>>>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// puppetDBSDConfigs defines a list of PuppetDB service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "puppetDBSDConfigs")]
    pub puppet_dbsd_configs: Option<Vec<ScrapeConfigPuppetDbsdConfigs>>,
    /// relabelings defines how to rewrite the target's labels before scraping.
    /// Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields.
    /// The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
    /// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relabelings: Option<Vec<ScrapeConfigRelabelings>>,
    /// sampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// scalewaySDConfigs defines a list of Scaleway instances and baremetal service discovery configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scalewaySDConfigs")]
    pub scaleway_sd_configs: Option<Vec<ScrapeConfigScalewaySdConfigs>>,
    /// scheme defines the protocol scheme used for requests.
    /// If empty, Prometheus uses HTTP by default.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ScrapeConfigScheme>,
    /// scrapeClass defines the scrape class to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeClass")]
    pub scrape_class: Option<String>,
    /// scrapeClassicHistograms defines whether to scrape a classic histogram that is also exposed as a native histogram.
    /// It requires Prometheus >= v2.45.0.
    /// 
    /// Notice: `scrapeClassicHistograms` corresponds to the `always_scrape_classic_histograms` field in the Prometheus configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeClassicHistograms")]
    pub scrape_classic_histograms: Option<bool>,
    /// scrapeInterval defines the interval between consecutive scrapes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeInterval")]
    pub scrape_interval: Option<String>,
    /// scrapeProtocols defines the protocols to negotiate during a scrape. It tells clients the
    /// protocols supported by Prometheus in order of preference (from most to least preferred).
    /// 
    /// If unset, Prometheus uses its default value.
    /// 
    /// It requires Prometheus >= v2.49.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeProtocols")]
    pub scrape_protocols: Option<Vec<String>>,
    /// scrapeTimeout defines the number of seconds to wait until a scrape request times out.
    /// The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// staticConfigs defines a list of static targets with a common label set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "staticConfigs")]
    pub static_configs: Option<Vec<ScrapeConfigStaticConfigs>>,
    /// targetLimit defines a limit on the number of scraped targets that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLimit")]
    pub target_limit: Option<i64>,
    /// tlsConfig defines the TLS configuration to use on every scrape request
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigTlsConfig>,
    /// trackTimestampsStaleness defines whether Prometheus tracks staleness of
    /// the metrics that have an explicit timestamp present in scraped data.
    /// Has no effect if `honorTimestamps` is false.
    /// It requires Prometheus >= v2.48.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trackTimestampsStaleness")]
    pub track_timestamps_staleness: Option<bool>,
}

/// authorization defines the header to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// AzureSDConfig allow retrieving scrape targets from Azure VMs.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#azure_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigs {
    /// authenticationMethod defines the authentication method, either `OAuth` or `ManagedIdentity` or `SDK`.
    /// See <https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview>
    /// SDK authentication method uses environment variables by default.
    /// See <https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authenticationMethod")]
    pub authentication_method: Option<ScrapeConfigAzureSdConfigsAuthenticationMethod>,
    /// authorization defines the authorization header configuration to authenticate against the target HTTP endpoint.
    /// Cannot be set at the same time as `oAuth2`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigAzureSdConfigsAuthorization>,
    /// basicAuth defines the information to authenticate against the target HTTP endpoint.
    /// More info: <https://prometheus.io/docs/operating/configuration/#endpoints>
    /// Cannot be set at the same time as `authorization`, or `oAuth2`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigAzureSdConfigsBasicAuth>,
    /// clientID defines client ID. Only required with the OAuth authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    /// clientSecret defines client secret. Only required with the OAuth authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientSecret")]
    pub client_secret: Option<ScrapeConfigAzureSdConfigsClientSecret>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// environment defines the Azure environment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub environment: Option<String>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigAzureSdConfigsOauth2>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    /// instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigAzureSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// resourceGroup defines resource group name. Limits discovery to this resource group.
    /// Requires  Prometheus v2.35.0 and above
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceGroup")]
    pub resource_group: Option<String>,
    /// subscriptionID defines subscription ID. Always required.
    #[serde(rename = "subscriptionID")]
    pub subscription_id: String,
    /// tenantID defines tenant ID. Only required with the OAuth authentication method.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tenantID")]
    pub tenant_id: Option<String>,
    /// tlsConfig defies the TLS configuration applying to the target HTTP endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigAzureSdConfigsTlsConfig>,
}

/// AzureSDConfig allow retrieving scrape targets from Azure VMs.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#azure_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigAzureSdConfigsAuthenticationMethod {
    OAuth,
    ManagedIdentity,
    #[serde(rename = "SDK")]
    Sdk,
}

/// authorization defines the authorization header configuration to authenticate against the target HTTP endpoint.
/// Cannot be set at the same time as `oAuth2`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigAzureSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the information to authenticate against the target HTTP endpoint.
/// More info: <https://prometheus.io/docs/operating/configuration/#endpoints>
/// Cannot be set at the same time as `authorization`, or `oAuth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigAzureSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigAzureSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines client secret. Only required with the OAuth authentication method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigAzureSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigAzureSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigAzureSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigAzureSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigAzureSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigAzureSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigAzureSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigAzureSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defies the TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigAzureSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigAzureSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigAzureSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigAzureSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigAzureSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigAzureSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigAzureSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigAzureSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigAzureSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigAzureSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defies the TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigAzureSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defies the TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigAzureSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// basicAuth defines information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConsulSDConfig defines a Consul service discovery configuration
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigs {
    /// allowStale Consul results (see <https://www.consul.io/api/features/consistency.html).> Will reduce load on Consul.
    /// If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStale")]
    pub allow_stale: Option<bool>,
    /// authorization defines the header configuration to authenticate against the Consul Server.
    /// Cannot be set at the same time as `basicAuth`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigConsulSdConfigsAuthorization>,
    /// basicAuth defines the information to authenticate against the Consul Server.
    /// More info: <https://prometheus.io/docs/operating/configuration/#endpoints>
    /// Cannot be set at the same time as `authorization`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigConsulSdConfigsBasicAuth>,
    /// datacenter defines the consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datacenter: Option<String>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// filter defines the filter expression used to filter the catalog results.
    /// See <https://www.consul.io/api-docs/catalog#list-services>
    /// It requires Prometheus >= 3.0.0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// namespace are only supported in Consul Enterprise.
    /// 
    /// It requires Prometheus >= 2.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// nodeMeta defines the node metadata key/value pairs to filter nodes for a given service.
    /// Starting with Consul 1.14, it is recommended to use `filter` with the `NodeMeta` selector instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeMeta")]
    pub node_meta: Option<BTreeMap<String, String>>,
    /// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
    /// Cannot be set at the same time as `authorization`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigConsulSdConfigsOauth2>,
    /// partition defines the admin Partitions are only supported in Consul Enterprise.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// pathPrefix defines the prefix for URIs for when consul is behind an API gateway (reverse proxy).
    /// 
    /// It requires Prometheus >= 2.45.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathPrefix")]
    pub path_prefix: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigConsulSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// scheme defines the HTTP Scheme default "http"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ScrapeConfigConsulSdConfigsScheme>,
    /// server defines the consul server address. A valid string consisting of a hostname or IP followed by an optional port number.
    pub server: String,
    /// services defines a list of services for which targets are retrieved. If omitted, all services are scraped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<String>>,
    /// tagSeparator defines the string by which Consul tags are joined into the tag label.
    /// If unset, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSeparator")]
    pub tag_separator: Option<String>,
    /// tags defines an optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.
    /// Starting with Consul 1.14, it is recommended to use `filter` with the `ServiceTags` selector instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigConsulSdConfigsTlsConfig>,
    /// tokenRef defines the consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenRef")]
    pub token_ref: Option<ScrapeConfigConsulSdConfigsTokenRef>,
}

/// authorization defines the header configuration to authenticate against the Consul Server.
/// Cannot be set at the same time as `basicAuth`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigConsulSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the information to authenticate against the Consul Server.
/// More info: <https://prometheus.io/docs/operating/configuration/#endpoints>
/// Cannot be set at the same time as `authorization`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigConsulSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigConsulSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
/// Cannot be set at the same time as `authorization`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigConsulSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigConsulSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigConsulSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigConsulSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigConsulSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ConsulSDConfig defines a Consul service discovery configuration
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigConsulSdConfigsScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigConsulSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigConsulSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigConsulSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigConsulSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigConsulSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigConsulSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigConsulSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigConsulSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigConsulSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tokenRef defines the consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigConsulSdConfigsTokenRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// DigitalOceanSDConfig allow retrieving scrape targets from DigitalOcean's Droplets API.
/// This service discovery uses the public IPv4 address by default, by that can be changed with relabeling
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#digitalocean_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigs {
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigDigitalOceanSdConfigsAuthorization>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigDigitalOceanSdConfigsOauth2>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigDigitalOceanSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfig>,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigDigitalOceanSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigDigitalOceanSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigDigitalOceanSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigDigitalOceanSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDigitalOceanSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDigitalOceanSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDigitalOceanSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDigitalOceanSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDigitalOceanSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDigitalOceanSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDigitalOceanSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets.
/// The DNS servers to be contacted are read from /etc/resolv.conf.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDnsSdConfigs {
    /// names defines a list of DNS domain names to be queried.
    pub names: Vec<String>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    /// Ignored for SRV records
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// type defines the type of DNS query to perform. One of SRV, A, AAAA, MX or NS.
    /// If not set, Prometheus uses its default value.
    /// 
    /// When set to NS, it requires Prometheus >= v2.49.0.
    /// When set to MX, it requires Prometheus >= v2.38.0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ScrapeConfigDnsSdConfigsType>,
}

/// DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets.
/// The DNS servers to be contacted are read from /etc/resolv.conf.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDnsSdConfigsType {
    A,
    #[serde(rename = "AAAA")]
    Aaaa,
    #[serde(rename = "MX")]
    Mx,
    #[serde(rename = "NS")]
    Ns,
    #[serde(rename = "SRV")]
    Srv,
}

/// Docker SD configurations allow retrieving scrape targets from Docker Engine hosts.
/// This SD discovers "containers" and will create a target for each network IP and
/// port the container is configured to expose.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#docker_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigs {
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigDockerSdConfigsAuthorization>,
    /// basicAuth defines information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigDockerSdConfigsBasicAuth>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// filters defines filters to limit the discovery process to a subset of the available resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filters: Option<Vec<ScrapeConfigDockerSdConfigsFilters>>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// host defines the address of the docker daemon
    pub host: String,
    /// hostNetworkingHost defines the host to use if the container is in host networking mode.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetworkingHost")]
    pub host_networking_host: Option<String>,
    /// matchFirstNetwork defines whether to match the first network if the container has multiple networks defined.
    /// If unset, Prometheus uses true by default.
    /// It requires Prometheus >= v2.54.1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFirstNetwork")]
    pub match_first_network: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigDockerSdConfigsOauth2>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigDockerSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigDockerSdConfigsTlsConfig>,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigDockerSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigDockerSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigDockerSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Filter name and value pairs to limit the discovery process to a subset of available resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsFilters {
    /// name of the Filter.
    pub name: String,
    /// values defines values to filter on.
    pub values: Vec<String>,
}

/// oauth2 defines the configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigDockerSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigDockerSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigDockerSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDockerSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDockerSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigDockerSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigDockerSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigDockerSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigDockerSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigDockerSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDockerSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDockerSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// DockerSwarmSDConfig configurations allow retrieving scrape targets from Docker Swarm engine.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dockerswarm_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigs {
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigDockerSwarmSdConfigsAuthorization>,
    /// basicAuth defines information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigDockerSwarmSdConfigsBasicAuth>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// filters defines the filters to limit the discovery process to a subset of available
    /// resources.
    /// The available filters are listed in the upstream documentation:
    /// Services: <https://docs.docker.com/engine/api/v1.40/#operation/ServiceList>
    /// Tasks: <https://docs.docker.com/engine/api/v1.40/#operation/TaskList>
    /// Nodes: <https://docs.docker.com/engine/api/v1.40/#operation/NodeList>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filters: Option<Vec<ScrapeConfigDockerSwarmSdConfigsFilters>>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// host defines the address of the Docker daemon
    pub host: String,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
    /// Cannot be set at the same time as `authorization`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigDockerSwarmSdConfigsOauth2>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    /// tasks and services that don't have published ports.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigDockerSwarmSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// role of the targets to retrieve. Must be `Services`, `Tasks`, or `Nodes`.
    pub role: ScrapeConfigDockerSwarmSdConfigsRole,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfig>,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigDockerSwarmSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigDockerSwarmSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigDockerSwarmSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Filter name and value pairs to limit the discovery process to a subset of available resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsFilters {
    /// name of the Filter.
    pub name: String,
    /// values defines values to filter on.
    pub values: Vec<String>,
}

/// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
/// Cannot be set at the same time as `authorization`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigDockerSwarmSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigDockerSwarmSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigDockerSwarmSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSwarmSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSwarmSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDockerSwarmSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// DockerSwarmSDConfig configurations allow retrieving scrape targets from Docker Swarm engine.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dockerswarm_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDockerSwarmSdConfigsRole {
    Services,
    Tasks,
    Nodes,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigDockerSwarmSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigDockerSwarmSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDockerSwarmSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigDockerSwarmSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// EC2SDConfig allow retrieving scrape targets from AWS EC2 instances.
/// The private IP address is used by default, but may be changed to the public IP address with relabeling.
/// The IAM credentials used must have the ec2:DescribeInstances permission to discover scrape targets
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ec2_sd_config>
/// 
/// The EC2 service discovery requires AWS API keys or role ARN for authentication.
/// BasicAuth, Authorization and OAuth2 fields are not present on purpose.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigs {
    /// accessKey defines the AWS API key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessKey")]
    pub access_key: Option<ScrapeConfigEc2SdConfigsAccessKey>,
    /// enableHTTP2 defines whether to enable HTTP2.
    /// It requires Prometheus >= v2.41.0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// filters can be used optionally to filter the instance list by other criteria.
    /// Available filter criteria can be found here:
    /// <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html>
    /// Filter API documentation: <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html>
    /// It requires Prometheus >= v2.3.0
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filters: Option<Vec<ScrapeConfigEc2SdConfigsFilters>>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    /// It requires Prometheus >= v2.41.0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    /// instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigEc2SdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// region defines the AWS region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// roleARN defines an alternative to using AWS API keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleARN")]
    pub role_arn: Option<String>,
    /// secretKey defines the AWS API secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKey")]
    pub secret_key: Option<ScrapeConfigEc2SdConfigsSecretKey>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    /// It requires Prometheus >= v2.41.0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigEc2SdConfigsTlsConfig>,
}

/// accessKey defines the AWS API key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsAccessKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Filter name and value pairs to limit the discovery process to a subset of available resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsFilters {
    /// name of the Filter.
    pub name: String,
    /// values defines values to filter on.
    pub values: Vec<String>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secretKey defines the AWS API secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsSecretKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
/// It requires Prometheus >= v2.41.0
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigEc2SdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigEc2SdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigEc2SdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigEc2SdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigEc2SdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigEc2SdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigEc2SdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigEc2SdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigEc2SdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEc2SdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
/// It requires Prometheus >= v2.41.0
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigEc2SdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
/// It requires Prometheus >= v2.41.0
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigEc2SdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// Eureka SD configurations allow retrieving scrape targets using the Eureka REST API.
/// Prometheus will periodically check the REST endpoint and create a target for every app instance.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#eureka_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigs {
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigEurekaSdConfigsAuthorization>,
    /// basicAuth defines the BasicAuth information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigEurekaSdConfigsBasicAuth>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigEurekaSdConfigsOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigEurekaSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// server defines the URL to connect to the Eureka server.
    pub server: String,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigEurekaSdConfigsTlsConfig>,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigEurekaSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the BasicAuth information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigEurekaSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigEurekaSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigEurekaSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigEurekaSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigEurekaSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigEurekaSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigEurekaSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigEurekaSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigEurekaSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigEurekaSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigEurekaSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigEurekaSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigEurekaSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigEurekaSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigEurekaSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigEurekaSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigEurekaSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigEurekaSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigEurekaSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigEurekaSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigEurekaSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigEurekaSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// spec defines the specification of ScrapeConfigSpec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigFallbackScrapeProtocol {
    PrometheusProto,
    #[serde(rename = "OpenMetricsText0.0.1")]
    OpenMetricsText001,
    #[serde(rename = "OpenMetricsText1.0.0")]
    OpenMetricsText100,
    #[serde(rename = "PrometheusText0.0.4")]
    PrometheusText004,
    #[serde(rename = "PrometheusText1.0.0")]
    PrometheusText100,
}

/// FileSDConfig defines a Prometheus file service discovery configuration
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigFileSdConfigs {
    /// files defines the list of files to be used for file discovery. Recommendation: use absolute paths. While relative paths work, the
    /// prometheus-operator project makes no guarantees about the working directory where the configuration file is
    /// stored.
    /// Files must be mounted using Prometheus.ConfigMaps or Prometheus.Secrets.
    pub files: Vec<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
}

/// GCESDConfig configures scrape targets from GCP GCE instances.
/// The private IP address is used by default, but may be changed to
/// the public IP address with relabeling.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#gce_sd_config>
/// 
/// The GCE service discovery will load the Google Cloud credentials
/// from the file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.
/// See <https://cloud.google.com/kubernetes-engine/docs/tutorials/authenticating-to-cloud-platform>
/// 
/// A pre-requisite for using GCESDConfig is that a Secret containing valid
/// Google Cloud credentials is mounted into the Prometheus or PrometheusAgent
/// pod via the `.spec.secrets` field and that the GOOGLE_APPLICATION_CREDENTIALS
/// environment variable is set to /etc/prometheus/secrets/<secret-name>/<credentials-filename.json>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigGceSdConfigs {
    /// filter defines the filter that can be used optionally to filter the instance list by other criteria
    /// Syntax of this filter is described in the filter query parameter section:
    /// <https://cloud.google.com/compute/docs/reference/latest/instances/list>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<String>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    /// instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// project defines the Google Cloud Project ID
    pub project: String,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// tagSeparator defines the tag separator is used to separate the tags on concatenation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSeparator")]
    pub tag_separator: Option<String>,
    /// zone defines the zone of the scrape targets. If you need multiple zones use multiple GCESDConfigs.
    pub zone: String,
}

/// HetznerSDConfig allow retrieving scrape targets from Hetzner Cloud API and Robot API.
/// This service discovery uses the public IPv4 address by default, but that can be changed with relabeling
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#hetzner_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigs {
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigHetznerSdConfigsAuthorization>,
    /// basicAuth defines information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigHetznerSdConfigsBasicAuth>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// labelSelector defines the label selector used to filter the servers when fetching them from the API.
    /// It requires Prometheus >= v3.5.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<String>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigHetznerSdConfigsOauth2>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigHetznerSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// role defines the Hetzner role of entities that should be discovered.
    pub role: ScrapeConfigHetznerSdConfigsRole,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigHetznerSdConfigsTlsConfig>,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigHetznerSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigHetznerSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigHetznerSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigHetznerSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigHetznerSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigHetznerSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHetznerSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHetznerSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHetznerSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigHetznerSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigHetznerSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// HetznerSDConfig allow retrieving scrape targets from Hetzner Cloud API and Robot API.
/// This service discovery uses the public IPv4 address by default, but that can be changed with relabeling
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#hetzner_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigHetznerSdConfigsRole {
    #[serde(rename = "hcloud")]
    Hcloud,
    #[serde(rename = "Hcloud")]
    HcloudX,
    #[serde(rename = "robot")]
    Robot,
    #[serde(rename = "Robot")]
    RobotX,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigHetznerSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigHetznerSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigHetznerSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigHetznerSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigHetznerSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHetznerSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHetznerSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHetznerSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHetznerSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHetznerSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigHetznerSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigHetznerSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// HTTPSDConfig defines a prometheus HTTP service discovery configuration
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#http_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigs {
    /// authorization defines the authorization header configuration to authenticate against the target HTTP endpoint.
    /// Cannot be set at the same time as `oAuth2`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigHttpSdConfigsAuthorization>,
    /// basicAuth defines information to use on every scrape request.
    /// More info: <https://prometheus.io/docs/operating/configuration/#endpoints>
    /// Cannot be set at the same time as `authorization`, or `oAuth2`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigHttpSdConfigsBasicAuth>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
    /// Cannot be set at the same time as `authorization`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigHttpSdConfigsOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigHttpSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// tlsConfig defines the TLS configuration applying to the target HTTP endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigHttpSdConfigsTlsConfig>,
    /// url defines the URL from which the targets are fetched.
    pub url: String,
}

/// authorization defines the authorization header configuration to authenticate against the target HTTP endpoint.
/// Cannot be set at the same time as `oAuth2`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigHttpSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines information to use on every scrape request.
/// More info: <https://prometheus.io/docs/operating/configuration/#endpoints>
/// Cannot be set at the same time as `authorization`, or `oAuth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigHttpSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigHttpSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
/// Cannot be set at the same time as `authorization`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigHttpSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigHttpSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigHttpSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHttpSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHttpSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHttpSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigHttpSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigHttpSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigHttpSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigHttpSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigHttpSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigHttpSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigHttpSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHttpSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHttpSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigHttpSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigHttpSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigHttpSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigHttpSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigHttpSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// IonosSDConfig configurations allow retrieving scrape targets from IONOS resources.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ionos_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigs {
    /// authorization defines the  header configuration to authenticate against the IONOS.
    /// Cannot be set at the same time as `oauth2`.
    pub authorization: ScrapeConfigIonosSdConfigsAuthorization,
    /// datacenterID defines the unique ID of the IONOS data center.
    #[serde(rename = "datacenterID")]
    pub datacenter_id: String,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigIonosSdConfigsOauth2>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigIonosSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigIonosSdConfigsTlsConfig>,
}

/// authorization defines the  header configuration to authenticate against the IONOS.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigIonosSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigIonosSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigIonosSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigIonosSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigIonosSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigIonosSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigIonosSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigIonosSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigIonosSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigIonosSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigIonosSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigIonosSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigIonosSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigIonosSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigIonosSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigIonosSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigIonosSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigIonosSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigIonosSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigIonosSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigIonosSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigs {
    /// apiServer defines the API server address consisting of a hostname or IP address followed
    /// by an optional port number.
    /// If left empty, Prometheus is assumed to run inside
    /// of the cluster. It will discover API servers automatically and use the pod's
    /// CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServer")]
    pub api_server: Option<String>,
    /// attachMetadata defines the metadata to attach to discovered targets.
    /// It requires Prometheus >= v2.35.0 when using the `Pod` role and
    /// Prometheus >= v2.37.0 for `Endpoints` and `Endpointslice` roles.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachMetadata")]
    pub attach_metadata: Option<ScrapeConfigKubernetesSdConfigsAttachMetadata>,
    /// authorization defines the authorization header to use on every scrape request.
    /// Cannot be set at the same time as `basicAuth`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigKubernetesSdConfigsAuthorization>,
    /// basicAuth defines information to use on every scrape request.
    /// Cannot be set at the same time as `authorization`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigKubernetesSdConfigsBasicAuth>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// namespaces defines the namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<ScrapeConfigKubernetesSdConfigsNamespaces>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
    /// Cannot be set at the same time as `authorization`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigKubernetesSdConfigsOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigKubernetesSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// role defines the Kubernetes role of the entities that should be discovered.
    /// Role `Endpointslice` requires Prometheus >= v2.21.0
    pub role: ScrapeConfigKubernetesSdConfigsRole,
    /// selectors defines the selector to select objects.
    /// It requires Prometheus >= v2.17.0
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selectors: Option<Vec<ScrapeConfigKubernetesSdConfigsSelectors>>,
    /// tlsConfig defines the TLS configuration to connect to the Kubernetes API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigKubernetesSdConfigsTlsConfig>,
}

/// attachMetadata defines the metadata to attach to discovered targets.
/// It requires Prometheus >= v2.35.0 when using the `Pod` role and
/// Prometheus >= v2.37.0 for `Endpoints` and `Endpointslice` roles.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsAttachMetadata {
    /// node attaches node metadata to discovered targets.
    /// When set to true, Prometheus must have the `get` permission on the
    /// `Nodes` objects.
    /// Only valid for Pod, Endpoint and Endpointslice roles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<bool>,
}

/// authorization defines the authorization header to use on every scrape request.
/// Cannot be set at the same time as `basicAuth`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigKubernetesSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines information to use on every scrape request.
/// Cannot be set at the same time as `authorization`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigKubernetesSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigKubernetesSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// namespaces defines the namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsNamespaces {
    /// names defines a list of namespaces where to watch for resources.
    /// If empty and `ownNamespace` isn't true, Prometheus watches for resources in all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
    /// ownNamespace includes the namespace in which the Prometheus pod runs to the list of watched namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ownNamespace")]
    pub own_namespace: Option<bool>,
}

/// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
/// Cannot be set at the same time as `authorization`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigKubernetesSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigKubernetesSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigKubernetesSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKubernetesSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKubernetesSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsRole {
    Pod,
    Endpoints,
    Ingress,
    Service,
    Node,
    EndpointSlice,
}

/// K8SSelectorConfig is Kubernetes Selector Config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsSelectors {
    /// field defines an optional field selector to limit the service discovery to resources which have fields with specific values.
    /// e.g: `metadata.name=foobar`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<String>,
    /// label defines an optional label selector to limit the service discovery to resources with specific labels and label values.
    /// e.g: `node.kubernetes.io/instance-type=master`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// role defines the type of Kubernetes resource to limit the service discovery to.
    /// Accepted values are: Node, Pod, Endpoints, EndpointSlice, Service, Ingress.
    pub role: ScrapeConfigKubernetesSdConfigsSelectorsRole,
}

/// K8SSelectorConfig is Kubernetes Selector Config
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsSelectorsRole {
    Pod,
    Endpoints,
    Ingress,
    Service,
    Node,
    EndpointSlice,
}

/// tlsConfig defines the TLS configuration to connect to the Kubernetes API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigKubernetesSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigKubernetesSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigKubernetesSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKubernetesSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKubernetesSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Kubernetes API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Kubernetes API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKubernetesSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// KumaSDConfig allow retrieving scrape targets from Kuma's control plane.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kuma_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigs {
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigKumaSdConfigsAuthorization>,
    /// basicAuth defines information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigKumaSdConfigsBasicAuth>,
    /// clientID is used by Kuma Control Plane to compute Monitoring Assignment for specific Prometheus backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// fetchTimeout defines the time after which the monitoring assignments are refreshed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fetchTimeout")]
    pub fetch_timeout: Option<String>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigKumaSdConfigsOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigKumaSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// server defines the address of the Kuma Control Plane's MADS xDS server.
    pub server: String,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigKumaSdConfigsTlsConfig>,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigKumaSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigKumaSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigKumaSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigKumaSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigKumaSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigKumaSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKumaSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKumaSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKumaSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKumaSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKumaSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigKumaSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigKumaSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigKumaSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigKumaSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigKumaSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKumaSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKumaSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigKumaSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigKumaSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigKumaSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKumaSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigKumaSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// LightSailSDConfig configurations allow retrieving scrape targets from AWS Lightsail instances.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#lightsail_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigs {
    /// accessKey defines the AWS API key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessKey")]
    pub access_key: Option<ScrapeConfigLightSailSdConfigsAccessKey>,
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigLightSailSdConfigsAuthorization>,
    /// basicAuth defines information to use on every scrape request.
    /// Cannot be set at the same time as `authorization`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigLightSailSdConfigsBasicAuth>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// endpoint defines the custom endpoint to be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
    /// Cannot be set at the same time as `authorization`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigLightSailSdConfigsOauth2>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigLightSailSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// region defines the AWS region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// roleARN defines the AWS Role ARN, an alternative to using AWS API keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleARN")]
    pub role_arn: Option<String>,
    /// secretKey defines the AWS API secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKey")]
    pub secret_key: Option<ScrapeConfigLightSailSdConfigsSecretKey>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigLightSailSdConfigsTlsConfig>,
}

/// accessKey defines the AWS API key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsAccessKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigLightSailSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines information to use on every scrape request.
/// Cannot be set at the same time as `authorization`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigLightSailSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigLightSailSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
/// Cannot be set at the same time as `authorization`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigLightSailSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigLightSailSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigLightSailSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLightSailSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLightSailSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLightSailSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigLightSailSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigLightSailSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secretKey defines the AWS API secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsSecretKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigLightSailSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigLightSailSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigLightSailSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigLightSailSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigLightSailSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLightSailSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLightSailSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLightSailSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLightSailSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLightSailSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigLightSailSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigLightSailSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// LinodeSDConfig configurations allow retrieving scrape targets from Linode's Linode APIv4.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#linode_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigs {
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigLinodeSdConfigsAuthorization>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
    /// Cannot be set at the same time as `authorization`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigLinodeSdConfigsOauth2>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigLinodeSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// region defines the region to filter on.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// tagSeparator defines the string by which Linode Instance tags are joined into the tag label.el.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSeparator")]
    pub tag_separator: Option<String>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigLinodeSdConfigsTlsConfig>,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigLinodeSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
/// Cannot be set at the same time as `authorization`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigLinodeSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigLinodeSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigLinodeSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLinodeSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLinodeSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLinodeSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigLinodeSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigLinodeSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigLinodeSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigLinodeSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigLinodeSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigLinodeSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigLinodeSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLinodeSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLinodeSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigLinodeSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigLinodeSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigLinodeSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigLinodeSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigLinodeSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigMetricRelabelings {
    /// action to perform based on the regex matching.
    /// 
    /// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    /// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
    /// 
    /// Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<ScrapeConfigMetricRelabelingsAction>,
    /// modulus to take of the hash of the source label values.
    /// 
    /// Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// regex defines the regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// replacement value against which a Replace action is performed if the
    /// regular expression matches.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// separator defines the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// sourceLabels defines the source labels select values from existing labels. Their content is
    /// concatenated using the configured Separator and matched against the
    /// configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// targetLabel defines the label to which the resulting string is written in a replacement.
    /// 
    /// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    /// `KeepEqual` and `DropEqual` actions.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigMetricRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "Replace")]
    ReplaceX,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "Keep")]
    KeepX,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "Drop")]
    DropX,
    #[serde(rename = "hashmod")]
    Hashmod,
    HashMod,
    #[serde(rename = "labelmap")]
    Labelmap,
    LabelMap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    LabelDrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "Lowercase")]
    LowercaseX,
    #[serde(rename = "uppercase")]
    Uppercase,
    #[serde(rename = "Uppercase")]
    UppercaseX,
    #[serde(rename = "keepequal")]
    Keepequal,
    KeepEqual,
    #[serde(rename = "dropequal")]
    Dropequal,
    DropEqual,
}

/// spec defines the specification of ScrapeConfigSpec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigNameEscapingScheme {
    #[serde(rename = "AllowUTF8")]
    AllowUtf8,
    Underscores,
    Dots,
    Values,
}

/// spec defines the specification of ScrapeConfigSpec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigNameValidationScheme {
    #[serde(rename = "UTF8")]
    Utf8,
    Legacy,
}

/// NomadSDConfig configurations allow retrieving scrape targets from Nomad's Service API.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#nomad_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigs {
    /// allowStale defines the information to access the Nomad API. It is to be defined
    /// as the Nomad documentation requires.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowStale")]
    pub allow_stale: Option<bool>,
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigNomadSdConfigsAuthorization>,
    /// basicAuth defines information to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigNomadSdConfigsBasicAuth>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// namespace defines the Nomad namespace to query for service discovery.
    /// When specified, only resources within this namespace will be discovered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the configuration to use on every scrape request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigNomadSdConfigsOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigNomadSdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// region defines the Nomad region to query for service discovery.
    /// When specified, only resources within this region will be discovered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// server defines the Nomad server address to connect to for service discovery.
    /// This should be the full URL including protocol (e.g., "<https://nomad.example.com:4646").>
    pub server: String,
    /// tagSeparator defines the separator used to join multiple tags.
    /// This determines how Nomad service tags are concatenated into Prometheus labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagSeparator")]
    pub tag_separator: Option<String>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigNomadSdConfigsTlsConfig>,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigNomadSdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines information to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigNomadSdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigNomadSdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigNomadSdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigNomadSdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigNomadSdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigNomadSdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigNomadSdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigNomadSdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigNomadSdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigNomadSdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigNomadSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigNomadSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigNomadSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigNomadSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigNomadSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigNomadSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigNomadSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigNomadSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigNomadSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigNomadSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigNomadSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigNomadSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// oauth2 defines the configuration to use on every scrape request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#openstack_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigs {
    /// allTenants defines whether the service discovery should list all instances for all projects.
    /// It is only relevant for the 'instance' role and usually requires admin permissions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allTenants")]
    pub all_tenants: Option<bool>,
    /// applicationCredentialId defines the OpenStack applicationCredentialId.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationCredentialId")]
    pub application_credential_id: Option<String>,
    /// applicationCredentialName defines the ApplicationCredentialID or ApplicationCredentialName fields are
    /// required if using an application credential to authenticate. Some providers
    /// allow you to create an application credential to authenticate rather than a
    /// password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationCredentialName")]
    pub application_credential_name: Option<String>,
    /// applicationCredentialSecret defines the requiered field if using an application
    /// credential to authenticate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationCredentialSecret")]
    pub application_credential_secret: Option<ScrapeConfigOpenstackSdConfigsApplicationCredentialSecret>,
    /// availability defines the availability of the endpoint to connect to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub availability: Option<ScrapeConfigOpenstackSdConfigsAvailability>,
    /// domainID defines The OpenStack domainID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainID")]
    pub domain_id: Option<String>,
    /// domainName defines at most one of domainId and domainName that must be provided if using username
    /// with Identity V3. Otherwise, either are optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "domainName")]
    pub domain_name: Option<String>,
    /// identityEndpoint defines the HTTP endpoint that is required to work with
    /// the Identity API of the appropriate version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityEndpoint")]
    pub identity_endpoint: Option<String>,
    /// password defines the password for the Identity V2 and V3 APIs. Consult with your provider's
    /// control panel to discover your account's preferred method of authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigOpenstackSdConfigsPassword>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    /// instead be specified in the relabeling rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// projectID defines the OpenStack projectID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectID")]
    pub project_id: Option<String>,
    /// projectName defines an ptional field for the Identity V2 API.
    /// Some providers allow you to specify a ProjectName instead of the ProjectId.
    /// Some require both. Your provider's authentication policies will determine
    /// how these fields influence authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "projectName")]
    pub project_name: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// region defines the OpenStack Region.
    pub region: String,
    /// role defines the OpenStack role of entities that should be discovered.
    /// 
    /// Note: The `LoadBalancer` role requires Prometheus >= v3.2.0.
    pub role: ScrapeConfigOpenstackSdConfigsRole,
    /// tlsConfig defines the TLS configuration applying to the target HTTP endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigOpenstackSdConfigsTlsConfig>,
    /// userid defines the OpenStack userid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub userid: Option<String>,
    /// username defines the username required if using Identity V2 API. Consult with your provider's
    /// control panel to discover your account's username.
    /// In Identity V3, either userid or a combination of username
    /// and domainId or domainName are needed
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// applicationCredentialSecret defines the requiered field if using an application
/// credential to authenticate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsApplicationCredentialSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#openstack_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigOpenstackSdConfigsAvailability {
    Public,
    #[serde(rename = "public")]
    PublicX,
    Admin,
    #[serde(rename = "admin")]
    AdminX,
    Internal,
    #[serde(rename = "internal")]
    InternalX,
}

/// password defines the password for the Identity V2 and V3 APIs. Consult with your provider's
/// control panel to discover your account's preferred method of authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#openstack_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigOpenstackSdConfigsRole {
    Instance,
    Hypervisor,
    LoadBalancer,
}

/// tlsConfig defines the TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigOpenstackSdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigOpenstackSdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigOpenstackSdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigOpenstackSdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOpenstackSdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigOpenstackSdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration applying to the target HTTP endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigOpenstackSdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// OVHCloudSDConfig configurations allow retrieving scrape targets from OVHcloud's dedicated servers and VPS using their API.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ovhcloud_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigOvhcloudSdConfigs {
    /// applicationKey defines the access key to use for OVHCloud API authentication.
    /// This is obtained from the OVHCloud API credentials at <https://api.ovh.com.>
    #[serde(rename = "applicationKey")]
    pub application_key: String,
    /// applicationSecret defines the secret key for OVHCloud API authentication.
    /// This contains the application secret obtained during OVHCloud API credential creation.
    #[serde(rename = "applicationSecret")]
    pub application_secret: ScrapeConfigOvhcloudSdConfigsApplicationSecret,
    /// consumerKey defines the consumer key for OVHCloud API authentication.
    /// This is the third component of OVHCloud's three-key authentication system.
    #[serde(rename = "consumerKey")]
    pub consumer_key: ScrapeConfigOvhcloudSdConfigsConsumerKey,
    /// endpoint defines a custom API endpoint to be used.
    /// When not specified, defaults to the standard OVHCloud API endpoint for the region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// service defines the service type of the targets to retrieve.
    /// Must be either `VPS` or `DedicatedServer` to specify which OVHCloud resources to discover.
    pub service: ScrapeConfigOvhcloudSdConfigsService,
}

/// applicationSecret defines the secret key for OVHCloud API authentication.
/// This contains the application secret obtained during OVHCloud API credential creation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOvhcloudSdConfigsApplicationSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// consumerKey defines the consumer key for OVHCloud API authentication.
/// This is the third component of OVHCloud's three-key authentication system.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigOvhcloudSdConfigsConsumerKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OVHCloudSDConfig configurations allow retrieving scrape targets from OVHcloud's dedicated servers and VPS using their API.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ovhcloud_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigOvhcloudSdConfigsService {
    #[serde(rename = "VPS")]
    Vps,
    DedicatedServer,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// PuppetDBSDConfig configurations allow retrieving scrape targets from PuppetDB resources.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#puppetdb_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigs {
    /// authorization defines the  header configuration to authenticate against the DigitalOcean API.
    /// Cannot be set at the same time as `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ScrapeConfigPuppetDbsdConfigsAuthorization>,
    /// basicAuth defines information to use on every scrape request.
    /// Cannot be set at the same time as `authorization`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ScrapeConfigPuppetDbsdConfigsBasicAuth>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// includeParameters defines whether to include the parameters as meta labels.
    /// Note: Enabling this exposes parameters in the Prometheus UI and API. Make sure
    /// that you don't have secrets exposed as parameters if you enable this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "includeParameters")]
    pub include_parameters: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
    /// Cannot be set at the same time as `authorization`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ScrapeConfigPuppetDbsdConfigsOauth2>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigPuppetDbsdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// query defines the Puppet Query Language (PQL) query. Only resources are supported.
    /// <https://puppet.com/docs/puppetdb/latest/api/query/v4/pql.html>
    pub query: String,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigPuppetDbsdConfigsTlsConfig>,
    /// url defines the URL of the PuppetDB root query endpoint.
    pub url: String,
}

/// authorization defines the  header configuration to authenticate against the DigitalOcean API.
/// Cannot be set at the same time as `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ScrapeConfigPuppetDbsdConfigsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines information to use on every scrape request.
/// Cannot be set at the same time as `authorization`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ScrapeConfigPuppetDbsdConfigsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ScrapeConfigPuppetDbsdConfigsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
/// Cannot be set at the same time as `authorization`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: ScrapeConfigPuppetDbsdConfigsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: ScrapeConfigPuppetDbsdConfigsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigPuppetDbsdConfigsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigPuppetDbsdConfigsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigPuppetDbsdConfigsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigPuppetDbsdConfigsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigPuppetDbsdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigPuppetDbsdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigPuppetDbsdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigPuppetDbsdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigPuppetDbsdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigPuppetDbsdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigPuppetDbsdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigPuppetDbsdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigPuppetDbsdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigPuppetDbsdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigPuppetDbsdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigPuppetDbsdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigRelabelings {
    /// action to perform based on the regex matching.
    /// 
    /// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    /// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
    /// 
    /// Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<ScrapeConfigRelabelingsAction>,
    /// modulus to take of the hash of the source label values.
    /// 
    /// Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// regex defines the regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// replacement value against which a Replace action is performed if the
    /// regular expression matches.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// separator defines the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// sourceLabels defines the source labels select values from existing labels. Their content is
    /// concatenated using the configured Separator and matched against the
    /// configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// targetLabel defines the label to which the resulting string is written in a replacement.
    /// 
    /// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    /// `KeepEqual` and `DropEqual` actions.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "Replace")]
    ReplaceX,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "Keep")]
    KeepX,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "Drop")]
    DropX,
    #[serde(rename = "hashmod")]
    Hashmod,
    HashMod,
    #[serde(rename = "labelmap")]
    Labelmap,
    LabelMap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    LabelDrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "Lowercase")]
    LowercaseX,
    #[serde(rename = "uppercase")]
    Uppercase,
    #[serde(rename = "Uppercase")]
    UppercaseX,
    #[serde(rename = "keepequal")]
    Keepequal,
    KeepEqual,
    #[serde(rename = "dropequal")]
    Dropequal,
    DropEqual,
}

/// ScalewaySDConfig configurations allow retrieving scrape targets from Scaleway instances and baremetal services.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scaleway_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigs {
    /// accessKey defines the access key to use. <https://console.scaleway.com/project/credentials>
    #[serde(rename = "accessKey")]
    pub access_key: String,
    /// apiURL defines the API URL to use when doing the server listing requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<String>,
    /// enableHTTP2 defines whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHTTP2")]
    pub enable_http2: Option<bool>,
    /// followRedirects defines whether HTTP requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// nameFilter defines a name filter (works as a LIKE) to apply on the server listing request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nameFilter")]
    pub name_filter: Option<String>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// port defines the port to scrape metrics from. If using the public IP address, this must
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// projectID defines the Project ID of the targets.
    #[serde(rename = "projectID")]
    pub project_id: String,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<ScrapeConfigScalewaySdConfigsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// refreshInterval defines the time after which the provided names are refreshed.
    /// If not set, Prometheus uses its default value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// role defines the service of the targets to retrieve. Must be `Instance` or `Baremetal`.
    pub role: ScrapeConfigScalewaySdConfigsRole,
    /// secretKey defines the secret key to use when listing targets.
    #[serde(rename = "secretKey")]
    pub secret_key: ScrapeConfigScalewaySdConfigsSecretKey,
    /// tagsFilter defines a tag filter (a server needs to have all defined tags to be listed) to apply on the server listing request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagsFilter")]
    pub tags_filter: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to connect to the Consul API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ScrapeConfigScalewaySdConfigsTlsConfig>,
    /// zone defines the availability zone of your targets (e.g. fr-par-1).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<String>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ScalewaySDConfig configurations allow retrieving scrape targets from Scaleway instances and baremetal services.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scaleway_sd_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigScalewaySdConfigsRole {
    Instance,
    Baremetal,
}

/// secretKey defines the secret key to use when listing targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsSecretKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigScalewaySdConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigScalewaySdConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigScalewaySdConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigScalewaySdConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigScalewaySdConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigScalewaySdConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigScalewaySdConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigScalewaySdConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigScalewaySdConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigScalewaySdConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigScalewaySdConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to connect to the Consul API.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigScalewaySdConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// spec defines the specification of ScrapeConfigSpec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// StaticConfig defines a Prometheus static configuration.
/// See <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigStaticConfigs {
    /// labels defines labels assigned to all metrics scraped from the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// targets defines the list of targets for this static configuration.
    pub targets: Vec<String>,
}

/// tlsConfig defines the TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ScrapeConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ScrapeConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ScrapeConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<ScrapeConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<ScrapeConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ScrapeConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ScrapeConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ScrapeConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use on every scrape request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ScrapeConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

