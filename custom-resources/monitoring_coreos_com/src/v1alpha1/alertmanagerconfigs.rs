// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/prometheus-operator/prometheus-operator/monitoring.coreos.com/v1alpha1/alertmanagerconfigs.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// spec defines the specification of AlertmanagerConfigSpec
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "monitoring.coreos.com", version = "v1alpha1", kind = "AlertmanagerConfig", plural = "alertmanagerconfigs")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct AlertmanagerConfigSpec {
    /// inhibitRules defines the list of inhibition rules. The rules will only apply to alerts matching
    /// the resource's namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inhibitRules")]
    pub inhibit_rules: Option<Vec<AlertmanagerConfigInhibitRules>>,
    /// muteTimeIntervals defines the list of MuteTimeInterval specifying when the routes should be muted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "muteTimeIntervals")]
    pub mute_time_intervals: Option<Vec<AlertmanagerConfigMuteTimeIntervals>>,
    /// receivers defines the list of receivers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub receivers: Option<Vec<AlertmanagerConfigReceivers>>,
    /// route defines the Alertmanager route definition for alerts matching the resource's
    /// namespace. If present, it will be added to the generated Alertmanager
    /// configuration as a first-level route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<AlertmanagerConfigRoute>,
}

/// InhibitRule defines an inhibition rule that allows to mute alerts when other
/// alerts are already firing.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#inhibit_rule>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigInhibitRules {
    /// equal defines labels that must have an equal value in the source and target alert
    /// for the inhibition to take effect. This ensures related alerts are properly grouped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub equal: Option<Vec<String>>,
    /// sourceMatch defines matchers for which one or more alerts have to exist for the inhibition
    /// to take effect. The operator enforces that the alert matches the resource's namespace.
    /// These are the "trigger" alerts that cause other alerts to be inhibited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceMatch")]
    pub source_match: Option<Vec<AlertmanagerConfigInhibitRulesSourceMatch>>,
    /// targetMatch defines matchers that have to be fulfilled in the alerts to be muted.
    /// The operator enforces that the alert matches the resource's namespace.
    /// When these conditions are met, matching alerts will be inhibited (silenced).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetMatch")]
    pub target_match: Option<Vec<AlertmanagerConfigInhibitRulesTargetMatch>>,
}

/// Matcher defines how to match on alert's labels.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigInhibitRulesSourceMatch {
    /// matchType defines the match operation available with AlertManager >= v0.22.0.
    /// Takes precedence over Regex (deprecated) if non-empty.
    /// Valid values: "=" (equality), "!=" (inequality), "=~" (regex match), "!~" (regex non-match).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchType")]
    pub match_type: Option<AlertmanagerConfigInhibitRulesSourceMatchMatchType>,
    /// name defines the label to match.
    /// This specifies which alert label should be evaluated.
    pub name: String,
    /// regex defines whether to match on equality (false) or regular-expression (true).
    /// Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<bool>,
    /// value defines the label value to match.
    /// This is the expected value for the specified label.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Matcher defines how to match on alert's labels.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigInhibitRulesSourceMatchMatchType {
    #[serde(rename = "!=")]
    KopiumVariant0,
    #[serde(rename = "=")]
    KopiumVariant1,
    #[serde(rename = "=~")]
    KopiumVariant2,
    #[serde(rename = "!~")]
    KopiumVariant3,
}

/// Matcher defines how to match on alert's labels.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigInhibitRulesTargetMatch {
    /// matchType defines the match operation available with AlertManager >= v0.22.0.
    /// Takes precedence over Regex (deprecated) if non-empty.
    /// Valid values: "=" (equality), "!=" (inequality), "=~" (regex match), "!~" (regex non-match).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchType")]
    pub match_type: Option<AlertmanagerConfigInhibitRulesTargetMatchMatchType>,
    /// name defines the label to match.
    /// This specifies which alert label should be evaluated.
    pub name: String,
    /// regex defines whether to match on equality (false) or regular-expression (true).
    /// Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<bool>,
    /// value defines the label value to match.
    /// This is the expected value for the specified label.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Matcher defines how to match on alert's labels.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigInhibitRulesTargetMatchMatchType {
    #[serde(rename = "!=")]
    KopiumVariant0,
    #[serde(rename = "=")]
    KopiumVariant1,
    #[serde(rename = "=~")]
    KopiumVariant2,
    #[serde(rename = "!~")]
    KopiumVariant3,
}

/// MuteTimeInterval specifies the periods in time when notifications will be muted
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigMuteTimeIntervals {
    /// name of the time interval
    pub name: String,
    /// timeIntervals defines a list of TimeInterval
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeIntervals")]
    pub time_intervals: Option<Vec<AlertmanagerConfigMuteTimeIntervalsTimeIntervals>>,
}

/// TimeInterval describes intervals of time
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigMuteTimeIntervalsTimeIntervals {
    /// daysOfMonth defines a list of DayOfMonthRange
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "daysOfMonth")]
    pub days_of_month: Option<Vec<AlertmanagerConfigMuteTimeIntervalsTimeIntervalsDaysOfMonth>>,
    /// months defines a list of MonthRange
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub months: Option<Vec<String>>,
    /// times defines a list of TimeRange
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub times: Option<Vec<AlertmanagerConfigMuteTimeIntervalsTimeIntervalsTimes>>,
    /// weekdays defines a list of WeekdayRange
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weekdays: Option<Vec<String>>,
    /// years defines a list of YearRange
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub years: Option<Vec<String>>,
}

/// DayOfMonthRange is an inclusive range of days of the month beginning at 1
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigMuteTimeIntervalsTimeIntervalsDaysOfMonth {
    /// end of the inclusive range
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,
    /// start of the inclusive range
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
}

/// TimeRange defines a start and end time in 24hr format
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigMuteTimeIntervalsTimeIntervalsTimes {
    /// endTime defines the end time in 24hr format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endTime")]
    pub end_time: Option<String>,
    /// startTime defines the start time in 24hr format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
}

/// Receiver defines one or more notification integrations.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceivers {
    /// discordConfigs defines the list of Slack configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discordConfigs")]
    pub discord_configs: Option<Vec<AlertmanagerConfigReceiversDiscordConfigs>>,
    /// emailConfigs defines the list of Email configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emailConfigs")]
    pub email_configs: Option<Vec<AlertmanagerConfigReceiversEmailConfigs>>,
    /// msteamsConfigs defines the list of MSTeams configurations.
    /// It requires Alertmanager >= 0.26.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "msteamsConfigs")]
    pub msteams_configs: Option<Vec<AlertmanagerConfigReceiversMsteamsConfigs>>,
    /// msteamsv2Configs defines the list of MSTeamsV2 configurations.
    /// It requires Alertmanager >= 0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "msteamsv2Configs")]
    pub msteamsv2_configs: Option<Vec<AlertmanagerConfigReceiversMsteamsv2Configs>>,
    /// name defines the name of the receiver. Must be unique across all items from the list.
    pub name: String,
    /// opsgenieConfigs defines the list of OpsGenie configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "opsgenieConfigs")]
    pub opsgenie_configs: Option<Vec<AlertmanagerConfigReceiversOpsgenieConfigs>>,
    /// pagerdutyConfigs defines the List of PagerDuty configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pagerdutyConfigs")]
    pub pagerduty_configs: Option<Vec<AlertmanagerConfigReceiversPagerdutyConfigs>>,
    /// pushoverConfigs defines the list of Pushover configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pushoverConfigs")]
    pub pushover_configs: Option<Vec<AlertmanagerConfigReceiversPushoverConfigs>>,
    /// rocketchatConfigs defines the list of RocketChat configurations.
    /// It requires Alertmanager >= 0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rocketchatConfigs")]
    pub rocketchat_configs: Option<Vec<AlertmanagerConfigReceiversRocketchatConfigs>>,
    /// slackConfigs defines the list of Slack configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "slackConfigs")]
    pub slack_configs: Option<Vec<AlertmanagerConfigReceiversSlackConfigs>>,
    /// snsConfigs defines the list of SNS configurations
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "snsConfigs")]
    pub sns_configs: Option<Vec<AlertmanagerConfigReceiversSnsConfigs>>,
    /// telegramConfigs defines the list of Telegram configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "telegramConfigs")]
    pub telegram_configs: Option<Vec<AlertmanagerConfigReceiversTelegramConfigs>>,
    /// victoropsConfigs defines the list of VictorOps configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "victoropsConfigs")]
    pub victorops_configs: Option<Vec<AlertmanagerConfigReceiversVictoropsConfigs>>,
    /// webexConfigs defines the list of Webex configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webexConfigs")]
    pub webex_configs: Option<Vec<AlertmanagerConfigReceiversWebexConfigs>>,
    /// webhookConfigs defines the List of webhook configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookConfigs")]
    pub webhook_configs: Option<Vec<AlertmanagerConfigReceiversWebhookConfigs>>,
    /// wechatConfigs defines the list of WeChat configurations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wechatConfigs")]
    pub wechat_configs: Option<Vec<AlertmanagerConfigReceiversWechatConfigs>>,
}

/// DiscordConfig configures notifications via Discord.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#discord_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigs {
    /// apiURL defines the secret's key that contains the Discord webhook URL.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(rename = "apiURL")]
    pub api_url: AlertmanagerConfigReceiversDiscordConfigsApiUrl,
    /// avatarURL defines the avatar url of the message sender.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "avatarURL")]
    pub avatar_url: Option<String>,
    /// content defines the template of the content's body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
    /// httpConfig defines the HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfig>,
    /// message defines the template of the message's body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// title defines the template of the message's title.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// username defines the username of the message sender.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// apiURL defines the secret's key that contains the Discord webhook URL.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsApiUrl {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// httpConfig defines the HTTP client configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversDiscordConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversDiscordConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversDiscordConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// EmailConfig configures notifications via Email.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigs {
    /// authIdentity defines the identity to use for SMTP authentication.
    /// This is typically used with PLAIN authentication mechanism.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authIdentity")]
    pub auth_identity: Option<String>,
    /// authPassword defines the secret's key that contains the password to use for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authPassword")]
    pub auth_password: Option<AlertmanagerConfigReceiversEmailConfigsAuthPassword>,
    /// authSecret defines the secret's key that contains the CRAM-MD5 secret.
    /// This is used for CRAM-MD5 authentication mechanism.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authSecret")]
    pub auth_secret: Option<AlertmanagerConfigReceiversEmailConfigsAuthSecret>,
    /// authUsername defines the username to use for SMTP authentication.
    /// This is used for SMTP AUTH when the server requires authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authUsername")]
    pub auth_username: Option<String>,
    /// from defines the sender address for email notifications.
    /// This appears as the "From" field in the email header.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// headers defines additional email header key/value pairs.
    /// These override any headers previously set by the notification implementation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AlertmanagerConfigReceiversEmailConfigsHeaders>>,
    /// hello defines the hostname to identify to the SMTP server.
    /// This is used in the SMTP HELO/EHLO command during the connection handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hello: Option<String>,
    /// html defines the HTML body of the email notification.
    /// This allows for rich formatting in the email content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html: Option<String>,
    /// requireTLS defines the SMTP TLS requirement.
    /// Note that Go does not support unencrypted connections to remote SMTP endpoints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireTLS")]
    pub require_tls: Option<bool>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// smarthost defines the SMTP host and port through which emails are sent.
    /// Format should be "hostname:port", e.g. "smtp.example.com:587".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub smarthost: Option<String>,
    /// text defines the plain text body of the email notification.
    /// This provides a fallback for email clients that don't support HTML.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// tlsConfig defines the TLS configuration for SMTP connections.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfig>,
    /// to defines the email address to send notifications to.
    /// This is the recipient address for alert notifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// authPassword defines the secret's key that contains the password to use for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// authSecret defines the secret's key that contains the CRAM-MD5 secret.
/// This is used for CRAM-MD5 authentication mechanism.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsAuthSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// KeyValue defines a (key, value) tuple.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsHeaders {
    /// key defines the key of the tuple.
    /// This is the identifier or name part of the key-value pair.
    pub key: String,
    /// value defines the value of the tuple.
    /// This is the data or content associated with the key.
    pub value: String,
}

/// tlsConfig defines the TLS configuration for SMTP connections.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversEmailConfigsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversEmailConfigsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for SMTP connections.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversEmailConfigsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for SMTP connections.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversEmailConfigsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// MSTeamsConfig configures notifications via Microsoft Teams.
/// It requires Alertmanager >= 0.26.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigs {
    /// httpConfig defines the HTTP client configuration for Teams webhook requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfig>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// summary defines the message summary template for Teams notifications.
    /// This provides a brief overview that appears in Teams notification previews.
    /// It requires Alertmanager >= 0.27.0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    /// text defines the message body template for Teams notifications.
    /// This contains the detailed content of the Teams message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// title defines the message title template for Teams notifications.
    /// This appears as the main heading of the Teams message card.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// webhookUrl defines the MSTeams webhook URL for sending notifications.
    /// This is the incoming webhook URL configured in your Teams channel.
    #[serde(rename = "webhookUrl")]
    pub webhook_url: AlertmanagerConfigReceiversMsteamsConfigsWebhookUrl,
}

/// httpConfig defines the HTTP client configuration for Teams webhook requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversMsteamsConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversMsteamsConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// webhookUrl defines the MSTeams webhook URL for sending notifications.
/// This is the incoming webhook URL configured in your Teams channel.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsConfigsWebhookUrl {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// MSTeamsV2Config configures notifications via Microsoft Teams using the new message format with adaptive cards as required by flows.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#msteamsv2_config>
/// It requires Alertmanager >= 0.28.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2Configs {
    /// httpConfig defines the HTTP client configuration for Teams webhook requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfig>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// text defines the message body template for adaptive card notifications.
    /// This contains the detailed content displayed in the Teams adaptive card format.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// title defines the message title template for adaptive card notifications.
    /// This appears as the main heading in the Teams adaptive card.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// webhookURL defines the MSTeams incoming webhook URL for adaptive card notifications.
    /// This webhook must support the newer adaptive cards format required by Teams flows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookURL")]
    pub webhook_url: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsWebhookUrl>,
}

/// httpConfig defines the HTTP client configuration for Teams webhook requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversMsteamsv2ConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// webhookURL defines the MSTeams incoming webhook URL for adaptive card notifications.
/// This webhook must support the newer adaptive cards format required by Teams flows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversMsteamsv2ConfigsWebhookUrl {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// OpsGenieConfig configures notifications via OpsGenie.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#opsgenie_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigs {
    /// actions defines a comma separated list of actions that will be available for the alert.
    /// These appear as action buttons in the OpsGenie interface.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<String>,
    /// apiKey defines the secret's key that contains the OpsGenie API key.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<AlertmanagerConfigReceiversOpsgenieConfigsApiKey>,
    /// apiURL defines the URL to send OpsGenie API requests to.
    /// When not specified, defaults to the standard OpsGenie API endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<String>,
    /// description defines the detailed description of the incident.
    /// This provides additional context beyond the message field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// details defines a set of arbitrary key/value pairs that provide further detail about the incident.
    /// These appear as additional fields in the OpsGenie alert.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details: Option<Vec<AlertmanagerConfigReceiversOpsgenieConfigsDetails>>,
    /// entity defines an optional field that can be used to specify which domain alert is related to.
    /// This helps group related alerts together in OpsGenie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entity: Option<String>,
    /// httpConfig defines the HTTP client configuration for OpsGenie API requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfig>,
    /// message defines the alert text limited to 130 characters.
    /// This appears as the main alert title in OpsGenie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// note defines an additional alert note.
    /// This provides supplementary information about the alert.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    /// priority defines the priority level of alert.
    /// Possible values are P1, P2, P3, P4, and P5, where P1 is highest priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<String>,
    /// responders defines the list of responders responsible for notifications.
    /// These determine who gets notified when the alert is created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub responders: Option<Vec<AlertmanagerConfigReceiversOpsgenieConfigsResponders>>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// source defines the backlink to the sender of the notification.
    /// This helps identify where the alert originated from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// tags defines a comma separated list of tags attached to the notifications.
    /// These help categorize and filter alerts within OpsGenie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<String>,
    /// updateAlerts defines Whether to update message and description of the alert in OpsGenie if it already exists
    /// By default, the alert is never updated in OpsGenie, the new message only appears in activity log.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateAlerts")]
    pub update_alerts: Option<bool>,
}

/// apiKey defines the secret's key that contains the OpsGenie API key.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsApiKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// KeyValue defines a (key, value) tuple.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsDetails {
    /// key defines the key of the tuple.
    /// This is the identifier or name part of the key-value pair.
    pub key: String,
    /// value defines the value of the tuple.
    /// This is the data or content associated with the key.
    pub value: String,
}

/// httpConfig defines the HTTP client configuration for OpsGenie API requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversOpsgenieConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// OpsGenieConfigResponder defines a responder to an incident.
/// One of `id`, `name` or `username` has to be defined.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AlertmanagerConfigReceiversOpsgenieConfigsResponders {
    /// id defines the unique identifier of the responder.
    /// This corresponds to the responder's ID within OpsGenie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// name defines the display name of the responder.
    /// This is used when the responder is identified by name rather than ID.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// type defines the type of responder.
    /// Valid values include "user", "team", "schedule", and "escalation".
    /// This determines how OpsGenie interprets the other identifier fields.
    #[serde(rename = "type")]
    pub r#type: AlertmanagerConfigReceiversOpsgenieConfigsRespondersType,
    /// username defines the username of the responder.
    /// This is typically used for user-type responders when identifying by username.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// OpsGenieConfigResponder defines a responder to an incident.
/// One of `id`, `name` or `username` has to be defined.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversOpsgenieConfigsRespondersType {
    #[serde(rename = "team")]
    Team,
    #[serde(rename = "teams")]
    Teams,
    #[serde(rename = "user")]
    User,
    #[serde(rename = "escalation")]
    Escalation,
    #[serde(rename = "schedule")]
    Schedule,
}

/// PagerDutyConfig configures notifications via PagerDuty.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#pagerduty_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigs {
    /// class defines the class/type of the event.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class: Option<String>,
    /// client defines the client identification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client: Option<String>,
    /// clientURL defines the backlink to the sender of notification.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientURL")]
    pub client_url: Option<String>,
    /// component defines the part or component of the affected system that is broken.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub component: Option<String>,
    /// description of the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// details defines the arbitrary key/value pairs that provide further detail about the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub details: Option<Vec<AlertmanagerConfigReceiversPagerdutyConfigsDetails>>,
    /// group defines a cluster or grouping of sources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// httpConfig defines the HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfig>,
    /// pagerDutyImageConfigs defines a list of image details to attach that provide further detail about an incident.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pagerDutyImageConfigs")]
    pub pager_duty_image_configs: Option<Vec<AlertmanagerConfigReceiversPagerdutyConfigsPagerDutyImageConfigs>>,
    /// pagerDutyLinkConfigs defines a list of link details to attach that provide further detail about an incident.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pagerDutyLinkConfigs")]
    pub pager_duty_link_configs: Option<Vec<AlertmanagerConfigReceiversPagerdutyConfigsPagerDutyLinkConfigs>>,
    /// routingKey defines the secret's key that contains the PagerDuty integration key (when using
    /// Events API v2). Either this field or `serviceKey` needs to be defined.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routingKey")]
    pub routing_key: Option<AlertmanagerConfigReceiversPagerdutyConfigsRoutingKey>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// serviceKey defines the secret's key that contains the PagerDuty service key (when using
    /// integration type "Prometheus"). Either this field or `routingKey` needs to
    /// be defined.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceKey")]
    pub service_key: Option<AlertmanagerConfigReceiversPagerdutyConfigsServiceKey>,
    /// severity of the incident.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
    /// source defines the unique location of the affected system.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// url defines the URL to send requests to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// KeyValue defines a (key, value) tuple.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsDetails {
    /// key defines the key of the tuple.
    /// This is the identifier or name part of the key-value pair.
    pub key: String,
    /// value defines the value of the tuple.
    /// This is the data or content associated with the key.
    pub value: String,
}

/// httpConfig defines the HTTP client configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversPagerdutyConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// PagerDutyImageConfig attaches images to an incident
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsPagerDutyImageConfigs {
    /// alt is the optional alternative text for the image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alt: Option<String>,
    /// href defines the optional URL; makes the image a clickable link.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub href: Option<String>,
    /// src of the image being attached to the incident
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub src: Option<String>,
}

/// PagerDutyLinkConfig attaches text links to an incident
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsPagerDutyLinkConfigs {
    /// alt defines the text that describes the purpose of the link, and can be used as the link's text.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alt: Option<String>,
    /// href defines the URL of the link to be attached
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub href: Option<String>,
}

/// routingKey defines the secret's key that contains the PagerDuty integration key (when using
/// Events API v2). Either this field or `serviceKey` needs to be defined.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsRoutingKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// serviceKey defines the secret's key that contains the PagerDuty service key (when using
/// integration type "Prometheus"). Either this field or `routingKey` needs to
/// be defined.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPagerdutyConfigsServiceKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// PushoverConfig configures notifications via Pushover.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#pushover_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigs {
    /// device defines the name of a specific device to send the notification to.
    /// If not specified, the notification is sent to all user's devices.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device: Option<String>,
    /// expire defines how long your notification will continue to be retried for,
    /// unless the user acknowledges the notification. Only applies to priority 2 notifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expire: Option<String>,
    /// html defines whether notification message is HTML or plain text.
    /// When true, the message can include HTML formatting tags.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub html: Option<bool>,
    /// httpConfig defines the HTTP client configuration for Pushover API requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfig>,
    /// message defines the notification message content.
    /// This is the main body text of the Pushover notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// priority defines the notification priority level.
    /// See <https://pushover.net/api#priority> for valid values and behavior.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<String>,
    /// retry defines how often the Pushover servers will send the same notification to the user.
    /// Must be at least 30 seconds. Only applies to priority 2 notifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry: Option<String>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// sound defines the name of one of the sounds supported by device clients.
    /// This overrides the user's default sound choice for this notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sound: Option<String>,
    /// title defines the notification title displayed in the Pushover message.
    /// This appears as the bold header text in the notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// token defines the secret's key that contains the registered application's API token.
    /// See <https://pushover.net/apps> for application registration.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    /// Either `token` or `tokenFile` is required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<AlertmanagerConfigReceiversPushoverConfigsToken>,
    /// tokenFile defines the token file that contains the registered application's API token.
    /// See <https://pushover.net/apps> for application registration.
    /// Either `token` or `tokenFile` is required.
    /// It requires Alertmanager >= v0.26.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenFile")]
    pub token_file: Option<String>,
    /// ttl defines the time to live for the alert notification.
    /// This determines how long the notification remains active before expiring.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
    /// url defines a supplementary URL shown alongside the message.
    /// This creates a clickable link within the Pushover notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// urlTitle defines a title for the supplementary URL.
    /// If not specified, the raw URL is shown instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlTitle")]
    pub url_title: Option<String>,
    /// userKey defines the secret's key that contains the recipient user's user key.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    /// Either `userKey` or `userKeyFile` is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userKey")]
    pub user_key: Option<AlertmanagerConfigReceiversPushoverConfigsUserKey>,
    /// userKeyFile defines the user key file that contains the recipient user's user key.
    /// Either `userKey` or `userKeyFile` is required.
    /// It requires Alertmanager >= v0.26.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userKeyFile")]
    pub user_key_file: Option<String>,
}

/// httpConfig defines the HTTP client configuration for Pushover API requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversPushoverConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversPushoverConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversPushoverConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// token defines the secret's key that contains the registered application's API token.
/// See <https://pushover.net/apps> for application registration.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
/// Either `token` or `tokenFile` is required.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// userKey defines the secret's key that contains the recipient user's user key.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
/// Either `userKey` or `userKeyFile` is required.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversPushoverConfigsUserKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RocketChatConfig configures notifications via RocketChat.
/// It requires Alertmanager >= 0.28.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigs {
    /// actions defines interactive actions to include in the message.
    /// These appear as buttons that users can click to trigger responses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<AlertmanagerConfigReceiversRocketchatConfigsActions>>,
    /// apiURL defines the API URL for RocketChat.
    /// Defaults to <https://open.rocket.chat/> if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<String>,
    /// channel defines the channel to send alerts to.
    /// This can be a channel name (e.g., "#alerts") or a direct message recipient.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
    /// color defines the message color displayed in RocketChat.
    /// This appears as a colored bar alongside the message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
    /// emoji defines the emoji to be displayed as an avatar.
    /// If provided, this emoji will be used instead of the default avatar or iconURL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub emoji: Option<String>,
    /// fields defines additional fields for the message attachment.
    /// These appear as structured key-value pairs within the message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<AlertmanagerConfigReceiversRocketchatConfigsFields>>,
    /// httpConfig defines the HTTP client configuration for RocketChat API requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfig>,
    /// iconURL defines the icon URL for the message avatar.
    /// This displays a custom image as the message sender's avatar.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iconURL")]
    pub icon_url: Option<String>,
    /// imageURL defines the image URL to display within the message.
    /// This embeds an image directly in the message attachment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageURL")]
    pub image_url: Option<String>,
    /// linkNames defines whether to enable automatic linking of usernames and channels.
    /// When true, @username and #channel references become clickable links.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkNames")]
    pub link_names: Option<bool>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// shortFields defines whether to use short fields in the message layout.
    /// When true, fields may be displayed side by side to save space.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shortFields")]
    pub short_fields: Option<bool>,
    /// text defines the message text to send.
    /// This is optional because attachments can be used instead of or alongside text.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// thumbURL defines the thumbnail URL for the message.
    /// This displays a small thumbnail image alongside the message content.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "thumbURL")]
    pub thumb_url: Option<String>,
    /// title defines the message title displayed prominently in the message.
    /// This appears as bold text at the top of the message attachment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// titleLink defines the URL that the title will link to when clicked.
    /// This makes the message title clickable in the RocketChat interface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "titleLink")]
    pub title_link: Option<String>,
    /// token defines the sender token for RocketChat authentication.
    /// This is the personal access token or bot token used to authenticate API requests.
    pub token: AlertmanagerConfigReceiversRocketchatConfigsToken,
    /// tokenID defines the sender token ID for RocketChat authentication.
    /// This is the user ID associated with the token used for API requests.
    #[serde(rename = "tokenID")]
    pub token_id: AlertmanagerConfigReceiversRocketchatConfigsTokenId,
}

/// RocketChatActionConfig defines actions for RocketChat messages.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsActions {
    /// msg defines the message to send when the button is clicked.
    /// This allows the button to post a predefined message to the channel.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub msg: Option<String>,
    /// text defines the button text displayed to users.
    /// This is the label that appears on the interactive button.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// url defines the URL the button links to when clicked.
    /// This creates a clickable button that opens the specified URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// RocketChatFieldConfig defines additional fields for RocketChat messages.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsFields {
    /// short defines whether this field should be a short field.
    /// When true, the field may be displayed inline with other short fields to save space.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short: Option<bool>,
    /// title defines the title of this field.
    /// This appears as bold text labeling the field content.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// value defines the value of this field, displayed underneath the title.
    /// This contains the actual data or content for the field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// httpConfig defines the HTTP client configuration for RocketChat API requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversRocketchatConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversRocketchatConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// token defines the sender token for RocketChat authentication.
/// This is the personal access token or bot token used to authenticate API requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tokenID defines the sender token ID for RocketChat authentication.
/// This is the user ID associated with the token used for API requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversRocketchatConfigsTokenId {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SlackConfig configures notifications via Slack.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#slack_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigs {
    /// actions defines a list of Slack actions that are sent with each notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<AlertmanagerConfigReceiversSlackConfigsActions>>,
    /// apiURL defines the secret's key that contains the Slack webhook URL.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<AlertmanagerConfigReceiversSlackConfigsApiUrl>,
    /// callbackId defines an identifier for the message used in interactive components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "callbackId")]
    pub callback_id: Option<String>,
    /// channel defines the channel or user to send notifications to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub channel: Option<String>,
    /// color defines the color of the left border of the Slack message attachment.
    /// Can be a hex color code (e.g., "#ff0000") or a predefined color name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
    /// fallback defines a plain-text summary of the attachment for clients that don't support attachments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fallback: Option<String>,
    /// fields defines a list of Slack fields that are sent with each notification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<AlertmanagerConfigReceiversSlackConfigsFields>>,
    /// footer defines small text displayed at the bottom of the message attachment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub footer: Option<String>,
    /// httpConfig defines the HTTP client configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfig>,
    /// iconEmoji defines the emoji to use as the bot's avatar (e.g., ":ghost:").
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iconEmoji")]
    pub icon_emoji: Option<String>,
    /// iconURL defines the URL to an image to use as the bot's avatar.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iconURL")]
    pub icon_url: Option<String>,
    /// imageURL defines the URL to an image file that will be displayed inside the message attachment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageURL")]
    pub image_url: Option<String>,
    /// linkNames enables automatic linking of channel names and usernames in the message.
    /// When true, @channel and @username will be converted to clickable links.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkNames")]
    pub link_names: Option<bool>,
    /// mrkdwnIn defines which fields should be parsed as Slack markdown.
    /// Valid values include "pretext", "text", and "fields".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mrkdwnIn")]
    pub mrkdwn_in: Option<Vec<String>>,
    /// pretext defines optional text that appears above the message attachment block.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pretext: Option<String>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// shortFields determines whether fields are displayed in a compact format.
    /// When true, fields are shown side by side when possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shortFields")]
    pub short_fields: Option<bool>,
    /// text defines the main text content of the Slack message attachment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// thumbURL defines the URL to an image file that will be displayed as a thumbnail
    /// on the right side of the message attachment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "thumbURL")]
    pub thumb_url: Option<String>,
    /// title defines the title text displayed in the Slack message attachment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// titleLink defines the URL that the title will link to when clicked.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "titleLink")]
    pub title_link: Option<String>,
    /// username defines the slack bot user name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// SlackAction configures a single Slack action that is sent with each
/// notification.
/// See <https://api.slack.com/docs/message-attachments#action_fields> and
/// <https://api.slack.com/docs/message-buttons> for more information.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsActions {
    /// confirm defines an optional confirmation dialog that appears before the action is executed.
    /// When set, users must confirm their intent before the action proceeds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub confirm: Option<AlertmanagerConfigReceiversSlackConfigsActionsConfirm>,
    /// name defines a unique identifier for the action within the message.
    /// This value is sent back to your application when the action is triggered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// style defines the visual appearance of the action element.
    /// Valid values include "default", "primary" (green), and "danger" (red).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<String>,
    /// text defines the user-visible label displayed on the action element.
    /// For buttons, this is the button text. For select menus, this is the placeholder text.
    pub text: String,
    /// type defines the type of interactive component.
    /// Common values include "button" for clickable buttons and "select" for dropdown menus.
    #[serde(rename = "type")]
    pub r#type: String,
    /// url defines the URL to open when the action is triggered.
    /// Only applicable for button-type actions. When set, clicking the button opens this URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// value defines the payload sent when the action is triggered.
    /// This data is included in the callback sent to your application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// confirm defines an optional confirmation dialog that appears before the action is executed.
/// When set, users must confirm their intent before the action proceeds.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsActionsConfirm {
    /// dismissText defines the label for the cancel button in the dialog.
    /// When not specified, defaults to "Cancel". This button cancels the action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dismissText")]
    pub dismiss_text: Option<String>,
    /// okText defines the label for the confirmation button in the dialog.
    /// When not specified, defaults to "Okay". This button proceeds with the action.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "okText")]
    pub ok_text: Option<String>,
    /// text defines the main message displayed in the confirmation dialog.
    /// This should be a clear question or statement asking the user to confirm their action.
    pub text: String,
    /// title defines the title text displayed at the top of the confirmation dialog.
    /// When not specified, a default title will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}

/// apiURL defines the secret's key that contains the Slack webhook URL.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsApiUrl {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SlackField configures a single Slack field that is sent with each notification.
/// Each field must contain a title, value, and optionally, a boolean value to indicate if the field
/// is short enough to be displayed next to other fields designated as short.
/// See <https://api.slack.com/docs/message-attachments#fields> for more information.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsFields {
    /// short determines whether this field can be displayed alongside other short fields.
    /// When true, Slack may display this field side by side with other short fields.
    /// When false or not specified, the field takes the full width of the message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short: Option<bool>,
    /// title defines the label or header text displayed for this field.
    /// This appears as bold text above the field value in the Slack message.
    pub title: String,
    /// value defines the content or data displayed for this field.
    /// This appears below the title and can contain plain text or Slack markdown.
    pub value: String,
}

/// httpConfig defines the HTTP client configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversSlackConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversSlackConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversSlackConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SNSConfig configures notifications via AWS SNS.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#sns_configs>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigs {
    /// apiURL defines the SNS API URL, e.g. <https://sns.us-east-2.amazonaws.com.>
    /// If not specified, the SNS API URL from the SNS SDK will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<String>,
    /// attributes defines SNS message attributes as key-value pairs.
    /// These provide additional metadata that can be used for message filtering and routing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attributes: Option<BTreeMap<String, String>>,
    /// httpConfig defines the HTTP client configuration for SNS API requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfig>,
    /// message defines the message content of the SNS notification.
    /// This is the actual notification text that will be sent to subscribers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// phoneNumber defines the phone number if message is delivered via SMS in E.164 format.
    /// If you don't specify this value, you must specify a value for the TopicARN or TargetARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "phoneNumber")]
    pub phone_number: Option<String>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// sigv4 configures AWS's Signature Verification 4 signing process to sign requests.
    /// This includes AWS credentials and region configuration for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sigv4: Option<AlertmanagerConfigReceiversSnsConfigsSigv4>,
    /// subject defines the subject line when the message is delivered to email endpoints.
    /// This field is only used when sending to email subscribers of an SNS topic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<String>,
    /// targetARN defines the mobile platform endpoint ARN if message is delivered via mobile notifications.
    /// If you don't specify this value, you must specify a value for the TopicARN or PhoneNumber.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetARN")]
    pub target_arn: Option<String>,
    /// topicARN defines the SNS topic ARN, e.g. arn:aws:sns:us-east-2:698519295917:My-Topic.
    /// If you don't specify this value, you must specify a value for the PhoneNumber or TargetARN.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topicARN")]
    pub topic_arn: Option<String>,
}

/// httpConfig defines the HTTP client configuration for SNS API requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversSnsConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversSnsConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversSnsConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// sigv4 configures AWS's Signature Verification 4 signing process to sign requests.
/// This includes AWS credentials and region configuration for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsSigv4 {
    /// accessKey defines the AWS API key. If not specified, the environment variable
    /// `AWS_ACCESS_KEY_ID` is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessKey")]
    pub access_key: Option<AlertmanagerConfigReceiversSnsConfigsSigv4AccessKey>,
    /// profile defines the named AWS profile used to authenticate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profile: Option<String>,
    /// region defines the AWS region. If blank, the region from the default credentials chain used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    /// roleArn defines the named AWS profile used to authenticate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleArn")]
    pub role_arn: Option<String>,
    /// secretKey defines the AWS API secret. If not specified, the environment
    /// variable `AWS_SECRET_ACCESS_KEY` is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKey")]
    pub secret_key: Option<AlertmanagerConfigReceiversSnsConfigsSigv4SecretKey>,
}

/// accessKey defines the AWS API key. If not specified, the environment variable
/// `AWS_ACCESS_KEY_ID` is used.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsSigv4AccessKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secretKey defines the AWS API secret. If not specified, the environment
/// variable `AWS_SECRET_ACCESS_KEY` is used.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversSnsConfigsSigv4SecretKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TelegramConfig configures notifications via Telegram.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#telegram_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigs {
    /// apiURL defines the Telegram API URL, e.g. <https://api.telegram.org.>
    /// If not specified, the default Telegram API URL will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<String>,
    /// botToken defines the Telegram bot token. It is mutually exclusive with `botTokenFile`.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    /// Either `botToken` or `botTokenFile` is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "botToken")]
    pub bot_token: Option<AlertmanagerConfigReceiversTelegramConfigsBotToken>,
    /// botTokenFile defines the file to read the Telegram bot token from.
    /// It is mutually exclusive with `botToken`.
    /// Either `botToken` or `botTokenFile` is required.
    /// It requires Alertmanager >= v0.26.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "botTokenFile")]
    pub bot_token_file: Option<String>,
    /// chatID defines the Telegram chat ID where messages will be sent.
    /// This can be a user ID, group ID, or channel ID (with @ prefix for public channels).
    #[serde(rename = "chatID")]
    pub chat_id: i64,
    /// disableNotifications controls whether Telegram notifications are sent silently.
    /// When true, users will receive the message without notification sounds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableNotifications")]
    pub disable_notifications: Option<bool>,
    /// httpConfig defines the HTTP client configuration for Telegram API requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfig>,
    /// message defines the message template for the Telegram notification.
    /// This is the content that will be sent to the specified chat.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// messageThreadID defines the Telegram Group Topic ID for threaded messages.
    /// This allows sending messages to specific topics within Telegram groups.
    /// It requires Alertmanager >= 0.26.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageThreadID")]
    pub message_thread_id: Option<i64>,
    /// parseMode defines the parse mode for telegram message formatting.
    /// Valid values are "MarkdownV2", "Markdown", and "HTML".
    /// This determines how text formatting is interpreted in the message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parseMode")]
    pub parse_mode: Option<AlertmanagerConfigReceiversTelegramConfigsParseMode>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
}

/// botToken defines the Telegram bot token. It is mutually exclusive with `botTokenFile`.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
/// Either `botToken` or `botTokenFile` is required.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsBotToken {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// httpConfig defines the HTTP client configuration for Telegram API requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversTelegramConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversTelegramConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversTelegramConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// TelegramConfig configures notifications via Telegram.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#telegram_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversTelegramConfigsParseMode {
    MarkdownV2,
    Markdown,
    #[serde(rename = "HTML")]
    Html,
}

/// VictorOpsConfig configures notifications via VictorOps.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#victorops_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigs {
    /// apiKey defines the secret's key that contains the API key to use when talking to the VictorOps API.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<AlertmanagerConfigReceiversVictoropsConfigsApiKey>,
    /// apiUrl defines the VictorOps API URL.
    /// When not specified, defaults to the standard VictorOps API endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiUrl")]
    pub api_url: Option<String>,
    /// customFields defines additional custom fields for notification.
    /// These provide extra metadata that will be included with the VictorOps incident.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customFields")]
    pub custom_fields: Option<Vec<AlertmanagerConfigReceiversVictoropsConfigsCustomFields>>,
    /// entityDisplayName contains a summary of the alerted problem.
    /// This appears as the main title or identifier for the incident.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "entityDisplayName")]
    pub entity_display_name: Option<String>,
    /// httpConfig defines the HTTP client's configuration for VictorOps API requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfig>,
    /// messageType describes the behavior of the alert.
    /// Valid values are "CRITICAL", "WARNING", and "INFO".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageType")]
    pub message_type: Option<String>,
    /// monitoringTool defines the monitoring tool the state message is from.
    /// This helps identify the source system that generated the alert.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "monitoringTool")]
    pub monitoring_tool: Option<String>,
    /// routingKey defines a key used to map the alert to a team.
    /// This determines which VictorOps team will receive the alert notification.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routingKey")]
    pub routing_key: Option<String>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// stateMessage contains a long explanation of the alerted problem.
    /// This provides detailed context about the incident.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stateMessage")]
    pub state_message: Option<String>,
}

/// apiKey defines the secret's key that contains the API key to use when talking to the VictorOps API.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsApiKey {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// KeyValue defines a (key, value) tuple.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsCustomFields {
    /// key defines the key of the tuple.
    /// This is the identifier or name part of the key-value pair.
    pub key: String,
    /// value defines the value of the tuple.
    /// This is the data or content associated with the key.
    pub value: String,
}

/// httpConfig defines the HTTP client's configuration for VictorOps API requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversVictoropsConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversVictoropsConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// WebexConfig configures notification via Cisco Webex
/// See <https://prometheus.io/docs/alerting/latest/configuration/#webex_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigs {
    /// apiURL defines the Webex Teams API URL i.e. <https://webexapis.com/v1/messages>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<String>,
    /// httpConfig defines the HTTP client's configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfig>,
    /// message defines the message template
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// roomID defines the ID of the Webex Teams room where to send the messages.
    #[serde(rename = "roomID")]
    pub room_id: String,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
}

/// httpConfig defines the HTTP client's configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversWebexConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWebexConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWebexConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// WebhookConfig configures notifications via a generic receiver supporting the webhook payload.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#webhook_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigs {
    /// httpConfig defines the HTTP client configuration for webhook requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfig>,
    /// maxAlerts defines the maximum number of alerts to be sent per webhook message.
    /// When 0, all alerts are included in the webhook payload.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAlerts")]
    pub max_alerts: Option<i32>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// timeout defines the maximum time to wait for a webhook request to complete,
    /// before failing the request and allowing it to be retried.
    /// It requires Alertmanager >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
    /// url defines the URL to send HTTP POST requests to.
    /// urlSecret takes precedence over url. One of urlSecret and url should be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// urlSecret defines the secret's key that contains the webhook URL to send HTTP requests to.
    /// urlSecret takes precedence over url. One of urlSecret and url should be defined.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "urlSecret")]
    pub url_secret: Option<AlertmanagerConfigReceiversWebhookConfigsUrlSecret>,
}

/// httpConfig defines the HTTP client configuration for webhook requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversWebhookConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWebhookConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWebhookConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// urlSecret defines the secret's key that contains the webhook URL to send HTTP requests to.
/// urlSecret takes precedence over url. One of urlSecret and url should be defined.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWebhookConfigsUrlSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// WeChatConfig configures notifications via WeChat.
/// See <https://prometheus.io/docs/alerting/latest/configuration/#wechat_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigs {
    /// agentID defines the application agent ID within WeChat Work.
    /// This identifies which WeChat Work application will send the notifications.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agentID")]
    pub agent_id: Option<String>,
    /// apiSecret defines the secret's key that contains the WeChat API key.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiSecret")]
    pub api_secret: Option<AlertmanagerConfigReceiversWechatConfigsApiSecret>,
    /// apiURL defines the WeChat API URL.
    /// When not specified, defaults to the standard WeChat Work API endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiURL")]
    pub api_url: Option<String>,
    /// corpID defines the corp id for authentication.
    /// This is the unique identifier for your WeChat Work organization.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corpID")]
    pub corp_id: Option<String>,
    /// httpConfig defines the HTTP client configuration for WeChat API requests.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpConfig")]
    pub http_config: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfig>,
    /// message defines the API request data as defined by the WeChat API.
    /// This contains the actual notification content to be sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// messageType defines the type of message to send.
    /// Valid values include "text", "markdown", and other WeChat Work supported message types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageType")]
    pub message_type: Option<String>,
    /// sendResolved defines whether or not to notify about resolved alerts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendResolved")]
    pub send_resolved: Option<bool>,
    /// toParty defines the target department(s) to receive the notification.
    /// Can be a single department ID or multiple department IDs separated by '|'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toParty")]
    pub to_party: Option<String>,
    /// toTag defines the target tag(s) to receive the notification.
    /// Can be a single tag ID or multiple tag IDs separated by '|'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toTag")]
    pub to_tag: Option<String>,
    /// toUser defines the target user(s) to receive the notification.
    /// Can be a single user ID or multiple user IDs separated by '|'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toUser")]
    pub to_user: Option<String>,
}

/// apiSecret defines the secret's key that contains the WeChat API key.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsApiSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// httpConfig defines the HTTP client configuration for WeChat API requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfig {
    /// authorization defines the authorization header configuration for the client.
    /// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigAuthorization>,
    /// basicAuth defines the basic authentication credentials for the client.
    /// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuth>,
    /// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
    /// for authentication.
    /// The secret needs to be in the same namespace as the AlertmanagerConfig
    /// object and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigBearerTokenSecret>,
    /// followRedirects specifies whether the client should follow HTTP 3xx redirects.
    /// When true, the client will automatically follow redirect responses.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
    /// This enables OAuth2 authentication flow for HTTP requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversWechatConfigsHttpConfigProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyURL defines an optional proxy URL for HTTP requests.
    /// If defined, this field takes precedence over `proxyUrl`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url_x: Option<String>,
    /// tlsConfig defines the TLS configuration for the client.
    /// This includes settings for certificates, CA validation, and TLS protocol options.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfig>,
}

/// authorization defines the authorization header configuration for the client.
/// This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the basic authentication credentials for the client.
/// This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client
/// for authentication.
/// The secret needs to be in the same namespace as the AlertmanagerConfig
/// object and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.
/// This enables OAuth2 authentication flow for HTTP requests.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWechatConfigsHttpConfigOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration for the client.
/// This includes settings for certificates, CA validation, and TLS protocol options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigReceiversWechatConfigsHttpConfigTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// route defines the Alertmanager route definition for alerts matching the resource's
/// namespace. If present, it will be added to the generated Alertmanager
/// configuration as a first-level route.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigRoute {
    /// activeTimeIntervals is a list of MuteTimeInterval names when this route should be active.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeTimeIntervals")]
    pub active_time_intervals: Option<Vec<String>>,
    /// continue defines the boolean indicating whether an alert should continue matching subsequent
    /// sibling nodes. It will always be overridden to true for the first-level
    /// route by the Prometheus operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "continue")]
    pub r#continue: Option<bool>,
    /// groupBy defines the list of labels to group by.
    /// Labels must not be repeated (unique list).
    /// Special label "..." (aggregate by all possible labels), if provided, must be the only element in the list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupBy")]
    pub group_by: Option<Vec<String>>,
    /// groupInterval defines how long to wait before sending an updated notification.
    /// Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
    /// Example: "5m"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupInterval")]
    pub group_interval: Option<String>,
    /// groupWait defines how long to wait before sending the initial notification.
    /// Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
    /// Example: "30s"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupWait")]
    pub group_wait: Option<String>,
    /// matchers defines the list of matchers that the alert's labels should match. For the first
    /// level route, the operator removes any existing equality and regexp
    /// matcher on the `namespace` label and adds a `namespace: <object
    /// namespace>` matcher.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matchers: Option<Vec<AlertmanagerConfigRouteMatchers>>,
    /// muteTimeIntervals is a list of MuteTimeInterval names that will mute this route when matched,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "muteTimeIntervals")]
    pub mute_time_intervals: Option<Vec<String>>,
    /// receiver defines the name of the receiver for this route. If not empty, it should be listed in
    /// the `receivers` field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub receiver: Option<String>,
    /// repeatInterval defines how long to wait before repeating the last notification.
    /// Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
    /// Example: "4h"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repeatInterval")]
    pub repeat_interval: Option<String>,
    /// routes defines the child routes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routes: Option<Vec<serde_json::Value>>,
}

/// Matcher defines how to match on alert's labels.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AlertmanagerConfigRouteMatchers {
    /// matchType defines the match operation available with AlertManager >= v0.22.0.
    /// Takes precedence over Regex (deprecated) if non-empty.
    /// Valid values: "=" (equality), "!=" (inequality), "=~" (regex match), "!~" (regex non-match).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchType")]
    pub match_type: Option<AlertmanagerConfigRouteMatchersMatchType>,
    /// name defines the label to match.
    /// This specifies which alert label should be evaluated.
    pub name: String,
    /// regex defines whether to match on equality (false) or regular-expression (true).
    /// Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<bool>,
    /// value defines the label value to match.
    /// This is the expected value for the specified label.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Matcher defines how to match on alert's labels.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AlertmanagerConfigRouteMatchersMatchType {
    #[serde(rename = "!=")]
    KopiumVariant0,
    #[serde(rename = "=")]
    KopiumVariant1,
    #[serde(rename = "=~")]
    KopiumVariant2,
    #[serde(rename = "!~")]
    KopiumVariant3,
}

