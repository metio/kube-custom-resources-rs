// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/prometheus-operator/prometheus-operator/monitoring.coreos.com/v1/podmonitors.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// spec defines the specification of desired Pod selection for target discovery by Prometheus.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "monitoring.coreos.com", version = "v1", kind = "PodMonitor", plural = "podmonitors")]
#[kube(namespaced)]
#[kube(status = "PodMonitorStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct PodMonitorSpec {
    /// attachMetadata defines additional metadata which is added to the
    /// discovered targets.
    /// 
    /// It requires Prometheus >= v2.35.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachMetadata")]
    pub attach_metadata: Option<PodMonitorAttachMetadata>,
    /// bodySizeLimit when defined specifies a job level limit on the size
    /// of uncompressed response body that will be accepted by Prometheus.
    /// 
    /// It requires Prometheus >= v2.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodySizeLimit")]
    pub body_size_limit: Option<String>,
    /// convertClassicHistogramsToNHCB defines whether to convert all scraped classic histograms into a native histogram with custom buckets.
    /// It requires Prometheus >= v3.0.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "convertClassicHistogramsToNHCB")]
    pub convert_classic_histograms_to_nhcb: Option<bool>,
    /// fallbackScrapeProtocol defines the protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.
    /// 
    /// It requires Prometheus >= v3.0.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fallbackScrapeProtocol")]
    pub fallback_scrape_protocol: Option<PodMonitorFallbackScrapeProtocol>,
    /// jobLabel defines the label to use to retrieve the job name from.
    /// `jobLabel` selects the label from the associated Kubernetes `Pod`
    /// object which will be used as the `job` label for all metrics.
    /// 
    /// For example if `jobLabel` is set to `foo` and the Kubernetes `Pod`
    /// object is labeled with `foo: bar`, then Prometheus adds the `job="bar"`
    /// label to all ingested metrics.
    /// 
    /// If the value of this field is empty, the `job` label of the metrics
    /// defaults to the namespace and name of the PodMonitor object (e.g. `<namespace>/<name>`).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobLabel")]
    pub job_label: Option<String>,
    /// keepDroppedTargets defines the per-scrape limit on the number of targets dropped by relabeling
    /// that will be kept in memory. 0 means no limit.
    /// 
    /// It requires Prometheus >= v2.47.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepDroppedTargets")]
    pub keep_dropped_targets: Option<i64>,
    /// labelLimit defines the per-scrape limit on number of labels that will be accepted for a sample.
    /// 
    /// It requires Prometheus >= v2.27.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelLimit")]
    pub label_limit: Option<i64>,
    /// labelNameLengthLimit defines the per-scrape limit on length of labels name that will be accepted for a sample.
    /// 
    /// It requires Prometheus >= v2.27.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelNameLengthLimit")]
    pub label_name_length_limit: Option<i64>,
    /// labelValueLengthLimit defines the per-scrape limit on length of labels value that will be accepted for a sample.
    /// 
    /// It requires Prometheus >= v2.27.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelValueLengthLimit")]
    pub label_value_length_limit: Option<i64>,
    /// namespaceSelector defines in which namespace(s) Prometheus should discover the pods.
    /// By default, the pods are discovered in the same namespace as the `PodMonitor` object but it is possible to select pods across different/all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PodMonitorNamespaceSelector>,
    /// nativeHistogramBucketLimit defines ff there are more than this many buckets in a native histogram,
    /// buckets will be merged to stay within the limit.
    /// It requires Prometheus >= v2.45.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nativeHistogramBucketLimit")]
    pub native_histogram_bucket_limit: Option<i64>,
    /// nativeHistogramMinBucketFactor defines if the growth factor of one bucket to the next is smaller than this,
    /// buckets will be merged to increase the factor sufficiently.
    /// It requires Prometheus >= v2.50.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nativeHistogramMinBucketFactor")]
    pub native_histogram_min_bucket_factor: Option<IntOrString>,
    /// podMetricsEndpoints defines how to scrape metrics from the selected pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podMetricsEndpoints")]
    pub pod_metrics_endpoints: Option<Vec<PodMonitorPodMetricsEndpoints>>,
    /// podTargetLabels defines the labels which are transferred from the
    /// associated Kubernetes `Pod` object onto the ingested metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTargetLabels")]
    pub pod_target_labels: Option<Vec<String>>,
    /// sampleLimit defines a per-scrape limit on the number of scraped samples
    /// that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// scrapeClass defines the scrape class to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeClass")]
    pub scrape_class: Option<String>,
    /// scrapeClassicHistograms defines whether to scrape a classic histogram that is also exposed as a native histogram.
    /// It requires Prometheus >= v2.45.0.
    /// 
    /// Notice: `scrapeClassicHistograms` corresponds to the `always_scrape_classic_histograms` field in the Prometheus configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeClassicHistograms")]
    pub scrape_classic_histograms: Option<bool>,
    /// scrapeProtocols defines the protocols to negotiate during a scrape. It tells clients the
    /// protocols supported by Prometheus in order of preference (from most to least preferred).
    /// 
    /// If unset, Prometheus uses its default value.
    /// 
    /// It requires Prometheus >= v2.49.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeProtocols")]
    pub scrape_protocols: Option<Vec<String>>,
    /// selector defines the label selector to select the Kubernetes `Pod` objects to scrape metrics from.
    pub selector: PodMonitorSelector,
    /// selectorMechanism defines the mechanism used to select the endpoints to scrape.
    /// By default, the selection process relies on relabel configurations to filter the discovered targets.
    /// Alternatively, you can opt in for role selectors, which may offer better efficiency in large clusters.
    /// Which strategy is best for your use case needs to be carefully evaluated.
    /// 
    /// It requires Prometheus >= v2.17.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "selectorMechanism")]
    pub selector_mechanism: Option<PodMonitorSelectorMechanism>,
    /// targetLimit defines a limit on the number of scraped targets that will
    /// be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLimit")]
    pub target_limit: Option<i64>,
}

/// attachMetadata defines additional metadata which is added to the
/// discovered targets.
/// 
/// It requires Prometheus >= v2.35.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorAttachMetadata {
    /// node when set to true, Prometheus attaches node metadata to the discovered
    /// targets.
    /// 
    /// The Prometheus service account must have the `list` and `watch`
    /// permissions on the `Nodes` objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<bool>,
}

/// spec defines the specification of desired Pod selection for target discovery by Prometheus.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorFallbackScrapeProtocol {
    PrometheusProto,
    #[serde(rename = "OpenMetricsText0.0.1")]
    OpenMetricsText001,
    #[serde(rename = "OpenMetricsText1.0.0")]
    OpenMetricsText100,
    #[serde(rename = "PrometheusText0.0.4")]
    PrometheusText004,
    #[serde(rename = "PrometheusText1.0.0")]
    PrometheusText100,
}

/// namespaceSelector defines in which namespace(s) Prometheus should discover the pods.
/// By default, the pods are discovered in the same namespace as the `PodMonitor` object but it is possible to select pods across different/all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorNamespaceSelector {
    /// any defines the boolean describing whether all namespaces are selected in contrast to a
    /// list restricting them.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<bool>,
    /// matchNames defines the list of namespace names to select from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchNames")]
    pub match_names: Option<Vec<String>>,
}

/// PodMetricsEndpoint defines an endpoint serving Prometheus metrics to be scraped by
/// Prometheus.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpoints {
    /// authorization configures the Authorization header credentials used by
    /// the client.
    /// 
    /// Cannot be set at the same time as `basicAuth`, `bearerTokenSecret` or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<PodMonitorPodMetricsEndpointsAuthorization>,
    /// basicAuth defines the Basic Authentication credentials used by the
    /// client.
    /// 
    /// Cannot be set at the same time as `authorization`, `bearerTokenSecret` or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<PodMonitorPodMetricsEndpointsBasicAuth>,
    /// bearerTokenSecret defines a key of a Secret containing the bearer token
    /// used by the client for authentication. The secret needs to be in the
    /// same namespace as the custom resource and readable by the Prometheus
    /// Operator.
    /// 
    /// Cannot be set at the same time as `authorization`, `basicAuth` or `oauth2`.
    /// 
    /// Deprecated: use `authorization` instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<PodMonitorPodMetricsEndpointsBearerTokenSecret>,
    /// enableHttp2 can be used to disable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHttp2")]
    pub enable_http2: Option<bool>,
    /// filterRunning when true, the pods which are not running (e.g. either in Failed or
    /// Succeeded state) are dropped during the target discovery.
    /// 
    /// If unset, the filtering is enabled.
    /// 
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterRunning")]
    pub filter_running: Option<bool>,
    /// followRedirects defines whether the client should follow HTTP 3xx
    /// redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// honorLabels when true preserves the metric's labels when they collide
    /// with the target's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorLabels")]
    pub honor_labels: Option<bool>,
    /// honorTimestamps defines whether Prometheus preserves the timestamps
    /// when exposed by the target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorTimestamps")]
    pub honor_timestamps: Option<bool>,
    /// interval at which Prometheus scrapes the metrics from the target.
    /// 
    /// If empty, Prometheus uses the global scrape interval.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// metricRelabelings defines the relabeling rules to apply to the
    /// samples before ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelings")]
    pub metric_relabelings: Option<Vec<PodMonitorPodMetricsEndpointsMetricRelabelings>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// oauth2 defines the OAuth2 settings used by the client.
    /// 
    /// It requires Prometheus >= 2.27.0.
    /// 
    /// Cannot be set at the same time as `authorization`, `basicAuth` or `bearerTokenSecret`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<PodMonitorPodMetricsEndpointsOauth2>,
    /// params define optional HTTP URL parameters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, Vec<String>>>,
    /// path defines the HTTP path from which to scrape for metrics.
    /// 
    /// If empty, Prometheus uses the default value (e.g. `/metrics`).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// port defines the `Pod` port name which exposes the endpoint.
    /// 
    /// It takes precedence over the `portNumber` and `targetPort` fields.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// portNumber defines the `Pod` port number which exposes the endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portNumber")]
    pub port_number: Option<i32>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<PodMonitorPodMetricsEndpointsProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// relabelings defines the relabeling rules to apply the target's
    /// metadata labels.
    /// 
    /// The Operator automatically adds relabelings for a few standard Kubernetes fields.
    /// 
    /// The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
    /// 
    /// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relabelings: Option<Vec<PodMonitorPodMetricsEndpointsRelabelings>>,
    /// scheme defines the HTTP scheme to use for scraping.
    /// 
    /// `http` and `https` are the expected values unless you rewrite the
    /// `__scheme__` label via relabeling.
    /// 
    /// If empty, Prometheus uses the default value `http`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<PodMonitorPodMetricsEndpointsScheme>,
    /// scrapeTimeout defines the timeout after which Prometheus considers the scrape to be failed.
    /// 
    /// If empty, Prometheus uses the global scrape timeout unless it is less
    /// than the target's scrape interval value in which the latter is used.
    /// The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// targetPort defines the name or number of the target port of the `Pod` object behind the Service, the
    /// port must be specified with container port property.
    /// 
    /// Deprecated: use 'port' or 'portNumber' instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPort")]
    pub target_port: Option<IntOrString>,
    /// tlsConfig defines the TLS configuration used by the client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<PodMonitorPodMetricsEndpointsTlsConfig>,
    /// trackTimestampsStaleness defines whether Prometheus tracks staleness of
    /// the metrics that have an explicit timestamp present in scraped data.
    /// Has no effect if `honorTimestamps` is false.
    /// 
    /// It requires Prometheus >= v2.48.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trackTimestampsStaleness")]
    pub track_timestamps_staleness: Option<bool>,
}

/// authorization configures the Authorization header credentials used by
/// the client.
/// 
/// Cannot be set at the same time as `basicAuth`, `bearerTokenSecret` or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsAuthorization {
    /// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<PodMonitorPodMetricsEndpointsAuthorizationCredentials>,
    /// type defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// credentials defines a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// basicAuth defines the Basic Authentication credentials used by the
/// client.
/// 
/// Cannot be set at the same time as `authorization`, `bearerTokenSecret` or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsBasicAuth {
    /// password defines a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<PodMonitorPodMetricsEndpointsBasicAuthPassword>,
    /// username defines a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<PodMonitorPodMetricsEndpointsBasicAuthUsername>,
}

/// password defines a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// username defines a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// bearerTokenSecret defines a key of a Secret containing the bearer token
/// used by the client for authentication. The secret needs to be in the
/// same namespace as the custom resource and readable by the Prometheus
/// Operator.
/// 
/// Cannot be set at the same time as `authorization`, `basicAuth` or `oauth2`.
/// 
/// Deprecated: use `authorization` instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsMetricRelabelings {
    /// action to perform based on the regex matching.
    /// 
    /// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    /// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
    /// 
    /// Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<PodMonitorPodMetricsEndpointsMetricRelabelingsAction>,
    /// modulus to take of the hash of the source label values.
    /// 
    /// Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// regex defines the regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// replacement value against which a Replace action is performed if the
    /// regular expression matches.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// separator defines the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// sourceLabels defines the source labels select values from existing labels. Their content is
    /// concatenated using the configured Separator and matched against the
    /// configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// targetLabel defines the label to which the resulting string is written in a replacement.
    /// 
    /// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    /// `KeepEqual` and `DropEqual` actions.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorPodMetricsEndpointsMetricRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "Replace")]
    ReplaceX,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "Keep")]
    KeepX,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "Drop")]
    DropX,
    #[serde(rename = "hashmod")]
    Hashmod,
    HashMod,
    #[serde(rename = "labelmap")]
    Labelmap,
    LabelMap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    LabelDrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "Lowercase")]
    LowercaseX,
    #[serde(rename = "uppercase")]
    Uppercase,
    #[serde(rename = "Uppercase")]
    UppercaseX,
    #[serde(rename = "keepequal")]
    Keepequal,
    KeepEqual,
    #[serde(rename = "dropequal")]
    Dropequal,
    DropEqual,
}

/// oauth2 defines the OAuth2 settings used by the client.
/// 
/// It requires Prometheus >= 2.27.0.
/// 
/// Cannot be set at the same time as `authorization`, `basicAuth` or `bearerTokenSecret`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2 {
    /// clientId defines a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: PodMonitorPodMetricsEndpointsOauth2ClientId,
    /// clientSecret defines a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: PodMonitorPodMetricsEndpointsOauth2ClientSecret,
    /// endpointParams configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// proxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<PodMonitorPodMetricsEndpointsOauth2ProxyConnectHeader>>>,
    /// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// proxyUrl defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// scopes defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfig>,
    /// tokenUrl defines the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// clientId defines a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2ClientId {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PodMonitorPodMetricsEndpointsOauth2ClientIdConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PodMonitorPodMetricsEndpointsOauth2ClientIdSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// clientSecret defines a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2TlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2TlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2TlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PodMonitorPodMetricsEndpointsOauth2TlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorPodMetricsEndpointsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorPodMetricsEndpointsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsRelabelings {
    /// action to perform based on the regex matching.
    /// 
    /// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    /// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
    /// 
    /// Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<PodMonitorPodMetricsEndpointsRelabelingsAction>,
    /// modulus to take of the hash of the source label values.
    /// 
    /// Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// regex defines the regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// replacement value against which a Replace action is performed if the
    /// regular expression matches.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// separator defines the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// sourceLabels defines the source labels select values from existing labels. Their content is
    /// concatenated using the configured Separator and matched against the
    /// configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// targetLabel defines the label to which the resulting string is written in a replacement.
    /// 
    /// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    /// `KeepEqual` and `DropEqual` actions.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorPodMetricsEndpointsRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "Replace")]
    ReplaceX,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "Keep")]
    KeepX,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "Drop")]
    DropX,
    #[serde(rename = "hashmod")]
    Hashmod,
    HashMod,
    #[serde(rename = "labelmap")]
    Labelmap,
    LabelMap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    LabelDrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "Lowercase")]
    LowercaseX,
    #[serde(rename = "uppercase")]
    Uppercase,
    #[serde(rename = "Uppercase")]
    UppercaseX,
    #[serde(rename = "keepequal")]
    Keepequal,
    KeepEqual,
    #[serde(rename = "dropequal")]
    Dropequal,
    DropEqual,
}

/// PodMetricsEndpoint defines an endpoint serving Prometheus metrics to be scraped by
/// Prometheus.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorPodMetricsEndpointsScheme {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

/// tlsConfig defines the TLS configuration used by the client.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsTlsConfig {
    /// ca defines the Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<PodMonitorPodMetricsEndpointsTlsConfigCa>,
    /// cert defines the Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<PodMonitorPodMetricsEndpointsTlsConfigCert>,
    /// insecureSkipVerify defines how to disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// keySecret defines the Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<PodMonitorPodMetricsEndpointsTlsConfigKeySecret>,
    /// maxVersion defines the maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<PodMonitorPodMetricsEndpointsTlsConfigMaxVersion>,
    /// minVersion defines the minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<PodMonitorPodMetricsEndpointsTlsConfigMinVersion>,
    /// serverName is used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// ca defines the Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsTlsConfigCa {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PodMonitorPodMetricsEndpointsTlsConfigCaConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PodMonitorPodMetricsEndpointsTlsConfigCaSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// cert defines the Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsTlsConfigCert {
    /// configMap defines the ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PodMonitorPodMetricsEndpointsTlsConfigCertConfigMap>,
    /// secret defines the Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PodMonitorPodMetricsEndpointsTlsConfigCertSecret>,
}

/// configMap defines the ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// secret defines the Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// keySecret defines the Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorPodMetricsEndpointsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// tlsConfig defines the TLS configuration used by the client.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorPodMetricsEndpointsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// tlsConfig defines the TLS configuration used by the client.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorPodMetricsEndpointsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// selector defines the label selector to select the Kubernetes `Pod` objects to scrape metrics from.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PodMonitorSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// spec defines the specification of desired Pod selection for target discovery by Prometheus.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorSelectorMechanism {
    RelabelConfig,
    RoleSelector,
}

/// status defines the status subresource. It is under active development and is updated only when the
/// "StatusForConfigurationResources" feature gate is enabled.
/// 
/// Most recent observed status of the PodMonitor. Read-only.
/// More info:
/// <https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PodMonitorStatus {
    /// bindings defines the list of workload resources (Prometheus, PrometheusAgent, ThanosRuler or Alertmanager) which select the configuration resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bindings: Option<Vec<PodMonitorStatusBindings>>,
}

/// WorkloadBinding is a link between a configuration resource and a workload resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PodMonitorStatusBindings {
    /// conditions defines the current state of the configuration resource when bound to the referenced Workload object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// group defines the group of the referenced resource.
    pub group: PodMonitorStatusBindingsGroup,
    /// name defines the name of the referenced object.
    pub name: String,
    /// namespace defines the namespace of the referenced object.
    pub namespace: String,
    /// resource defines the type of resource being referenced (e.g. Prometheus, PrometheusAgent, ThanosRuler or Alertmanager).
    pub resource: PodMonitorStatusBindingsResource,
}

/// WorkloadBinding is a link between a configuration resource and a workload resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorStatusBindingsGroup {
    #[serde(rename = "monitoring.coreos.com")]
    MonitoringCoreosCom,
}

/// WorkloadBinding is a link between a configuration resource and a workload resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PodMonitorStatusBindingsResource {
    #[serde(rename = "prometheuses")]
    Prometheuses,
    #[serde(rename = "prometheusagents")]
    Prometheusagents,
    #[serde(rename = "thanosrulers")]
    Thanosrulers,
    #[serde(rename = "alertmanagers")]
    Alertmanagers,
}

