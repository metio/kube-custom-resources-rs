// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/projectcalico/calico/policy.networking.k8s.io/v1alpha2/clusternetworkpolicies.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// Spec defines the desired behavior of ClusterNetworkPolicy.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "policy.networking.k8s.io", version = "v1alpha2", kind = "ClusterNetworkPolicy", plural = "clusternetworkpolicies")]
#[kube(status = "ClusterNetworkPolicyStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct ClusterNetworkPolicySpec {
    /// Egress is the list of Egress rules to be applied to the selected pods.
    /// 
    /// A maximum of 25 rules is allowed in this block.
    /// 
    /// The relative precedence of egress rules within a single CNP object
    /// (all of which share the priority) will be determined by the order
    /// in which the rule is written.
    /// Thus, a rule that appears at the top of the egress rules
    /// would take the highest precedence.
    /// CNPs with no egress rules do not affect egress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress: Option<Vec<ClusterNetworkPolicyEgress>>,
    /// Ingress is the list of Ingress rules to be applied to the selected pods.
    /// 
    /// A maximum of 25 rules is allowed in this block.
    /// 
    /// The relative precedence of ingress rules within a single CNP object
    /// (all of which share the priority) will be determined by the order
    /// in which the rule is written.
    /// Thus, a rule that appears at the top of the ingress rules
    /// would take the highest precedence.
    /// CNPs with no ingress rules do not affect ingress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<Vec<ClusterNetworkPolicyIngress>>,
    /// Priority is a value from 0 to 1000 indicating the precedence of
    /// the policy within its tier. Policies with lower priority values have
    /// higher precedence, and are checked before policies with higher priority
    /// values in the same tier. All Admin tier rules have higher precedence than
    /// NetworkPolicy or Baseline tier rules.
    /// If two (or more) policies in the same tier with the same priority
    /// could match a connection, then the implementation can apply any of the
    /// matching policies to the connection, and there is no way for the user to
    /// reliably determine which one it will choose. Administrators must be
    /// careful about assigning the priorities for policies with rules that will
    /// match many connections, and ensure that policies have unique priority
    /// values in cases where ambiguity would be unacceptable.
    pub priority: i32,
    /// Subject defines the pods to which this ClusterNetworkPolicy applies.
    pub subject: ClusterNetworkPolicySubject,
    /// Tier is used as the top-level grouping for network policy prioritization.
    /// 
    /// Policy tiers are evaluated in the following order:
    /// * Admin tier
    /// * NetworkPolicy tier
    /// * Baseline tier
    /// 
    /// ClusterNetworkPolicy can use 2 of these tiers: Admin and Baseline.
    /// 
    /// The Admin tier takes precedence over all other policies. Policies
    /// defined in this tier are used to set cluster-wide security rules
    /// that cannot be overridden in the other tiers. If Admin tier has
    /// made a final decision (Accept or Deny) on a connection, then no
    /// further evaluation is done.
    /// 
    /// NetworkPolicy tier is the tier for the namespaced v1.NetworkPolicy.
    /// These policies are intended for the application developer to describe
    /// the security policy associated with their deployments inside their
    /// namespace. v1.NetworkPolicy always makes a final decision for selected
    /// pods. Further evaluation only happens for Pods not selected by a
    /// v1.NetworkPolicy.
    /// 
    /// Baseline tier is a cluster-wide policy that can be overridden by the
    /// v1.NetworkPolicy. If Baseline tier has made a final decision (Accept or
    /// Deny) on a connection, then no further evaluation is done.
    /// 
    /// If a given connection wasn't allowed or denied by any of the tiers,
    /// the default kubernetes policy is applied, which says that
    /// all pods can communicate with each other.
    pub tier: ClusterNetworkPolicyTier,
}

/// ClusterNetworkPolicyEgressRule describes an action to take on a particular
/// set of traffic originating from pods selected by a ClusterNetworkPolicy's
/// Subject field.
/// <network-policy-api:experimental:validation>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterNetworkPolicyEgress {
    /// Action specifies the effect this rule will have on matching
    /// traffic.  Currently the following actions are supported:
    /// 
    /// - Accept: Accepts the selected traffic, allowing it to
    ///   egress. No further ClusterNetworkPolicy or NetworkPolicy
    ///   rules will be processed.
    /// 
    /// - Deny: Drops the selected traffic. No further
    ///   ClusterNetworkPolicy or NetworkPolicy rules will be
    ///   processed.
    /// 
    /// - Pass: Skips all further ClusterNetworkPolicy rules in the
    ///   current tier for the selected traffic, and passes
    ///   evaluation to the next tier.
    pub action: ClusterNetworkPolicyEgressAction,
    /// Name is an identifier for this rule, that may be no more than
    /// 100 characters in length. This field should be used by the implementation
    /// to help improve observability, readability and error-reporting
    /// for any applied AdminNetworkPolicies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Ports allows for matching traffic based on port and protocols.
    /// This field is a list of destination ports for the outgoing egress traffic.
    /// If Ports is not set then the rule does not filter traffic via port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ClusterNetworkPolicyEgressPorts>>,
    /// To is the List of destinations whose traffic this rule applies to.
    /// If any element matches the destination of outgoing
    /// traffic then the specified action is applied.
    /// This field must be defined and contain at least one item.
    pub to: Vec<ClusterNetworkPolicyEgressTo>,
}

/// ClusterNetworkPolicyEgressRule describes an action to take on a particular
/// set of traffic originating from pods selected by a ClusterNetworkPolicy's
/// Subject field.
/// <network-policy-api:experimental:validation>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterNetworkPolicyEgressAction {
    Accept,
    Deny,
    Pass,
}

/// ClusterNetworkPolicyPort describes how to select destination network ports.
/// Exactly one field must be set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressPorts {
    /// Port selects a destination port based on protocol and port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portNumber")]
    pub port_number: Option<ClusterNetworkPolicyEgressPortsPortNumber>,
    /// PortRange selects a destination port range based on protocol and
    /// start and end port numbers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    pub port_range: Option<ClusterNetworkPolicyEgressPortsPortRange>,
}

/// Port selects a destination port based on protocol and port number.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressPortsPortNumber {
    /// Number defines a network port value.
    pub port: i32,
    /// Protocol is the network protocol (TCP, UDP, or SCTP) which traffic must
    /// match. If not specified, this field defaults to TCP.
    pub protocol: String,
}

/// PortRange selects a destination port range based on protocol and
/// start and end port numbers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressPortsPortRange {
    /// End defines a network port that is the end of a port range, the End value
    /// must be greater than Start.
    pub end: i32,
    /// Protocol is the network protocol (TCP, UDP, or SCTP) which traffic must
    /// match. If not specified, this field defaults to TCP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    /// Start defines a network port that is the start of a port range, the Start
    /// value must be less than End.
    pub start: i32,
}

/// ClusterNetworkPolicyEgressPeer defines a peer to allow traffic to.
/// 
/// Exactly one of the fields must be set for a given peer and this is enforced
/// by the validation rules on the CRD. If an implementation sees no fields are
/// set then it can infer that the deployed CRD is of an incompatible version
/// with an unknown field.  In that case it should fail closed.
/// 
/// For "Accept" rules, "fail closed" means: "treat the rule as matching no
/// traffic". For "Deny" and "Pass" rules, "fail closed" means: "treat the rule
/// as a 'Deny all' rule".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressTo {
    /// Namespaces defines a way to select all pods within a set of Namespaces.
    /// Note that host-networked pods are not included in this type of peer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<ClusterNetworkPolicyEgressToNamespaces>,
    /// Networks defines a way to select peers via CIDR blocks.
    /// This is intended for representing entities that live outside the cluster,
    /// which can't be selected by pods, namespaces and nodes peers, but note
    /// that cluster-internal traffic will be checked against the rule as
    /// well. So if you Accept or Deny traffic to `"0.0.0.0/0"`, that will allow
    /// or deny all IPv4 pod-to-pod traffic as well. If you don't want that,
    /// add a rule that Passes all pod traffic before the Networks rule.
    /// 
    /// Each item in Networks should be provided in the CIDR format and should be
    /// IPv4 or IPv6, for example "10.0.0.0/8" or "fd00::/8".
    /// 
    /// Networks can have upto 25 CIDRs specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networks: Option<Vec<String>>,
    /// Pods defines a way to select a set of pods in
    /// a set of namespaces. Note that host-networked pods
    /// are not included in this type of peer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pods: Option<ClusterNetworkPolicyEgressToPods>,
}

/// Namespaces defines a way to select all pods within a set of Namespaces.
/// Note that host-networked pods are not included in this type of peer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressToNamespaces {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterNetworkPolicyEgressToNamespacesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressToNamespacesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Pods defines a way to select a set of pods in
/// a set of namespaces. Note that host-networked pods
/// are not included in this type of peer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressToPods {
    /// NamespaceSelector follows standard label selector semantics; if empty,
    /// it selects all Namespaces.
    #[serde(rename = "namespaceSelector")]
    pub namespace_selector: ClusterNetworkPolicyEgressToPodsNamespaceSelector,
    /// PodSelector is used to explicitly select pods within a namespace;
    /// if empty, it selects all Pods.
    #[serde(rename = "podSelector")]
    pub pod_selector: ClusterNetworkPolicyEgressToPodsPodSelector,
}

/// NamespaceSelector follows standard label selector semantics; if empty,
/// it selects all Namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressToPodsNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterNetworkPolicyEgressToPodsNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressToPodsNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// PodSelector is used to explicitly select pods within a namespace;
/// if empty, it selects all Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressToPodsPodSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterNetworkPolicyEgressToPodsPodSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyEgressToPodsPodSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ClusterNetworkPolicyIngressRule describes an action to take on a particular
/// set of traffic destined for pods selected by a ClusterNetworkPolicy's
/// Subject field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterNetworkPolicyIngress {
    /// Action specifies the effect this rule will have on matching
    /// traffic. Currently the following actions are supported:
    /// 
    /// - Accept: Accepts the selected traffic, allowing it into
    ///   the destination. No further ClusterNetworkPolicy or
    ///   NetworkPolicy rules will be processed.
    /// 
    ///   Note: while Accept ensures traffic is accepted by
    ///   Kubernetes network policy, it is still possible that the
    ///   packet is blocked in other ways: custom nftable rules,
    ///   high-layers e.g. service mesh.
    /// 
    /// - Deny: Drops the selected traffic. No further
    ///   ClusterNetworkPolicy or NetworkPolicy rules will be
    ///   processed.
    /// 
    /// - Pass: Skips all further ClusterNetworkPolicy rules in the
    ///   current tier for the selected traffic, and passes
    ///   evaluation to the next tier.
    pub action: ClusterNetworkPolicyIngressAction,
    /// From is the list of sources whose traffic this rule applies to.
    /// If any element matches the source of incoming
    /// traffic then the specified action is applied.
    /// This field must be defined and contain at least one item.
    pub from: Vec<ClusterNetworkPolicyIngressFrom>,
    /// Name is an identifier for this rule, that may be no more than
    /// 100 characters in length. This field should be used by the implementation
    /// to help improve observability, readability and error-reporting
    /// for any applied AdminNetworkPolicies.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Ports allows for matching traffic based on port and protocols.
    /// This field is a list of ports which should be matched on
    /// the pods selected for this policy i.e the subject of the policy.
    /// So it matches on the destination port for the ingress traffic.
    /// If Ports is not set then the rule does not filter traffic via port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ClusterNetworkPolicyIngressPorts>>,
}

/// ClusterNetworkPolicyIngressRule describes an action to take on a particular
/// set of traffic destined for pods selected by a ClusterNetworkPolicy's
/// Subject field.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterNetworkPolicyIngressAction {
    Accept,
    Deny,
    Pass,
}

/// ClusterNetworkPolicyIngressPeer defines a peer to allow traffic from.
/// 
/// Exactly one of the fields must be set for a given peer and this is enforced
/// by the validation rules on the CRD. If an implementation sees no fields are
/// set then it can infer that the deployed CRD is of an incompatible version
/// with an unknown field.  In that case it should fail closed.
/// 
/// For "Accept" rules, "fail closed" means: "treat the rule as matching no
/// traffic". For "Deny" and "Pass" rules, "fail closed" means: "treat the rule
/// as a 'Deny all' rule".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressFrom {
    /// Namespaces defines a way to select all pods within a set of Namespaces.
    /// Note that host-networked pods are not included in this type of peer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<ClusterNetworkPolicyIngressFromNamespaces>,
    /// Pods defines a way to select a set of pods in
    /// a set of namespaces. Note that host-networked pods
    /// are not included in this type of peer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pods: Option<ClusterNetworkPolicyIngressFromPods>,
}

/// Namespaces defines a way to select all pods within a set of Namespaces.
/// Note that host-networked pods are not included in this type of peer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressFromNamespaces {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterNetworkPolicyIngressFromNamespacesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressFromNamespacesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Pods defines a way to select a set of pods in
/// a set of namespaces. Note that host-networked pods
/// are not included in this type of peer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressFromPods {
    /// NamespaceSelector follows standard label selector semantics; if empty,
    /// it selects all Namespaces.
    #[serde(rename = "namespaceSelector")]
    pub namespace_selector: ClusterNetworkPolicyIngressFromPodsNamespaceSelector,
    /// PodSelector is used to explicitly select pods within a namespace;
    /// if empty, it selects all Pods.
    #[serde(rename = "podSelector")]
    pub pod_selector: ClusterNetworkPolicyIngressFromPodsPodSelector,
}

/// NamespaceSelector follows standard label selector semantics; if empty,
/// it selects all Namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressFromPodsNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterNetworkPolicyIngressFromPodsNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressFromPodsNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// PodSelector is used to explicitly select pods within a namespace;
/// if empty, it selects all Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressFromPodsPodSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterNetworkPolicyIngressFromPodsPodSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressFromPodsPodSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ClusterNetworkPolicyPort describes how to select destination network ports.
/// Exactly one field must be set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressPorts {
    /// Port selects a destination port based on protocol and port number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portNumber")]
    pub port_number: Option<ClusterNetworkPolicyIngressPortsPortNumber>,
    /// PortRange selects a destination port range based on protocol and
    /// start and end port numbers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portRange")]
    pub port_range: Option<ClusterNetworkPolicyIngressPortsPortRange>,
}

/// Port selects a destination port based on protocol and port number.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressPortsPortNumber {
    /// Number defines a network port value.
    pub port: i32,
    /// Protocol is the network protocol (TCP, UDP, or SCTP) which traffic must
    /// match. If not specified, this field defaults to TCP.
    pub protocol: String,
}

/// PortRange selects a destination port range based on protocol and
/// start and end port numbers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyIngressPortsPortRange {
    /// End defines a network port that is the end of a port range, the End value
    /// must be greater than Start.
    pub end: i32,
    /// Protocol is the network protocol (TCP, UDP, or SCTP) which traffic must
    /// match. If not specified, this field defaults to TCP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    /// Start defines a network port that is the start of a port range, the Start
    /// value must be less than End.
    pub start: i32,
}

/// Subject defines the pods to which this ClusterNetworkPolicy applies.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicySubject {
    /// Namespaces is used to select pods via namespace selectors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<ClusterNetworkPolicySubjectNamespaces>,
    /// Pods is used to select pods via namespace AND pod selectors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pods: Option<ClusterNetworkPolicySubjectPods>,
}

/// Namespaces is used to select pods via namespace selectors.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicySubjectNamespaces {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterNetworkPolicySubjectNamespacesMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicySubjectNamespacesMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Pods is used to select pods via namespace AND pod selectors.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicySubjectPods {
    /// NamespaceSelector follows standard label selector semantics; if empty,
    /// it selects all Namespaces.
    #[serde(rename = "namespaceSelector")]
    pub namespace_selector: ClusterNetworkPolicySubjectPodsNamespaceSelector,
    /// PodSelector is used to explicitly select pods within a namespace;
    /// if empty, it selects all Pods.
    #[serde(rename = "podSelector")]
    pub pod_selector: ClusterNetworkPolicySubjectPodsPodSelector,
}

/// NamespaceSelector follows standard label selector semantics; if empty,
/// it selects all Namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicySubjectPodsNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterNetworkPolicySubjectPodsNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicySubjectPodsNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// PodSelector is used to explicitly select pods within a namespace;
/// if empty, it selects all Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicySubjectPodsPodSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterNetworkPolicySubjectPodsPodSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicySubjectPodsPodSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Spec defines the desired behavior of ClusterNetworkPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterNetworkPolicyTier {
    Admin,
    Baseline,
}

/// Status is the status to be reported by the implementation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterNetworkPolicyStatus {
    pub conditions: Vec<Condition>,
}

