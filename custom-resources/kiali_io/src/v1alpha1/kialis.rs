// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/kiali/kiali-operator/kiali.io/v1alpha1/kialis.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// This is the CRD for the resources called Kiali CRs. The Kiali Operator will watch for resources of this type and when it detects a Kiali CR has been added, deleted, or modified, it will install, uninstall, and update the associated Kiali Server installation. The settings here will configure the Kiali Server as well as the Kiali Operator. All of these settings will be stored in the Kiali ConfigMap. Do not modify the ConfigMap; it will be managed by the Kiali Operator. Only modify the Kiali CR when you want to change a configuration setting.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "kiali.io", version = "v1alpha1", kind = "Kiali", plural = "kialis")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct KialiSpec {
    /// A list of additional details that Kiali will look for in annotations. When found on any workload or service, Kiali will display the additional details in the respective workload or service details page. This is typically used to inject some CI metadata or documentation links into Kiali views. For example, by default, Kiali will recognize these annotations on a service or workload (e.g. a Deployment, StatefulSet, etc.):
    /// ```text
    /// spec:
    ///   annotations:
    ///     kiali.io/api-spec: <http://list/to/my/api/doc>
    ///     kiali.io/api-type: rest
    /// ```
    /// Note that if you change this setting for your own custom annotations, keep in mind that it would override the current default. So you would have to add the default setting as shown in the example CR if you want to preserve the default links.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub additional_display_details: Option<Vec<KialiAdditionalDisplayDetails>>,
    /// DEPRECATED AFTER v1.73: These settings control how the Kiali API should be accessed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api: Option<KialiApi>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<KialiAuth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub chat_ai: Option<KialiChatAi>,
    /// Multi-cluster related features.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clustering: Option<KialiClustering>,
    /// A list of user-defined custom monitoring dashboards that you can use to generate metrics charts
    /// for your applications. The server has some built-in dashboards; if you define a custom dashboard here
    /// with the same name as a built-in dashboard, your custom dashboard takes precedence and will overwrite
    /// the built-in dashboard. You can disable one or more of the built-in dashboards by simply defining an
    /// empty dashboard.
    /// 
    /// An example of an additional user-defined dashboard,
    /// ```text
    /// spec:
    ///   custom_dashboards:
    ///   - name: myapp
    ///     title: My App Metrics
    ///     items:
    ///     - chart:
    ///         name: "Thread Count"
    ///         spans: 4
    ///         metricName: "thread-count"
    ///         dataType: "raw"
    /// ```
    /// 
    /// An example of disabling a built-in dashboard (in this case, disabling the Envoy dashboard),
    /// ```text
    /// spec:
    ///   custom_dashboards:
    ///   - name: envoy
    /// ```
    /// 
    /// To learn more about custom monitoring dashboards, see the documentation at <https://kiali.io/docs/configuration/custom-dashboard/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_dashboards: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<KialiDeployment>,
    /// Defines third-party extensions whose metrics can be integrated into the Kiali traffic graph.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extensions: Option<Vec<KialiExtensions>>,
    /// These external service configuration settings define how to connect to the external services
    /// like Prometheus, Grafana, and Jaeger.
    /// 
    /// Regarding sensitive values in the external_services 'auth' sections:
    /// Some external services configured below support an 'auth' sub-section in order to tell Kiali
    /// how it should authenticate with the external services. Credentials used to authenticate Kiali
    /// to those external services can be defined in the `auth.password` and `auth.token` values
    /// within the `auth` sub-section. Because these are sensitive values, you may not want to declare
    /// the actual credentials here in the Kiali CR. In this case, you may store the actual password
    /// or token string in a Kubernetes secret. If you do, you need to set the `auth.password` or
    /// `auth.token` to a value in the format `secret:<secretName>:<secretKey>` where `<secretName>`
    /// is the name of the secret object that Kiali can access, and `<secretKey>` is the name of the
    /// key within the named secret that contains the actual password or token string. For example,
    /// if Grafana requires a password, you can store that password in a secret named 'myGrafanaCredentials'
    /// in a key named 'myGrafanaPw'. In this case, you would set `external_services.grafana.auth.password`
    /// to `secret:myGrafanaCredentials:myGrafanaPw`.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub external_services: Option<KialiExternalServices>,
    /// This section defines what it means for nodes to be healthy. For more details, see <https://kiali.io/docs/configuration/health/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health_config: Option<KialiHealthConfig>,
    /// Settings that define the Kiali server identity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<KialiIdentity>,
    /// Tag used to identify a particular instance/installation of the Kiali server. This is merely a human-readable string that will be used within Kiali to help a user identify the Kiali being used (e.g. in the Kiali UI title bar). See `deployment.instance_name` for the setting used to customize Kiali resource names that are created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub installation_tag: Option<String>,
    /// Defines specific labels used by Istio that Kiali needs to know about.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_labels: Option<KialiIstioLabels>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The namespace where Istio is installed is now autodetected. If left empty, it was previously assumed to be the same namespace as where Kiali is installed (i.e. `deployment.namespace`).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_namespace: Option<String>,
    /// Kiali features that can be enabled or disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kiali_feature_flags: Option<KialiKialiFeatureFlags>,
    /// Unstructured section for internal testing and debugging features.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kiali_internal: Option<BTreeMap<String, serde_json::Value>>,
    /// Configuration of Kiali's access of the Kubernetes API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kubernetes_config: Option<KialiKubernetesConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub login_token: Option<KialiLoginToken>,
    /// Configuration that controls some core components within the Kiali Server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server: Option<KialiServer>,
    /// The version of the Ansible role that will be executed in order to install Kiali.
    /// This also indirectly determines the version of Kiali that will be installed.
    /// You normally will want to use `default` since this is the only officially supported value today.
    /// 
    /// If not specified, the value of `default` is assumed which means the most recent Ansible role is used;
    /// thus the most recent release of Kiali will be installed.
    /// 
    /// Refer to this file to see what the valid values are for this `version` field (as defined in the master branch),
    /// <https://github.com/kiali/kiali-operator/blob/master/playbooks/kiali-default-supported-images.yml>
    /// 
    /// This `version` setting affects the defaults of the `deployment.image_name` and
    /// `deployment.image_version` settings. See the documentation for those settings below for
    /// additional details. In short, this `version` setting will dictate which version of the
    /// Kiali image will be deployed by default. However, if you explicitly set `deployment.image_name`
    /// and/or `deployment.image_version` to reference your own custom image, that will override the
    /// default Kiali image to be installed; therefore, you are responsible for ensuring those settings
    /// are compatible with the Ansible role that will be executed in order to install Kiali (i.e. your
    /// custom Kiali image must be compatible with the rest of the configuration and resources the
    /// operator will install).
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiAdditionalDisplayDetails {
    /// The name of the annotation whose value is a URL to additional documentation useful to the user.
    pub annotation: String,
    /// The name of the annotation whose value is used to determine what icon to display. The annotation name itself can be anything, but note that the value of that annotation must be one of: `rest`, `grpc`, and `graphql` - any other value is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icon_annotation: Option<String>,
    /// The title of the link that Kiali will display. The link will go to the URL specified in the value of the configured `annotation`.
    pub title: String,
}

/// DEPRECATED AFTER v1.73: These settings control how the Kiali API should be accessed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiApi {
    /// DEPRECATED AFTER v1.73: Settings for the API namespaces feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<KialiApiNamespaces>,
}

/// DEPRECATED AFTER v1.73: Settings for the API namespaces feature.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiApiNamespaces {
    /// DEPRECATED AFTER v1.73: A list of namespace names that will be excluded from Kiali API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exclude: Option<Vec<String>>,
    /// DEPRECATED AFTER v1.73: A list of namespace names that will be included in Kiali API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub include: Option<Vec<String>>,
    /// DEPRECATED AFTER v1.73: A Kubernetes label selector expression that will be used to exclude namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label_selector_exclude: Option<String>,
    /// DEPRECATED AFTER v1.73: A Kubernetes label selector expression that will be used to include namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label_selector_include: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiAuth {
    /// To learn more about these settings and how to configure the OpenId authentication strategy, read the documentation at <https://kiali.io/docs/configuration/authentication/openid/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub openid: Option<KialiAuthOpenid>,
    /// To learn more about these settings and how to configure the OpenShift authentication strategy, read the documentation at <https://kiali.io/docs/configuration/authentication/openshift/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub openshift: Option<KialiAuthOpenshift>,
    /// Determines what authentication strategy to use when users log into Kiali.
    /// Options are `anonymous`, `token`, `openshift`, `openid`, or `header`.
    /// 
    /// * Choose `anonymous` to allow full access to Kiali without requiring any credentials.
    /// * Choose `token` to allow access to Kiali using service account tokens, which controls
    /// access based on RBAC roles assigned to the service account.
    /// * Choose `openshift` to use the OpenShift OAuth login which controls access based on
    /// the individual's RBAC roles in OpenShift. Not valid for non-OpenShift environments.
    /// * Choose `openid` to enable OpenID Connect-based authentication. Your cluster is required to
    /// be configured to accept the tokens issued by your IdP. There are additional required
    /// configurations for this strategy. See below for the additional OpenID configuration section.
    /// * Choose `header` when Kiali is running behind a reverse proxy that will inject an
    /// Authorization header and potentially impersonation headers.
    /// 
    /// When empty, this value will default to `openshift` on OpenShift and `token` on other Kubernetes environments.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<KialiAuthStrategy>,
}

/// To learn more about these settings and how to configure the OpenId authentication strategy, read the documentation at <https://kiali.io/docs/configuration/authentication/openid/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiAuthOpenid {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub additional_request_params: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allowed_domains: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_proxy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_proxy_ca_data: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_token: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication_timeout: Option<i64>,
    /// DEPRECATED since v2.21: Use auth.openid.discovery_override.authorization_endpoint instead. The URL of the provider's authorization endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization_endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable_rbac: Option<bool>,
    /// Optional configuration to override OpenID Connect auto-discovery. Use when the IdP restricts access to /.well-known/openid-configuration endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discovery_override: Option<KialiAuthOpenidDiscoveryOverride>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_proxy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub https_proxy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure_skip_verify_tls: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issuer_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username_claim: Option<String>,
}

/// Optional configuration to override OpenID Connect auto-discovery. Use when the IdP restricts access to /.well-known/openid-configuration endpoint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiAuthOpenidDiscoveryOverride {
    /// The URL of the provider's authorization endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization_endpoint: Option<String>,
    /// The URL of the provider's JWK Set document.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwks_uri: Option<String>,
    /// The URL of the provider's token endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token_endpoint: Option<String>,
    /// The URL of the provider's UserInfo endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub userinfo_endpoint: Option<String>,
}

/// To learn more about these settings and how to configure the OpenShift authentication strategy, read the documentation at <https://kiali.io/docs/configuration/authentication/openshift/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiAuthOpenshift {
    /// DEPRECATED AFTER v1.73: The amount of time in seconds Kiali will wait for a response from the OpenShift API when requesting authentication information.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_timeout: Option<i64>,
    /// DEPRECATED AFTER v1.73: A prefix that will be applied to the OpenShift OAuth client identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_id_prefix: Option<String>,
    /// Set true to skip verifying certificate validity when Kiali contacts OpenShift over https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure_skip_verify_tls: Option<bool>,
    /// Custom redirect URIs for the OpenShift OAuth client. These URIs specify where users will be redirected after successful authentication. If not specified, Kiali will automatically generate appropriate redirect URIs based on the Kiali server's route. You normally do not have to set this unless you are creating remote cluster resources (see `deployment.remote_cluster_resources_only`) with `auth.strategy` set to `openshift`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redirect_uris: Option<Vec<String>>,
    /// Sets the maximum time in seconds that can elapse between consecutive uses of an OAuth access token before it expires due to inactivity. This helps improve security by automatically expiring unused tokens. If set to 0, tokens will not expire due to inactivity. Note that OpenShift may enforce minimum values for this setting, and existing tokens are not affected by changes to this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token_inactivity_timeout: Option<i64>,
    /// Sets the absolute maximum lifetime in seconds for OAuth access tokens, regardless of activity. After this time period, tokens will expire and users must re-authenticate. If set to 0, tokens will not have an absolute expiration time and will only expire due to inactivity (if token_inactivity_timeout is configured).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token_max_age: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiAuthStrategy {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "anonymous")]
    Anonymous,
    #[serde(rename = "token")]
    Token,
    #[serde(rename = "openshift")]
    Openshift,
    #[serde(rename = "openid")]
    Openid,
    #[serde(rename = "header")]
    Header,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiChatAi {
    /// The default provider to use for the ChatAI feature. This is the provider that will be used if no provider is specified in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_provider: Option<String>,
    /// Enable or disable the ChatAI feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// A list of providers that can be used for the ChatAI feature. This is the list of providers that will be available to the user to choose from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub providers: Option<Vec<KialiChatAiProviders>>,
    /// Configuration for the ChatAI store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub store_config: Option<KialiChatAiStoreConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiChatAiProviders {
    /// The type of the config needed by the AI models provider. Available values are `default`, `gemini`, and `azure`. Default value is `default`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<String>,
    /// The default model of the provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default_model: Option<String>,
    /// The description of the provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Enable or disable the provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The key of the provider. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the token is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// A list of models that can be used for the ChatAI feature. This is the list of models that will be available to the user to choose from.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub models: Option<Vec<KialiChatAiProvidersModels>>,
    /// The name of the provider.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The type of the AI models provider. Available values are `openai`. Default value is `openai`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiChatAiProvidersModels {
    /// The description of the model.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Enable or disable the model.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The endpoint of the model.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// The key of the model. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the token is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The model of the model.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub model: Option<String>,
    /// The name of the model.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Configuration for the ChatAI store.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiChatAiStoreConfig {
    /// Enable or disable the ChatAI store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The maximum cache memory for the ChatAI store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_cache_memory_mb: Option<i64>,
    /// The threshold for the ChatAI store reduction with AI. This is the number of messages in a conversation before the conversation is reduced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reduce_threshold: Option<i64>,
    /// Enable or disable the ChatAI store reduction with AI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reduce_with_ai: Option<bool>,
}

/// Multi-cluster related features.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiClustering {
    /// Settings to allow cluster secrets to be auto-detected. Secrets must exist in the Kiali deployment namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autodetect_secrets: Option<KialiClusteringAutodetectSecrets>,
    /// A list of clusters that the Kiali Server can access. You need to specify the remote clusters here if 'autodetect_secrets.enabled' is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clusters: Option<Vec<KialiClusteringClusters>>,
    /// Flag to enable exec provider for clustering authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable_exec_provider: Option<bool>,
    /// Set to true for an external Kiali deployment, or if Kiali should not try to discover Istio on the home cluster. When set to `true`, it is required to set `kubernetes_config.cluster_name`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore_home_cluster: Option<bool>,
    /// A map between cluster name, instance name and namespace to a Kiali URL. Will be used showing the Mesh page's Kiali URLs. The Kiali service's 'kiali.io/external-url' annotation will be overridden when this property is set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kiali_urls: Option<Vec<KialiClusteringKialiUrls>>,
}

/// Settings to allow cluster secrets to be auto-detected. Secrets must exist in the Kiali deployment namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiClusteringAutodetectSecrets {
    /// If true then remote cluster secrets will be autodetected during the installation of the Kiali Server Deployment. Any remote cluster secrets found in the Kiali deployment namespace will be mounted to the Kiali Server's file system. If false, you can still manually specify the remote cluster secret information in the 'clusters' setting if you wish to utilize multicluster features.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The name and value of a label that exists on all remote cluster secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiClusteringClusters {
    /// The name of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The name of the secret that contains the credentials necessary to connect to the remote cluster. This secret must exist in the Kiali deployment namespace. If a secret name is not provided then it's assumed that the cluster is inaccessible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiClusteringKialiUrls {
    /// The name of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster_name: Option<String>,
    /// The instance name of this Kiali installation. This should be the value used in `deployment.instance_name` for Kiali resource name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instance_name: Option<String>,
    /// The namespace into which Kiali is installed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The URL of Kiali in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeployment {
    /// DEPRECATED AFTER v1.73: A list of namespaces Kiali is allowed to access. This replaces discovery selectors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub accessible_namespaces: Option<Vec<String>>,
    /// Additional containers to add to the list of pod containers. Use this to add container(s) to the Kiali pod. SECURITY: By default, the operator will forcibly apply a restrictive security context to all containers (allowPrivilegeEscalation: false, privileged: false, readOnlyRootFilesystem: true, runAsNonRoot: true, capabilities dropped). However, if the operator's ALLOW_SECURITY_CONTEXT_OVERRIDE environment variable is set to 'true', containers can define their own security contexts which will be preserved. Secret-backed volumes are automatically forced to read-only regardless of the security context override setting. Use with care since containers may cause the Kiali container itself to operate incorrectly. It is up to the user who added the additional containers to ensure it works properly inside the Kiali pod; Kiali makes no guarantee additional containers will work.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub additional_pod_containers_yaml: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// Additional initContainers to add to the list of pod initContainers. Use this to add initContainer(s) to the Kiali pod. SECURITY: By default, the operator will forcibly apply a restrictive security context to all initContainers (allowPrivilegeEscalation: false, privileged: false, readOnlyRootFilesystem: true, runAsNonRoot: true, capabilities dropped). However, if the operator's ALLOW_SECURITY_CONTEXT_OVERRIDE environment variable is set to 'true', initContainers can define their own security contexts which will be preserved. Secret-backed volumes are automatically forced to read-only regardless of the security context override setting. Use with care since initContainers may cause the Kiali container itself to operate incorrectly. It is up to the user who added the additional initContainers to ensure it works properly inside the Kiali pod; Kiali makes no guarantee additional initContainers will work.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub additional_pod_init_containers_yaml: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// Additional custom yaml to add to the service definition. This is used mainly to customize the service type. For example, if the `deployment.service_type` is set to 'LoadBalancer' and you want to set the loadBalancerIP, you can do so here with: `additional_service_yaml: { 'loadBalancerIP': '78.11.24.19' }`. Another example would be if the `deployment.service_type` is set to 'ExternalName' you will need to configure the name via: `additional_service_yaml: { 'externalName': 'my.kiali.example.com' }`. A final example would be if external IPs need to be set: `additional_service_yaml: { 'externalIPs': ['80.11.12.10'] }`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub additional_service_yaml: Option<BTreeMap<String, serde_json::Value>>,
    /// Affinity definitions that are to be used to define the nodes where the Kiali pod should be constrained. See the Kubernetes documentation on Assigning Pods to Nodes for the proper syntax for these three different affinity types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<KialiDeploymentAffinity>,
    /// Determines if the Kiali server will be granted cluster-wide permissions to see all namespaces. When true, this provides more efficient caching within the Kiali server. It must be `true` if `deployment.discovery_selectors.default` is left unset. To limit the namespaces for which Kiali has permissions, set to `false` and define the desired selectors in `deployment.discovery_selectors.default`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster_wide_access: Option<bool>,
    /// Custom annotations to be created on the Kiali ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configmap_annotations: Option<BTreeMap<String, String>>,
    /// Defines additional environment variables to be set in the Kiali server pod. This is typically used for (but not limited to) setting proxy environment variables such as HTTP_PROXY, HTTPS_PROXY, and/or NO_PROXY.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_envs: Option<Vec<KialiDeploymentCustomEnvs>>,
    /// Defines additional secrets that are to be mounted in the Kiali pod.
    /// 
    /// These are useful to contain client certificates that are used by Kiali to authenticate to third party systems
    /// using mTLS (for example, see `external_services.tracing.auth.cert_file` and `external_services.tracing.auth.key_file`).
    /// 
    /// These secrets must be created by an external mechanism. Kiali will not generate these secrets; it
    /// is assumed these secrets are externally managed. You can define 0, 1, or more secrets.
    /// An example configuration is,
    /// ```text
    /// spec:
    ///   deployment:
    ///     custom_secrets:
    ///     - name: mysecret
    ///       mount: /mysecret-path
    ///     - name: my-other-secret
    ///       mount: /my-other-secret-location
    ///       optional: true
    /// ```
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_secrets: Option<Vec<KialiDeploymentCustomSecrets>>,
    /// Discovery selectors used to determine which namespaces are accessible to Kiali and which namespaces are visible to Kiali users.
    /// You can define discovery selectors to match namespaces on the local cluster as well as remote clusters.
    /// The list of namespaces that a user can access is a subset of these namespaces, given that user's RBAC permissions.
    /// These selectors will have similar semantics as defined by Istio ( <https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig> )
    /// and the syntax of the equality-based and set-based label selectors are documented by Kubernetes here
    /// ( <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#resources-that-support-set-based-requirements> )
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discovery_selectors: Option<KialiDeploymentDiscoverySelectors>,
    /// The Kiali server pod's DNS configuration. Kubernetes supports different DNS policies and configurations.
    /// For further details, consult the Kubernetes documentation - <https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<KialiDeploymentDns>,
    /// Extra name/value pairs to be added to the labels of all resources created by the operator.
    /// These are added to the labels the operator creates by default. These will not overwrite
    /// labels that the operator creates itself. For example, if you set "app.kubernetes.io/name"
    /// as an extra label, it will be silently ignored because that is one of the labels the operator
    /// creates on all resources.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra_labels: Option<BTreeMap<String, String>>,
    /// This is content for the Kubernetes 'hostAliases' setting for the Kiali server.
    /// This allows you to modify the Kiali server pod '/etc/hosts' file.
    /// A typical way to configure this setting is,
    /// ```text
    /// spec:
    ///   deployment:
    ///     host_aliases:
    ///     - ip: 192.168.1.100
    ///       hostnames:
    ///       - "foo.local"
    ///       - "bar.local"
    /// ```
    /// For details on the content of this setting, see <https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/#adding-additional-entries-with-hostaliases>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host_aliases: Option<Vec<KialiDeploymentHostAliases>>,
    /// Determines what (if any) HorizontalPodAutoscaler should be created to autoscale the Kiali pod.
    /// A typical way to configure HPA for Kiali is,
    /// ```text
    /// spec:
    ///   deployment:
    ///     hpa:
    ///       api_version: "autoscaling/v2"
    ///       spec:
    ///         maxReplicas: 2
    ///         minReplicas: 1
    ///         metrics:
    ///         - type: Resource
    ///           resource:
    ///             name: cpu
    ///             target:
    ///               type: Utilization
    ///               averageUtilization: 50
    /// ```
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hpa: Option<KialiDeploymentHpa>,
    /// If `deployment.image_version` is a digest hash, this value indicates what type of digest it is. A typical value would be 'sha256'. Note: do NOT prefix this value with a '@'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_digest: Option<String>,
    /// Determines which Kiali image to download and install. If you set this to a specific name (i.e. you do not leave it as the default empty string), you must make sure that image is supported by the operator. If empty, the operator will use a known supported image name based on which `version` was defined. Note that, as a security measure, a cluster admin may have configured the Kiali operator to ignore this setting. A cluster admin may do this to ensure the Kiali operator only installs a single, specific Kiali version, thus this setting may have no effect depending on how the operator itself was configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_name: Option<String>,
    /// The Kubernetes pull policy for the Kiali deployment. This is overridden to be 'Always' if `deployment.image_version` is set to 'latest'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_pull_policy: Option<String>,
    /// The names of the secrets to be used when container images are to be pulled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_pull_secrets: Option<Vec<String>>,
    /// Determines which version of Kiali to install.
    /// Choose 'lastrelease' to use the last Kiali release.
    /// Choose 'latest' to use the latest image (which may or may not be a released version of Kiali).
    /// Choose 'operator_version' to use the image whose version is the same as the operator version.
    /// Otherwise, you can set this to any valid Kiali version (such as 'v1.0') or any valid Kiali
    /// digest hash (if you set this to a digest hash, you must indicate the digest in `deployment.image_digest`).
    /// 
    /// Note that if this is set to 'latest' then the `deployment.image_pull_policy` will be set to 'Always'.
    /// 
    /// If you set this to a specific version (i.e. you do not leave it as the default empty string),
    /// you must make sure that image is supported by the operator.
    /// 
    /// If empty, the operator will use a known supported image version based on which 'version' was defined.
    /// Note that, as a security measure, a cluster admin may have configured the Kiali operator to
    /// ignore this setting. A cluster admin may do this to ensure the Kiali operator only installs
    /// a single, specific Kiali version, thus this setting may have no effect depending on how the
    /// operator itself was configured.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image_version: Option<String>,
    /// Configures if/how the Kiali endpoint should be exposed externally.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<KialiDeploymentIngress>,
    /// The instance name of this Kiali installation. This instance name will be the prefix prepended to the names of all Kiali resources created by the operator and will be used to label those resources as belonging to this Kiali installation instance. You cannot change this instance name after a Kiali CR is created. If you attempt to change it, the operator will abort with an error. If you want to change it, you must first delete the original Kiali CR and create a new one. Note that this does not affect the name of the auto-generated signing key secret. If you do not supply a signing key, the operator will create one for you in a secret, but that secret will always be named 'kiali-signing-key' and shared across all Kiali instances in the same deployment namespace. If you want a different signing key secret, you are free to create your own and tell the operator about it via `login_token.signing_key`. See the docs on that setting for more details. Note also that if you are setting this value, you may also want to change the `installation_tag` setting, but this is not required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instance_name: Option<String>,
    /// Configures the logger that emits messages to the Kiali server pod logs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logger: Option<KialiDeploymentLogger>,
    /// The namespace into which Kiali is to be installed. If this is empty or not defined, the default will be the namespace where the Kiali CR is located.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Configures if the Kiali server pod should be protected by a NetworkPolicy resource that restricts both ingress and egress traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub network_policy: Option<KialiDeploymentNetworkPolicy>,
    /// A set of node labels that dictate onto which node the Kiali pod will be deployed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_selector: Option<BTreeMap<String, serde_json::Value>>,
    /// Custom annotations to be created on the Kiali pod.
    /// By default, the following annotation is applied:
    /// ```text
    /// proxy.istio.io/config: '{ "holdApplicationUntilProxyStarts": true }'
    /// ```
    /// If you define your own pod_annotations, they will overwrite this default.
    /// To retain the default behavior while adding your own annotations,
    /// make sure to include this value alongside your custom annotations.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pod_annotations: Option<BTreeMap<String, String>>,
    /// Custom labels to be created on the Kiali pod.
    /// An example use for this setting is to inject an Istio sidecar such as,
    /// ```text
    /// sidecar.istio.io/inject: "true"
    /// ```
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pod_labels: Option<BTreeMap<String, String>>,
    /// The priorityClassName used to assign the priority of the Kiali pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority_class_name: Option<String>,
    /// Configures the liveness, readiness, and startup probes of the Kiali pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<KialiDeploymentProbes>,
    /// When `true`, only those resources necessary for a remote Kiali Server to access this cluster are created (such as the service account and roles/bindings). There will be no Kiali Server deployment/pod created when this is `true`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remote_cluster_resources_only: Option<bool>,
    /// The replica count for the Kiail deployment. If `deployment.hpa` is specified, this setting is ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i64>,
    /// Defines compute resources that are to be given to the Kiali pod's container. The value is a dict as defined by Kubernetes. See the Kubernetes documentation (<https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container).>
    /// If you set this to an empty dict (`{}`) then no resources will be defined in the Deployment.
    /// If you do not set this at all, the default is,
    /// ```text
    /// spec:
    ///   deployment:
    ///     resources:
    ///       requests:
    ///         cpu: "10m"
    ///         memory: "64Mi"
    ///       limits:
    ///         memory: "1Gi"
    /// ```
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<BTreeMap<String, serde_json::Value>>,
    /// The name of a secret used by the Kiali. This secret is optionally used when configuring the OpenID authentication strategy. Consult the OpenID docs for more information at <https://kiali.io/docs/configuration/authentication/openid/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_name: Option<String>,
    /// Custom security context to be placed on the server container. The entire security context on the container will be the value of this setting if the operator is configured to allow it. Note that, as a security measure, a cluster admin may have configured the Kiali operator to not allow portions of this override setting - in this case you can specify additional security context settings but you cannot replace existing, default ones.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security_context: Option<BTreeMap<String, serde_json::Value>>,
    /// Custom annotations to be created on the Kiali Service resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_annotations: Option<BTreeMap<String, String>>,
    /// The Kiali service type. Kubernetes determines what values are valid. Common values are 'NodePort', 'ClusterIP', and 'LoadBalancer'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_type: Option<String>,
    /// TLS policy configuration. When source is 'auto' on OpenShift, the APIServer TLSSecurityProfile is used. Otherwise, the explicit config values are enforced.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<KialiDeploymentTlsConfig>,
    /// A list of tolerations which declare which node taints Kiali can tolerate. See the Kubernetes documentation on Taints and Tolerations for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of constraints which control how the Kiali pods are spread across your cluster to help achieve high availability as well as efficient resource utilization. See the Kubernetes documentation on Topology Spread Constraints for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topology_spread_constraints: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// DEPRECATED AFTER v1.73: When true, Kiali will log additional debug information about its operations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verbose_mode: Option<bool>,
    /// Kiali resources will be assigned a 'version' label when they are deployed.
    /// This setting determines what value those 'version' labels will have.
    /// When empty, its default will be determined as follows,
    /// 
    /// * If `deployment.image_version` is 'latest', `version_label` will be fixed to 'master'.
    /// * If `deployment.image_version` is 'lastrelease', `version_label` will be fixed to the last Kiali release version string.
    /// * If `deployment.image_version` is anything else, `version_label` will be that value, too.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version_label: Option<String>,
    /// When true, Kiali will be in 'view only' mode, allowing the user to view and retrieve management and monitoring data for the service mesh, but not allow the user to modify the service mesh.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub view_only_mode: Option<bool>,
}

/// Affinity definitions that are to be used to define the nodes where the Kiali pod should be constrained. See the Kubernetes documentation on Assigning Pods to Nodes for the proper syntax for these three different affinity types.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<BTreeMap<String, serde_json::Value>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pod: Option<BTreeMap<String, serde_json::Value>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pod_anti: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentCustomEnvs {
    /// The name of the custom environment variable.
    pub name: String,
    /// The value of the custom environment variable.
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentCustomSecrets {
    /// Defines CSI-specific settings that allows a secret from an external CSI secret store to be injected in the pod via a volume mount. For details, see <https://secrets-store-csi-driver.sigs.k8s.io/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<BTreeMap<String, serde_json::Value>>,
    /// The file path location where the secret content will be mounted. The custom secret cannot be mounted on a path that the operator will use to mount its secrets. Make sure you set your custom secret mount path to a unique, unused path. Paths such as `/kiali-configuration`, `/kiali-cert`, `/kiali-cabundle`, `/kiali-secret`, `/kiali-override-secrets`, and `/kiali-remote-cluster-secrets` should not be used as mount paths for custom secrets because the operator may want to use one of those paths.
    pub mount: String,
    /// The name of the secret that is to be mounted to the Kiali pod's file system. The name of the custom secret must not be the same name as one created by the operator. Names such as `kiali`, `kiali-cert-secret`, and `kiali-cabundle` should not be used as a custom secret name because the operator may want to create one with one of those names.
    pub name: String,
    /// Indicates if the secret may or may not exist at the time the Kiali pod starts. This is ignored if `csi` is specified - CSI secrets must exist when specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Discovery selectors used to determine which namespaces are accessible to Kiali and which namespaces are visible to Kiali users.
/// You can define discovery selectors to match namespaces on the local cluster as well as remote clusters.
/// The list of namespaces that a user can access is a subset of these namespaces, given that user's RBAC permissions.
/// These selectors will have similar semantics as defined by Istio ( <https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig> )
/// and the syntax of the equality-based and set-based label selectors are documented by Kubernetes here
/// ( <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#resources-that-support-set-based-requirements> )
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentDiscoverySelectors {
    /// These are label selectors for the Kiali local cluster and for all remote clusters that do not have overrides.
    /// Namespaces that match these selectors are visible to Kiali users.
    /// When `cluster_wide_access=false` these `default` selectors are used to restrict which namespaces Kiali will have access to.
    /// If there are no default discovery selectors, then `cluster_wide_access` should be `true` in which case Kiali will have
    /// permissions to access all namespaces.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<Vec<KialiDeploymentDiscoverySelectorsDefault>>,
    /// If a remote cluster has different namespaces than the local cluster, these overrides provide a way for you to match those remote namespaces. Kiali will make these remote namespaces visible to users. The name of the overrides section is the name of the remote cluster. Note that the `default` selectors are ignored when matching namespaces on a remote cluster if that remote cluster has overrides defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<BTreeMap<String, Vec<KialiDeploymentDiscoverySelectorsOverrides>>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentDiscoverySelectorsDefault {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<KialiDeploymentDiscoverySelectorsDefaultMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct KialiDeploymentDiscoverySelectorsDefaultMatchExpressions {
    pub key: String,
    pub operator: KialiDeploymentDiscoverySelectorsDefaultMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiDeploymentDiscoverySelectorsDefaultMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentDiscoverySelectorsOverrides {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<KialiDeploymentDiscoverySelectorsOverridesMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct KialiDeploymentDiscoverySelectorsOverridesMatchExpressions {
    pub key: String,
    pub operator: KialiDeploymentDiscoverySelectorsOverridesMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiDeploymentDiscoverySelectorsOverridesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

/// The Kiali server pod's DNS configuration. Kubernetes supports different DNS policies and configurations.
/// For further details, consult the Kubernetes documentation - <https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentDns {
    /// DNS configuration that is applied to the DNS policy. See the Kubernetes documentation for the different configuration settings that are supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<BTreeMap<String, serde_json::Value>>,
    /// DNS policy. See the Kubernetes documentation for the different policies that are supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentHostAliases {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
}

/// Determines what (if any) HorizontalPodAutoscaler should be created to autoscale the Kiali pod.
/// A typical way to configure HPA for Kiali is,
/// ```text
/// spec:
///   deployment:
///     hpa:
///       api_version: "autoscaling/v2"
///       spec:
///         maxReplicas: 2
///         minReplicas: 1
///         metrics:
///         - type: Resource
///           resource:
///             name: cpu
///             target:
///               type: Utilization
///               averageUtilization: 50
/// ```
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentHpa {
    /// A specific HPA API version that can be specified in case there is some HPA feature you want to use that is only supported in that specific version. If value is an empty string, an attempt will be made to determine a valid version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_version: Option<String>,
    /// The `spec` specified here will be placed in the created HPA resource's 'spec' section. If `spec` is left empty, no HPA resource will be created. Note that you must not specify the 'scaleTargetRef' section in `spec`; the Kiali Operator will populate that for you.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

/// Configures if/how the Kiali endpoint should be exposed externally.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentIngress {
    /// Additional labels to add to the Ingress (or Route if on OpenShift). These are added to the labels that are created by default; these do not override the default labels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub additional_labels: Option<BTreeMap<String, String>>,
    /// If `class_name` is a non-empty string, it will be used as the 'spec.ingressClassName' in the created Kubernetes Ingress resource. This setting is ignored if on OpenShift. This is also ignored if `override_yaml.spec` is defined (i.e. you must define the 'ingressClassName' directly in your override yaml).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class_name: Option<String>,
    /// Determines if the Kiali endpoint should be exposed externally. If 'true', an Ingress will be created if on Kubernetes or a Route if on OpenShift. If left undefined, this will be 'false' on Kubernetes and 'true' on OpenShift.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Because an Ingress into a cluster can vary wildly in its desired configuration,
    /// this setting provides a way to override complete portions of the Ingress resource
    /// configuration (Ingress on Kubernetes and Route on OpenShift). It is up to the user
    /// to ensure this override YAML configuration is valid and supports the cluster environment
    /// since the operator will blindly copy this custom configuration into the resource it
    /// creates.
    /// 
    /// This setting is not used if `deployment.ingress.enabled` is set to 'false'.
    /// Note that only 'metadata.annotations' and 'spec' is valid and only they will
    /// be used to override those same sections in the created resource. You can define
    /// either one or both.
    /// 
    /// Note that `override_yaml.metadata.labels` is not allowed - you cannot override the labels; to add
    /// labels to the default set of labels, use the `deployment.ingress.additional_labels` setting.
    /// Example,
    /// ```text
    /// spec:
    ///   deployment:
    ///     ingress:
    ///       override_yaml:
    ///         metadata:
    ///           annotations:
    ///             nginx.ingress.kubernetes.io/secure-backends: "true"
    ///             nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
    ///         spec:
    ///           rules:
    ///           - http:
    ///               paths:
    ///               - path: /kiali
    ///                 pathType: Prefix
    ///                 backend:
    ///                   service
    ///                     name: "kiali"
    ///                     port:
    ///                       number: 20001
    /// ```
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub override_yaml: Option<KialiDeploymentIngressOverrideYaml>,
}

/// Because an Ingress into a cluster can vary wildly in its desired configuration,
/// this setting provides a way to override complete portions of the Ingress resource
/// configuration (Ingress on Kubernetes and Route on OpenShift). It is up to the user
/// to ensure this override YAML configuration is valid and supports the cluster environment
/// since the operator will blindly copy this custom configuration into the resource it
/// creates.
/// 
/// This setting is not used if `deployment.ingress.enabled` is set to 'false'.
/// Note that only 'metadata.annotations' and 'spec' is valid and only they will
/// be used to override those same sections in the created resource. You can define
/// either one or both.
/// 
/// Note that `override_yaml.metadata.labels` is not allowed - you cannot override the labels; to add
/// labels to the default set of labels, use the `deployment.ingress.additional_labels` setting.
/// Example,
/// ```text
/// spec:
///   deployment:
///     ingress:
///       override_yaml:
///         metadata:
///           annotations:
///             nginx.ingress.kubernetes.io/secure-backends: "true"
///             nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
///         spec:
///           rules:
///           - http:
///               paths:
///               - path: /kiali
///                 pathType: Prefix
///                 backend:
///                   service
///                     name: "kiali"
///                     port:
///                       number: 20001
/// ```
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentIngressOverrideYaml {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<KialiDeploymentIngressOverrideYamlMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentIngressOverrideYamlMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, serde_json::Value>>,
}

/// Configures the logger that emits messages to the Kiali server pod logs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentLogger {
    /// Indicates if the logs should be written with one log message per line or using a JSON format. Must be one of: `text` or `json`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log_format: Option<KialiDeploymentLoggerLogFormat>,
    /// The lowest priority of messages to log. Must be one of: `trace`, `debug`, `info`, `warn`, `error`, or `fatal`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log_level: Option<KialiDeploymentLoggerLogLevel>,
    /// With this setting every sampler_rate-th message will be logged. By default, every message is logged. As an example, setting this to `'2'` means every other message will be logged. The value of this setting is a string but must be parsable as an integer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sampler_rate: Option<String>,
    /// The log message timestamp format. This supports a golang time format (see <https://golang.org/pkg/time/)>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time_field_format: Option<String>,
}

/// Configures the logger that emits messages to the Kiali server pod logs.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiDeploymentLoggerLogFormat {
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "json")]
    Json,
}

/// Configures the logger that emits messages to the Kiali server pod logs.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiDeploymentLoggerLogLevel {
    #[serde(rename = "trace")]
    Trace,
    #[serde(rename = "debug")]
    Debug,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "warn")]
    Warn,
    #[serde(rename = "error")]
    Error,
    #[serde(rename = "fatal")]
    Fatal,
}

/// Configures if the Kiali server pod should be protected by a NetworkPolicy resource that restricts both ingress and egress traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentNetworkPolicy {
    /// If true, a NetworkPolicy resource is created to restrict traffic to the Kiali server pod. The NetworkPolicy will allow ingress traffic only to the Kiali server API port and, if enabled, the metrics port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configures the liveness, readiness, and startup probes of the Kiali pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentProbes {
    /// Configures the liveness probe of the Kiali pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub liveness: Option<KialiDeploymentProbesLiveness>,
    /// Configures the readiness probe of the Kiali pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub readiness: Option<KialiDeploymentProbesReadiness>,
    /// Configures the startup probe of the Kiali pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub startup: Option<KialiDeploymentProbesStartup>,
}

/// Configures the liveness probe of the Kiali pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentProbesLiveness {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initial_delay_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub period_seconds: Option<i64>,
}

/// Configures the readiness probe of the Kiali pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentProbesReadiness {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initial_delay_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub period_seconds: Option<i64>,
}

/// Configures the startup probe of the Kiali pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentProbesStartup {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failure_threshold: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initial_delay_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub period_seconds: Option<i64>,
}

/// TLS policy configuration. When source is 'auto' on OpenShift, the APIServer TLSSecurityProfile is used. Otherwise, the explicit config values are enforced.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiDeploymentTlsConfig {
    /// Explicit TLS cipher suites (OpenSSL names). Ignored for TLS 1.3.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cipher_suites: Option<Vec<String>>,
    /// Maximum TLS version (e.g., TLSv1.3, TLSv1.2).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_version: Option<String>,
    /// Minimum TLS version (e.g., TLSv1.3, TLSv1.2).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub min_version: Option<String>,
    /// TLS policy source: 'auto' to use OpenShift TLSSecurityProfile; 'config' to use explicit settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<KialiDeploymentTlsConfigSource>,
}

/// TLS policy configuration. When source is 'auto' on OpenShift, the APIServer TLSSecurityProfile is used. Otherwise, the explicit config values are enforced.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiDeploymentTlsConfigSource {
    #[serde(rename = "auto")]
    Auto,
    #[serde(rename = "config")]
    Config,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExtensions {
    /// Determines if the Kiali traffic graph should incorporate the extension's metrics.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The name that is used to identify the metric time series for the extension.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// These external service configuration settings define how to connect to the external services
/// like Prometheus, Grafana, and Jaeger.
/// 
/// Regarding sensitive values in the external_services 'auth' sections:
/// Some external services configured below support an 'auth' sub-section in order to tell Kiali
/// how it should authenticate with the external services. Credentials used to authenticate Kiali
/// to those external services can be defined in the `auth.password` and `auth.token` values
/// within the `auth` sub-section. Because these are sensitive values, you may not want to declare
/// the actual credentials here in the Kiali CR. In this case, you may store the actual password
/// or token string in a Kubernetes secret. If you do, you need to set the `auth.password` or
/// `auth.token` to a value in the format `secret:<secretName>:<secretKey>` where `<secretName>`
/// is the name of the secret object that Kiali can access, and `<secretKey>` is the name of the
/// key within the named secret that contains the actual password or token string. For example,
/// if Grafana requires a password, you can store that password in a secret named 'myGrafanaCredentials'
/// in a key named 'myGrafanaPw'. In this case, you would set `external_services.grafana.auth.password`
/// to `secret:myGrafanaCredentials:myGrafanaPw`.
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServices {
    /// Settings for enabling and discovering custom dashboards.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_dashboards: Option<KialiExternalServicesCustomDashboards>,
    /// Configuration used to access the Grafana dashboards.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grafana: Option<KialiExternalServicesGrafana>,
    /// Istio configuration that Kiali needs to know about in order to observe the mesh.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio: Option<KialiExternalServicesIstio>,
    /// Configuration used to access the Perses dashboards.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub perses: Option<KialiExternalServicesPerses>,
    /// The Prometheus configuration defined here refers to the Prometheus instance that is used by Istio to store its telemetry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prometheus: Option<KialiExternalServicesPrometheus>,
    /// Configuration used to access the Tracing (Jaeger or Tempo) dashboards.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tracing: Option<KialiExternalServicesTracing>,
}

/// Settings for enabling and discovering custom dashboards.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesCustomDashboards {
    /// Threshold of the number of pods, for a given Application or Workload, above which dashboards discovery will be skipped. This setting only takes effect when `discovery_enabled` is set to 'auto'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discovery_auto_threshold: Option<i64>,
    /// Enable, disable or set 'auto' mode to the dashboards discovery process. If set to 'true', Kiali will always try to discover dashboards based on metrics. Note that this can generate performance penalties while discovering dashboards for workloads having many pods (thus many metrics). When set to 'auto', Kiali will skip dashboards discovery for workloads with more than a configured threshold of pods (see `discovery_auto_threshold`). When discovery is disabled or auto/skipped, it is still possible to tie workloads with dashboards through annotations on pods (refer to the doc <https://kiali.io/docs/configuration/custom-dashboard/#pod-annotations).> Value must be a string and be one of: `true`, `false`, `auto`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discovery_enabled: Option<KialiExternalServicesCustomDashboardsDiscoveryEnabled>,
    /// Enable or disable custom dashboards, including the dashboards discovery process.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Used in the Components health feature. When true, the unhealthy scenarios will be raised as errors. Otherwise, they will be raised as a warning.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_core: Option<bool>,
    /// The Prometheus label name used for identifying namespaces in metrics for custom dashboards. The default is `namespace` but you may want to use `kubernetes_namespace` depending on your Prometheus configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace_label: Option<String>,
    /// The Prometheus configuration defined here refers to the Prometheus instance that is dedicated to fetching metrics for custom dashboards. This means you can obtain these metrics for the custom dashboards from a Prometheus instance that is different from the one that Istio uses. If this section is omitted, the same Prometheus that is used to obtain the Istio metrics will also be used for retrieving custom dashboard metrics.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prometheus: Option<KialiExternalServicesCustomDashboardsPrometheus>,
}

/// Settings for enabling and discovering custom dashboards.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiExternalServicesCustomDashboardsDiscoveryEnabled {
    #[serde(rename = "true")]
    True,
    #[serde(rename = "false")]
    False,
    #[serde(rename = "auto")]
    Auto,
}

/// The Prometheus configuration defined here refers to the Prometheus instance that is dedicated to fetching metrics for custom dashboards. This means you can obtain these metrics for the custom dashboards from a Prometheus instance that is different from the one that Istio uses. If this section is omitted, the same Prometheus that is used to obtain the Istio metrics will also be used for retrieving custom dashboard metrics.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesCustomDashboardsPrometheus {
    /// Settings used to authenticate with the Prometheus instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<KialiExternalServicesCustomDashboardsPrometheusAuth>,
    /// Prometheus caching duration expressed in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_duration: Option<i64>,
    /// Enable/disable Prometheus caching used for Health services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_enabled: Option<bool>,
    /// Prometheus caching expiration expressed in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_expiration: Option<i64>,
    /// A set of name/value settings that will be passed as headers when requests are sent to Prometheus.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_headers: Option<BTreeMap<String, String>>,
    /// Used in the Components health feature. This is the url which Kiali will ping to determine whether the component is reachable or not. It defaults to `url` when not provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health_check_url: Option<String>,
    /// Used in the Components health feature. When true, the unhealthy scenarios will be raised as errors. Otherwise, they will be raised as a warning.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_core: Option<bool>,
    /// A set of labelName/labelValue settings applied to every Prometheus query. Used to narrow unified metrics to only those scoped to the Kiali instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query_scope: Option<BTreeMap<String, String>>,
    /// Define this section if Prometheus is to be queried through a Thanos proxy. Kiali will still use the `url` setting to query for Prometheus metrics so make sure that is set appropriately.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thanos_proxy: Option<KialiExternalServicesCustomDashboardsPrometheusThanosProxy>,
    /// The URL used to query the Prometheus Server. This URL must be accessible from the Kiali pod. If empty, the default will assume Prometheus is in the Istio control plane namespace; e.g. `<http://prometheus.istio-system:9090`.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Settings used to authenticate with the Prometheus instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesCustomDashboardsPrometheusAuth {
    /// DEPRECATED since v2.20: This setting is deprecated and will be ignored. To configure custom CA certificates, use the kiali-cabundle ConfigMap instead. See the TLS Configuration documentation for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_file: Option<String>,
    /// The client certificate file to use when accessing Prometheus using https with mTLS. An empty string means no client certificate is used. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the certificate is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert_file: Option<String>,
    /// Set true to skip verifying certificate validity when Kiali contacts Prometheus over https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure_skip_verify: Option<bool>,
    /// The client private key file to use when accessing Prometheus using https with mTLS. An empty string means no client private key is used. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the key is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key_file: Option<String>,
    /// Password to be used when making requests to Prometheus, for basic authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the password is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// Token / API key to access Prometheus, for token-based authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the token is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
    /// The type of authentication to use when contacting the server. Use `bearer` to send the token to the Prometheus server. Use `basic` to connect with username and password credentials. Use `none` to not use any authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// When true and if `auth.type` is `bearer`, Kiali Service Account token will be used for the API calls to Prometheus (in this case, `auth.token` config is ignored).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_kiali_token: Option<bool>,
    /// Username to be used when making requests to Prometheus with `basic` authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the username is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// Define this section if Prometheus is to be queried through a Thanos proxy. Kiali will still use the `url` setting to query for Prometheus metrics so make sure that is set appropriately.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesCustomDashboardsPrometheusThanosProxy {
    /// Set to true when a Thanos proxy is in front of Prometheus.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Thanos Retention period value expressed as a string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retention_period: Option<String>,
    /// Thanos Scrape interval value expressed as a string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_interval: Option<String>,
}

/// Configuration used to access the Grafana dashboards.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesGrafana {
    /// Settings used to authenticate with the Grafana instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<KialiExternalServicesGrafanaAuth>,
    /// A list of Grafana dashboards that Kiali can link to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dashboards: Option<Vec<KialiExternalServicesGrafanaDashboards>>,
    /// The UID of the Datasource configured in Grafana must be specified if multiple datasources are configured. It is empty by default and is used only in conjunction with the `datasource` variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datasource_uid: Option<String>,
    /// When true, Grafana support will be enabled in Kiali.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The URL that the Kiali UI uses when displaying Grafana links to the user. This URL must be accessible to clients external to the cluster (e.g. a browser) in order for the integration to work properly. If empty, an attempt to auto-discover it is made. This URL can contain query parameters if needed, such as '?orgId=1'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub external_url: Option<String>,
    /// Used in the Components health feature. This is the URL which Kiali will ping to determine whether the component is reachable or not. It defaults to `internal_url` when not provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health_check_url: Option<String>,
    /// DEPRECATED AFTER v1.73: The URL used for in-cluster access to Grafana.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub in_cluster_url: Option<String>,
    /// The URL used by Kiali to perform requests and queries to Grafana. An example would be `<http://grafana.istio-system:3000`.> This URL can contain query parameters if needed, such as '?orgId=1'. If not defined, it will default to `<http://grafana.<istio> namespace>:3000`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub internal_url: Option<String>,
    /// Used in the Components health feature. When true, the unhealthy scenarios will be raised as errors. Otherwise, they will be raised as a warning.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_core: Option<bool>,
    /// DEPRECATED AFTER v1.73: The URL used to access Grafana from external sources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Settings used to authenticate with the Grafana instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesGrafanaAuth {
    /// DEPRECATED since v2.20: This setting is deprecated and will be ignored. To configure custom CA certificates, use the kiali-cabundle ConfigMap instead. See the TLS Configuration documentation for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_file: Option<String>,
    /// The client certificate file to use when accessing Grafana using https with mTLS. An empty string means no client certificate is used. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the certificate is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert_file: Option<String>,
    /// Set true to skip verifying certificate validity when Kiali contacts Grafana over https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure_skip_verify: Option<bool>,
    /// The client private key file to use when accessing Grafana using https with mTLS. An empty string means no client private key is used. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the key is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key_file: Option<String>,
    /// Password to be used when making requests to Grafana, for basic authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the password is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// Token / API key to access Grafana, for token-based authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the token is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
    /// The type of authentication to use when contacting the server. Use `bearer` to send the token to the Grafana server. Use `basic` to connect with username and password credentials. Use `none` to not use any authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// When true and if `auth.type` is `bearer`, Kiali Service Account token will be used for the API calls to Grafana (in this case, `auth.token` config is ignored).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_kiali_token: Option<bool>,
    /// Username to be used when making requests to Grafana with `basic` authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the username is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesGrafanaDashboards {
    /// The name of the Grafana dashboard.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<KialiExternalServicesGrafanaDashboardsVariables>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesGrafanaDashboardsVariables {
    /// The name of a variable that holds the app name, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app: Option<String>,
    /// The name of the variable that holds the Datasource UID, required if Grafana has multiple datasources configured (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datasource: Option<String>,
    /// The name of a variable that holds the namespace, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The name of a variable that holds the service name, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    /// The name of a variable that holds the version, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// The name of a variable that holds the workload name, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workload: Option<String>,
}

/// Istio configuration that Kiali needs to know about in order to observe the mesh.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesIstio {
    /// Istio components whose status will be monitored by Kiali.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub component_status: Option<KialiExternalServicesIstioComponentStatus>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The name of the istio control plane config map is now autodetected based on revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config_map_name: Option<String>,
    /// The namespace where Istio EgressGateway component is read for a status check. When left empty, the control plane namespace is used. e.g. `istio-system`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress_gateway_namespace: Option<String>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The port which Kiali will open to fetch envoy config data information is now hardcoded to the standard Envoy port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub envoy_admin_local_port: Option<i64>,
    /// DEPRECATED AFTER v1.73: The name of the Gateway API Class used by Istio.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway_api_class_name: Option<String>,
    /// A list declaring all the Gateway API Classes used in Istio. If empty or undefined, Kiali attempts to auto-discover Gateway Classes if `cluster_wide_access` is set `true` for Kiali; otherwise, it defaults to `istio`, `istio-remote`, and adds `istio-waypoint` for Ambient mode or `istio-east-west` for multicluster setup.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway_api_classes: Option<Vec<KialiExternalServicesIstioGatewayApiClasses>>,
    /// Label selector for auto-discovering K8s Gateway API Classes. Used if `gateway_api_classes` is unset and `cluster_wide_access` is set `true` for Kiali. When left empty then all K8s Gateway API Classes will be loaded.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway_api_classes_label_selector: Option<String>,
    /// Indicates if Kiali has access to istiod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_api_enabled: Option<bool>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. Canary upgrade/downgrade functionality now autodetects canary revisions from running istiod pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_canary_revision: Option<KialiExternalServicesIstioIstioCanaryRevision>,
    /// The annotation used by Istio to identify domains.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_identity_domain: Option<String>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The name of the field that annotates a workload to indicate a sidecar should be automatically injected by Istio is now hardcoded to the standard value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_injection_annotation: Option<String>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The pod annotation used by Istio to identify the sidecar is now hardcoded to the standard value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_sidecar_annotation: Option<String>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The name of the istio-sidecar-injector config map is now autodetected based on revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_sidecar_injector_config_map_name: Option<String>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The name of the istiod deployment is now autodetected.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istiod_deployment_name: Option<String>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The monitoring port of the IstioD pod is now autodetected from the deployment args.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istiod_pod_monitoring_port: Option<i64>,
    /// How often in seconds Kiali will poll istiod(s) for proxy status and registry services. Polling is not performed if istio_api_enabled is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istiod_polling_interval_seconds: Option<i64>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The namespace to treat as the administrative root namespace for Istio configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub root_namespace: Option<String>,
    /// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. The Istio service used to determine the Istio version is now autodetected from services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url_service_version: Option<String>,
    /// When true, Kiali will detect changes in Istio configuration and trigger validation reconciliation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validation_change_detection_enabled: Option<bool>,
    /// Configures how often Kiali will validate Istio configuration. Validations cannot be disabled at the moment but you can set this to a long period of time. Accepts a golang duration string e.g. '1h' or '30m'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validation_reconcile_interval: Option<String>,
}

/// Istio components whose status will be monitored by Kiali.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesIstioComponentStatus {
    /// A specific Istio component whose status will be monitored by Kiali.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<KialiExternalServicesIstioComponentStatusComponents>>,
    /// Determines if Istio component statuses will be displayed in the Kiali masthead indicator.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesIstioComponentStatusComponents {
    /// Istio component pod app label.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_label: Option<String>,
    /// Whether the component is to be considered a core component for your deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_core: Option<bool>,
    /// Whether the component is a multi-cluster component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_multicluster: Option<bool>,
    /// Whether the component is a native Envoy proxy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_proxy: Option<bool>,
    /// The namespace where the component is installed. It defaults to the Istio control plane namespace (e.g. `istio-system`). Note that the Istio documentation suggests you install the ingress and egress to different namespaces, so you most likely will want to explicitly set this namespace value for the ingress and egress components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesIstioGatewayApiClasses {
    /// The name of the GatewayClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub class_name: Option<String>,
    /// The name of the Gateway API implementation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// DEPRECATED AFTER v2.11: This setting is deprecated and will be ignored. Canary upgrade/downgrade functionality now autodetects canary revisions from running istiod pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesIstioIstioCanaryRevision {
    /// DEPRECATED AFTER v2.11: The currently installed Istio revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub current: Option<String>,
    /// DEPRECATED AFTER v2.11: The installed Istio canary revision to upgrade to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub upgrade: Option<String>,
}

/// Configuration used to access the Perses dashboards.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesPerses {
    /// Settings used to authenticate with the Perses instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<KialiExternalServicesPersesAuth>,
    /// A list of Perses dashboards that Kiali can link to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dashboards: Option<Vec<KialiExternalServicesPersesDashboards>>,
    /// When true, Perses support will be enabled in Kiali.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The URL that the Kiali UI uses when displaying Perses links to the user. This URL must be accessible to clients external to the cluster (e.g. a browser) in order for the integration to work properly. If empty, an attempt to auto-discover it is made. This URL can contain query parameters if needed, such as '?orgId=1'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub external_url: Option<String>,
    /// Used in the Components health feature. This is the URL which Kiali will ping to determine whether the component is reachable or not. It defaults to `internal_url` when not provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health_check_url: Option<String>,
    /// The URL used by Kiali to perform requests and queries to Perses. An example would be `<http://perses.istio-system:4000`.> This URL can contain query parameters if needed, such as '?orgId=1'. If not defined, it will default to `<http://perses.<istio_namespace>:4000`.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub internal_url: Option<String>,
    /// Used in the Components health feature. When true, the unhealthy scenarios will be raised as errors. Otherwise, they will be raised as a warning.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_core: Option<bool>,
    /// The name of the project where the Dashboards are defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// The URL format. Leave empty (the default) for standard Perses upstream. Use `openshift` when using Perses Dashboards via the Cluster Observability operator in OpenShift.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url_format: Option<KialiExternalServicesPersesUrlFormat>,
}

/// Settings used to authenticate with the Perses instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesPersesAuth {
    /// DEPRECATED since v2.20: This setting is deprecated and will be ignored. To configure custom CA certificates, use the kiali-cabundle ConfigMap instead. See the TLS Configuration documentation for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_file: Option<String>,
    /// The client certificate file to use when accessing Perses using https with mTLS. An empty string means no client certificate is used. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the certificate is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert_file: Option<String>,
    /// Set true to skip verifying certificate validity when Kiali contacts Perses over https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure_skip_verify: Option<bool>,
    /// The client private key file to use when accessing Perses using https with mTLS. An empty string means no client private key is used. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the key is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key_file: Option<String>,
    /// Password to be used when making requests to Perses, for basic authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the password is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// The type of authentication to use when contacting the server. Use `bearer` to send the token to the Perses server. Use `basic` to connect with username and password credentials. Use `none` to not use any authentication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// When true and if `auth.type` is `bearer`, Kiali Service Account token will be used for the API calls to Perses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_kiali_token: Option<bool>,
    /// Username to be used when making requests to Perses with `basic` authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the username is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesPersesDashboards {
    /// The name of the Perses dashboard.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<KialiExternalServicesPersesDashboardsVariables>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesPersesDashboardsVariables {
    /// The name of a variable that holds the app name, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app: Option<String>,
    /// The name of the variable that holds the Datasource UID, required if Perses has multiple datasources configured (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datasource: Option<String>,
    /// The name of a variable that holds the namespace, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The name of a variable that holds the service name, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
    /// The name of a variable that holds the version, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// The name of a variable that holds the workload name, if used in that dashboard (else it must be omitted).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workload: Option<String>,
}

/// Configuration used to access the Perses dashboards.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiExternalServicesPersesUrlFormat {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "openshift")]
    Openshift,
}

/// The Prometheus configuration defined here refers to the Prometheus instance that is used by Istio to store its telemetry.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesPrometheus {
    /// Settings used to authenticate with the Prometheus instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<KialiExternalServicesPrometheusAuth>,
    /// Prometheus caching duration expressed in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_duration: Option<i64>,
    /// Enable/disable Prometheus caching used for Health services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_enabled: Option<bool>,
    /// Prometheus caching expiration expressed in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_expiration: Option<i64>,
    /// A set of name/value settings that will be passed as headers when requests are sent to Prometheus.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_headers: Option<BTreeMap<String, String>>,
    /// Used in the Components health feature. This is the url which Kiali will ping to determine whether the component is reachable or not. It defaults to `url` when not provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health_check_url: Option<String>,
    /// Used in the Components health feature. When true, the unhealthy scenarios will be raised as errors. Otherwise, they will be raised as a warning.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_core: Option<bool>,
    /// A set of labelName/labelValue settings applied to every Prometheus query. Used to narrow unified metrics to only those scoped to the Kiali instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query_scope: Option<BTreeMap<String, String>>,
    /// Define this section if Prometheus is to be queried through a Thanos proxy. Kiali will still use the `url` setting to query for Prometheus metrics so make sure that is set appropriately.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thanos_proxy: Option<KialiExternalServicesPrometheusThanosProxy>,
    /// The URL used to query the Prometheus Server. This URL must be accessible from the Kiali pod. If empty, the default will assume Prometheus is in the Istio control plane namespace; e.g. `<http://prometheus.istio-system:9090`.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Settings used to authenticate with the Prometheus instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesPrometheusAuth {
    /// DEPRECATED since v2.20: This setting is deprecated and will be ignored. To configure custom CA certificates, use the kiali-cabundle ConfigMap instead. See the TLS Configuration documentation for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_file: Option<String>,
    /// The client certificate file to use when accessing Prometheus using https with mTLS. An empty string means no client certificate is used. May refer to a secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert_file: Option<String>,
    /// Set true to skip verifying certificate validity when Kiali contacts Prometheus over https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure_skip_verify: Option<bool>,
    /// The client private key file to use when accessing Prometheus using https with mTLS. An empty string means no client private key is used. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the key is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key_file: Option<String>,
    /// Password to be used when making requests to Prometheus, for basic authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the password is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// Token / API key to access Prometheus, for token-based authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the token is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
    /// The type of authentication to use when contacting the server. Use `bearer` to send the token to the Prometheus server. Use `basic` to connect with username and password credentials. Use `none` to not use any authentication (this is the default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// When true and if `auth.type` is `bearer`, Kiali Service Account token will be used for the API calls to Prometheus (in this case, `auth.token` config is ignored).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_kiali_token: Option<bool>,
    /// Username to be used when making requests to Prometheus with `basic` authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the username is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// Define this section if Prometheus is to be queried through a Thanos proxy. Kiali will still use the `url` setting to query for Prometheus metrics so make sure that is set appropriately.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesPrometheusThanosProxy {
    /// Set to true when a Thanos proxy is in front of Prometheus.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Thanos Retention period value expressed as a string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retention_period: Option<String>,
    /// Thanos Scrape interval value expressed as a string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scrape_interval: Option<String>,
}

/// Configuration used to access the Tracing (Jaeger or Tempo) dashboards.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesTracing {
    /// Settings used to authenticate with the Tracing server instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<KialiExternalServicesTracingAuth>,
    /// A set of name/value settings that will be passed as headers when requests are sent to the Tracing backend.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_headers: Option<BTreeMap<String, String>>,
    /// When true, the version of the Tracing backend will not be retrieved. This will mean Kiali will not be able to display the version of your Tracing component in the Kiali UI. This may be needed in order to avoid Kiali reporting errors in cases where the full version endpoint is not accessible or is unknown. A common use case is when using Jaeger with gRPC and the HTTP endpoint is not deployed in the standard port (80).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disable_version_check: Option<bool>,
    /// When true, connections to the Tracing server are enabled. `internal_url` and/or `external_url` need to be provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The URL that the Kiali UI uses when displaying Tracing UI links to the user. This URL must be accessible to clients external to the cluster (e.g. a browser) in order to generate valid links. If the tracing service is deployed with a QUERY_BASE_PATH set, set this URL like <https://<hostname>/<QUERY_BASE_PATH>;> for example, <https://tracing-service:8080/jaeger>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub external_url: Option<String>,
    /// Set port number when `use_grpc` is true and `provider` is `tempo`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc_port: Option<i64>,
    /// Used in the Components health feature. This is the url which Kiali will ping to determine whether the component is reachable or not. It defaults to `url` when not provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health_check_url: Option<String>,
    /// DEPRECATED AFTER v1.73: The URL used for in-cluster access to the tracing service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub in_cluster_url: Option<String>,
    /// The URL used by Kiali to perform requests and queries to the tracing backend which enables further integration between Kiali and the tracing server. When not provided, Kiali will only show external links using the `external_url` setting. Note: Jaeger v1.20+ has separated ports for GRPC(16685) and HTTP(16686) requests. Make sure you use the appropriate port according to the `use_grpc` value. Example: <http://tracing.istio-system:16685>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub internal_url: Option<String>,
    /// Used in the Components health feature. When true, the unhealthy scenarios will be raised as errors. Otherwise, they will be raised as a warning.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub is_core: Option<bool>,
    /// Kiali use this boolean to find traces with a namespace selector : service.namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace_selector: Option<bool>,
    /// The trace provider to get the traces from. Value must be one of: `jaeger` or `tempo`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<KialiExternalServicesTracingProvider>,
    /// A set of tagKey/tagValue settings applied to every Jaeger query. Used to narrow unified traces to only those scoped to the Kiali instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query_scope: Option<BTreeMap<String, String>>,
    /// The amount of time in seconds Kiali will wait for a response from 'jaeger-query' service when fetching traces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub query_timeout: Option<i64>,
    /// Settings used to configure the access url to the Tempo Datasource in Grafana.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tempo_config: Option<KialiExternalServicesTracingTempoConfig>,
    /// DEPRECATED AFTER v1.73: The URL used to access the tracing service from external sources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// Set to true in order to enable GRPC connections between Kiali and Jaeger which will speed up the queries. In some setups you might not be able to use GRPC (e.g. if Jaeger is behind some reverse proxy that doesn't support it).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_grpc: Option<bool>,
    /// Kiali will get the traces of these services found in the Istio control plane namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub whitelist_istio_system: Option<Vec<String>>,
}

/// Settings used to authenticate with the Tracing server instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesTracingAuth {
    /// DEPRECATED since v2.20: This setting is deprecated and will be ignored. To configure custom CA certificates, use the kiali-cabundle ConfigMap instead. See the TLS Configuration documentation for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_file: Option<String>,
    /// The client certificate file to use when accessing the Tracing server using https with mTLS. An empty string means no client certificate is used. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the certificate is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert_file: Option<String>,
    /// Set true to skip verifying certificate validity when Kiali contacts the Tracing server over https.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure_skip_verify: Option<bool>,
    /// The client private key file to use when accessing the Tracing server using https with mTLS. An empty string means no client private key is used. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the key is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key_file: Option<String>,
    /// Password to be used when making requests to the Tracing server, for basic authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the password is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// Token / API key to access the Tracing server, for token-based authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the token is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
    /// The type of authentication to use when contacting the server. Use `bearer` to send the token to the Tracing server. Use `basic` to connect with username and password credentials. Use `none` to not use any authentication (this is the default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// When true and if `auth.type` is `bearer`, Kiali Service Account token will be used for the API calls to the Tracing server (in this case, `auth.token` config is ignored).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub use_kiali_token: Option<bool>,
    /// Username to be used when making requests to the Tracing server with `basic` authentication. May refer to a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the username is cached and automatically refreshed when the secret changes, enabling rotation without pod restart.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// Configuration used to access the Tracing (Jaeger or Tempo) dashboards.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiExternalServicesTracingProvider {
    #[serde(rename = "jaeger")]
    Jaeger,
    #[serde(rename = "tempo")]
    Tempo,
}

/// Settings used to configure the access url to the Tempo Datasource in Grafana.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiExternalServicesTracingTempoConfig {
    /// When `cache_enabled` is true, the number of traces saved in the cache.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_capacity: Option<i64>,
    /// A FIFO cache with the last `cache_capacity` traces viewed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_enabled: Option<bool>,
    /// The unique identifier (uid) of the Tempo datasource in Grafana.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datasource_uid: Option<String>,
    /// The name of the Tempo instance for the `url_format` of `openshift` in the Plugin UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The namespace of the Tempo instance for the `url_format` of `openshift` in the Plugin UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The Id of the organization that the dashboard is in. Default to 1 (the first and default organization).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub org_id: Option<String>,
    /// The name of the Tempo tenant for the `url_format` of `openshift` in the Plugin UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant: Option<String>,
    /// The URL format for the external url. Can be 'jaeger', 'grafana' or 'openshift'. Default to 'grafana'. Openshift will need the name, namespace and tenant in the `tempo_config` settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url_format: Option<KialiExternalServicesTracingTempoConfigUrlFormat>,
}

/// Settings used to configure the access url to the Tempo Datasource in Grafana.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiExternalServicesTracingTempoConfigUrlFormat {
    #[serde(rename = "jaeger")]
    Jaeger,
    #[serde(rename = "grafana")]
    Grafana,
    #[serde(rename = "openshift")]
    Openshift,
}

/// This section defines what it means for nodes to be healthy. For more details, see <https://kiali.io/docs/configuration/health/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiHealthConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rate: Option<Vec<KialiHealthConfigRate>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiHealthConfigRate {
    /// The type of resource that this configuration applies to. This is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// The name of a resource that this configuration applies to. This is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The name of the namespace that this configuration applies to. This is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// A list of tolerances for this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerance: Option<Vec<KialiHealthConfigRateTolerance>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiHealthConfigRateTolerance {
    /// The status code that applies for this tolerance. This is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// Health will be considered degraded when the telemetry reaches this value (specified as an integer representing a percentage).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub degraded: Option<i64>,
    /// The direction that applies for this tolerance (e.g. inbound or outbound). This is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub direction: Option<String>,
    /// A failure status will be shown when the telemetry reaches this value (specified as an integer representing a percentage).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failure: Option<i64>,
    /// The protocol that applies for this tolerance (e.g. grpc or http). This is a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Settings that define the Kiali server identity.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiIdentity {
    /// Certificate file used to identify the Kiali server. If set, you must go over https to access Kiali. The Kiali operator will set this if it deploys Kiali behind https. When left undefined, the operator will attempt to generate a cluster-specific cert file that provides https by default (today, this auto-generation of a cluster-specific cert is only supported on OpenShift). When set to an empty string, https will be disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert_file: Option<String>,
    /// Private key file used to identify the Kiali server. If set, you must go over https to access Kiali. When left undefined, the Kiali operator will attempt to generate a cluster-specific private key file that provides https by default (today, this auto-generation of a cluster-specific private key is only supported on OpenShift). When set to an empty string, https will be disabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private_key_file: Option<String>,
}

/// Defines specific labels used by Istio that Kiali needs to know about.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiIstioLabels {
    /// If using a single scheme for app/version labeling, set this to the app label name being used. This is typically `app` or `app.kubernetes.io/name`. The default is unset, and Kiali will handle mixed schemes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_label_name: Option<String>,
    /// The selector label for Egress Gateway workload. This is typically `istio=egressgateway`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress_gateway_label: Option<String>,
    /// The selector label for Ingress Gateway workload. This is typically `istio=ingressgateway`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress_gateway_label: Option<String>,
    /// The name of the label used to instruct Istio to automatically inject sidecar proxies when applications are deployed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub injection_label_name: Option<String>,
    /// The label used to identify the Istio revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub injection_label_rev: Option<String>,
    /// If using a single scheme for app/version labeling, set this to the version label name being used. This is typically `version` or `app.kubernetes.io/version`. The default is unset, and Kiali will handle mixed schemes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version_label_name: Option<String>,
}

/// Kiali features that can be enabled or disabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlags {
    /// DEPRECATED AFTER v1.73: Settings for certificate information indicators.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificates_information_indicators: Option<KialiKialiFeatureFlagsCertificatesInformationIndicators>,
    /// DEPRECATED AFTER v1.73: Multi-cluster related features.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clustering: Option<KialiKialiFeatureFlagsClustering>,
    /// Enable observability tabs (Traffic, Logs, Metrics, Traces) for custom workload types beyond the built-in Kubernetes controllers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_workload_types: Option<Vec<KialiKialiFeatureFlagsCustomWorkloadTypes>>,
    /// There may be some features that admins do not want to be accessible to users (even in 'view only' mode). In this case, this setting allows you to disable one or more of those features entirely.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub disabled_features: Option<Vec<String>>,
    /// Flag to enable/disable an Action to edit annotations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_annotation_action: Option<bool>,
    /// Flag to enable/disable an Action to label a namespace for automatic Istio Sidecar injection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_injection_action: Option<bool>,
    /// Flag to activate the Kiali functionality of upgrading namespaces to point to an installed Istio Canary revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub istio_upgrade_action: Option<bool>,
    /// Default settings for the UI. These defaults apply to all users.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ui_defaults: Option<KialiKialiFeatureFlagsUiDefaults>,
    /// Features specific to the validations subsystem.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validations: Option<KialiKialiFeatureFlagsValidations>,
}

/// DEPRECATED AFTER v1.73: Settings for certificate information indicators.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsCertificatesInformationIndicators {
    /// DEPRECATED AFTER v1.73: When true, certificate information indicators will be displayed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// DEPRECATED AFTER v1.73: List of secrets that contain certificate information.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
}

/// DEPRECATED AFTER v1.73: Multi-cluster related features.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsClustering {
    /// DEPRECATED AFTER v1.73: Settings to allow cluster secrets to be auto-detected.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autodetect_secrets: Option<KialiKialiFeatureFlagsClusteringAutodetectSecrets>,
    /// DEPRECATED AFTER v1.73: A list of clusters that the Kiali Server can access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clusters: Option<Vec<KialiKialiFeatureFlagsClusteringClusters>>,
    /// DEPRECATED AFTER v1.73: Flag to enable exec provider for clustering authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable_exec_provider: Option<bool>,
    /// DEPRECATED AFTER v1.73: A map between cluster name, instance name and namespace to a Kiali URL.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kiali_urls: Option<Vec<KialiKialiFeatureFlagsClusteringKialiUrls>>,
}

/// DEPRECATED AFTER v1.73: Settings to allow cluster secrets to be auto-detected.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsClusteringAutodetectSecrets {
    /// DEPRECATED AFTER v1.73: If true then remote cluster secrets will be autodetected.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// DEPRECATED AFTER v1.73: The name and value of a label that exists on all remote cluster secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsClusteringClusters {
    /// DEPRECATED AFTER v1.73: The name of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// DEPRECATED AFTER v1.73: The name of the secret that contains the credentials necessary to connect to the remote cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsClusteringKialiUrls {
    /// DEPRECATED AFTER v1.73: The name of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster_name: Option<String>,
    /// DEPRECATED AFTER v1.73: The instance name of this Kiali installation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instance_name: Option<String>,
    /// DEPRECATED AFTER v1.73: The namespace into which Kiali is installed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// DEPRECATED AFTER v1.73: The URL of Kiali in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsCustomWorkloadTypes {
    /// The API group of the custom workload type (e.g., 'argoproj.io').
    pub group: String,
    /// The kind of the custom workload type (e.g., 'Rollout').
    pub kind: String,
    /// The API version of the custom workload type (e.g., 'v1alpha1').
    pub version: String,
}

/// Default settings for the UI. These defaults apply to all users.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaults {
    /// Default settings for the Graph UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub graph: Option<KialiKialiFeatureFlagsUiDefaultsGraph>,
    /// Default settings for the i18n values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub i18n: Option<KialiKialiFeatureFlagsUiDefaultsI18n>,
    /// Default settings for the List views (Apps, Workloads, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub list: Option<KialiKialiFeatureFlagsUiDefaultsList>,
    /// Default settings for the Mesh UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mesh: Option<KialiKialiFeatureFlagsUiDefaultsMesh>,
    /// Additional label aggregation for inbound metric pages in detail pages.
    /// You will see these configurations in the 'Metric Settings' drop-down.
    /// An example,
    /// ```text
    /// spec:
    ///   kiali_feature_flags:
    ///     ui_defaults:
    ///       metrics_inbound:
    ///         aggregations:
    ///         - display_name: Istio Network
    ///           label: topology_istio_io_network
    ///         - display_name: Istio Revision
    ///           label: istio_io_rev
    /// ```
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_inbound: Option<KialiKialiFeatureFlagsUiDefaultsMetricsInbound>,
    /// Additional label aggregation for outbound metric pages in detail pages.
    /// You will see these configurations in the 'Metric Settings' drop-down.
    /// An example,
    /// ```text
    /// spec:
    ///   kiali_feature_flags:
    ///     ui_defaults:
    ///       metrics_outbound:
    ///         aggregations:
    ///         - display_name: Istio Network
    ///           label: topology_istio_io_network
    ///         - display_name: Istio Revision
    ///           label: istio_io_rev
    /// ```
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_outbound: Option<KialiKialiFeatureFlagsUiDefaultsMetricsOutbound>,
    /// Duration of metrics to fetch on each refresh. Value must be one of: `1m`, `2m`, `5m`, `10m`, `30m`, `1h`, `3h`, `6h`, `12h`, `1d`, `7d`, or `30d`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics_per_refresh: Option<KialiKialiFeatureFlagsUiDefaultsMetricsPerRefresh>,
    /// Default selections for the namespace selection dropdown. Non-existent or inaccessible namespaces will be ignored. Omit or set to an empty array for no default namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// The automatic refresh interval for pages offering automatic refresh. `Manual` requires user action even for initial page load. Value must be one of: `pause`, `manual`, `10s`, `15s`, `30s`, `1m`, `5m` or `15m`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub refresh_interval: Option<KialiKialiFeatureFlagsUiDefaultsRefreshInterval>,
    /// Default settings for the Tracing UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tracing: Option<KialiKialiFeatureFlagsUiDefaultsTracing>,
}

/// Default settings for the Graph UI.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsGraph {
    /// A list of commonly used and useful find expressions that will be provided to the user out-of-box.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub find_options: Option<Vec<KialiKialiFeatureFlagsUiDefaultsGraphFindOptions>>,
    /// A list of commonly used and useful hide expressions that will be provided to the user out-of-box.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hide_options: Option<Vec<KialiKialiFeatureFlagsUiDefaultsGraphHideOptions>>,
    /// Various presentation options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<KialiKialiFeatureFlagsUiDefaultsGraphSettings>,
    /// These settings determine which rates are used to determine graph traffic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub traffic: Option<KialiKialiFeatureFlagsUiDefaultsGraphTraffic>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsGraphFindOptions {
    /// If true this option will be selected and take effect automatically. Note that only one option in the list can have this value be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auto_select: Option<bool>,
    /// Human-readable text to let the user know what the expression does.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The find expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsGraphHideOptions {
    /// If true this option will be selected and take effect automatically. Note that only one option in the list can have this value be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auto_select: Option<bool>,
    /// Human-readable text to let the user know what the expression does.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The hide expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
}

/// Various presentation options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsGraphSettings {
    /// The traffic animation style. Value must be one of: `dash` or `point`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub animation: Option<KialiKialiFeatureFlagsUiDefaultsGraphSettingsAnimation>,
}

/// Various presentation options.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiKialiFeatureFlagsUiDefaultsGraphSettingsAnimation {
    #[serde(rename = "dash")]
    Dash,
    #[serde(rename = "point")]
    Point,
}

/// These settings determine which rates are used to determine graph traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsGraphTraffic {
    /// Ambient traffic is reported by ztunnel and/or waypoints. Value must be one of: `none`, `total`, `waypoint`, or `ztunnel`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ambient: Option<KialiKialiFeatureFlagsUiDefaultsGraphTrafficAmbient>,
    /// gRPC traffic is measured in requests or sent/received/total messages. Value must be one of: `none`, `requests`, `sent`, `received`, or `total`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<KialiKialiFeatureFlagsUiDefaultsGraphTrafficGrpc>,
    /// HTTP traffic is measured in requests. Value must be one of: `none` or `requests`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<KialiKialiFeatureFlagsUiDefaultsGraphTrafficHttp>,
    /// TCP traffic is measured in sent/received/total bytes. Only request traffic supplies response codes. Value must be one of: `none`, `sent`, `received`, or `total`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<KialiKialiFeatureFlagsUiDefaultsGraphTrafficTcp>,
}

/// These settings determine which rates are used to determine graph traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiKialiFeatureFlagsUiDefaultsGraphTrafficAmbient {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "total")]
    Total,
    #[serde(rename = "waypoint")]
    Waypoint,
    #[serde(rename = "ztunnel")]
    Ztunnel,
}

/// These settings determine which rates are used to determine graph traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiKialiFeatureFlagsUiDefaultsGraphTrafficGrpc {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "requests")]
    Requests,
    #[serde(rename = "sent")]
    Sent,
    #[serde(rename = "received")]
    Received,
    #[serde(rename = "total")]
    Total,
}

/// These settings determine which rates are used to determine graph traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiKialiFeatureFlagsUiDefaultsGraphTrafficHttp {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "requests")]
    Requests,
}

/// These settings determine which rates are used to determine graph traffic.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiKialiFeatureFlagsUiDefaultsGraphTrafficTcp {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "sent")]
    Sent,
    #[serde(rename = "received")]
    Received,
    #[serde(rename = "total")]
    Total,
}

/// Default settings for the i18n values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsI18n {
    /// Default language used in Kiali application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
    /// If true Kiali masthead displays language selector icon.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub show_selector: Option<bool>,
}

/// Default settings for the List views (Apps, Workloads, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsList {
    /// Include Health column (by default) for applicable list views. Setting to false can improve performance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub include_health: Option<bool>,
    /// Include Istio resources (by default) in Details column for applicable list views. Setting to false can improve performance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub include_istio_resources: Option<bool>,
    /// Include Configuration validation column (by default) for applicable list views. Setting to false can improve performance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub include_validations: Option<bool>,
    /// If true list pages display checkbox toggles for the include options, Otherwise the configured settings are applied but can not be changed by the user.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub show_include_toggles: Option<bool>,
}

/// Default settings for the Mesh UI.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsMesh {
    /// A list of commonly used and useful find expressions that will be provided to the user out-of-box.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub find_options: Option<Vec<KialiKialiFeatureFlagsUiDefaultsMeshFindOptions>>,
    /// A list of commonly used and useful hide expressions that will be provided to the user out-of-box.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hide_options: Option<Vec<KialiKialiFeatureFlagsUiDefaultsMeshHideOptions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsMeshFindOptions {
    /// If true this option will be selected and take effect automatically. Note that only one option in the list can have this value be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auto_select: Option<bool>,
    /// Human-readable text to let the user know what the expression does.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The find expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsMeshHideOptions {
    /// If true this option will be selected and take effect automatically. Note that only one option in the list can have this value be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auto_select: Option<bool>,
    /// Human-readable text to let the user know what the expression does.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The hide expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
}

/// Additional label aggregation for inbound metric pages in detail pages.
/// You will see these configurations in the 'Metric Settings' drop-down.
/// An example,
/// ```text
/// spec:
///   kiali_feature_flags:
///     ui_defaults:
///       metrics_inbound:
///         aggregations:
///         - display_name: Istio Network
///           label: topology_istio_io_network
///         - display_name: Istio Revision
///           label: istio_io_rev
/// ```
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsMetricsInbound {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aggregations: Option<Vec<KialiKialiFeatureFlagsUiDefaultsMetricsInboundAggregations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsMetricsInboundAggregations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// Flag to indicate if only one option can be selected for this aggregation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_selection: Option<bool>,
}

/// Additional label aggregation for outbound metric pages in detail pages.
/// You will see these configurations in the 'Metric Settings' drop-down.
/// An example,
/// ```text
/// spec:
///   kiali_feature_flags:
///     ui_defaults:
///       metrics_outbound:
///         aggregations:
///         - display_name: Istio Network
///           label: topology_istio_io_network
///         - display_name: Istio Revision
///           label: istio_io_rev
/// ```
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsMetricsOutbound {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aggregations: Option<Vec<KialiKialiFeatureFlagsUiDefaultsMetricsOutboundAggregations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsMetricsOutboundAggregations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// Flag to indicate if only one option can be selected for this aggregation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub single_selection: Option<bool>,
}

/// Default settings for the UI. These defaults apply to all users.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiKialiFeatureFlagsUiDefaultsMetricsPerRefresh {
    #[serde(rename = "1m")]
    r#_1m,
    #[serde(rename = "2m")]
    r#_2m,
    #[serde(rename = "5m")]
    r#_5m,
    #[serde(rename = "10m")]
    r#_10m,
    #[serde(rename = "30m")]
    r#_30m,
    #[serde(rename = "1h")]
    r#_1h,
    #[serde(rename = "3h")]
    r#_3h,
    #[serde(rename = "6h")]
    r#_6h,
    #[serde(rename = "12h")]
    r#_12h,
    #[serde(rename = "1d")]
    r#_1d,
    #[serde(rename = "7d")]
    r#_7d,
    #[serde(rename = "30d")]
    r#_30d,
}

/// Default settings for the UI. These defaults apply to all users.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiKialiFeatureFlagsUiDefaultsRefreshInterval {
    #[serde(rename = "pause")]
    Pause,
    #[serde(rename = "manual")]
    Manual,
    #[serde(rename = "10s")]
    r#_10s,
    #[serde(rename = "15s")]
    r#_15s,
    #[serde(rename = "30s")]
    r#_30s,
    #[serde(rename = "1m")]
    r#_1m,
    #[serde(rename = "5m")]
    r#_5m,
    #[serde(rename = "15m")]
    r#_15m,
}

/// Default settings for the Tracing UI.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsUiDefaultsTracing {
    /// The default limit for the number of traces that will be fetched. It can be customized in the UI. It must be a number between 10 and 1000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limit: Option<i64>,
}

/// Features specific to the validations subsystem.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKialiFeatureFlagsValidations {
    /// A list of one or more validation codes whose errors are to be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignore: Option<Vec<String>>,
    /// The KIA0301 validation checks duplicity of host and port combinations across all Istio Gateways. This includes also Gateways with '*' in hosts. But Istio considers such a Gateway with a wildcard in hosts as the last in order, after the Gateways with FQDN in hosts. This option is to skip Gateways with wildcards in hosts from the KIA0301 validations but still keep Gateways with FQDN hosts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub skip_wildcard_gateway_hosts: Option<bool>,
}

/// Configuration of Kiali's access of the Kubernetes API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiKubernetesConfig {
    /// The Burst value of the Kubernetes client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub burst: Option<i64>,
    /// The ratio interval (expressed in seconds) used for the cache to perform a full refresh. Only used when `cache_enabled` is true.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_duration: Option<i64>,
    /// This Kiali cache is a list of namespaces per user. This is typically a short-lived cache compared with the duration of the namespace cache defined by the `cache_duration` setting. This is specified in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache_token_namespace_duration: Option<i64>,
    /// The name of the cluster Kiali is deployed in. This is also known as the home cluster. This is only used in multi cluster environments. This must be set when `clustering.ignore_home_cluster=true`. If not set, Kiali will try to auto detect the cluster name from the Istiod deployment or use the default 'Kubernetes'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster_name: Option<String>,
    /// List of controllers that won't be used for Workload calculation. Kiali queries Deployment, ReplicaSet, ReplicationController, DeploymentConfig, StatefulSet, Job and CronJob controllers. Deployment and ReplicaSet will be always queried, but ReplicationController, DeploymentConfig, StatefulSet, Job and CronJobs can be skipped from Kiali workloads queries if they are present in this list.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excluded_workloads: Option<Vec<String>>,
    /// The QPS value of the Kubernetes client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub qps: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiLoginToken {
    /// A user's login token expiration specified in seconds. This is applicable to token and header auth strategies only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expiration_seconds: Option<i64>,
    /// The signing key used to generate tokens for user authentication. Because this is potentially sensitive, you have the option to store this value in a secret using the pattern `secret:<secretName>:<secretKey>`. When using a secret, the signing key is read dynamically, enabling automatic rotation without pod restart. If left as an empty string, a secret with a random signing key will be generated for you. The signing key must be 16, 24 or 32 byte long.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signing_key: Option<String>,
}

/// Configuration that controls some core components within the Kiali Server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiServer {
    /// Where the Kiali server is bound. The console and API server are accessible on this host.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// When true, allows additional audit logging on write operations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audit_log: Option<bool>,
    /// When true, allows the web console to send requests to other domains other than where the console came from. Typically used for development environments only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cors_allow_all: Option<bool>,
    /// When true, Kiali serves http requests with gzip enabled (if the browser supports it) when the requests are over 1400 bytes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gzip_enabled: Option<bool>,
    /// If `deployment.service_type` is 'NodePort' and this value is set, then this is the node port that the Kiali service will listen to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node_port: Option<i64>,
    /// Settings to enable observability into the Kiali server itself.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub observability: Option<KialiServerObservability>,
    /// The port that the server will bind to in order to receive console and API requests.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// Controls the internal profiler used to debug the internals of Kiali
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profiler: Option<KialiServerProfiler>,
    /// When true, the /api endpoint will require users to authenticate themselves. When false, users need not authenticate with Kiali in order to get basic runtime info about the server via the /api endpoint. This setting is ignored if auth.strategy is 'anonymous'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub require_auth: Option<bool>,
    /// Defines the public domain where Kiali is being served. This is the 'domain' part of the URL (usually it's a fully-qualified domain name). For example, `kiali.example.org`. When empty, Kiali will try to guess this value from HTTP headers. On non-OpenShift clusters, you must populate this value if you want to enable cross-linking between Kiali instances in a multi-cluster setup.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_fqdn: Option<String>,
    /// Define the history mode of kiali UI. Value must be one of: `browser` or `hash`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_history_mode: Option<KialiServerWebHistoryMode>,
    /// Defines the ingress port where the connections come from. This is usually necessary when the application responds through a proxy/ingress, and it does not forward the correct headers (when this happens, Kiali cannot guess the port). When empty, Kiali will try to guess this value from HTTP headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_port: Option<String>,
    /// Defines the context root path for the Kiali console and API endpoints and readiness probes. When providing a context root path that is not `/`, do not add a trailing slash (i.e. use `/kiali` not `/kiali/`). When empty, this will default to `/` on OpenShift and `/kiali` on other Kubernetes environments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_root: Option<String>,
    /// Defines the public HTTP schema used to serve Kiali. Value must be one of: `http` or `https`. When empty, Kiali will try to guess this value from HTTP headers. On non-OpenShift clusters, you must populate this value if you want to enable cross-linking between Kiali instances in a multi-cluster setup.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub web_schema: Option<KialiServerWebSchema>,
    /// The maximum duration before timing out writes of the HTTP response back to the client.
    /// Can be specified as a number (seconds) or duration string (e.g., "30s", "1h", "2m30s").
    /// 
    /// In OpenShift clusters, the route request time out should be also increased.
    /// This can be done by annotating the specific route with `haproxy.router.openshift.io/timeout`.
    /// See <https://docs.openshift.com/container-platform/4.16/networking/routes/route-configuration.html#nw-configuring-route-timeouts_route-configuration> for further details.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub write_timeout: Option<IntOrString>,
}

/// Settings to enable observability into the Kiali server itself.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiServerObservability {
    /// Settings that control how Kiali itself emits its own metrics.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<KialiServerObservabilityMetrics>,
    /// Settings that control how the Kiali server itself emits its own tracing data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tracing: Option<KialiServerObservabilityTracing>,
}

/// Settings that control how Kiali itself emits its own metrics.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiServerObservabilityMetrics {
    /// When true, the metrics endpoint will be available for Prometheus to scrape.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The port that the server will bind to in order to receive metric requests. This is the port Prometheus will need to scrape when collecting metrics from Kiali.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
}

/// Settings that control how the Kiali server itself emits its own tracing data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiServerObservabilityTracing {
    /// The collector type to use. Today the only valid value is `otel`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub collector_type: Option<KialiServerObservabilityTracingCollectorType>,
    /// Used to determine where the Kiali server tracing data will be stored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub collector_url: Option<String>,
    /// When true, the Kiali server itself will product its own tracing data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Specific properties when the collector type is `otel`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub otel: Option<KialiServerObservabilityTracingOtel>,
    /// Sampling rate for Kiali server traces. >= 1.0 always samples and <= 0 never samples.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sampling_rate: Option<f64>,
}

/// Settings that control how the Kiali server itself emits its own tracing data.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiServerObservabilityTracingCollectorType {
    #[serde(rename = "otel")]
    Otel,
}

/// Specific properties when the collector type is `otel`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiServerObservabilityTracingOtel {
    /// DEPRECATED since v2.20: This setting is deprecated and will be ignored. To configure custom CA certificates, use the kiali-cabundle ConfigMap instead. See the TLS Configuration documentation for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_name: Option<String>,
    /// Protocol. Value must be one of: `http`, `https` or `grpc`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<KialiServerObservabilityTracingOtelProtocol>,
    /// If true, TLS certificate verification will not be performed. This is an unsecure option and is recommended only for testing.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub skip_verify: Option<bool>,
    /// Enable TLS for the collector. This must be specified when `protocol` is `https` or `grpc`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_enabled: Option<bool>,
}

/// Specific properties when the collector type is `otel`.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiServerObservabilityTracingOtelProtocol {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
    #[serde(rename = "grpc")]
    Grpc,
}

/// Controls the internal profiler used to debug the internals of Kiali
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct KialiServerProfiler {
    /// When 'true', the profiler will be enabled and accessible at /debug/pprof/ on the Kiali endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Configuration that controls some core components within the Kiali Server.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiServerWebHistoryMode {
    #[serde(rename = "browser")]
    Browser,
    #[serde(rename = "hash")]
    Hash,
}

/// Configuration that controls some core components within the Kiali Server.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum KialiServerWebSchema {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

