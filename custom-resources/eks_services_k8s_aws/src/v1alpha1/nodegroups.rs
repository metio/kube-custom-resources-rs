// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/aws-controllers-k8s/eks-controller/eks.services.k8s.aws/v1alpha1/nodegroups.yaml
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// NodegroupSpec defines the desired state of Nodegroup.
/// 
/// An object representing an Amazon EKS managed node group.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "eks.services.k8s.aws", version = "v1alpha1", kind = "Nodegroup", plural = "nodegroups")]
#[kube(namespaced)]
#[kube(status = "NodegroupStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct NodegroupSpec {
    /// The AMI type for your node group. If you specify launchTemplate, and your
    /// launch template uses a custom AMI, then don't specify amiType, or the node
    /// group deployment will fail. If your launch template uses a Windows custom
    /// AMI, then add eks:kube-proxy-windows to your Windows nodes rolearn in the
    /// aws-auth ConfigMap. For more information about using launch templates with
    /// Amazon EKS, see Customizing managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
    /// in the Amazon EKS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "amiType")]
    pub ami_type: Option<String>,
    /// The capacity type for your node group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "capacityType")]
    pub capacity_type: Option<String>,
    /// A unique, case-sensitive identifier that you provide to ensurethe idempotency
    /// of the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientRequestToken")]
    pub client_request_token: Option<String>,
    /// The name of your cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterName")]
    pub cluster_name: Option<String>,
    /// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
    /// type to provide more user friendly syntax for references using 'from' field
    /// Ex:
    /// APIIDRef:
    /// 
    /// 	from:
    /// 	  name: my-api
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterRef")]
    pub cluster_ref: Option<NodegroupClusterRef>,
    /// The root device disk size (in GiB) for your node group instances. The default
    /// disk size is 20 GiB for Linux and Bottlerocket. The default disk size is
    /// 50 GiB for Windows. If you specify launchTemplate, then don't specify diskSize,
    /// or the node group deployment will fail. For more information about using
    /// launch templates with Amazon EKS, see Customizing managed nodes with launch
    /// templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
    /// in the Amazon EKS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSize")]
    pub disk_size: Option<i64>,
    /// Specify the instance types for a node group. If you specify a GPU instance
    /// type, make sure to also specify an applicable GPU AMI type with the amiType
    /// parameter. If you specify launchTemplate, then you can specify zero or one
    /// instance type in your launch template or you can specify 0-20 instance types
    /// for instanceTypes. If however, you specify an instance type in your launch
    /// template and specify any instanceTypes, the node group deployment will fail.
    /// If you don't specify an instance type in a launch template or for instanceTypes,
    /// then t3.medium is used, by default. If you specify Spot for capacityType,
    /// then we recommend specifying multiple values for instanceTypes. For more
    /// information, see Managed node group capacity types (<https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types)>
    /// and Customizing managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
    /// in the Amazon EKS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceTypes")]
    pub instance_types: Option<Vec<String>>,
    /// The Kubernetes labels to apply to the nodes in the node group when they are
    /// created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// An object representing a node group's launch template specification. When
    /// using this object, don't directly specify instanceTypes, diskSize, or remoteAccess.
    /// You cannot later specify a different launch template ID or name than what
    /// was used to create the node group.
    /// 
    /// Make sure that the launch template meets the requirements in launchTemplateSpecification.
    /// Also refer to Customizing managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
    /// in the Amazon EKS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "launchTemplate")]
    pub launch_template: Option<NodegroupLaunchTemplate>,
    /// The unique name to give your node group.
    pub name: String,
    /// The Amazon Resource Name (ARN) of the IAM role to associate with your node
    /// group. The Amazon EKS worker node kubelet daemon makes calls to Amazon Web
    /// Services APIs on your behalf. Nodes receive permissions for these API calls
    /// through an IAM instance profile and associated policies. Before you can launch
    /// nodes and register them into a cluster, you must create an IAM role for those
    /// nodes to use when they are launched. For more information, see Amazon EKS
    /// node IAM role (<https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html)>
    /// in the Amazon EKS User Guide . If you specify launchTemplate, then don't
    /// specify IamInstanceProfile (<https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html)>
    /// in your launch template, or the node group deployment will fail. For more
    /// information about using launch templates with Amazon EKS, see Customizing
    /// managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
    /// in the Amazon EKS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeRole")]
    pub node_role: Option<String>,
    /// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
    /// type to provide more user friendly syntax for references using 'from' field
    /// Ex:
    /// APIIDRef:
    /// 
    /// 	from:
    /// 	  name: my-api
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeRoleRef")]
    pub node_role_ref: Option<NodegroupNodeRoleRef>,
    /// The AMI version of the Amazon EKS optimized AMI to use with your node group.
    /// By default, the latest available AMI version for the node group's current
    /// Kubernetes version is used. For information about Linux versions, see Amazon
    /// EKS optimized Amazon Linux AMI versions (<https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html)>
    /// in the Amazon EKS User Guide. Amazon EKS managed node groups support the
    /// November 2022 and later releases of the Windows AMIs. For information about
    /// Windows versions, see Amazon EKS optimized Windows AMI versions (<https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html)>
    /// in the Amazon EKS User Guide.
    /// 
    /// If you specify launchTemplate, and your launch template uses a custom AMI,
    /// then don't specify releaseVersion, or the node group deployment will fail.
    /// For more information about using launch templates with Amazon EKS, see Customizing
    /// managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
    /// in the Amazon EKS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "releaseVersion")]
    pub release_version: Option<String>,
    /// The remote access configuration to use with your node group. For Linux, the
    /// protocol is SSH. For Windows, the protocol is RDP. If you specify launchTemplate,
    /// then don't specify remoteAccess, or the node group deployment will fail.
    /// For more information about using launch templates with Amazon EKS, see Customizing
    /// managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
    /// in the Amazon EKS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteAccess")]
    pub remote_access: Option<NodegroupRemoteAccess>,
    /// The scaling configuration details for the Auto Scaling group that is created
    /// for your node group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scalingConfig")]
    pub scaling_config: Option<NodegroupScalingConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subnetRefs")]
    pub subnet_refs: Option<Vec<NodegroupSubnetRefs>>,
    /// The subnets to use for the Auto Scaling group that is created for your node
    /// group. If you specify launchTemplate, then don't specify SubnetId (<https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html)>
    /// in your launch template, or the node group deployment will fail. For more
    /// information about using launch templates with Amazon EKS, see Customizing
    /// managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
    /// in the Amazon EKS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnets: Option<Vec<String>>,
    /// Metadata that assists with categorization and organization. Each tag consists
    /// of a key and an optional value. You define both. Tags don't propagate to
    /// any other cluster or Amazon Web Services resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
    /// The Kubernetes taints to be applied to the nodes in the node group. For more
    /// information, see Node taints on managed node groups (<https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html).>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub taints: Option<Vec<NodegroupTaints>>,
    /// The node group update configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateConfig")]
    pub update_config: Option<NodegroupUpdateConfig>,
    /// The Kubernetes version to use for your managed nodes. By default, the Kubernetes
    /// version of the cluster is used, and this is the only accepted specified value.
    /// If you specify launchTemplate, and your launch template uses a custom AMI,
    /// then don't specify version, or the node group deployment will fail. For more
    /// information about using launch templates with Amazon EKS, see Customizing
    /// managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
    /// in the Amazon EKS User Guide.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
/// type to provide more user friendly syntax for references using 'from' field
/// Ex:
/// APIIDRef:
/// 
/// 	from:
/// 	  name: my-api
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupClusterRef {
    /// AWSResourceReference provides all the values necessary to reference another
    /// k8s resource for finding the identifier(Id/ARN/Name)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<NodegroupClusterRefFrom>,
}

/// AWSResourceReference provides all the values necessary to reference another
/// k8s resource for finding the identifier(Id/ARN/Name)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupClusterRefFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// An object representing a node group's launch template specification. When
/// using this object, don't directly specify instanceTypes, diskSize, or remoteAccess.
/// You cannot later specify a different launch template ID or name than what
/// was used to create the node group.
/// 
/// Make sure that the launch template meets the requirements in launchTemplateSpecification.
/// Also refer to Customizing managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
/// in the Amazon EKS User Guide.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupLaunchTemplate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
/// type to provide more user friendly syntax for references using 'from' field
/// Ex:
/// APIIDRef:
/// 
/// 	from:
/// 	  name: my-api
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupNodeRoleRef {
    /// AWSResourceReference provides all the values necessary to reference another
    /// k8s resource for finding the identifier(Id/ARN/Name)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<NodegroupNodeRoleRefFrom>,
}

/// AWSResourceReference provides all the values necessary to reference another
/// k8s resource for finding the identifier(Id/ARN/Name)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupNodeRoleRefFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The remote access configuration to use with your node group. For Linux, the
/// protocol is SSH. For Windows, the protocol is RDP. If you specify launchTemplate,
/// then don't specify remoteAccess, or the node group deployment will fail.
/// For more information about using launch templates with Amazon EKS, see Customizing
/// managed nodes with launch templates (<https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)>
/// in the Amazon EKS User Guide.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupRemoteAccess {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ec2SshKey")]
    pub ec2_ssh_key: Option<String>,
    /// Reference field for SourceSecurityGroups
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSecurityGroupRefs")]
    pub source_security_group_refs: Option<Vec<NodegroupRemoteAccessSourceSecurityGroupRefs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceSecurityGroups")]
    pub source_security_groups: Option<Vec<String>>,
}

/// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
/// type to provide more user friendly syntax for references using 'from' field
/// Ex:
/// APIIDRef:
/// 
/// 	from:
/// 	  name: my-api
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupRemoteAccessSourceSecurityGroupRefs {
    /// AWSResourceReference provides all the values necessary to reference another
    /// k8s resource for finding the identifier(Id/ARN/Name)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<NodegroupRemoteAccessSourceSecurityGroupRefsFrom>,
}

/// AWSResourceReference provides all the values necessary to reference another
/// k8s resource for finding the identifier(Id/ARN/Name)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupRemoteAccessSourceSecurityGroupRefsFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The scaling configuration details for the Auto Scaling group that is created
/// for your node group.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupScalingConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredSize")]
    pub desired_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSize")]
    pub max_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minSize")]
    pub min_size: Option<i64>,
}

/// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
/// type to provide more user friendly syntax for references using 'from' field
/// Ex:
/// APIIDRef:
/// 
/// 	from:
/// 	  name: my-api
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupSubnetRefs {
    /// AWSResourceReference provides all the values necessary to reference another
    /// k8s resource for finding the identifier(Id/ARN/Name)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<NodegroupSubnetRefsFrom>,
}

/// AWSResourceReference provides all the values necessary to reference another
/// k8s resource for finding the identifier(Id/ARN/Name)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupSubnetRefsFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// A property that allows a node to repel a Pod. For more information, see Node
/// taints on managed node groups (<https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html)>
/// in the Amazon EKS User Guide.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupTaints {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// The node group update configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupUpdateConfig {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailablePercentage")]
    pub max_unavailable_percentage: Option<i64>,
}

/// NodegroupStatus defines the observed state of Nodegroup
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupStatus {
    /// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
    /// that is used to contain resource sync state, account ownership,
    /// constructed ARN for the resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResourceMetadata")]
    pub ack_resource_metadata: Option<NodegroupStatusAckResourceMetadata>,
    /// All CRs managed by ACK have a common `Status.Conditions` member that
    /// contains a collection of `ackv1alpha1.Condition` objects that describe
    /// the various terminal states of the CR and its backend AWS service API
    /// resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// The Unix epoch timestamp at object creation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createdAt")]
    pub created_at: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredSize")]
    pub desired_size: Option<i64>,
    /// The health status of the node group. If there are issues with your node group's
    /// health, they are listed here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health: Option<NodegroupStatusHealth>,
    /// The Unix epoch timestamp for the last modification to the object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modifiedAt")]
    pub modified_at: Option<String>,
    /// The resources associated with the node group, such as Auto Scaling groups
    /// and security groups for remote access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<NodegroupStatusResources>,
    /// The current status of the managed node group.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
/// that is used to contain resource sync state, account ownership,
/// constructed ARN for the resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupStatusAckResourceMetadata {
    /// ARN is the Amazon Resource Name for the resource. This is a
    /// globally-unique identifier and is set only by the ACK service controller
    /// once the controller has orchestrated the creation of the resource OR
    /// when it has verified that an "adopted" resource (a resource where the
    /// ARN annotation was set by the Kubernetes user on the CR) exists and
    /// matches the supplied CR's Spec field values.
    /// <https://github.com/aws/aws-controllers-k8s/issues/270>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// OwnerAccountID is the AWS Account ID of the account that owns the
    /// backend AWS service API resource.
    #[serde(rename = "ownerAccountID")]
    pub owner_account_id: String,
    /// Region is the AWS region in which the resource exists or will exist.
    pub region: String,
}

/// The health status of the node group. If there are issues with your node group's
/// health, they are listed here.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupStatusHealth {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issues: Option<Vec<NodegroupStatusHealthIssues>>,
}

/// An object representing an issue with an Amazon EKS resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupStatusHealthIssues {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceIDs")]
    pub resource_i_ds: Option<Vec<String>>,
}

/// The resources associated with the node group, such as Auto Scaling groups
/// and security groups for remote access.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupStatusResources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoScalingGroups")]
    pub auto_scaling_groups: Option<Vec<NodegroupStatusResourcesAutoScalingGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteAccessSecurityGroup")]
    pub remote_access_security_group: Option<String>,
}

/// An Auto Scaling group that is associated with an Amazon EKS managed node
/// group.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodegroupStatusResourcesAutoScalingGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

