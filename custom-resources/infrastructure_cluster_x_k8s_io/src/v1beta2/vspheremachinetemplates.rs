// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/kubernetes-sigs/cluster-api-provider-vsphere/infrastructure.cluster.x-k8s.io/v1beta2/vspheremachinetemplates.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// spec is the desired state of VSphereMachineTemplate.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "infrastructure.cluster.x-k8s.io", version = "v1beta2", kind = "VSphereMachineTemplate", plural = "vspheremachinetemplates")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct VSphereMachineTemplateSpec {
    /// template defines the desired state of VSphereMachineTemplate.
    pub template: VSphereMachineTemplateTemplate,
}

/// template defines the desired state of VSphereMachineTemplate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplate {
    /// metadata is the standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<VSphereMachineTemplateTemplateMetadata>,
    /// spec is the specification of the desired behavior of the machine.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<VSphereMachineTemplateTemplateSpec>,
}

/// metadata is the standard object's metadata.
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateMetadata {
    /// annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <http://kubernetes.io/docs/user-guide/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <http://kubernetes.io/docs/user-guide/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// spec is the specification of the desired behavior of the machine.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpec {
    /// additionalDisksGiB holds the sizes of additional disks of the virtual machine, in GiB
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalDisksGiB")]
    pub additional_disks_gi_b: Option<Vec<i64>>,
    /// cloneMode specifies the type of clone operation.
    /// The LinkedClone mode is only support for templates that have at least
    /// one snapshot. If the template has no snapshots, then CloneMode defaults
    /// to FullClone.
    /// When LinkedClone mode is enabled the DiskGiB field is ignored as it is
    /// not possible to expand disks of linked clones.
    /// Defaults to LinkedClone, but fails gracefully to FullClone if the source
    /// of the clone operation has no snapshots.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloneMode")]
    pub clone_mode: Option<VSphereMachineTemplateTemplateSpecCloneMode>,
    /// customVMXKeys is a dictionary of advanced VMX options that can be set on VM
    /// Defaults to empty map
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customVMXKeys")]
    pub custom_vmx_keys: Option<BTreeMap<String, String>>,
    /// dataDisks are additional disks to add to the VM that are not part of the VM's OVA template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataDisks")]
    pub data_disks: Option<Vec<VSphereMachineTemplateTemplateSpecDataDisks>>,
    /// datacenter is the name, inventory path, managed object reference or the managed
    /// object ID of the datacenter in which the virtual machine is created/located.
    /// Defaults to * which selects the default datacenter.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datacenter: Option<String>,
    /// datastore is the name, inventory path, managed object reference or the managed
    /// object ID of the datastore in which the virtual machine is created/located.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datastore: Option<String>,
    /// diskGiB is the size of a virtual machine's disk, in GiB.
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskGiB")]
    pub disk_gi_b: Option<i32>,
    /// folder is the name, inventory path, managed object reference or the managed
    /// object ID of the folder in which the virtual machine is created/located.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub folder: Option<String>,
    /// guestSoftPowerOffTimeoutSeconds sets the wait timeout for shutdown in the VM guest.
    /// The VM will be powered off forcibly after the timeout if the VM is still
    /// up and running when the PowerOffMode is set to trySoft.
    /// 
    /// This parameter only applies when the PowerOffMode is set to trySoft.
    /// 
    /// If omitted, the timeout defaults to 5 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "guestSoftPowerOffTimeoutSeconds")]
    pub guest_soft_power_off_timeout_seconds: Option<i32>,
    /// hardwareVersion is the hardware version of the virtual machine.
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    /// Check the compatibility with the ESXi version before setting the value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hardwareVersion")]
    pub hardware_version: Option<String>,
    /// memoryMiB is the size of a virtual machine's memory, in MiB.
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryMiB")]
    pub memory_mi_b: Option<i64>,
    /// naming allows configuring the naming strategy used when calculating the name of the VSphereVM.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub naming: Option<VSphereMachineTemplateTemplateSpecNaming>,
    /// network is the network configuration for this machine's VM.
    pub network: VSphereMachineTemplateTemplateSpecNetwork,
    /// numCPUs is the number of virtual processors in a virtual machine.
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numCPUs")]
    pub num_cp_us: Option<i32>,
    /// numCoresPerSocket is the number of cores among which to distribute CPUs in this
    /// virtual machine.
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    /// Note: Starting with vSphere 8 numCoresPerSocket can be set to 0 to enable "Assigned at power on".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numCoresPerSocket")]
    pub num_cores_per_socket: Option<i32>,
    /// os is the Operating System of the virtual machine
    /// Defaults to Linux
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub os: Option<String>,
    /// pciDevices is the list of pci devices used by the virtual machine.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pciDevices")]
    pub pci_devices: Option<Vec<VSphereMachineTemplateTemplateSpecPciDevices>>,
    /// powerOffMode describes the desired behavior when powering off a VM.
    /// 
    /// There are three, supported power off modes: hard, soft, and
    /// trySoft. The first mode, hard, is the equivalent of a physical
    /// system's power cord being ripped from the wall. The soft mode
    /// requires the VM's guest to have VM Tools installed and attempts to
    /// gracefully shut down the VM. Its variant, trySoft, first attempts
    /// a graceful shutdown, and if that fails or the VM is not in a powered off
    /// state after reaching the GuestSoftPowerOffTimeoutSeconds, the VM is halted.
    /// 
    /// If omitted, the mode defaults to hard.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "powerOffMode")]
    pub power_off_mode: Option<VSphereMachineTemplateTemplateSpecPowerOffMode>,
    /// providerID is the virtual machine's BIOS UUID formatted as
    /// vsphere://12345678-1234-1234-1234-123456789abc
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerID")]
    pub provider_id: Option<String>,
    /// resourcePool is the name, inventory path, managed object reference or the managed
    /// object ID in which the virtual machine is created/located.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourcePool")]
    pub resource_pool: Option<String>,
    /// resources is the definition of the VM's cpu and memory
    /// reservations, limits and shares.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<VSphereMachineTemplateTemplateSpecResources>,
    /// server is the IP address or FQDN of the vSphere server on which
    /// the virtual machine is created/located.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server: Option<String>,
    /// snapshot is the name of the snapshot from which to create a linked clone.
    /// This field is ignored if LinkedClone is not enabled.
    /// Defaults to the source's current snapshot.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub snapshot: Option<String>,
    /// storagePolicyName of the storage policy to use with this
    /// Virtual Machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyName")]
    pub storage_policy_name: Option<String>,
    /// tagIDs is an optional set of tags to add to an instance. Specified tagIDs
    /// must use URN-notation instead of display names.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagIDs")]
    pub tag_i_ds: Option<Vec<String>>,
    /// template is the name, inventory path, managed object reference or the managed
    /// object ID of the template used to clone the virtual machine.
    pub template: String,
    /// thumbprint is the colon-separated SHA-1 checksum of the given vCenter server's host certificate
    /// When this is set to empty, this VirtualMachine would be created
    /// without TLS certificate validation of the communication between Cluster API Provider vSphere
    /// and the VMware vCenter server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thumbprint: Option<String>,
}

/// spec is the specification of the desired behavior of the machine.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VSphereMachineTemplateTemplateSpecCloneMode {
    #[serde(rename = "fullClone")]
    FullClone,
    #[serde(rename = "linkedClone")]
    LinkedClone,
}

/// VSphereDisk is an additional disk to add to the VM that is not part of the VM OVA template.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecDataDisks {
    /// name is used to identify the disk definition. Name is required and needs to be unique so that it can be used to
    /// clearly identify purpose of the disk.
    pub name: String,
    /// provisioningMode specifies the provisioning type to be used by this vSphere data disk.
    /// If not set, the setting will be provided by the default storage policy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provisioningMode")]
    pub provisioning_mode: Option<VSphereMachineTemplateTemplateSpecDataDisksProvisioningMode>,
    /// sizeGiB is the size of the disk in GiB.
    #[serde(rename = "sizeGiB")]
    pub size_gi_b: i32,
}

/// VSphereDisk is an additional disk to add to the VM that is not part of the VM OVA template.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VSphereMachineTemplateTemplateSpecDataDisksProvisioningMode {
    Thin,
    Thick,
    EagerlyZeroed,
}

/// naming allows configuring the naming strategy used when calculating the name of the VSphereVM.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecNaming {
    /// template defines the template to use for generating the name of the VSphereVM object.
    /// If not defined, it will fall back to `{{ .machine.name }}`.
    /// The templating has the following data available:
    /// * `.machine.name`: The name of the Machine object.
    /// The templating also has the following funcs available:
    /// * `trimSuffix`: same as strings.TrimSuffix
    /// * `trunc`: truncates a string, e.g. `trunc 2 "hello"` or `trunc -2 "hello"`
    /// Notes:
    /// * While the template offers some flexibility, we would like the name to link to the Machine name
    ///   to ensure better user experience when troubleshooting
    /// * Generated names must be valid Kubernetes names as they are used to create a VSphereVM object
    ///   and usually also as the name of the Node object.
    /// * Names are automatically truncated at 63 characters. Please note that this can lead to name conflicts,
    ///   so we highly recommend to use a template which leads to a name shorter than 63 characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
}

/// network is the network configuration for this machine's VM.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecNetwork {
    /// devices is the list of network devices used by the virtual machine.
    /// 
    pub devices: Vec<VSphereMachineTemplateTemplateSpecNetworkDevices>,
    /// routes is a list of optional, static routes applied to the virtual
    /// machine.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routes: Option<Vec<VSphereMachineTemplateTemplateSpecNetworkRoutes>>,
}

/// NetworkDeviceSpec defines the network configuration for a virtual machine's
/// network device.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecNetworkDevices {
    /// addressesFromPools is a list of IPAddressPools that should be assigned
    /// to IPAddressClaims. The machine's cloud-init metadata will be populated
    /// with IPAddresses fulfilled by an IPAM provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "addressesFromPools")]
    pub addresses_from_pools: Option<Vec<VSphereMachineTemplateTemplateSpecNetworkDevicesAddressesFromPools>>,
    /// deviceName may be used to explicitly assign a name to the network device
    /// as it exists in the guest operating system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceName")]
    pub device_name: Option<String>,
    /// dhcp4 is a flag that indicates whether or not to use DHCP for IPv4
    /// on this device.
    /// If true then IPAddrs should not contain any IPv4 addresses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dhcp4: Option<bool>,
    /// dhcp4Overrides allows for the control over several DHCP behaviors.
    /// Overrides will only be applied when the corresponding DHCP flag is set.
    /// Only configured values will be sent, omitted values will default to
    /// distribution defaults.
    /// Dependent on support in the network stack for your distribution.
    /// For more information see the netplan reference (<https://netplan.io/reference#dhcp-overrides)>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dhcp4Overrides")]
    pub dhcp4_overrides: Option<VSphereMachineTemplateTemplateSpecNetworkDevicesDhcp4Overrides>,
    /// dhcp6 is a flag that indicates whether or not to use DHCP for IPv6
    /// on this device.
    /// If true then IPAddrs should not contain any IPv6 addresses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dhcp6: Option<bool>,
    /// dhcp6Overrides allows for the control over several DHCP behaviors.
    /// Overrides will only be applied when the corresponding DHCP flag is set.
    /// Only configured values will be sent, omitted values will default to
    /// distribution defaults.
    /// Dependent on support in the network stack for your distribution.
    /// For more information see the netplan reference (<https://netplan.io/reference#dhcp-overrides)>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dhcp6Overrides")]
    pub dhcp6_overrides: Option<VSphereMachineTemplateTemplateSpecNetworkDevicesDhcp6Overrides>,
    /// gateway4 is the IPv4 gateway used by this device.
    /// Required when DHCP4 is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway4: Option<String>,
    /// gateway6 is the IPv6 gateway used by this device.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway6: Option<String>,
    /// ipAddrs is a list of one or more IPv4 and/or IPv6 addresses to assign
    /// to this device. IP addresses must also specify the segment length in
    /// CIDR notation.
    /// Required when DHCP4, DHCP6 and SkipIPAllocation are false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipAddrs")]
    pub ip_addrs: Option<Vec<String>>,
    /// macAddr is the MAC address used by this device.
    /// It is generally a good idea to omit this field and allow a MAC address
    /// to be generated.
    /// Please note that this value must use the VMware OUI to work with the
    /// in-tree vSphere cloud provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "macAddr")]
    pub mac_addr: Option<String>,
    /// mtu is the deviceâ€™s Maximum Transmission Unit size in bytes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mtu: Option<i64>,
    /// nameservers is a list of IPv4 and/or IPv6 addresses used as DNS
    /// nameservers.
    /// Please note that Linux allows only three nameservers (<https://linux.die.net/man/5/resolv.conf).>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nameservers: Option<Vec<String>>,
    /// networkName is the name, managed object reference or the managed
    /// object ID of the vSphere network to which the device will be connected.
    #[serde(rename = "networkName")]
    pub network_name: String,
    /// routes is a list of optional, static routes applied to the device.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub routes: Option<Vec<VSphereMachineTemplateTemplateSpecNetworkDevicesRoutes>>,
    /// searchDomains is a list of search domains used when resolving IP
    /// addresses with DNS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "searchDomains")]
    pub search_domains: Option<Vec<String>>,
    /// skipIPAllocation allows the device to not have IP address or DHCP configured.
    /// This is suitable for devices for which IP allocation is handled externally, eg. using Multus CNI.
    /// If true, CAPV will not verify IP address allocation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipIPAllocation")]
    pub skip_ip_allocation: Option<bool>,
}

/// IPPoolReference is a reference to an IPPool.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecNetworkDevicesAddressesFromPools {
    /// apiGroup of the IPPool.
    /// apiGroup must be fully qualified domain name.
    #[serde(rename = "apiGroup")]
    pub api_group: String,
    /// kind of the IPPool.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the IPPool.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// dhcp4Overrides allows for the control over several DHCP behaviors.
/// Overrides will only be applied when the corresponding DHCP flag is set.
/// Only configured values will be sent, omitted values will default to
/// distribution defaults.
/// Dependent on support in the network stack for your distribution.
/// For more information see the netplan reference (<https://netplan.io/reference#dhcp-overrides)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecNetworkDevicesDhcp4Overrides {
    /// hostname is the name which will be sent to the DHCP server instead of
    /// the machine's hostname.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// routeMetric is used to prioritize routes for devices. A lower metric for
    /// an interface will have a higher priority.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeMetric")]
    pub route_metric: Option<i32>,
    /// sendHostname when `true`, the hostname of the machine will be sent to the
    /// DHCP server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendHostname")]
    pub send_hostname: Option<bool>,
    /// useDNS when `true`, the DNS servers in the DHCP server will be used and
    /// take precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDNS")]
    pub use_dns: Option<bool>,
    /// useDomains can take the values `true`, `false`, or `route`. When `true`,
    /// the domain name from the DHCP server will be used as the DNS search
    /// domain for this device. When `route`, the domain name from the DHCP
    /// response will be used for routing DNS only, not for searching.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDomains")]
    pub use_domains: Option<String>,
    /// useHostname when `true`, the hostname from the DHCP server will be set
    /// as the transient hostname of the machine.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useHostname")]
    pub use_hostname: Option<bool>,
    /// useMTU when `true`, the MTU from the DHCP server will be set as the
    /// MTU of the device.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useMTU")]
    pub use_mtu: Option<bool>,
    /// useNTP when `true`, the NTP servers from the DHCP server will be used
    /// by systemd-timesyncd and take precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useNTP")]
    pub use_ntp: Option<bool>,
    /// useRoutes when `true`, the routes from the DHCP server will be installed
    /// in the routing table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useRoutes")]
    pub use_routes: Option<String>,
}

/// dhcp6Overrides allows for the control over several DHCP behaviors.
/// Overrides will only be applied when the corresponding DHCP flag is set.
/// Only configured values will be sent, omitted values will default to
/// distribution defaults.
/// Dependent on support in the network stack for your distribution.
/// For more information see the netplan reference (<https://netplan.io/reference#dhcp-overrides)>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecNetworkDevicesDhcp6Overrides {
    /// hostname is the name which will be sent to the DHCP server instead of
    /// the machine's hostname.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// routeMetric is used to prioritize routes for devices. A lower metric for
    /// an interface will have a higher priority.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeMetric")]
    pub route_metric: Option<i32>,
    /// sendHostname when `true`, the hostname of the machine will be sent to the
    /// DHCP server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sendHostname")]
    pub send_hostname: Option<bool>,
    /// useDNS when `true`, the DNS servers in the DHCP server will be used and
    /// take precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDNS")]
    pub use_dns: Option<bool>,
    /// useDomains can take the values `true`, `false`, or `route`. When `true`,
    /// the domain name from the DHCP server will be used as the DNS search
    /// domain for this device. When `route`, the domain name from the DHCP
    /// response will be used for routing DNS only, not for searching.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useDomains")]
    pub use_domains: Option<String>,
    /// useHostname when `true`, the hostname from the DHCP server will be set
    /// as the transient hostname of the machine.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useHostname")]
    pub use_hostname: Option<bool>,
    /// useMTU when `true`, the MTU from the DHCP server will be set as the
    /// MTU of the device.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useMTU")]
    pub use_mtu: Option<bool>,
    /// useNTP when `true`, the NTP servers from the DHCP server will be used
    /// by systemd-timesyncd and take precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useNTP")]
    pub use_ntp: Option<bool>,
    /// useRoutes when `true`, the routes from the DHCP server will be installed
    /// in the routing table.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useRoutes")]
    pub use_routes: Option<String>,
}

/// NetworkRouteSpec defines a static network route.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecNetworkDevicesRoutes {
    /// metric is the weight/priority of the route.
    pub metric: i32,
    /// to is an IPv4 or IPv6 address.
    pub to: String,
    /// via is an IPv4 or IPv6 address.
    pub via: String,
}

/// NetworkRouteSpec defines a static network route.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecNetworkRoutes {
    /// metric is the weight/priority of the route.
    pub metric: i32,
    /// to is an IPv4 or IPv6 address.
    pub to: String,
    /// via is an IPv4 or IPv6 address.
    pub via: String,
}

/// PCIDeviceSpec defines virtual machine's PCI configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecPciDevices {
    /// customLabel is the hardware label of a virtual machine's PCI device.
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customLabel")]
    pub custom_label: Option<String>,
    /// deviceId is the device ID of a virtual machine's PCI, in integer.
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    /// Mutually exclusive with VGPUProfile as VGPUProfile and DeviceID + VendorID
    /// are two independent ways to define PCI devices.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceId")]
    pub device_id: Option<i32>,
    /// vGPUProfile is the profile name of a virtual machine's vGPU, in string.
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    /// Mutually exclusive with DeviceID and VendorID as VGPUProfile and DeviceID + VendorID
    /// are two independent ways to define PCI devices.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vGPUProfile")]
    pub v_gpu_profile: Option<String>,
    /// vendorId is the vendor ID of a virtual machine's PCI, in integer.
    /// Defaults to the eponymous property value in the template from which the
    /// virtual machine is cloned.
    /// Mutually exclusive with VGPUProfile as VGPUProfile and DeviceID + VendorID
    /// are two independent ways to define PCI devices.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vendorId")]
    pub vendor_id: Option<i32>,
}

/// spec is the specification of the desired behavior of the machine.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum VSphereMachineTemplateTemplateSpecPowerOffMode {
    #[serde(rename = "hard")]
    Hard,
    #[serde(rename = "soft")]
    Soft,
    #[serde(rename = "trySoft")]
    TrySoft,
}

/// resources is the definition of the VM's cpu and memory
/// reservations, limits and shares.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecResources {
    /// limits is the definition of the VM's cpu (in hertz, rounded up to the nearest MHz)
    /// and memory (in bytes, rounded up to the nearest MiB) limits
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<VSphereMachineTemplateTemplateSpecResourcesLimits>,
    /// requests is the definition of the VM's cpu (in hertz, rounded up to the nearest MHz)
    /// and memory (in bytes, rounded up to the nearest MiB) reservations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<VSphereMachineTemplateTemplateSpecResourcesRequests>,
    /// shares is the definition of the VM's cpu and memory shares
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shares: Option<VSphereMachineTemplateTemplateSpecResourcesShares>,
}

/// limits is the definition of the VM's cpu (in hertz, rounded up to the nearest MHz)
/// and memory (in bytes, rounded up to the nearest MiB) limits
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecResourcesLimits {
    /// cpu is the definition of the cpu quantity for the given VM hardware policy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<IntOrString>,
    /// memory is the definition of the memory quantity for the given VM hardware policy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<IntOrString>,
}

/// requests is the definition of the VM's cpu (in hertz, rounded up to the nearest MHz)
/// and memory (in bytes, rounded up to the nearest MiB) reservations
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecResourcesRequests {
    /// cpu is the definition of the cpu quantity for the given VM hardware policy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<IntOrString>,
    /// memory is the definition of the memory quantity for the given VM hardware policy
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<IntOrString>,
}

/// shares is the definition of the VM's cpu and memory shares
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct VSphereMachineTemplateTemplateSpecResourcesShares {
    /// cpu is the number of spu shares to assign to the VM
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<i32>,
    /// memory is the number of memory shares to assign to the VM
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<i32>,
}

