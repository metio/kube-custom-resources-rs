// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/tinkerbell/cluster-api-provider-tinkerbell/infrastructure.cluster.x-k8s.io/v1beta1/tinkerbellmachines.yaml
// kopium version: 0.22.4

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// TinkerbellMachineSpec defines the desired state of TinkerbellMachine.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "infrastructure.cluster.x-k8s.io", version = "v1beta1", kind = "TinkerbellMachine", plural = "tinkerbellmachines")]
#[kube(namespaced)]
#[kube(status = "TinkerbellMachineStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct TinkerbellMachineSpec {
    /// BootOptions are options that control the booting of Hardware.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootOptions")]
    pub boot_options: Option<TinkerbellMachineBootOptions>,
    /// HardwareAffinity allows filtering for hardware.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hardwareAffinity")]
    pub hardware_affinity: Option<TinkerbellMachineHardwareAffinity>,
    /// Those fields are set programmatically, but they cannot be re-constructed from "state of the world", so
    /// we put them in spec instead of status.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hardwareName")]
    pub hardware_name: Option<String>,
    /// ImageLookupBaseRegistry is the base Registry URL that is used for pulling images,
    /// if not set, the default will be to use ghcr.io/tinkerbell/cluster-api-provider-tinkerbell.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageLookupBaseRegistry")]
    pub image_lookup_base_registry: Option<String>,
    /// ImageLookupFormat is the URL naming format to use for machine images when
    /// a machine does not specify. When set, this will be used for all cluster machines
    /// unless a machine specifies a different ImageLookupFormat. Supports substitutions
    /// for {{.BaseRegistry}}, {{.OSDistro}}, {{.OSVersion}} and {{.KubernetesVersion}} with
    /// the basse URL, OS distribution, OS version, and kubernetes version, respectively.
    /// BaseRegistry will be the value in ImageLookupBaseRegistry or ghcr.io/tinkerbell/cluster-api-provider-tinkerbell
    /// (the default), OSDistro will be the value in ImageLookupOSDistro or ubuntu (the default),
    /// OSVersion will be the value in ImageLookupOSVersion or default based on the OSDistro
    /// (if known), and the kubernetes version as defined by the packages produced by
    /// kubernetes/release: v1.13.0, v1.12.5-mybuild.1, or v1.17.3. For example, the default
    /// image format of {{.BaseRegistry}}/{{.OSDistro}}-{{.OSVersion}}:{{.KubernetesVersion}}.gz will
    /// attempt to pull the image from that location. See also: <https://golang.org/pkg/text/template/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageLookupFormat")]
    pub image_lookup_format: Option<String>,
    /// ImageLookupOSDistro is the name of the OS distro to use when fetching machine images,
    /// if not set it will default to ubuntu.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageLookupOSDistro")]
    pub image_lookup_os_distro: Option<String>,
    /// ImageLookupOSVersion is the version of the OS distribution to use when fetching machine
    /// images. If not set it will default based on ImageLookupOSDistro.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageLookupOSVersion")]
    pub image_lookup_os_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "providerID")]
    pub provider_id: Option<String>,
    /// TemplateOverride overrides the default Tinkerbell template used by CAPT.
    /// You can learn more about Tinkerbell templates here: <https://tinkerbell.org/docs/concepts/templates/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateOverride")]
    pub template_override: Option<String>,
}

/// BootOptions are options that control the booting of Hardware.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineBootOptions {
    /// BootMode is the type of booting that will be done.
    /// Must be one of "none", "netboot", "iso", or "isoboot".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootMode")]
    pub boot_mode: Option<TinkerbellMachineBootOptionsBootMode>,
    /// ISOURL is the URL of the ISO that will be one-time booted.
    /// A HardwareRef that contains a spec.BmcRef must be provided.
    /// 
    /// The format of the ISOURL must be <http://$IP:$Port/iso/hook.iso>
    /// The name of the ISO file must have the .iso extension, but the name can be anything.
    /// The $IP and $Port should generally point to the IP and Port of the Smee server
    /// as this is where the ISO patching endpoint lives.
    /// The controller will append the MAC address of the hardware in the ISO URL
    /// right before the iso file name in the URL.
    /// MAC address is then used to retrieve hardware specific information such as
    /// IPAM info, custom kernel cmd line args and populate the worker ID for the tink worker/agent.
    /// For ex. the above format would be replaced to <http://$IP:$Port/iso/<macAddress>/hook.iso>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isoURL")]
    pub iso_url: Option<String>,
}

/// BootOptions are options that control the booting of Hardware.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TinkerbellMachineBootOptionsBootMode {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "netboot")]
    Netboot,
    #[serde(rename = "iso")]
    Iso,
    #[serde(rename = "isoboot")]
    Isoboot,
}

/// HardwareAffinity allows filtering for hardware.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineHardwareAffinity {
    /// Preferred are the preferred hardware affinity terms. Hardware matching these terms are preferred according to the
    /// weights provided, but are not required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preferred: Option<Vec<TinkerbellMachineHardwareAffinityPreferred>>,
    /// Required are the required hardware affinity terms.  The terms are OR'd together, hardware must match one term to
    /// be considered.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required: Option<Vec<TinkerbellMachineHardwareAffinityRequired>>,
}

/// WeightedHardwareAffinityTerm is a HardwareAffinityTerm with an associated weight.  The weights of all the matched
/// WeightedHardwareAffinityTerm fields are added per-hardware to find the most preferred hardware.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineHardwareAffinityPreferred {
    /// HardwareAffinityTerm is the term associated with the corresponding weight.
    #[serde(rename = "hardwareAffinityTerm")]
    pub hardware_affinity_term: TinkerbellMachineHardwareAffinityPreferredHardwareAffinityTerm,
    /// Weight associated with matching the corresponding hardwareAffinityTerm, in the range 1-100.
    pub weight: i32,
}

/// HardwareAffinityTerm is the term associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineHardwareAffinityPreferredHardwareAffinityTerm {
    /// LabelSelector is used to select for particular hardware by label.
    #[serde(rename = "labelSelector")]
    pub label_selector: TinkerbellMachineHardwareAffinityPreferredHardwareAffinityTermLabelSelector,
}

/// LabelSelector is used to select for particular hardware by label.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineHardwareAffinityPreferredHardwareAffinityTermLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<TinkerbellMachineHardwareAffinityPreferredHardwareAffinityTermLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineHardwareAffinityPreferredHardwareAffinityTermLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// HardwareAffinityTerm is used to select for a particular existing hardware resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineHardwareAffinityRequired {
    /// LabelSelector is used to select for particular hardware by label.
    #[serde(rename = "labelSelector")]
    pub label_selector: TinkerbellMachineHardwareAffinityRequiredLabelSelector,
}

/// LabelSelector is used to select for particular hardware by label.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineHardwareAffinityRequiredLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<TinkerbellMachineHardwareAffinityRequiredLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineHardwareAffinityRequiredLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// TinkerbellMachineStatus defines the observed state of TinkerbellMachine.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineStatus {
    /// Addresses contains the Tinkerbell device associated addresses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addresses: Option<Vec<TinkerbellMachineStatusAddresses>>,
    /// ErrorMessage will be set in the event that there is a terminal problem
    /// reconciling the Machine and will contain a more verbose string suitable
    /// for logging and human consumption.
    /// 
    /// This field should not be set for transitive errors that a controller
    /// faces that are expected to be fixed automatically over
    /// time (like service outages), but instead indicate that something is
    /// fundamentally wrong with the Machine's spec or the configuration of
    /// the controller, and that manual intervention is required. Examples
    /// of terminal errors would be invalid combinations of settings in the
    /// spec, values that are unsupported by the controller, or the
    /// responsible controller itself being critically misconfigured.
    /// 
    /// Any transient errors that occur during the reconciliation of Machines
    /// can be added as events to the Machine object and/or logged in the
    /// controller's output.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorMessage")]
    pub error_message: Option<String>,
    /// Any transient errors that occur during the reconciliation of Machines
    /// can be added as events to the Machine object and/or logged in the
    /// controller's output.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "errorReason")]
    pub error_reason: Option<String>,
    /// InstanceStatus is the status of the Tinkerbell device instance for this machine.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "instanceStatus")]
    pub instance_status: Option<i64>,
    /// Ready is true when the provider resource is ready.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ready: Option<bool>,
}

/// NodeAddress contains information for the node's address.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TinkerbellMachineStatusAddresses {
    /// The node address.
    pub address: String,
    /// Node address type, one of Hostname, ExternalIP or InternalIP.
    #[serde(rename = "type")]
    pub r#type: String,
}

