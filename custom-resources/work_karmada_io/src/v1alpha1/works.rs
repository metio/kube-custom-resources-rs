// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/karmada-io/karmada/work.karmada.io/v1alpha1/works.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// Spec represents the desired behavior of Work.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "work.karmada.io", version = "v1alpha1", kind = "Work", plural = "works")]
#[kube(namespaced)]
#[kube(status = "WorkStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct WorkSpec {
    /// PreserveResourcesOnDeletion controls whether resources should be preserved on the
    /// member cluster when the Work object is deleted.
    /// If set to true, resources will be preserved on the member cluster.
    /// Default is false, which means resources will be deleted along with the Work object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preserveResourcesOnDeletion")]
    pub preserve_resources_on_deletion: Option<bool>,
    /// SuspendDispatching controls whether dispatching should
    /// be suspended, nil means not suspend.
    /// Note: true means stop propagating to the corresponding member cluster, and
    /// does not prevent status collection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "suspendDispatching")]
    pub suspend_dispatching: Option<bool>,
    /// Workload represents the manifest workload to be deployed on managed cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workload: Option<WorkWorkload>,
}

/// Workload represents the manifest workload to be deployed on managed cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct WorkWorkload {
    /// Manifests represents a list of Kubernetes resources to be deployed on the managed cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub manifests: Option<Vec<BTreeMap<String, serde_json::Value>>>,
}

/// Status represents the status of PropagationStatus.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct WorkStatus {
    /// Conditions contain the different condition statuses for this work.
    /// Valid condition types are:
    /// 1. Applied represents workload in Work is applied successfully on a managed cluster.
    /// 2. Progressing represents workload in Work is being applied on a managed cluster.
    /// 3. Available represents workload in Work exists on the managed cluster.
    /// 4. Degraded represents the current state of workload does not match the desired
    /// state for a certain period.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ManifestStatuses contains running status of manifests in spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "manifestStatuses")]
    pub manifest_statuses: Option<Vec<WorkStatusManifestStatuses>>,
}

/// ManifestStatus contains running status of a specific manifest in spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct WorkStatusManifestStatuses {
    /// Health represents the healthy state of the current resource.
    /// There maybe different rules for different resources to achieve health status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub health: Option<WorkStatusManifestStatusesHealth>,
    /// Identifier represents the identity of a resource linking to manifests in spec.
    pub identifier: WorkStatusManifestStatusesIdentifier,
    /// Status reflects running status of current manifest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<BTreeMap<String, serde_json::Value>>,
}

/// ManifestStatus contains running status of a specific manifest in spec.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum WorkStatusManifestStatusesHealth {
    Healthy,
    Unhealthy,
    Unknown,
}

/// Identifier represents the identity of a resource linking to manifests in spec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct WorkStatusManifestStatusesIdentifier {
    /// Group is the group of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// Kind is the kind of the resource.
    pub kind: String,
    /// Name is the name of the resource
    pub name: String,
    /// Namespace is the namespace of the resource, the resource is cluster scoped if the value
    /// is empty
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Ordinal represents an index in manifests list, so the condition can still be linked
    /// to a manifest even though manifest cannot be parsed successfully.
    pub ordinal: i64,
    /// Resource is the resource type of the resource
    pub resource: String,
    /// Version is the version of the resource.
    pub version: String,
}

