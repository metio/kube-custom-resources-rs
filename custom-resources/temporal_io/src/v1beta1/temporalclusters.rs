// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/alexandrevilain/temporal-operator/temporal.io/v1beta1/temporalclusters.yaml
// kopium version: 0.22.4

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// Specification of the desired behavior of the Temporal cluster.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "temporal.io", version = "v1beta1", kind = "TemporalCluster", plural = "temporalclusters")]
#[kube(namespaced)]
#[kube(status = "TemporalClusterStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct TemporalClusterSpec {
    /// AdminTools allows configuration of the optional admin tool pod deployed alongside the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admintools: Option<TemporalClusterAdmintools>,
    /// Archival allows Workflow Execution Event Histories and Visibility data backups for the temporal cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archival: Option<TemporalClusterArchival>,
    /// Authorization allows authorization configuration for the temporal cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<TemporalClusterAuthorization>,
    /// DynamicConfig allows advanced configuration for the temporal cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicConfig")]
    pub dynamic_config: Option<TemporalClusterDynamicConfig>,
    /// Image defines the temporal server docker image the cluster should use for each services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// An optional list of references to secrets in the same namespace
    /// to use for pulling temporal images from registries.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecrets")]
    pub image_pull_secrets: Option<Vec<TemporalClusterImagePullSecrets>>,
    /// JobInitContainers adds a list of init containers to the setup's jobs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobInitContainers")]
    pub job_init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// JobResources allows set resources for setup/update jobs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobResources")]
    pub job_resources: Option<TemporalClusterJobResources>,
    /// JobTTLSecondsAfterFinished is amount of time to keep job pods after jobs are completed.
    /// Defaults to 300 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobTtlSecondsAfterFinished")]
    pub job_ttl_seconds_after_finished: Option<i32>,
    /// Log defines temporal cluster's logger configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub log: Option<TemporalClusterLog>,
    /// MTLS allows configuration of the network traffic encryption for the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mTLS")]
    pub m_tls: Option<TemporalClusterMTls>,
    /// Metrics allows configuration of scraping endpoints for stats. prometheus or m3.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<TemporalClusterMetrics>,
    /// NumHistoryShards is the desired number of history shards.
    /// This field is immutable.
    #[serde(rename = "numHistoryShards")]
    pub num_history_shards: i32,
    /// Persistence defines temporal persistence configuration.
    pub persistence: TemporalClusterPersistence,
    /// Services allows customizations for each temporal services deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<TemporalClusterServices>,
    /// UI allows configuration of the optional temporal web ui deployed alongside the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ui: Option<TemporalClusterUi>,
    /// Version defines the temporal version the cluster to be deployed.
    /// This version impacts the underlying persistence schemas versions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// AdminTools allows configuration of the optional admin tool pod deployed alongside the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAdmintools {
    /// Enabled defines if the operator should deploy the admin tools alongside the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Image defines the temporal admin tools docker image the instance should run.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Overrides adds some overrides to the resources deployed for the ui.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<TemporalClusterAdmintoolsOverrides>,
    /// Compute Resources required by the ui.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TemporalClusterAdmintoolsResources>,
    /// Version defines the temporal admin tools version the instance should run.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Overrides adds some overrides to the resources deployed for the ui.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAdmintoolsOverrides {
    /// Override configuration for the temporal service Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<TemporalClusterAdmintoolsOverridesDeployment>,
}

/// Override configuration for the temporal service Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAdmintoolsOverridesDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPatch")]
    pub json_patch: Option<serde_json::Value>,
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterAdmintoolsOverridesDeploymentMetadata>,
    /// Specification of the desired behavior of the Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<TemporalClusterAdmintoolsOverridesDeploymentSpec>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAdmintoolsOverridesDeploymentMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Specification of the desired behavior of the Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAdmintoolsOverridesDeploymentSpec {
    /// Template describes the pods that will be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TemporalClusterAdmintoolsOverridesDeploymentSpecTemplate>,
}

/// Template describes the pods that will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAdmintoolsOverridesDeploymentSpecTemplate {
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterAdmintoolsOverridesDeploymentSpecTemplateMetadata>,
    /// Specification of the desired behavior of the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<serde_json::Value>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAdmintoolsOverridesDeploymentSpecTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Compute Resources required by the ui.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAdmintoolsResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TemporalClusterAdmintoolsResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAdmintoolsResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Archival allows Workflow Execution Event Histories and Visibility data backups for the temporal cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchival {
    /// Enabled defines if the archival is enabled for the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// History is the default config for the history archival.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub history: Option<TemporalClusterArchivalHistory>,
    /// Provider defines the archival provider for the cluster.
    /// The same provider is used for both history and visibility,
    /// but some config can be changed using spec.archival.[history|visibility].config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<TemporalClusterArchivalProvider>,
    /// Visibility is the default config for visibility archival.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub visibility: Option<TemporalClusterArchivalVisibility>,
}

/// History is the default config for the history archival.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalHistory {
    /// EnableRead allows temporal to read from the archived Event History.
    #[serde(rename = "enableRead")]
    pub enable_read: bool,
    /// Enabled defines if the archival is enabled by default for all namespaces
    /// or for a particular namespace (depends if it's for a TemporalCluster or a TemporalNamespace).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Path is ...
    pub path: String,
    /// Paused defines if the archival is paused.
    pub paused: bool,
}

/// Provider defines the archival provider for the cluster.
/// The same provider is used for both history and visibility,
/// but some config can be changed using spec.archival.[history|visibility].config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalProvider {
    /// FilestoreArchiver is the file store archival provider configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filestore: Option<TemporalClusterArchivalProviderFilestore>,
    /// GCSArchiver is the GCS archival provider configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gcs: Option<TemporalClusterArchivalProviderGcs>,
    /// S3Archiver is the S3 archival provider configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<TemporalClusterArchivalProviderS3>,
}

/// FilestoreArchiver is the file store archival provider configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalProviderFilestore {
    /// DirPermissions sets the directory permissions of the archive directory.
    /// It's recommend to leave it empty and use the default value of "0766" to avoid read/write issues.
    #[serde(rename = "dirPermissions")]
    pub dir_permissions: String,
    /// FilePermissions sets the file permissions of the archived files.
    /// It's recommend to leave it empty and use the default value of "0666" to avoid read/write issues.
    #[serde(rename = "filePermissions")]
    pub file_permissions: String,
}

/// GCSArchiver is the GCS archival provider configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalProviderGcs {
    /// SecretAccessKeyRef is the secret key selector containing Google Cloud Storage credentials file.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: TemporalClusterArchivalProviderGcsCredentialsRef,
}

/// SecretAccessKeyRef is the secret key selector containing Google Cloud Storage credentials file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalProviderGcsCredentialsRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// S3Archiver is the S3 archival provider configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalProviderS3 {
    /// Use credentials if you want to use aws credentials from secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<TemporalClusterArchivalProviderS3Credentials>,
    /// Use Endpoint if you want to use s3-compatible object storage.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// Region is the aws s3 region.
    pub region: String,
    /// Use RoleName if you want the temporal service account
    /// to assume an AWS Identity and Access Management (IAM) role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleName")]
    pub role_name: Option<String>,
    /// Use s3ForcePathStyle if you want to use s3 path style.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "s3ForcePathStyle")]
    pub s3_force_path_style: Option<bool>,
}

/// Use credentials if you want to use aws credentials from secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalProviderS3Credentials {
    /// AccessKeyIDRef is the secret key selector containing AWS access key ID.
    #[serde(rename = "accessKeyIdRef")]
    pub access_key_id_ref: TemporalClusterArchivalProviderS3CredentialsAccessKeyIdRef,
    /// SecretAccessKeyRef is the secret key selector containing AWS secret access key.
    #[serde(rename = "secretKeyRef")]
    pub secret_key_ref: TemporalClusterArchivalProviderS3CredentialsSecretKeyRef,
}

/// AccessKeyIDRef is the secret key selector containing AWS access key ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalProviderS3CredentialsAccessKeyIdRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretAccessKeyRef is the secret key selector containing AWS secret access key.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalProviderS3CredentialsSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Visibility is the default config for visibility archival.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterArchivalVisibility {
    /// EnableRead allows temporal to read from the archived Event History.
    #[serde(rename = "enableRead")]
    pub enable_read: bool,
    /// Enabled defines if the archival is enabled by default for all namespaces
    /// or for a particular namespace (depends if it's for a TemporalCluster or a TemporalNamespace).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Path is ...
    pub path: String,
    /// Paused defines if the archival is paused.
    pub paused: bool,
}

/// Authorization allows authorization configuration for the temporal cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAuthorization {
    /// Authorizer defines the authorization mechanism to be used. It can be left as an empty string to
    /// use a no-operation authorizer (noopAuthorizer), or set to "default" to use the temporal's default
    /// authorizer (defaultAuthorizer).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorizer: Option<String>,
    /// ClaimMapper specifies the claim mapping mechanism used for handling JWT claims. Similar to the Authorizer,
    /// it can be left as an empty string to use a no-operation claim mapper (noopClaimMapper), or set to "default"
    /// to use the default JWT claim mapper (defaultJWTClaimMapper).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "claimMapper")]
    pub claim_mapper: Option<String>,
    /// JWTKeyProvider specifies the signing key provider used for validating JWT tokens.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtKeyProvider")]
    pub jwt_key_provider: Option<TemporalClusterAuthorizationJwtKeyProvider>,
    /// PermissionsClaimName is the name of the claim within the JWT token that contains the user's permissions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "permissionsClaimName")]
    pub permissions_claim_name: Option<String>,
}

/// JWTKeyProvider specifies the signing key provider used for validating JWT tokens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterAuthorizationJwtKeyProvider {
    /// KeySourceURIs is a list of URIs where the JWT signing keys can be obtained. These URIs are used by the
    /// authorization system to fetch the public keys necessary for validating JWT tokens.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySourceURIs")]
    pub key_source_ur_is: Option<Vec<String>>,
    /// RefreshInterval defines the time interval at which temporal should refresh the JWT signing keys from
    /// the specified URIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
}

/// DynamicConfig allows advanced configuration for the temporal cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterDynamicConfig {
    /// PollInterval defines how often the config should be updated by checking provided values.
    /// Defaults to 10s.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pollInterval")]
    pub poll_interval: Option<String>,
    /// Values contains all dynamic config keys and their constrained values.
    pub values: BTreeMap<String, Vec<TemporalClusterDynamicConfigValues>>,
}

/// ConstrainedValue is an alias for temporal's dynamicconfig.ConstrainedValue.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterDynamicConfigValues {
    /// Constraints describe under what conditions a ConstrainedValue should be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub constraints: Option<TemporalClusterDynamicConfigValuesConstraints>,
    /// Value is the value for the configuration key.
    /// The type of the Value field depends on the key.
    /// Acceptable types will be one of: int, float64, bool, string, map[string]any, time.Duration
    pub value: serde_json::Value,
}

/// Constraints describe under what conditions a ConstrainedValue should be used.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterDynamicConfigValuesConstraints {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceId")]
    pub namespace_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardId")]
    pub shard_id: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskQueueName")]
    pub task_queue_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskQueueType")]
    pub task_queue_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskType")]
    pub task_type: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterImagePullSecrets {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// JobResources allows set resources for setup/update jobs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterJobResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TemporalClusterJobResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterJobResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Log defines temporal cluster's logger configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterLog {
    /// Development determines whether the logger is run in Development (== Test) or in
    /// Production mode.  Default is Production.  Production-stage disables panics from
    /// DPanic logging.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub development: Option<bool>,
    /// Format determines the format of each log file printed to the output.
    /// Use "console" if you want stack traces to appear on multiple lines.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<TemporalClusterLogFormat>,
    /// Level is the desired log level; see colocated zap_logger.go::parseZapLevel()
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<TemporalClusterLogLevel>,
    /// OutputFile is the path to the log output file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "outputFile")]
    pub output_file: Option<String>,
    /// Stdout is true if the output needs to goto standard out; default is stderr.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<bool>,
}

/// Log defines temporal cluster's logger configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterLogFormat {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "console")]
    Console,
}

/// Log defines temporal cluster's logger configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterLogLevel {
    #[serde(rename = "debug")]
    Debug,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "warn")]
    Warn,
    #[serde(rename = "error")]
    Error,
    #[serde(rename = "dpanic")]
    Dpanic,
    #[serde(rename = "panic")]
    Panic,
    #[serde(rename = "fatal")]
    Fatal,
}

/// MTLS allows configuration of the network traffic encryption for the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMTls {
    /// CertificatesDuration allows configuration of maximum certificates lifetime.
    /// Useless if mTLS provider is not cert-manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificatesDuration")]
    pub certificates_duration: Option<TemporalClusterMTlsCertificatesDuration>,
    /// Frontend allows configuration of the frontend's public endpoint traffic encryption.
    /// Useless if mTLS provider is not cert-manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub frontend: Option<TemporalClusterMTlsFrontend>,
    /// Internode allows configuration of the internode traffic encryption.
    /// Useless if mTLS provider is not cert-manager.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub internode: Option<TemporalClusterMTlsInternode>,
    /// PermissiveMetrics allows insecure HTTP requests to the metrics endpoint.
    /// This is handy if the metrics collector does not support mTLS.
    /// Useless if mTLS provider is not istio
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "permissiveMetrics")]
    pub permissive_metrics: Option<bool>,
    /// Provider defines the tool used to manage mTLS certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<TemporalClusterMTlsProvider>,
    /// RefreshInterval defines interval between refreshes of certificates in the cluster components.
    /// Defaults to 1 hour.
    /// Useless if mTLS provider is not cert-manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "refreshInterval")]
    pub refresh_interval: Option<String>,
    /// RenewBefore is defines how long before the currently issued certificate's expiry
    /// cert-manager should renew the certificate. The default is 2/3 of the
    /// issued certificate's duration. Minimum accepted value is 5 minutes.
    /// Useless if mTLS provider is not cert-manager.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "renewBefore")]
    pub renew_before: Option<String>,
}

/// CertificatesDuration allows configuration of maximum certificates lifetime.
/// Useless if mTLS provider is not cert-manager.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMTlsCertificatesDuration {
    /// ClientCertificates is the 'duration' (i.e. lifetime) of the client certificates.
    /// It defaults to 1 year.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCertificates")]
    pub client_certificates: Option<String>,
    /// FrontendCertificate is the 'duration' (i.e. lifetime) of the frontend certificate.
    /// It defaults to 1 year.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "frontendCertificate")]
    pub frontend_certificate: Option<String>,
    /// IntermediateCACertificates is the 'duration' (i.e. lifetime) of the intermediate CAs Certificates.
    /// It defaults to 5 years.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intermediateCAsCertificates")]
    pub intermediate_c_as_certificates: Option<String>,
    /// InternodeCertificate is the 'duration' (i.e. lifetime) of the internode certificate.
    /// It defaults to 1 year.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internodeCertificate")]
    pub internode_certificate: Option<String>,
    /// RootCACertificate is the 'duration' (i.e. lifetime) of the Root CA Certificate.
    /// It defaults to 10 years.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootCACertificate")]
    pub root_ca_certificate: Option<String>,
}

/// Frontend allows configuration of the frontend's public endpoint traffic encryption.
/// Useless if mTLS provider is not cert-manager.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMTlsFrontend {
    /// Enabled defines if the operator should enable mTLS for cluster's public endpoints.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// ExtraDNSNames is a list of additional DNS names associated with the TemporalCluster.
    /// These DNS names can be used for accessing the TemporalCluster from external services.
    /// The DNS names specified here will be added to the TLS certificate for secure communication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraDnsNames")]
    pub extra_dns_names: Option<Vec<String>>,
}

/// Internode allows configuration of the internode traffic encryption.
/// Useless if mTLS provider is not cert-manager.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMTlsInternode {
    /// Enabled defines if the operator should enable mTLS for network between cluster nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// MTLS allows configuration of the network traffic encryption for the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterMTlsProvider {
    #[serde(rename = "cert-manager")]
    CertManager,
    #[serde(rename = "linkerd")]
    Linkerd,
    #[serde(rename = "istio")]
    Istio,
}

/// Metrics allows configuration of scraping endpoints for stats. prometheus or m3.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetrics {
    /// Enabled defines if the operator should enable metrics exposition on temporal components.
    pub enabled: bool,
    /// ExcludeTags is a map from tag name string to tag values string list.
    /// Each value present in keys will have relevant tag value replaced with "_tag_excluded_"
    /// Each value in values list will white-list tag values to be reported as usual.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeTags")]
    pub exclude_tags: Option<BTreeMap<String, Vec<String>>>,
    /// PerUnitHistogramBoundaries defines the default histogram bucket boundaries.
    /// Configuration of histogram boundaries for given metric unit.
    /// 
    /// Supported values:
    /// - "dimensionless"
    /// - "milliseconds"
    /// - "bytes"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "perUnitHistogramBoundaries")]
    pub per_unit_histogram_boundaries: Option<BTreeMap<String, Vec<String>>>,
    /// Prefix sets the prefix to all outgoing metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// Prometheus reporter configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prometheus: Option<TemporalClusterMetricsPrometheus>,
}

/// Prometheus reporter configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheus {
    /// Deprecated. Address for prometheus to serve metrics from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "listenAddress")]
    pub listen_address: Option<String>,
    /// ListenPort for prometheus to serve metrics from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "listenPort")]
    pub listen_port: Option<i32>,
    /// ScrapeConfig is the prometheus scrape configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeConfig")]
    pub scrape_config: Option<TemporalClusterMetricsPrometheusScrapeConfig>,
}

/// ScrapeConfig is the prometheus scrape configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfig {
    /// Annotations defines if the operator should add prometheus scrape annotations to the services pods.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<bool>,
    /// PrometheusScrapeConfigServiceMonitor is the configuration for prometheus operator ServiceMonitor.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceMonitor")]
    pub service_monitor: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitor>,
}

/// PrometheusScrapeConfigServiceMonitor is the configuration for prometheus operator ServiceMonitor.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitor {
    /// Enabled defines if the operator should create a ServiceMonitor for each services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Labels adds extra labels to the ServiceMonitor.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// MetricRelabelConfigs to apply to samples before ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelings")]
    pub metric_relabelings: Option<Vec<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings>>,
    /// Override allows customization of the created ServiceMonitor.
    /// All fields can be overwritten except "endpoints", "selector" and "namespaceSelector".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "override")]
    pub r#override: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverride>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings {
    /// Action to perform based on the regex matching.
    /// 
    /// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    /// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
    /// 
    /// Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsAction>,
    /// Modulus to take of the hash of the source label values.
    /// 
    /// Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a Replace action is performed if the
    /// regular expression matches.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator is the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is
    /// concatenated using the configured Separator and matched against the
    /// configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting string is written in a replacement.
    /// 
    /// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    /// `KeepEqual` and `DropEqual` actions.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "Replace")]
    ReplaceX,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "Keep")]
    KeepX,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "Drop")]
    DropX,
    #[serde(rename = "hashmod")]
    Hashmod,
    HashMod,
    #[serde(rename = "labelmap")]
    Labelmap,
    LabelMap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    LabelDrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "Lowercase")]
    LowercaseX,
    #[serde(rename = "uppercase")]
    Uppercase,
    #[serde(rename = "Uppercase")]
    UppercaseX,
    #[serde(rename = "keepequal")]
    Keepequal,
    KeepEqual,
    #[serde(rename = "dropequal")]
    Dropequal,
    DropEqual,
}

/// Override allows customization of the created ServiceMonitor.
/// All fields can be overwritten except "endpoints", "selector" and "namespaceSelector".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverride {
    /// `attachMetadata` defines additional metadata which is added to the
    /// discovered targets.
    /// 
    /// It requires Prometheus >= v2.37.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachMetadata")]
    pub attach_metadata: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata>,
    /// When defined, bodySizeLimit specifies a job level limit on the size
    /// of uncompressed response body that will be accepted by Prometheus.
    /// 
    /// It requires Prometheus >= v2.28.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodySizeLimit")]
    pub body_size_limit: Option<String>,
    /// List of endpoints part of this ServiceMonitor.
    /// Defines how to scrape metrics from Kubernetes [Endpoints](<https://kubernetes.io/docs/concepts/services-networking/service/#endpoints)> objects.
    /// In most cases, an Endpoints object is backed by a Kubernetes [Service](<https://kubernetes.io/docs/concepts/services-networking/service/)> object with the same name and labels.
    pub endpoints: Vec<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints>,
    /// `jobLabel` selects the label from the associated Kubernetes `Service`
    /// object which will be used as the `job` label for all metrics.
    /// 
    /// For example if `jobLabel` is set to `foo` and the Kubernetes `Service`
    /// object is labeled with `foo: bar`, then Prometheus adds the `job="bar"`
    /// label to all ingested metrics.
    /// 
    /// If the value of this field is empty or if the label doesn't exist for
    /// the given Service, the `job` label of the metrics defaults to the name
    /// of the associated Kubernetes `Service`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobLabel")]
    pub job_label: Option<String>,
    /// Per-scrape limit on the number of targets dropped by relabeling
    /// that will be kept in memory. 0 means no limit.
    /// 
    /// It requires Prometheus >= v2.47.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepDroppedTargets")]
    pub keep_dropped_targets: Option<i64>,
    /// Per-scrape limit on number of labels that will be accepted for a sample.
    /// 
    /// It requires Prometheus >= v2.27.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelLimit")]
    pub label_limit: Option<i64>,
    /// Per-scrape limit on length of labels name that will be accepted for a sample.
    /// 
    /// It requires Prometheus >= v2.27.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelNameLengthLimit")]
    pub label_name_length_limit: Option<i64>,
    /// Per-scrape limit on length of labels value that will be accepted for a sample.
    /// 
    /// It requires Prometheus >= v2.27.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelValueLengthLimit")]
    pub label_value_length_limit: Option<i64>,
    /// `namespaceSelector` defines in which namespace(s) Prometheus should discover the services.
    /// By default, the services are discovered in the same namespace as the `ServiceMonitor` object but it is possible to select pods across different/all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector>,
    /// If there are more than this many buckets in a native histogram,
    /// buckets will be merged to stay within the limit.
    /// It requires Prometheus >= v2.45.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nativeHistogramBucketLimit")]
    pub native_histogram_bucket_limit: Option<i64>,
    /// If the growth factor of one bucket to the next is smaller than this,
    /// buckets will be merged to increase the factor sufficiently.
    /// It requires Prometheus >= v2.50.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nativeHistogramMinBucketFactor")]
    pub native_histogram_min_bucket_factor: Option<IntOrString>,
    /// `podTargetLabels` defines the labels which are transferred from the
    /// associated Kubernetes `Pod` object onto the ingested metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTargetLabels")]
    pub pod_target_labels: Option<Vec<String>>,
    /// `sampleLimit` defines a per-scrape limit on the number of scraped samples
    /// that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// The scrape class to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeClass")]
    pub scrape_class: Option<String>,
    /// Whether to scrape a classic histogram that is also exposed as a native histogram.
    /// It requires Prometheus >= v2.45.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeClassicHistograms")]
    pub scrape_classic_histograms: Option<bool>,
    /// `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
    /// protocols supported by Prometheus in order of preference (from most to least preferred).
    /// 
    /// If unset, Prometheus uses its default value.
    /// 
    /// It requires Prometheus >= v2.49.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeProtocols")]
    pub scrape_protocols: Option<Vec<String>>,
    /// Label selector to select the Kubernetes `Endpoints` objects to scrape metrics from.
    pub selector: TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector,
    /// `targetLabels` defines the labels which are transferred from the
    /// associated Kubernetes `Service` object onto the ingested metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabels")]
    pub target_labels: Option<Vec<String>>,
    /// `targetLimit` defines a limit on the number of scraped targets that will
    /// be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLimit")]
    pub target_limit: Option<i64>,
}

/// `attachMetadata` defines additional metadata which is added to the
/// discovered targets.
/// 
/// It requires Prometheus >= v2.37.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata {
    /// When set to true, Prometheus attaches node metadata to the discovered
    /// targets.
    /// 
    /// The Prometheus service account must have the `list` and `watch`
    /// permissions on the `Nodes` objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<bool>,
}

/// Endpoint defines an endpoint serving Prometheus metrics to be scraped by
/// Prometheus.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints {
    /// `authorization` configures the Authorization header credentials to use when
    /// scraping the target.
    /// 
    /// Cannot be set at the same time as `basicAuth`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization>,
    /// `basicAuth` configures the Basic Authentication credentials to use when
    /// scraping the target.
    /// 
    /// Cannot be set at the same time as `authorization`, or `oauth2`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth>,
    /// File to read bearer token for scraping the target.
    /// 
    /// Deprecated: use `authorization` instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenFile")]
    pub bearer_token_file: Option<String>,
    /// `bearerTokenSecret` specifies a key of a Secret containing the bearer
    /// token for scraping targets. The secret needs to be in the same namespace
    /// as the ServiceMonitor object and readable by the Prometheus Operator.
    /// 
    /// Deprecated: use `authorization` instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret>,
    /// `enableHttp2` can be used to disable HTTP2 when scraping the target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHttp2")]
    pub enable_http2: Option<bool>,
    /// When true, the pods which are not running (e.g. either in Failed or
    /// Succeeded state) are dropped during the target discovery.
    /// 
    /// If unset, the filtering is enabled.
    /// 
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterRunning")]
    pub filter_running: Option<bool>,
    /// `followRedirects` defines whether the scrape requests should follow HTTP
    /// 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// When true, `honorLabels` preserves the metric's labels when they collide
    /// with the target's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorLabels")]
    pub honor_labels: Option<bool>,
    /// `honorTimestamps` controls whether Prometheus preserves the timestamps
    /// when exposed by the target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorTimestamps")]
    pub honor_timestamps: Option<bool>,
    /// Interval at which Prometheus scrapes the metrics from the target.
    /// 
    /// If empty, Prometheus uses the global scrape interval.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// `metricRelabelings` configures the relabeling rules to apply to the
    /// samples before ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelings")]
    pub metric_relabelings: Option<Vec<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings>>,
    /// `oauth2` configures the OAuth2 settings to use when scraping the target.
    /// 
    /// It requires Prometheus >= 2.27.0.
    /// 
    /// Cannot be set at the same time as `authorization`, or `basicAuth`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2>,
    /// params define optional HTTP URL parameters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, Vec<String>>>,
    /// HTTP path from which to scrape for metrics.
    /// 
    /// If empty, Prometheus uses the default value (e.g. `/metrics`).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name of the Service port which this endpoint refers to.
    /// 
    /// It takes precedence over `targetPort`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// `proxyURL` configures the HTTP Proxy URL (e.g.
    /// "<http://proxyserver:2195")> to go through when scraping the target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// `relabelings` configures the relabeling rules to apply the target's
    /// metadata labels.
    /// 
    /// The Operator automatically adds relabelings for a few standard Kubernetes fields.
    /// 
    /// The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
    /// 
    /// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relabelings: Option<Vec<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings>>,
    /// HTTP scheme to use for scraping.
    /// 
    /// `http` and `https` are the expected values unless you rewrite the
    /// `__scheme__` label via relabeling.
    /// 
    /// If empty, Prometheus uses the default value `http`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsScheme>,
    /// Timeout after which Prometheus considers the scrape to be failed.
    /// 
    /// If empty, Prometheus uses the global scrape timeout unless it is less
    /// than the target's scrape interval value in which the latter is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// Name or number of the target port of the `Pod` object behind the
    /// Service. The port must be specified with the container's port property.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPort")]
    pub target_port: Option<IntOrString>,
    /// TLS configuration to use when scraping the target.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig>,
    /// `trackTimestampsStaleness` defines whether Prometheus tracks staleness of
    /// the metrics that have an explicit timestamp present in scraped data.
    /// Has no effect if `honorTimestamps` is false.
    /// 
    /// It requires Prometheus >= v2.48.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trackTimestampsStaleness")]
    pub track_timestamps_staleness: Option<bool>,
}

/// `authorization` configures the Authorization header credentials to use when
/// scraping the target.
/// 
/// Cannot be set at the same time as `basicAuth`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization {
    /// Selects a key of a Secret in the namespace that contains the credentials for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials>,
    /// Defines the authentication type. The value is case-insensitive.
    /// 
    /// "Basic" is not a supported value.
    /// 
    /// Default: "Bearer"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// Selects a key of a Secret in the namespace that contains the credentials for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `basicAuth` configures the Basic Authentication credentials to use when
/// scraping the target.
/// 
/// Cannot be set at the same time as `authorization`, or `oauth2`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth {
    /// `password` specifies a key of a Secret containing the password for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword>,
    /// `username` specifies a key of a Secret containing the username for
    /// authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername>,
}

/// `password` specifies a key of a Secret containing the password for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `username` specifies a key of a Secret containing the username for
/// authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `bearerTokenSecret` specifies a key of a Secret containing the bearer
/// token for scraping targets. The secret needs to be in the same namespace
/// as the ServiceMonitor object and readable by the Prometheus Operator.
/// 
/// Deprecated: use `authorization` instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings {
    /// Action to perform based on the regex matching.
    /// 
    /// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    /// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
    /// 
    /// Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsAction>,
    /// Modulus to take of the hash of the source label values.
    /// 
    /// Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a Replace action is performed if the
    /// regular expression matches.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator is the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is
    /// concatenated using the configured Separator and matched against the
    /// configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting string is written in a replacement.
    /// 
    /// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    /// `KeepEqual` and `DropEqual` actions.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "Replace")]
    ReplaceX,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "Keep")]
    KeepX,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "Drop")]
    DropX,
    #[serde(rename = "hashmod")]
    Hashmod,
    HashMod,
    #[serde(rename = "labelmap")]
    Labelmap,
    LabelMap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    LabelDrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "Lowercase")]
    LowercaseX,
    #[serde(rename = "uppercase")]
    Uppercase,
    #[serde(rename = "Uppercase")]
    UppercaseX,
    #[serde(rename = "keepequal")]
    Keepequal,
    KeepEqual,
    #[serde(rename = "dropequal")]
    Dropequal,
    DropEqual,
}

/// `oauth2` configures the OAuth2 settings to use when scraping the target.
/// 
/// It requires Prometheus >= 2.27.0.
/// 
/// Cannot be set at the same time as `authorization`, or `basicAuth`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2 {
    /// `clientId` specifies a key of a Secret or ConfigMap containing the
    /// OAuth2 client's ID.
    #[serde(rename = "clientId")]
    pub client_id: TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId,
    /// `clientSecret` specifies a key of a Secret containing the OAuth2
    /// client's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret,
    /// `endpointParams` configures the HTTP parameters to append to the token
    /// URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    /// that should be excluded from proxying. IP and domain names can
    /// contain port numbers.
    /// 
    /// It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noProxy")]
    pub no_proxy: Option<String>,
    /// ProxyConnectHeader optionally specifies headers to send to
    /// proxies during CONNECT requests.
    /// 
    /// It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyConnectHeader")]
    pub proxy_connect_header: Option<BTreeMap<String, Vec<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ProxyConnectHeader>>>,
    /// Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
    /// 
    /// It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyFromEnvironment")]
    pub proxy_from_environment: Option<bool>,
    /// `proxyURL` defines the HTTP proxy server to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// `scopes` defines the OAuth2 scopes used for the token request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// TLS configuration to use when connecting to the OAuth2 server.
    /// It requires Prometheus >= v2.43.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig>,
    /// `tokenURL` configures the URL to fetch the token from.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// `clientId` specifies a key of a Secret or ConfigMap containing the
/// OAuth2 client's ID.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// `clientSecret` specifies a key of a Secret containing the OAuth2
/// client's secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// SecretKeySelector selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ProxyConnectHeader {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret>,
    /// Maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigMaxVersion>,
    /// Minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigMinVersion>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// TLS configuration to use when connecting to the OAuth2 server.
/// It requires Prometheus >= v2.43.0.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings {
    /// Action to perform based on the regex matching.
    /// 
    /// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    /// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
    /// 
    /// Default: "Replace"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsAction>,
    /// Modulus to take of the hash of the source label values.
    /// 
    /// Only applicable when the action is `HashMod`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a Replace action is performed if the
    /// regular expression matches.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator is the string between concatenated SourceLabels.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is
    /// concatenated using the configured Separator and matched against the
    /// configured regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting string is written in a replacement.
    /// 
    /// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    /// `KeepEqual` and `DropEqual` actions.
    /// 
    /// Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
/// scraped samples and remote write samples.
/// 
/// More info: <https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "Replace")]
    ReplaceX,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "Keep")]
    KeepX,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "Drop")]
    DropX,
    #[serde(rename = "hashmod")]
    Hashmod,
    HashMod,
    #[serde(rename = "labelmap")]
    Labelmap,
    LabelMap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    LabelDrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "Lowercase")]
    LowercaseX,
    #[serde(rename = "uppercase")]
    Uppercase,
    #[serde(rename = "Uppercase")]
    UppercaseX,
    #[serde(rename = "keepequal")]
    Keepequal,
    KeepEqual,
    #[serde(rename = "dropequal")]
    Dropequal,
    DropEqual,
}

/// Endpoint defines an endpoint serving Prometheus metrics to be scraped by
/// Prometheus.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsScheme {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

/// TLS configuration to use when scraping the target.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa>,
    /// Path to the CA cert in the Prometheus container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert>,
    /// Path to the client cert file in the Prometheus container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the Prometheus container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret>,
    /// Maximum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.41.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigMaxVersion>,
    /// Minimum acceptable TLS version.
    /// 
    /// It requires Prometheus >= v2.35.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigMinVersion>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS configuration to use when scraping the target.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigMaxVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// TLS configuration to use when scraping the target.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigMinVersion {
    #[serde(rename = "TLS10")]
    Tls10,
    #[serde(rename = "TLS11")]
    Tls11,
    #[serde(rename = "TLS12")]
    Tls12,
    #[serde(rename = "TLS13")]
    Tls13,
}

/// `namespaceSelector` defines in which namespace(s) Prometheus should discover the services.
/// By default, the services are discovered in the same namespace as the `ServiceMonitor` object but it is possible to select pods across different/all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector {
    /// Boolean describing whether all namespaces are selected in contrast to a
    /// list restricting them.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<bool>,
    /// List of namespace names to select from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchNames")]
    pub match_names: Option<Vec<String>>,
}

/// Label selector to select the Kubernetes `Endpoints` objects to scrape metrics from.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Persistence defines temporal persistence configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistence {
    /// AdvancedVisibilityStore holds the advanced visibility datastore specs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedVisibilityStore")]
    pub advanced_visibility_store: Option<TemporalClusterPersistenceAdvancedVisibilityStore>,
    /// DefaultStore holds the default datastore specs.
    #[serde(rename = "defaultStore")]
    pub default_store: TemporalClusterPersistenceDefaultStore,
    /// SecondaryVisibilityStore holds the secondary visibility datastore specs.
    /// Feature only available for clusters >= 1.21.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryVisibilityStore")]
    pub secondary_visibility_store: Option<TemporalClusterPersistenceSecondaryVisibilityStore>,
    /// VisibilityStore holds the visibility datastore specs.
    #[serde(rename = "visibilityStore")]
    pub visibility_store: TemporalClusterPersistenceVisibilityStore,
}

/// AdvancedVisibilityStore holds the advanced visibility datastore specs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStore {
    /// Cassandra holds all connection parameters for Cassandra datastore.
    /// Note that cassandra is now deprecated for visibility store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cassandra: Option<TemporalClusterPersistenceAdvancedVisibilityStoreCassandra>,
    /// Elasticsearch holds all connection parameters for Elasticsearch datastores.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<TemporalClusterPersistenceAdvancedVisibilityStoreElasticsearch>,
    /// Name is the name of the datastore.
    /// It should be unique and will be referenced within the persistence spec.
    /// Defaults to "default" for default sore, "visibility" for visibility store,
    /// "secondaryVisibility" for secondary visibility store and
    /// "advancedVisibility" for advanced visibility store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// PasswordSecret is the reference to the secret holding the password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordSecretRef")]
    pub password_secret_ref: Option<TemporalClusterPersistenceAdvancedVisibilityStorePasswordSecretRef>,
    /// SkipCreate instructs the operator to skip creating the database for SQL datastores or to skip creating keyspace for Cassandra. Use this option if your database or keyspace has already been provisioned by an administrator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipCreate")]
    pub skip_create: Option<bool>,
    /// SQL holds all connection parameters for SQL datastores.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sql: Option<TemporalClusterPersistenceAdvancedVisibilityStoreSql>,
    /// TLS is an optional option to connect to the datastore using TLS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<TemporalClusterPersistenceAdvancedVisibilityStoreTls>,
}

/// Cassandra holds all connection parameters for Cassandra datastore.
/// Note that cassandra is now deprecated for visibility store.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStoreCassandra {
    /// ConnectTimeout is a timeout for initial dial to cassandra server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Consistency configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consistency: Option<TemporalClusterPersistenceAdvancedVisibilityStoreCassandraConsistency>,
    /// Datacenter is the data center filter arg for cassandra.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datacenter: Option<String>,
    /// DisableInitialHostLookup instructs the gocql client to connect only using the supplied hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableInitialHostLookup")]
    pub disable_initial_host_lookup: Option<bool>,
    /// Hosts is a list of cassandra endpoints.
    pub hosts: Vec<String>,
    /// Keyspace is the cassandra keyspace.
    pub keyspace: String,
    /// MaxConns is the max number of connections to this datastore for a single keyspace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConns")]
    pub max_conns: Option<i64>,
    /// Port is the cassandra port used for connection by gocql client.
    pub port: i64,
    /// User is the cassandra user used for authentication by gocql client.
    pub user: String,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStoreCassandraConsistency {
    /// Consistency sets the default consistency level.
    /// Values identical to gocql Consistency values. (defaults to LOCAL_QUORUM if not set).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consistency: Option<i64>,
    /// SerialConsistency sets the consistency for the serial prtion of queries. Values identical to gocql SerialConsistency values.
    /// (defaults to LOCAL_SERIAL if not set)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serialConsistency")]
    pub serial_consistency: Option<i64>,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceAdvancedVisibilityStoreCassandraConsistencyConsistency {
    #[serde(rename = "ANY")]
    Any,
    #[serde(rename = "ONE")]
    One,
    #[serde(rename = "TWO")]
    Two,
    #[serde(rename = "THREE")]
    Three,
    #[serde(rename = "QUORUM")]
    Quorum,
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "LOCAL_QUORUM")]
    LocalQuorum,
    #[serde(rename = "EACH_QUORUM")]
    EachQuorum,
    #[serde(rename = "LOCAL_ONE")]
    LocalOne,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceAdvancedVisibilityStoreCassandraConsistencySerialConsistency {
    #[serde(rename = "SERIAL")]
    Serial,
    #[serde(rename = "LOCAL_SERIAL")]
    LocalSerial,
}

/// Elasticsearch holds all connection parameters for Elasticsearch datastores.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStoreElasticsearch {
    /// CloseIdleConnectionsInterval is the max duration a connection stay open while idle.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "closeIdleConnectionsInterval")]
    pub close_idle_connections_interval: Option<String>,
    /// EnableHealthcheck enables or disables healthcheck on the temporal cluster's es client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHealthcheck")]
    pub enable_healthcheck: Option<bool>,
    /// EnableSniff enables or disables sniffer on the temporal cluster's es client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSniff")]
    pub enable_sniff: Option<bool>,
    /// Indices holds visibility index names.
    pub indices: TemporalClusterPersistenceAdvancedVisibilityStoreElasticsearchIndices,
    /// LogLevel defines the temporal cluster's es client logger level.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// URL is the connection url to connect to the instance.
    pub url: String,
    /// Username is the username to be used for the connection.
    pub username: String,
    /// Version defines the elasticsearch version.
    pub version: String,
}

/// Indices holds visibility index names.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStoreElasticsearchIndices {
    /// SecondaryVisibility defines secondary visibility's index name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryVisibility")]
    pub secondary_visibility: Option<String>,
    /// Visibility defines visibility's index name.
    pub visibility: String,
}

/// PasswordSecret is the reference to the secret holding the password.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStorePasswordSecretRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// SQL holds all connection parameters for SQL datastores.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStoreSql {
    /// ConnectAddr is the remote addr of the database.
    #[serde(rename = "connectAddr")]
    pub connect_addr: String,
    /// ConnectAttributes is a set of key-value attributes to be sent as part of connect data_source_name url
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectAttributes")]
    pub connect_attributes: Option<BTreeMap<String, String>>,
    /// ConnectProtocol is the protocol that goes with the ConnectAddr.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectProtocol")]
    pub connect_protocol: Option<String>,
    /// DatabaseName is the name of SQL database to connect to.
    #[serde(rename = "databaseName")]
    pub database_name: String,
    /// GCPServiceAccount is the service account to use to authenticate with GCP CloudSQL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpServiceAccount")]
    pub gcp_service_account: Option<String>,
    /// MaxConnLifetime is the maximum time a connection can be alive
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnLifetime")]
    pub max_conn_lifetime: Option<String>,
    /// MaxConns the max number of connections to this datastore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConns")]
    pub max_conns: Option<i64>,
    /// MaxIdleConns is the max number of idle connections to this datastore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxIdleConns")]
    pub max_idle_conns: Option<i64>,
    /// PluginName is the name of SQL plugin.
    #[serde(rename = "pluginName")]
    pub plugin_name: TemporalClusterPersistenceAdvancedVisibilityStoreSqlPluginName,
    /// TaskScanPartitions is the number of partitions to sequentially scan during ListTaskQueue operations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskScanPartitions")]
    pub task_scan_partitions: Option<i64>,
    /// User is the username to be used for the connection.
    pub user: String,
}

/// SQL holds all connection parameters for SQL datastores.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceAdvancedVisibilityStoreSqlPluginName {
    #[serde(rename = "postgres")]
    Postgres,
    #[serde(rename = "postgres12")]
    Postgres12,
    #[serde(rename = "mysql")]
    Mysql,
    #[serde(rename = "mysql8")]
    Mysql8,
}

/// TLS is an optional option to connect to the datastore using TLS.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStoreTls {
    /// CaFileRef is a reference to a secret containing the ca file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFileRef")]
    pub ca_file_ref: Option<TemporalClusterPersistenceAdvancedVisibilityStoreTlsCaFileRef>,
    /// CertFileRef is a reference to a secret containing the cert file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFileRef")]
    pub cert_file_ref: Option<TemporalClusterPersistenceAdvancedVisibilityStoreTlsCertFileRef>,
    /// EnableHostVerification defines if the hostname should be verified when connecting to the datastore.
    #[serde(rename = "enableHostVerification")]
    pub enable_host_verification: bool,
    /// Enabled defines if the cluster should use a TLS connection to connect to the datastore.
    pub enabled: bool,
    /// KeyFileRef is a reference to a secret containing the key file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFileRef")]
    pub key_file_ref: Option<TemporalClusterPersistenceAdvancedVisibilityStoreTlsKeyFileRef>,
    /// ServerName the datastore should present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// CaFileRef is a reference to a secret containing the ca file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStoreTlsCaFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// CertFileRef is a reference to a secret containing the cert file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStoreTlsCertFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// KeyFileRef is a reference to a secret containing the key file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceAdvancedVisibilityStoreTlsKeyFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// DefaultStore holds the default datastore specs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStore {
    /// Cassandra holds all connection parameters for Cassandra datastore.
    /// Note that cassandra is now deprecated for visibility store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cassandra: Option<TemporalClusterPersistenceDefaultStoreCassandra>,
    /// Elasticsearch holds all connection parameters for Elasticsearch datastores.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<TemporalClusterPersistenceDefaultStoreElasticsearch>,
    /// Name is the name of the datastore.
    /// It should be unique and will be referenced within the persistence spec.
    /// Defaults to "default" for default sore, "visibility" for visibility store,
    /// "secondaryVisibility" for secondary visibility store and
    /// "advancedVisibility" for advanced visibility store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// PasswordSecret is the reference to the secret holding the password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordSecretRef")]
    pub password_secret_ref: Option<TemporalClusterPersistenceDefaultStorePasswordSecretRef>,
    /// SkipCreate instructs the operator to skip creating the database for SQL datastores or to skip creating keyspace for Cassandra. Use this option if your database or keyspace has already been provisioned by an administrator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipCreate")]
    pub skip_create: Option<bool>,
    /// SQL holds all connection parameters for SQL datastores.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sql: Option<TemporalClusterPersistenceDefaultStoreSql>,
    /// TLS is an optional option to connect to the datastore using TLS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<TemporalClusterPersistenceDefaultStoreTls>,
}

/// Cassandra holds all connection parameters for Cassandra datastore.
/// Note that cassandra is now deprecated for visibility store.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStoreCassandra {
    /// ConnectTimeout is a timeout for initial dial to cassandra server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Consistency configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consistency: Option<TemporalClusterPersistenceDefaultStoreCassandraConsistency>,
    /// Datacenter is the data center filter arg for cassandra.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datacenter: Option<String>,
    /// DisableInitialHostLookup instructs the gocql client to connect only using the supplied hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableInitialHostLookup")]
    pub disable_initial_host_lookup: Option<bool>,
    /// Hosts is a list of cassandra endpoints.
    pub hosts: Vec<String>,
    /// Keyspace is the cassandra keyspace.
    pub keyspace: String,
    /// MaxConns is the max number of connections to this datastore for a single keyspace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConns")]
    pub max_conns: Option<i64>,
    /// Port is the cassandra port used for connection by gocql client.
    pub port: i64,
    /// User is the cassandra user used for authentication by gocql client.
    pub user: String,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStoreCassandraConsistency {
    /// Consistency sets the default consistency level.
    /// Values identical to gocql Consistency values. (defaults to LOCAL_QUORUM if not set).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consistency: Option<i64>,
    /// SerialConsistency sets the consistency for the serial prtion of queries. Values identical to gocql SerialConsistency values.
    /// (defaults to LOCAL_SERIAL if not set)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serialConsistency")]
    pub serial_consistency: Option<i64>,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceDefaultStoreCassandraConsistencyConsistency {
    #[serde(rename = "ANY")]
    Any,
    #[serde(rename = "ONE")]
    One,
    #[serde(rename = "TWO")]
    Two,
    #[serde(rename = "THREE")]
    Three,
    #[serde(rename = "QUORUM")]
    Quorum,
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "LOCAL_QUORUM")]
    LocalQuorum,
    #[serde(rename = "EACH_QUORUM")]
    EachQuorum,
    #[serde(rename = "LOCAL_ONE")]
    LocalOne,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceDefaultStoreCassandraConsistencySerialConsistency {
    #[serde(rename = "SERIAL")]
    Serial,
    #[serde(rename = "LOCAL_SERIAL")]
    LocalSerial,
}

/// Elasticsearch holds all connection parameters for Elasticsearch datastores.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStoreElasticsearch {
    /// CloseIdleConnectionsInterval is the max duration a connection stay open while idle.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "closeIdleConnectionsInterval")]
    pub close_idle_connections_interval: Option<String>,
    /// EnableHealthcheck enables or disables healthcheck on the temporal cluster's es client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHealthcheck")]
    pub enable_healthcheck: Option<bool>,
    /// EnableSniff enables or disables sniffer on the temporal cluster's es client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSniff")]
    pub enable_sniff: Option<bool>,
    /// Indices holds visibility index names.
    pub indices: TemporalClusterPersistenceDefaultStoreElasticsearchIndices,
    /// LogLevel defines the temporal cluster's es client logger level.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// URL is the connection url to connect to the instance.
    pub url: String,
    /// Username is the username to be used for the connection.
    pub username: String,
    /// Version defines the elasticsearch version.
    pub version: String,
}

/// Indices holds visibility index names.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStoreElasticsearchIndices {
    /// SecondaryVisibility defines secondary visibility's index name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryVisibility")]
    pub secondary_visibility: Option<String>,
    /// Visibility defines visibility's index name.
    pub visibility: String,
}

/// PasswordSecret is the reference to the secret holding the password.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStorePasswordSecretRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// SQL holds all connection parameters for SQL datastores.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStoreSql {
    /// ConnectAddr is the remote addr of the database.
    #[serde(rename = "connectAddr")]
    pub connect_addr: String,
    /// ConnectAttributes is a set of key-value attributes to be sent as part of connect data_source_name url
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectAttributes")]
    pub connect_attributes: Option<BTreeMap<String, String>>,
    /// ConnectProtocol is the protocol that goes with the ConnectAddr.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectProtocol")]
    pub connect_protocol: Option<String>,
    /// DatabaseName is the name of SQL database to connect to.
    #[serde(rename = "databaseName")]
    pub database_name: String,
    /// GCPServiceAccount is the service account to use to authenticate with GCP CloudSQL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpServiceAccount")]
    pub gcp_service_account: Option<String>,
    /// MaxConnLifetime is the maximum time a connection can be alive
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnLifetime")]
    pub max_conn_lifetime: Option<String>,
    /// MaxConns the max number of connections to this datastore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConns")]
    pub max_conns: Option<i64>,
    /// MaxIdleConns is the max number of idle connections to this datastore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxIdleConns")]
    pub max_idle_conns: Option<i64>,
    /// PluginName is the name of SQL plugin.
    #[serde(rename = "pluginName")]
    pub plugin_name: TemporalClusterPersistenceDefaultStoreSqlPluginName,
    /// TaskScanPartitions is the number of partitions to sequentially scan during ListTaskQueue operations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskScanPartitions")]
    pub task_scan_partitions: Option<i64>,
    /// User is the username to be used for the connection.
    pub user: String,
}

/// SQL holds all connection parameters for SQL datastores.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceDefaultStoreSqlPluginName {
    #[serde(rename = "postgres")]
    Postgres,
    #[serde(rename = "postgres12")]
    Postgres12,
    #[serde(rename = "mysql")]
    Mysql,
    #[serde(rename = "mysql8")]
    Mysql8,
}

/// TLS is an optional option to connect to the datastore using TLS.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStoreTls {
    /// CaFileRef is a reference to a secret containing the ca file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFileRef")]
    pub ca_file_ref: Option<TemporalClusterPersistenceDefaultStoreTlsCaFileRef>,
    /// CertFileRef is a reference to a secret containing the cert file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFileRef")]
    pub cert_file_ref: Option<TemporalClusterPersistenceDefaultStoreTlsCertFileRef>,
    /// EnableHostVerification defines if the hostname should be verified when connecting to the datastore.
    #[serde(rename = "enableHostVerification")]
    pub enable_host_verification: bool,
    /// Enabled defines if the cluster should use a TLS connection to connect to the datastore.
    pub enabled: bool,
    /// KeyFileRef is a reference to a secret containing the key file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFileRef")]
    pub key_file_ref: Option<TemporalClusterPersistenceDefaultStoreTlsKeyFileRef>,
    /// ServerName the datastore should present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// CaFileRef is a reference to a secret containing the ca file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStoreTlsCaFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// CertFileRef is a reference to a secret containing the cert file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStoreTlsCertFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// KeyFileRef is a reference to a secret containing the key file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceDefaultStoreTlsKeyFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// SecondaryVisibilityStore holds the secondary visibility datastore specs.
/// Feature only available for clusters >= 1.21.0.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStore {
    /// Cassandra holds all connection parameters for Cassandra datastore.
    /// Note that cassandra is now deprecated for visibility store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cassandra: Option<TemporalClusterPersistenceSecondaryVisibilityStoreCassandra>,
    /// Elasticsearch holds all connection parameters for Elasticsearch datastores.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<TemporalClusterPersistenceSecondaryVisibilityStoreElasticsearch>,
    /// Name is the name of the datastore.
    /// It should be unique and will be referenced within the persistence spec.
    /// Defaults to "default" for default sore, "visibility" for visibility store,
    /// "secondaryVisibility" for secondary visibility store and
    /// "advancedVisibility" for advanced visibility store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// PasswordSecret is the reference to the secret holding the password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordSecretRef")]
    pub password_secret_ref: Option<TemporalClusterPersistenceSecondaryVisibilityStorePasswordSecretRef>,
    /// SkipCreate instructs the operator to skip creating the database for SQL datastores or to skip creating keyspace for Cassandra. Use this option if your database or keyspace has already been provisioned by an administrator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipCreate")]
    pub skip_create: Option<bool>,
    /// SQL holds all connection parameters for SQL datastores.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sql: Option<TemporalClusterPersistenceSecondaryVisibilityStoreSql>,
    /// TLS is an optional option to connect to the datastore using TLS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<TemporalClusterPersistenceSecondaryVisibilityStoreTls>,
}

/// Cassandra holds all connection parameters for Cassandra datastore.
/// Note that cassandra is now deprecated for visibility store.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStoreCassandra {
    /// ConnectTimeout is a timeout for initial dial to cassandra server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Consistency configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consistency: Option<TemporalClusterPersistenceSecondaryVisibilityStoreCassandraConsistency>,
    /// Datacenter is the data center filter arg for cassandra.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datacenter: Option<String>,
    /// DisableInitialHostLookup instructs the gocql client to connect only using the supplied hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableInitialHostLookup")]
    pub disable_initial_host_lookup: Option<bool>,
    /// Hosts is a list of cassandra endpoints.
    pub hosts: Vec<String>,
    /// Keyspace is the cassandra keyspace.
    pub keyspace: String,
    /// MaxConns is the max number of connections to this datastore for a single keyspace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConns")]
    pub max_conns: Option<i64>,
    /// Port is the cassandra port used for connection by gocql client.
    pub port: i64,
    /// User is the cassandra user used for authentication by gocql client.
    pub user: String,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStoreCassandraConsistency {
    /// Consistency sets the default consistency level.
    /// Values identical to gocql Consistency values. (defaults to LOCAL_QUORUM if not set).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consistency: Option<i64>,
    /// SerialConsistency sets the consistency for the serial prtion of queries. Values identical to gocql SerialConsistency values.
    /// (defaults to LOCAL_SERIAL if not set)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serialConsistency")]
    pub serial_consistency: Option<i64>,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceSecondaryVisibilityStoreCassandraConsistencyConsistency {
    #[serde(rename = "ANY")]
    Any,
    #[serde(rename = "ONE")]
    One,
    #[serde(rename = "TWO")]
    Two,
    #[serde(rename = "THREE")]
    Three,
    #[serde(rename = "QUORUM")]
    Quorum,
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "LOCAL_QUORUM")]
    LocalQuorum,
    #[serde(rename = "EACH_QUORUM")]
    EachQuorum,
    #[serde(rename = "LOCAL_ONE")]
    LocalOne,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceSecondaryVisibilityStoreCassandraConsistencySerialConsistency {
    #[serde(rename = "SERIAL")]
    Serial,
    #[serde(rename = "LOCAL_SERIAL")]
    LocalSerial,
}

/// Elasticsearch holds all connection parameters for Elasticsearch datastores.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStoreElasticsearch {
    /// CloseIdleConnectionsInterval is the max duration a connection stay open while idle.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "closeIdleConnectionsInterval")]
    pub close_idle_connections_interval: Option<String>,
    /// EnableHealthcheck enables or disables healthcheck on the temporal cluster's es client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHealthcheck")]
    pub enable_healthcheck: Option<bool>,
    /// EnableSniff enables or disables sniffer on the temporal cluster's es client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSniff")]
    pub enable_sniff: Option<bool>,
    /// Indices holds visibility index names.
    pub indices: TemporalClusterPersistenceSecondaryVisibilityStoreElasticsearchIndices,
    /// LogLevel defines the temporal cluster's es client logger level.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// URL is the connection url to connect to the instance.
    pub url: String,
    /// Username is the username to be used for the connection.
    pub username: String,
    /// Version defines the elasticsearch version.
    pub version: String,
}

/// Indices holds visibility index names.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStoreElasticsearchIndices {
    /// SecondaryVisibility defines secondary visibility's index name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryVisibility")]
    pub secondary_visibility: Option<String>,
    /// Visibility defines visibility's index name.
    pub visibility: String,
}

/// PasswordSecret is the reference to the secret holding the password.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStorePasswordSecretRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// SQL holds all connection parameters for SQL datastores.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStoreSql {
    /// ConnectAddr is the remote addr of the database.
    #[serde(rename = "connectAddr")]
    pub connect_addr: String,
    /// ConnectAttributes is a set of key-value attributes to be sent as part of connect data_source_name url
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectAttributes")]
    pub connect_attributes: Option<BTreeMap<String, String>>,
    /// ConnectProtocol is the protocol that goes with the ConnectAddr.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectProtocol")]
    pub connect_protocol: Option<String>,
    /// DatabaseName is the name of SQL database to connect to.
    #[serde(rename = "databaseName")]
    pub database_name: String,
    /// GCPServiceAccount is the service account to use to authenticate with GCP CloudSQL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpServiceAccount")]
    pub gcp_service_account: Option<String>,
    /// MaxConnLifetime is the maximum time a connection can be alive
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnLifetime")]
    pub max_conn_lifetime: Option<String>,
    /// MaxConns the max number of connections to this datastore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConns")]
    pub max_conns: Option<i64>,
    /// MaxIdleConns is the max number of idle connections to this datastore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxIdleConns")]
    pub max_idle_conns: Option<i64>,
    /// PluginName is the name of SQL plugin.
    #[serde(rename = "pluginName")]
    pub plugin_name: TemporalClusterPersistenceSecondaryVisibilityStoreSqlPluginName,
    /// TaskScanPartitions is the number of partitions to sequentially scan during ListTaskQueue operations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskScanPartitions")]
    pub task_scan_partitions: Option<i64>,
    /// User is the username to be used for the connection.
    pub user: String,
}

/// SQL holds all connection parameters for SQL datastores.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceSecondaryVisibilityStoreSqlPluginName {
    #[serde(rename = "postgres")]
    Postgres,
    #[serde(rename = "postgres12")]
    Postgres12,
    #[serde(rename = "mysql")]
    Mysql,
    #[serde(rename = "mysql8")]
    Mysql8,
}

/// TLS is an optional option to connect to the datastore using TLS.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStoreTls {
    /// CaFileRef is a reference to a secret containing the ca file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFileRef")]
    pub ca_file_ref: Option<TemporalClusterPersistenceSecondaryVisibilityStoreTlsCaFileRef>,
    /// CertFileRef is a reference to a secret containing the cert file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFileRef")]
    pub cert_file_ref: Option<TemporalClusterPersistenceSecondaryVisibilityStoreTlsCertFileRef>,
    /// EnableHostVerification defines if the hostname should be verified when connecting to the datastore.
    #[serde(rename = "enableHostVerification")]
    pub enable_host_verification: bool,
    /// Enabled defines if the cluster should use a TLS connection to connect to the datastore.
    pub enabled: bool,
    /// KeyFileRef is a reference to a secret containing the key file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFileRef")]
    pub key_file_ref: Option<TemporalClusterPersistenceSecondaryVisibilityStoreTlsKeyFileRef>,
    /// ServerName the datastore should present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// CaFileRef is a reference to a secret containing the ca file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStoreTlsCaFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// CertFileRef is a reference to a secret containing the cert file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStoreTlsCertFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// KeyFileRef is a reference to a secret containing the key file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceSecondaryVisibilityStoreTlsKeyFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// VisibilityStore holds the visibility datastore specs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStore {
    /// Cassandra holds all connection parameters for Cassandra datastore.
    /// Note that cassandra is now deprecated for visibility store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cassandra: Option<TemporalClusterPersistenceVisibilityStoreCassandra>,
    /// Elasticsearch holds all connection parameters for Elasticsearch datastores.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<TemporalClusterPersistenceVisibilityStoreElasticsearch>,
    /// Name is the name of the datastore.
    /// It should be unique and will be referenced within the persistence spec.
    /// Defaults to "default" for default sore, "visibility" for visibility store,
    /// "secondaryVisibility" for secondary visibility store and
    /// "advancedVisibility" for advanced visibility store.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// PasswordSecret is the reference to the secret holding the password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordSecretRef")]
    pub password_secret_ref: Option<TemporalClusterPersistenceVisibilityStorePasswordSecretRef>,
    /// SkipCreate instructs the operator to skip creating the database for SQL datastores or to skip creating keyspace for Cassandra. Use this option if your database or keyspace has already been provisioned by an administrator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipCreate")]
    pub skip_create: Option<bool>,
    /// SQL holds all connection parameters for SQL datastores.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sql: Option<TemporalClusterPersistenceVisibilityStoreSql>,
    /// TLS is an optional option to connect to the datastore using TLS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<TemporalClusterPersistenceVisibilityStoreTls>,
}

/// Cassandra holds all connection parameters for Cassandra datastore.
/// Note that cassandra is now deprecated for visibility store.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStoreCassandra {
    /// ConnectTimeout is a timeout for initial dial to cassandra server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectTimeout")]
    pub connect_timeout: Option<String>,
    /// Consistency configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consistency: Option<TemporalClusterPersistenceVisibilityStoreCassandraConsistency>,
    /// Datacenter is the data center filter arg for cassandra.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datacenter: Option<String>,
    /// DisableInitialHostLookup instructs the gocql client to connect only using the supplied hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableInitialHostLookup")]
    pub disable_initial_host_lookup: Option<bool>,
    /// Hosts is a list of cassandra endpoints.
    pub hosts: Vec<String>,
    /// Keyspace is the cassandra keyspace.
    pub keyspace: String,
    /// MaxConns is the max number of connections to this datastore for a single keyspace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConns")]
    pub max_conns: Option<i64>,
    /// Port is the cassandra port used for connection by gocql client.
    pub port: i64,
    /// User is the cassandra user used for authentication by gocql client.
    pub user: String,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStoreCassandraConsistency {
    /// Consistency sets the default consistency level.
    /// Values identical to gocql Consistency values. (defaults to LOCAL_QUORUM if not set).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consistency: Option<i64>,
    /// SerialConsistency sets the consistency for the serial prtion of queries. Values identical to gocql SerialConsistency values.
    /// (defaults to LOCAL_SERIAL if not set)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serialConsistency")]
    pub serial_consistency: Option<i64>,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceVisibilityStoreCassandraConsistencyConsistency {
    #[serde(rename = "ANY")]
    Any,
    #[serde(rename = "ONE")]
    One,
    #[serde(rename = "TWO")]
    Two,
    #[serde(rename = "THREE")]
    Three,
    #[serde(rename = "QUORUM")]
    Quorum,
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "LOCAL_QUORUM")]
    LocalQuorum,
    #[serde(rename = "EACH_QUORUM")]
    EachQuorum,
    #[serde(rename = "LOCAL_ONE")]
    LocalOne,
}

/// Consistency configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceVisibilityStoreCassandraConsistencySerialConsistency {
    #[serde(rename = "SERIAL")]
    Serial,
    #[serde(rename = "LOCAL_SERIAL")]
    LocalSerial,
}

/// Elasticsearch holds all connection parameters for Elasticsearch datastores.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStoreElasticsearch {
    /// CloseIdleConnectionsInterval is the max duration a connection stay open while idle.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "closeIdleConnectionsInterval")]
    pub close_idle_connections_interval: Option<String>,
    /// EnableHealthcheck enables or disables healthcheck on the temporal cluster's es client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHealthcheck")]
    pub enable_healthcheck: Option<bool>,
    /// EnableSniff enables or disables sniffer on the temporal cluster's es client.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSniff")]
    pub enable_sniff: Option<bool>,
    /// Indices holds visibility index names.
    pub indices: TemporalClusterPersistenceVisibilityStoreElasticsearchIndices,
    /// LogLevel defines the temporal cluster's es client logger level.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// URL is the connection url to connect to the instance.
    pub url: String,
    /// Username is the username to be used for the connection.
    pub username: String,
    /// Version defines the elasticsearch version.
    pub version: String,
}

/// Indices holds visibility index names.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStoreElasticsearchIndices {
    /// SecondaryVisibility defines secondary visibility's index name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryVisibility")]
    pub secondary_visibility: Option<String>,
    /// Visibility defines visibility's index name.
    pub visibility: String,
}

/// PasswordSecret is the reference to the secret holding the password.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStorePasswordSecretRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// SQL holds all connection parameters for SQL datastores.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStoreSql {
    /// ConnectAddr is the remote addr of the database.
    #[serde(rename = "connectAddr")]
    pub connect_addr: String,
    /// ConnectAttributes is a set of key-value attributes to be sent as part of connect data_source_name url
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectAttributes")]
    pub connect_attributes: Option<BTreeMap<String, String>>,
    /// ConnectProtocol is the protocol that goes with the ConnectAddr.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectProtocol")]
    pub connect_protocol: Option<String>,
    /// DatabaseName is the name of SQL database to connect to.
    #[serde(rename = "databaseName")]
    pub database_name: String,
    /// GCPServiceAccount is the service account to use to authenticate with GCP CloudSQL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcpServiceAccount")]
    pub gcp_service_account: Option<String>,
    /// MaxConnLifetime is the maximum time a connection can be alive
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConnLifetime")]
    pub max_conn_lifetime: Option<String>,
    /// MaxConns the max number of connections to this datastore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConns")]
    pub max_conns: Option<i64>,
    /// MaxIdleConns is the max number of idle connections to this datastore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxIdleConns")]
    pub max_idle_conns: Option<i64>,
    /// PluginName is the name of SQL plugin.
    #[serde(rename = "pluginName")]
    pub plugin_name: TemporalClusterPersistenceVisibilityStoreSqlPluginName,
    /// TaskScanPartitions is the number of partitions to sequentially scan during ListTaskQueue operations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskScanPartitions")]
    pub task_scan_partitions: Option<i64>,
    /// User is the username to be used for the connection.
    pub user: String,
}

/// SQL holds all connection parameters for SQL datastores.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum TemporalClusterPersistenceVisibilityStoreSqlPluginName {
    #[serde(rename = "postgres")]
    Postgres,
    #[serde(rename = "postgres12")]
    Postgres12,
    #[serde(rename = "mysql")]
    Mysql,
    #[serde(rename = "mysql8")]
    Mysql8,
}

/// TLS is an optional option to connect to the datastore using TLS.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStoreTls {
    /// CaFileRef is a reference to a secret containing the ca file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFileRef")]
    pub ca_file_ref: Option<TemporalClusterPersistenceVisibilityStoreTlsCaFileRef>,
    /// CertFileRef is a reference to a secret containing the cert file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFileRef")]
    pub cert_file_ref: Option<TemporalClusterPersistenceVisibilityStoreTlsCertFileRef>,
    /// EnableHostVerification defines if the hostname should be verified when connecting to the datastore.
    #[serde(rename = "enableHostVerification")]
    pub enable_host_verification: bool,
    /// Enabled defines if the cluster should use a TLS connection to connect to the datastore.
    pub enabled: bool,
    /// KeyFileRef is a reference to a secret containing the key file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFileRef")]
    pub key_file_ref: Option<TemporalClusterPersistenceVisibilityStoreTlsKeyFileRef>,
    /// ServerName the datastore should present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// CaFileRef is a reference to a secret containing the ca file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStoreTlsCaFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// CertFileRef is a reference to a secret containing the cert file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStoreTlsCertFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// KeyFileRef is a reference to a secret containing the key file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterPersistenceVisibilityStoreTlsKeyFileRef {
    /// Key in the Secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Name of the Secret.
    pub name: String,
}

/// Services allows customizations for each temporal services deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServices {
    /// Frontend service custom specifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub frontend: Option<TemporalClusterServicesFrontend>,
    /// History service custom specifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub history: Option<TemporalClusterServicesHistory>,
    /// Internal Frontend service custom specifications.
    /// Only compatible with temporal >= 1.20.0
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalFrontend")]
    pub internal_frontend: Option<TemporalClusterServicesInternalFrontend>,
    /// Matching service custom specifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matching: Option<TemporalClusterServicesMatching>,
    /// Overrides adds some overrides to the resources deployed for all temporal services services.
    /// Those overrides can be customized per service using spec.services.<serviceName>.overrides.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<TemporalClusterServicesOverrides>,
    /// Worker service custom specifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub worker: Option<TemporalClusterServicesWorker>,
}

/// Frontend service custom specifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesFrontend {
    /// HTTPPort defines a custom http port for the service.
    /// Default values are:
    /// 7243 for Frontend service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<i32>,
    /// InitContainers adds a list of init containers to the service's deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// MembershipPort defines a custom membership port for the service.
    /// Default values are:
    /// 6933 for Frontend service
    /// 6934 for History service
    /// 6935 for Matching service
    /// 6939 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "membershipPort")]
    pub membership_port: Option<i32>,
    /// Overrides adds some overrides to the resources deployed for the service.
    /// Those overrides takes precedence over spec.services.overrides.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<TemporalClusterServicesFrontendOverrides>,
    /// Port defines a custom gRPC port for the service.
    /// Default values are:
    /// 7233 for Frontend service
    /// 7234 for History service
    /// 7235 for Matching service
    /// 7239 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Number of desired replicas for the service. Default to 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Compute Resources required by this service.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TemporalClusterServicesFrontendResources>,
}

/// Overrides adds some overrides to the resources deployed for the service.
/// Those overrides takes precedence over spec.services.overrides.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesFrontendOverrides {
    /// Override configuration for the temporal service Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<TemporalClusterServicesFrontendOverridesDeployment>,
}

/// Override configuration for the temporal service Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesFrontendOverridesDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPatch")]
    pub json_patch: Option<serde_json::Value>,
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesFrontendOverridesDeploymentMetadata>,
    /// Specification of the desired behavior of the Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<TemporalClusterServicesFrontendOverridesDeploymentSpec>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesFrontendOverridesDeploymentMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Specification of the desired behavior of the Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesFrontendOverridesDeploymentSpec {
    /// Template describes the pods that will be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TemporalClusterServicesFrontendOverridesDeploymentSpecTemplate>,
}

/// Template describes the pods that will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesFrontendOverridesDeploymentSpecTemplate {
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesFrontendOverridesDeploymentSpecTemplateMetadata>,
    /// Specification of the desired behavior of the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<serde_json::Value>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesFrontendOverridesDeploymentSpecTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Compute Resources required by this service.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesFrontendResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TemporalClusterServicesFrontendResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesFrontendResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// History service custom specifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesHistory {
    /// HTTPPort defines a custom http port for the service.
    /// Default values are:
    /// 7243 for Frontend service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<i32>,
    /// InitContainers adds a list of init containers to the service's deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// MembershipPort defines a custom membership port for the service.
    /// Default values are:
    /// 6933 for Frontend service
    /// 6934 for History service
    /// 6935 for Matching service
    /// 6939 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "membershipPort")]
    pub membership_port: Option<i32>,
    /// Overrides adds some overrides to the resources deployed for the service.
    /// Those overrides takes precedence over spec.services.overrides.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<TemporalClusterServicesHistoryOverrides>,
    /// Port defines a custom gRPC port for the service.
    /// Default values are:
    /// 7233 for Frontend service
    /// 7234 for History service
    /// 7235 for Matching service
    /// 7239 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Number of desired replicas for the service. Default to 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Compute Resources required by this service.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TemporalClusterServicesHistoryResources>,
}

/// Overrides adds some overrides to the resources deployed for the service.
/// Those overrides takes precedence over spec.services.overrides.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesHistoryOverrides {
    /// Override configuration for the temporal service Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<TemporalClusterServicesHistoryOverridesDeployment>,
}

/// Override configuration for the temporal service Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesHistoryOverridesDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPatch")]
    pub json_patch: Option<serde_json::Value>,
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesHistoryOverridesDeploymentMetadata>,
    /// Specification of the desired behavior of the Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<TemporalClusterServicesHistoryOverridesDeploymentSpec>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesHistoryOverridesDeploymentMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Specification of the desired behavior of the Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesHistoryOverridesDeploymentSpec {
    /// Template describes the pods that will be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TemporalClusterServicesHistoryOverridesDeploymentSpecTemplate>,
}

/// Template describes the pods that will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesHistoryOverridesDeploymentSpecTemplate {
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesHistoryOverridesDeploymentSpecTemplateMetadata>,
    /// Specification of the desired behavior of the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<serde_json::Value>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesHistoryOverridesDeploymentSpecTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Compute Resources required by this service.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesHistoryResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TemporalClusterServicesHistoryResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesHistoryResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Internal Frontend service custom specifications.
/// Only compatible with temporal >= 1.20.0
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesInternalFrontend {
    /// Enabled defines if we want to spawn the internal frontend service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// HTTPPort defines a custom http port for the service.
    /// Default values are:
    /// 7243 for Frontend service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<i32>,
    /// InitContainers adds a list of init containers to the service's deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// MembershipPort defines a custom membership port for the service.
    /// Default values are:
    /// 6933 for Frontend service
    /// 6934 for History service
    /// 6935 for Matching service
    /// 6939 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "membershipPort")]
    pub membership_port: Option<i32>,
    /// Overrides adds some overrides to the resources deployed for the service.
    /// Those overrides takes precedence over spec.services.overrides.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<TemporalClusterServicesInternalFrontendOverrides>,
    /// Port defines a custom gRPC port for the service.
    /// Default values are:
    /// 7233 for Frontend service
    /// 7234 for History service
    /// 7235 for Matching service
    /// 7239 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Number of desired replicas for the service. Default to 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Compute Resources required by this service.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TemporalClusterServicesInternalFrontendResources>,
}

/// Overrides adds some overrides to the resources deployed for the service.
/// Those overrides takes precedence over spec.services.overrides.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesInternalFrontendOverrides {
    /// Override configuration for the temporal service Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<TemporalClusterServicesInternalFrontendOverridesDeployment>,
}

/// Override configuration for the temporal service Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesInternalFrontendOverridesDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPatch")]
    pub json_patch: Option<serde_json::Value>,
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesInternalFrontendOverridesDeploymentMetadata>,
    /// Specification of the desired behavior of the Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<TemporalClusterServicesInternalFrontendOverridesDeploymentSpec>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesInternalFrontendOverridesDeploymentMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Specification of the desired behavior of the Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesInternalFrontendOverridesDeploymentSpec {
    /// Template describes the pods that will be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TemporalClusterServicesInternalFrontendOverridesDeploymentSpecTemplate>,
}

/// Template describes the pods that will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesInternalFrontendOverridesDeploymentSpecTemplate {
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata>,
    /// Specification of the desired behavior of the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<serde_json::Value>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Compute Resources required by this service.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesInternalFrontendResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TemporalClusterServicesInternalFrontendResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesInternalFrontendResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Matching service custom specifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesMatching {
    /// HTTPPort defines a custom http port for the service.
    /// Default values are:
    /// 7243 for Frontend service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<i32>,
    /// InitContainers adds a list of init containers to the service's deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// MembershipPort defines a custom membership port for the service.
    /// Default values are:
    /// 6933 for Frontend service
    /// 6934 for History service
    /// 6935 for Matching service
    /// 6939 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "membershipPort")]
    pub membership_port: Option<i32>,
    /// Overrides adds some overrides to the resources deployed for the service.
    /// Those overrides takes precedence over spec.services.overrides.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<TemporalClusterServicesMatchingOverrides>,
    /// Port defines a custom gRPC port for the service.
    /// Default values are:
    /// 7233 for Frontend service
    /// 7234 for History service
    /// 7235 for Matching service
    /// 7239 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Number of desired replicas for the service. Default to 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Compute Resources required by this service.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TemporalClusterServicesMatchingResources>,
}

/// Overrides adds some overrides to the resources deployed for the service.
/// Those overrides takes precedence over spec.services.overrides.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesMatchingOverrides {
    /// Override configuration for the temporal service Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<TemporalClusterServicesMatchingOverridesDeployment>,
}

/// Override configuration for the temporal service Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesMatchingOverridesDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPatch")]
    pub json_patch: Option<serde_json::Value>,
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesMatchingOverridesDeploymentMetadata>,
    /// Specification of the desired behavior of the Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<TemporalClusterServicesMatchingOverridesDeploymentSpec>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesMatchingOverridesDeploymentMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Specification of the desired behavior of the Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesMatchingOverridesDeploymentSpec {
    /// Template describes the pods that will be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TemporalClusterServicesMatchingOverridesDeploymentSpecTemplate>,
}

/// Template describes the pods that will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesMatchingOverridesDeploymentSpecTemplate {
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesMatchingOverridesDeploymentSpecTemplateMetadata>,
    /// Specification of the desired behavior of the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<serde_json::Value>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesMatchingOverridesDeploymentSpecTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Compute Resources required by this service.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesMatchingResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TemporalClusterServicesMatchingResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesMatchingResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Overrides adds some overrides to the resources deployed for all temporal services services.
/// Those overrides can be customized per service using spec.services.<serviceName>.overrides.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesOverrides {
    /// Override configuration for the temporal service Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<TemporalClusterServicesOverridesDeployment>,
}

/// Override configuration for the temporal service Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesOverridesDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPatch")]
    pub json_patch: Option<serde_json::Value>,
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesOverridesDeploymentMetadata>,
    /// Specification of the desired behavior of the Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<TemporalClusterServicesOverridesDeploymentSpec>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesOverridesDeploymentMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Specification of the desired behavior of the Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesOverridesDeploymentSpec {
    /// Template describes the pods that will be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TemporalClusterServicesOverridesDeploymentSpecTemplate>,
}

/// Template describes the pods that will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesOverridesDeploymentSpecTemplate {
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesOverridesDeploymentSpecTemplateMetadata>,
    /// Specification of the desired behavior of the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<serde_json::Value>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesOverridesDeploymentSpecTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Worker service custom specifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesWorker {
    /// HTTPPort defines a custom http port for the service.
    /// Default values are:
    /// 7243 for Frontend service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<i32>,
    /// InitContainers adds a list of init containers to the service's deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// MembershipPort defines a custom membership port for the service.
    /// Default values are:
    /// 6933 for Frontend service
    /// 6934 for History service
    /// 6935 for Matching service
    /// 6939 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "membershipPort")]
    pub membership_port: Option<i32>,
    /// Overrides adds some overrides to the resources deployed for the service.
    /// Those overrides takes precedence over spec.services.overrides.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<TemporalClusterServicesWorkerOverrides>,
    /// Port defines a custom gRPC port for the service.
    /// Default values are:
    /// 7233 for Frontend service
    /// 7234 for History service
    /// 7235 for Matching service
    /// 7239 for Worker service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// Number of desired replicas for the service. Default to 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Compute Resources required by this service.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TemporalClusterServicesWorkerResources>,
}

/// Overrides adds some overrides to the resources deployed for the service.
/// Those overrides takes precedence over spec.services.overrides.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesWorkerOverrides {
    /// Override configuration for the temporal service Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<TemporalClusterServicesWorkerOverridesDeployment>,
}

/// Override configuration for the temporal service Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesWorkerOverridesDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPatch")]
    pub json_patch: Option<serde_json::Value>,
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesWorkerOverridesDeploymentMetadata>,
    /// Specification of the desired behavior of the Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<TemporalClusterServicesWorkerOverridesDeploymentSpec>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesWorkerOverridesDeploymentMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Specification of the desired behavior of the Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesWorkerOverridesDeploymentSpec {
    /// Template describes the pods that will be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TemporalClusterServicesWorkerOverridesDeploymentSpecTemplate>,
}

/// Template describes the pods that will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesWorkerOverridesDeploymentSpecTemplate {
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterServicesWorkerOverridesDeploymentSpecTemplateMetadata>,
    /// Specification of the desired behavior of the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<serde_json::Value>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesWorkerOverridesDeploymentSpecTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Compute Resources required by this service.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesWorkerResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TemporalClusterServicesWorkerResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterServicesWorkerResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// UI allows configuration of the optional temporal web ui deployed alongside the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUi {
    /// Enabled defines if the operator should deploy the web ui alongside the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Image defines the temporal ui docker image the instance should run.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Ingress is an optional ingress configuration for the UI.
    /// If lived empty, no ingress configuration will be created and the UI will only by available trough ClusterIP service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<TemporalClusterUiIngress>,
    /// Overrides adds some overrides to the resources deployed for the ui.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<TemporalClusterUiOverrides>,
    /// Number of desired replicas for the ui. Default to 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Compute Resources required by the ui.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<TemporalClusterUiResources>,
    /// Service is an optional service resource configuration for the UI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<TemporalClusterUiService>,
    /// Version defines the temporal ui version the instance should run.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Ingress is an optional ingress configuration for the UI.
/// If lived empty, no ingress configuration will be created and the UI will only by available trough ClusterIP service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiIngress {
    /// Annotations allows custom annotations on the ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Host is the list of host the ingress should use.
    pub hosts: Vec<String>,
    /// IngressClassName is the name of the IngressClass the deployed ingress resource should use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// TLS configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<Vec<TemporalClusterUiIngressTls>>,
}

/// IngressTLS describes the transport layer security associated with an ingress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiIngressTls {
    /// hosts is a list of hosts included in the TLS certificate. The values in
    /// this list must match the name/s used in the tlsSecret. Defaults to the
    /// wildcard host setting for the loadbalancer controller fulfilling this
    /// Ingress, if left unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    /// secretName is the name of the secret used to terminate TLS traffic on
    /// port 443. Field is left optional to allow TLS routing based on SNI
    /// hostname alone. If the SNI host in a listener conflicts with the "Host"
    /// header field used by an IngressRule, the SNI host is used for termination
    /// and value of the "Host" header is used for routing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Overrides adds some overrides to the resources deployed for the ui.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiOverrides {
    /// Override configuration for the temporal service Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deployment: Option<TemporalClusterUiOverridesDeployment>,
}

/// Override configuration for the temporal service Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiOverridesDeployment {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPatch")]
    pub json_patch: Option<serde_json::Value>,
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterUiOverridesDeploymentMetadata>,
    /// Specification of the desired behavior of the Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<TemporalClusterUiOverridesDeploymentSpec>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiOverridesDeploymentMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Specification of the desired behavior of the Deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiOverridesDeploymentSpec {
    /// Template describes the pods that will be created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<TemporalClusterUiOverridesDeploymentSpecTemplate>,
}

/// Template describes the pods that will be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiOverridesDeploymentSpecTemplate {
    /// ObjectMetaOverride provides the ability to override an object metadata.
    /// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<TemporalClusterUiOverridesDeploymentSpecTemplateMetadata>,
    /// Specification of the desired behavior of the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<serde_json::Value>,
}

/// ObjectMetaOverride provides the ability to override an object metadata.
/// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiOverridesDeploymentSpecTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Compute Resources required by the ui.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<TemporalClusterUiResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Service is an optional service resource configuration for the UI.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterUiService {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Most recent observed status of the Temporal cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterStatus {
    /// Conditions represent the latest available observations of the Cluster state.
    pub conditions: Vec<Condition>,
    /// Persistence holds all datastores statuses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub persistence: Option<TemporalClusterStatusPersistence>,
    /// Services holds all services statuses.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<TemporalClusterStatusServices>>,
    /// Version holds the current temporal version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Persistence holds all datastores statuses.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterStatusPersistence {
    /// AdvancedVisibilityStore holds the advanced visibility datastore status.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advancedVisibilityStore")]
    pub advanced_visibility_store: Option<TemporalClusterStatusPersistenceAdvancedVisibilityStore>,
    /// DefaultStore holds the default datastore status.
    #[serde(rename = "defaultStore")]
    pub default_store: TemporalClusterStatusPersistenceDefaultStore,
    /// SecondaryVisibilityStore holds the secondary visibility datastore status.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secondaryVisibilityStore")]
    pub secondary_visibility_store: Option<TemporalClusterStatusPersistenceSecondaryVisibilityStore>,
    /// VisibilityStore holds the visibility datastore status.
    #[serde(rename = "visibilityStore")]
    pub visibility_store: TemporalClusterStatusPersistenceVisibilityStore,
}

/// AdvancedVisibilityStore holds the advanced visibility datastore status.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterStatusPersistenceAdvancedVisibilityStore {
    /// Created indicates if the database or keyspace has been created.
    pub created: bool,
    /// SchemaVersion report the current schema version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schemaVersion")]
    pub schema_version: Option<String>,
    /// Setup indicates if tables have been set up.
    pub setup: bool,
    /// Type indicates the datastore type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// DefaultStore holds the default datastore status.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterStatusPersistenceDefaultStore {
    /// Created indicates if the database or keyspace has been created.
    pub created: bool,
    /// SchemaVersion report the current schema version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schemaVersion")]
    pub schema_version: Option<String>,
    /// Setup indicates if tables have been set up.
    pub setup: bool,
    /// Type indicates the datastore type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// SecondaryVisibilityStore holds the secondary visibility datastore status.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterStatusPersistenceSecondaryVisibilityStore {
    /// Created indicates if the database or keyspace has been created.
    pub created: bool,
    /// SchemaVersion report the current schema version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schemaVersion")]
    pub schema_version: Option<String>,
    /// Setup indicates if tables have been set up.
    pub setup: bool,
    /// Type indicates the datastore type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// VisibilityStore holds the visibility datastore status.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterStatusPersistenceVisibilityStore {
    /// Created indicates if the database or keyspace has been created.
    pub created: bool,
    /// SchemaVersion report the current schema version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schemaVersion")]
    pub schema_version: Option<String>,
    /// Setup indicates if tables have been set up.
    pub setup: bool,
    /// Type indicates the datastore type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// ServiceStatus reports a service status.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct TemporalClusterStatusServices {
    /// Name of the temporal service.
    pub name: String,
    /// Ready defines if the service is ready.
    pub ready: bool,
    /// Current observed version of the service.
    pub version: String,
}

