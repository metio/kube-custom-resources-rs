// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/zalando/postgres-operator/acid.zalan.do/v1/postgresqls.yaml
// kopium version: 0.22.4

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "acid.zalan.do", version = "v1", kind = "postgresql", plural = "postgresqls")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct PostgresqlSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalVolumes")]
    pub additional_volumes: Option<Vec<PostgresqlAdditionalVolumes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSourceRanges")]
    pub allowed_source_ranges: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clone: Option<PostgresqlClone>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPooler")]
    pub connection_pooler: Option<PostgresqlConnectionPooler>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub databases: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConnectionPooler")]
    pub enable_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableLogicalBackup")]
    pub enable_logical_backup: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterLoadBalancer")]
    pub enable_master_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterPoolerLoadBalancer")]
    pub enable_master_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaConnectionPooler")]
    pub enable_replica_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaLoadBalancer")]
    pub enable_replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaPoolerLoadBalancer")]
    pub enable_replica_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableShmVolume")]
    pub enable_shm_volume: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "init_containers")]
    pub init_containers_x: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupRetention")]
    pub logical_backup_retention: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupSchedule")]
    pub logical_backup_schedule: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindows")]
    pub maintenance_windows: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterServiceAnnotations")]
    pub master_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<PostgresqlNodeAffinity>,
    #[serde(rename = "numberOfInstances")]
    pub number_of_instances: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patroni: Option<PostgresqlPatroni>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAnnotations")]
    pub pod_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPriorityClassName")]
    pub pod_priority_class_name: Option<String>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pod_priority_class_name")]
    pub pod_priority_class_name_x: Option<String>,
    pub postgresql: PostgresqlPostgresql,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preparedDatabases")]
    pub prepared_databases: Option<BTreeMap<String, PostgresqlPreparedDatabases>>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaLoadBalancer")]
    pub replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceAnnotations")]
    pub replica_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAnnotations")]
    pub service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloFSGroup")]
    pub spilo_fs_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsGroup")]
    pub spilo_run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsUser")]
    pub spilo_run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<PostgresqlStandby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub streams: Option<Vec<PostgresqlStreams>>,
    #[serde(rename = "teamId")]
    pub team_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<PostgresqlTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresqlTolerations>>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useLoadBalancer")]
    pub use_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<BTreeMap<String, Vec<String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersIgnoringSecretRotation")]
    pub users_ignoring_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithInPlaceSecretRotation")]
    pub users_with_in_place_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithSecretRotation")]
    pub users_with_secret_rotation: Option<Vec<String>>,
    pub volume: PostgresqlVolume,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlAdditionalVolumes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetContainers")]
    pub target_containers: Option<Vec<String>>,
    #[serde(rename = "volumeSource")]
    pub volume_source: BTreeMap<String, serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlClone {
    pub cluster: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_access_key_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_force_path_style: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_secret_access_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlConnectionPooler {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDBConnections")]
    pub max_db_connections: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<PostgresqlConnectionPoolerMode>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberOfInstances")]
    pub number_of_instances: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlConnectionPoolerResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlConnectionPoolerMode {
    #[serde(rename = "session")]
    Session,
    #[serde(rename = "transaction")]
    Transaction,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlConnectionPoolerResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlConnectionPoolerResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlConnectionPoolerResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlConnectionPoolerResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlConnectionPoolerResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlPatroni {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failsafe_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initdb: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loop_wait: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum_lag_on_failover: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pg_hba: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry_timeout: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slots: Option<BTreeMap<String, BTreeMap<String, String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode_strict: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_node_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PostgresqlPostgresql {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<BTreeMap<String, String>>,
    pub version: PostgresqlPostgresqlVersion,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlPostgresqlVersion {
    #[serde(rename = "13")]
    r#_13,
    #[serde(rename = "14")]
    r#_14,
    #[serde(rename = "15")]
    r#_15,
    #[serde(rename = "16")]
    r#_16,
    #[serde(rename = "17")]
    r#_17,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlPreparedDatabases {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extensions: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schemas: Option<BTreeMap<String, PostgresqlPreparedDatabasesSchemas>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretNamespace")]
    pub secret_namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlPreparedDatabasesSchemas {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRoles")]
    pub default_roles: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlStandby {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gs_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlStreams {
    #[serde(rename = "applicationId")]
    pub application_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSize")]
    pub batch_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    pub database: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRecovery")]
    pub enable_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    pub tables: BTreeMap<String, PostgresqlStreamsTables>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlStreamsTables {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idColumn")]
    pub id_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreRecovery")]
    pub ignore_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadColumn")]
    pub payload_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoveryEventType")]
    pub recovery_event_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caSecretName")]
    pub ca_secret_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateFile")]
    pub certificate_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyFile")]
    pub private_key_file: Option<String>,
    #[serde(rename = "secretName")]
    pub secret_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<PostgresqlTolerationsEffect>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<PostgresqlTolerationsOperator>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlTolerationsEffect {
    NoExecute,
    NoSchedule,
    PreferNoSchedule,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlTolerationsOperator {
    Equal,
    Exists,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlVolume {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iops: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresqlVolumeSelector>,
    pub size: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClass")]
    pub storage_class: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throughput: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlVolumeSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlVolumeSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PostgresqlVolumeSelectorMatchExpressions {
    pub key: String,
    pub operator: PostgresqlVolumeSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlVolumeSelectorMatchExpressionsOperator {
    DoesNotExist,
    Exists,
    In,
    NotIn,
}

