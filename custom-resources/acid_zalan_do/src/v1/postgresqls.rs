// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/zalando/postgres-operator/acid.zalan.do/v1/postgresqls.yaml
// kopium version: 0.22.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "acid.zalan.do", version = "v1", kind = "postgresql", plural = "postgresqls")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct PostgresqlSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalVolumes")]
    pub additional_volumes: Option<Vec<PostgresqlSpecAdditionalVolumes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSourceRanges")]
    pub allowed_source_ranges: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clone: Option<PostgresqlSpecClone>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPooler")]
    pub connection_pooler: Option<PostgresqlSpecConnectionPooler>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub databases: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConnectionPooler")]
    pub enable_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableLogicalBackup")]
    pub enable_logical_backup: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterLoadBalancer")]
    pub enable_master_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterPoolerLoadBalancer")]
    pub enable_master_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaConnectionPooler")]
    pub enable_replica_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaLoadBalancer")]
    pub enable_replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaPoolerLoadBalancer")]
    pub enable_replica_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableShmVolume")]
    pub enable_shm_volume: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "init_containers")]
    pub init_containers_x: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupRetention")]
    pub logical_backup_retention: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupSchedule")]
    pub logical_backup_schedule: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindows")]
    pub maintenance_windows: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterServiceAnnotations")]
    pub master_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<PostgresqlSpecNodeAffinity>,
    #[serde(rename = "numberOfInstances")]
    pub number_of_instances: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patroni: Option<PostgresqlSpecPatroni>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAnnotations")]
    pub pod_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPriorityClassName")]
    pub pod_priority_class_name: Option<String>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pod_priority_class_name")]
    pub pod_priority_class_name_x: Option<String>,
    pub postgresql: PostgresqlSpecPostgresql,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preparedDatabases")]
    pub prepared_databases: Option<BTreeMap<String, PostgresqlSpecPreparedDatabases>>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaLoadBalancer")]
    pub replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceAnnotations")]
    pub replica_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlSpecResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAnnotations")]
    pub service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloFSGroup")]
    pub spilo_fs_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsGroup")]
    pub spilo_run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsUser")]
    pub spilo_run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<PostgresqlSpecStandby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub streams: Option<Vec<PostgresqlSpecStreams>>,
    #[serde(rename = "teamId")]
    pub team_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<PostgresqlSpecTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresqlSpecTolerations>>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useLoadBalancer")]
    pub use_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<BTreeMap<String, Vec<String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersIgnoringSecretRotation")]
    pub users_ignoring_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithInPlaceSecretRotation")]
    pub users_with_in_place_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithSecretRotation")]
    pub users_with_secret_rotation: Option<Vec<String>>,
    pub volume: PostgresqlSpecVolume,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecAdditionalVolumes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetContainers")]
    pub target_containers: Option<Vec<String>>,
    #[serde(rename = "volumeSource")]
    pub volume_source: BTreeMap<String, serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecClone {
    pub cluster: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_access_key_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_force_path_style: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_secret_access_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecConnectionPooler {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDBConnections")]
    pub max_db_connections: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<PostgresqlSpecConnectionPoolerMode>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberOfInstances")]
    pub number_of_instances: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlSpecConnectionPoolerResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecConnectionPoolerMode {
    #[serde(rename = "session")]
    Session,
    #[serde(rename = "transaction")]
    Transaction,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecConnectionPoolerResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlSpecConnectionPoolerResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlSpecConnectionPoolerResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecConnectionPoolerResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecConnectionPoolerResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecPatroni {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failsafe_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initdb: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loop_wait: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum_lag_on_failover: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pg_hba: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry_timeout: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slots: Option<BTreeMap<String, BTreeMap<String, String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode_strict: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_node_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PostgresqlSpecPostgresql {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<BTreeMap<String, String>>,
    pub version: PostgresqlSpecPostgresqlVersion,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecPostgresqlVersion {
    #[serde(rename = "13")]
    r#_13,
    #[serde(rename = "14")]
    r#_14,
    #[serde(rename = "15")]
    r#_15,
    #[serde(rename = "16")]
    r#_16,
    #[serde(rename = "17")]
    r#_17,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecPreparedDatabases {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extensions: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schemas: Option<BTreeMap<String, PostgresqlSpecPreparedDatabasesSchemas>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretNamespace")]
    pub secret_namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecPreparedDatabasesSchemas {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRoles")]
    pub default_roles: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlSpecResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlSpecResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecStandby {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gs_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecStreams {
    #[serde(rename = "applicationId")]
    pub application_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSize")]
    pub batch_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    pub database: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRecovery")]
    pub enable_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    pub tables: BTreeMap<String, PostgresqlSpecStreamsTables>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecStreamsTables {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idColumn")]
    pub id_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreRecovery")]
    pub ignore_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadColumn")]
    pub payload_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoveryEventType")]
    pub recovery_event_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caSecretName")]
    pub ca_secret_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateFile")]
    pub certificate_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyFile")]
    pub private_key_file: Option<String>,
    #[serde(rename = "secretName")]
    pub secret_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<PostgresqlSpecTolerationsEffect>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<PostgresqlSpecTolerationsOperator>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecTolerationsEffect {
    NoExecute,
    NoSchedule,
    PreferNoSchedule,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecTolerationsOperator {
    Equal,
    Exists,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecVolume {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iops: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresqlSpecVolumeSelector>,
    pub size: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClass")]
    pub storage_class: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throughput: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PostgresqlSpecVolumeSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlSpecVolumeSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PostgresqlSpecVolumeSelectorMatchExpressions {
    pub key: String,
    pub operator: PostgresqlSpecVolumeSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecVolumeSelectorMatchExpressionsOperator {
    DoesNotExist,
    Exists,
    In,
    NotIn,
}

