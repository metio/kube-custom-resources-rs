// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/kubernetes-sigs/node-feature-discovery-operator/nfd.k8s-sigs.io/v1alpha1/nodefeaturegroups.yaml
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// Spec defines the rules to be evaluated.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "nfd.k8s-sigs.io", version = "v1alpha1", kind = "NodeFeatureGroup", plural = "nodefeaturegroups")]
#[kube(namespaced)]
#[kube(status = "NodeFeatureGroupStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct NodeFeatureGroupSpec {
    /// List of rules to evaluate to determine nodes that belong in this group.
    #[serde(rename = "featureGroupRules")]
    pub feature_group_rules: Vec<NodeFeatureGroupFeatureGroupRules>,
}

/// GroupRule defines a rule for nodegroup filtering.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeFeatureGroupFeatureGroupRules {
    /// MatchAny specifies a list of matchers one of which must match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchAny")]
    pub match_any: Option<Vec<NodeFeatureGroupFeatureGroupRulesMatchAny>>,
    /// MatchFeatures specifies a set of matcher terms all of which must match.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFeatures")]
    pub match_features: Option<Vec<NodeFeatureGroupFeatureGroupRulesMatchFeatures>>,
    /// Name of the rule.
    pub name: String,
}

/// MatchAnyElem specifies one sub-matcher of MatchAny.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeFeatureGroupFeatureGroupRulesMatchAny {
    /// MatchFeatures specifies a set of matcher terms all of which must match.
    #[serde(rename = "matchFeatures")]
    pub match_features: Vec<NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeatures>,
}

/// FeatureMatcherTerm defines requirements against one feature set. All
/// requirements (specified as MatchExpressions) are evaluated against each
/// element in the feature set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeatures {
    /// Feature is the name of the feature set to match against.
    pub feature: String,
    /// MatchExpressions is the set of per-element expressions evaluated. These
    /// match against the value of the specified elements.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<BTreeMap<String, NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions>>,
    /// MatchName in an expression that is matched against the name of each
    /// element in the feature set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeaturesMatchName>,
}

/// MatchExpressions is the set of per-element expressions evaluated. These
/// match against the value of the specified elements.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions {
    /// Op is the operator to be applied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub op: Option<NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressionsOp>,
    /// Value is the list of values that the operand evaluates the input
    /// against. Value should be empty if the operator is Exists, DoesNotExist,
    /// IsTrue or IsFalse. Value should contain exactly one element if the
    /// operator is Gt or Lt and exactly two elements if the operator is GtLt.
    /// In other cases Value should contain at least one element.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<Vec<String>>,
}

/// MatchExpressions is the set of per-element expressions evaluated. These
/// match against the value of the specified elements.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressionsOp {
    In,
    NotIn,
    InRegexp,
    Exists,
    DoesNotExist,
    Gt,
    Lt,
    GtLt,
    IsTrue,
    IsFalse,
}

/// MatchName in an expression that is matched against the name of each
/// element in the feature set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeaturesMatchName {
    /// Op is the operator to be applied.
    pub op: NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeaturesMatchNameOp,
    /// Value is the list of values that the operand evaluates the input
    /// against. Value should be empty if the operator is Exists, DoesNotExist,
    /// IsTrue or IsFalse. Value should contain exactly one element if the
    /// operator is Gt or Lt and exactly two elements if the operator is GtLt.
    /// In other cases Value should contain at least one element.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<Vec<String>>,
}

/// MatchName in an expression that is matched against the name of each
/// element in the feature set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum NodeFeatureGroupFeatureGroupRulesMatchAnyMatchFeaturesMatchNameOp {
    In,
    NotIn,
    InRegexp,
    Exists,
    DoesNotExist,
    Gt,
    Lt,
    GtLt,
    IsTrue,
    IsFalse,
}

/// FeatureMatcherTerm defines requirements against one feature set. All
/// requirements (specified as MatchExpressions) are evaluated against each
/// element in the feature set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeFeatureGroupFeatureGroupRulesMatchFeatures {
    /// Feature is the name of the feature set to match against.
    pub feature: String,
    /// MatchExpressions is the set of per-element expressions evaluated. These
    /// match against the value of the specified elements.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<BTreeMap<String, NodeFeatureGroupFeatureGroupRulesMatchFeaturesMatchExpressions>>,
    /// MatchName in an expression that is matched against the name of each
    /// element in the feature set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<NodeFeatureGroupFeatureGroupRulesMatchFeaturesMatchName>,
}

/// MatchExpressions is the set of per-element expressions evaluated. These
/// match against the value of the specified elements.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeFeatureGroupFeatureGroupRulesMatchFeaturesMatchExpressions {
    /// Op is the operator to be applied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub op: Option<NodeFeatureGroupFeatureGroupRulesMatchFeaturesMatchExpressionsOp>,
    /// Value is the list of values that the operand evaluates the input
    /// against. Value should be empty if the operator is Exists, DoesNotExist,
    /// IsTrue or IsFalse. Value should contain exactly one element if the
    /// operator is Gt or Lt and exactly two elements if the operator is GtLt.
    /// In other cases Value should contain at least one element.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<Vec<String>>,
}

/// MatchExpressions is the set of per-element expressions evaluated. These
/// match against the value of the specified elements.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum NodeFeatureGroupFeatureGroupRulesMatchFeaturesMatchExpressionsOp {
    In,
    NotIn,
    InRegexp,
    Exists,
    DoesNotExist,
    Gt,
    Lt,
    GtLt,
    IsTrue,
    IsFalse,
}

/// MatchName in an expression that is matched against the name of each
/// element in the feature set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct NodeFeatureGroupFeatureGroupRulesMatchFeaturesMatchName {
    /// Op is the operator to be applied.
    pub op: NodeFeatureGroupFeatureGroupRulesMatchFeaturesMatchNameOp,
    /// Value is the list of values that the operand evaluates the input
    /// against. Value should be empty if the operator is Exists, DoesNotExist,
    /// IsTrue or IsFalse. Value should contain exactly one element if the
    /// operator is Gt or Lt and exactly two elements if the operator is GtLt.
    /// In other cases Value should contain at least one element.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<Vec<String>>,
}

/// MatchName in an expression that is matched against the name of each
/// element in the feature set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum NodeFeatureGroupFeatureGroupRulesMatchFeaturesMatchNameOp {
    In,
    NotIn,
    InRegexp,
    Exists,
    DoesNotExist,
    Gt,
    Lt,
    GtLt,
    IsTrue,
    IsFalse,
}

/// Status of the NodeFeatureGroup after the most recent evaluation of the
/// specification.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeFeatureGroupStatus {
    /// Nodes is a list of FeatureGroupNode in the cluster that match the featureGroupRules
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nodes: Option<Vec<NodeFeatureGroupStatusNodes>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeFeatureGroupStatusNodes {
    /// Name of the node.
    pub name: String,
}

