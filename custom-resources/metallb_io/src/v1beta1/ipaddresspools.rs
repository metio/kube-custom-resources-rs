// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/metallb/metallb-operator/metallb.io/v1beta1/ipaddresspools.yaml
// kopium version: 0.22.4

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// IPAddressPoolSpec defines the desired state of IPAddressPool.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "metallb.io", version = "v1beta1", kind = "IPAddressPool", plural = "ipaddresspools")]
#[kube(namespaced)]
#[kube(status = "IpAddressPoolStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct IpAddressPoolSpec {
    /// A list of IP address ranges over which MetalLB has authority.
    /// You can list multiple ranges in a single pool, they will all share the
    /// same settings. Each range can be either a CIDR prefix, or an explicit
    /// start-end range of IPs.
    pub addresses: Vec<String>,
    /// AutoAssign flag used to prevent MetallB from automatic allocation
    /// for a pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoAssign")]
    pub auto_assign: Option<bool>,
    /// AvoidBuggyIPs prevents addresses ending with .0 and .255
    /// to be used by a pool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "avoidBuggyIPs")]
    pub avoid_buggy_i_ps: Option<bool>,
    /// AllocateTo makes ip pool allocation to specific namespace and/or service.
    /// The controller will use the pool with lowest value of priority in case of
    /// multiple matches. A pool with no priority set will be used only if the
    /// pools with priority can't be used. If multiple matching IPAddressPools are
    /// available it will check for the availability of IPs sorting the matching
    /// IPAddressPools by priority, starting from the highest to the lowest. If
    /// multiple IPAddressPools have the same priority, choice will be random.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAllocation")]
    pub service_allocation: Option<IpAddressPoolServiceAllocation>,
}

/// AllocateTo makes ip pool allocation to specific namespace and/or service.
/// The controller will use the pool with lowest value of priority in case of
/// multiple matches. A pool with no priority set will be used only if the
/// pools with priority can't be used. If multiple matching IPAddressPools are
/// available it will check for the availability of IPs sorting the matching
/// IPAddressPools by priority, starting from the highest to the lowest. If
/// multiple IPAddressPools have the same priority, choice will be random.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpAddressPoolServiceAllocation {
    /// NamespaceSelectors list of label selectors to select namespace(s) for ip pool,
    /// an alternative to using namespace list.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelectors")]
    pub namespace_selectors: Option<Vec<IpAddressPoolServiceAllocationNamespaceSelectors>>,
    /// Namespaces list of namespace(s) on which ip pool can be attached.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// Priority priority given for ip pool while ip allocation on a service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// ServiceSelectors list of label selector to select service(s) for which ip pool
    /// can be used for ip allocation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSelectors")]
    pub service_selectors: Option<Vec<IpAddressPoolServiceAllocationServiceSelectors>>,
}

/// A label selector is a label query over a set of resources. The result of matchLabels and
/// matchExpressions are ANDed. An empty label selector matches all objects. A null
/// label selector matches no objects.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpAddressPoolServiceAllocationNamespaceSelectors {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<IpAddressPoolServiceAllocationNamespaceSelectorsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpAddressPoolServiceAllocationNamespaceSelectorsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label selector is a label query over a set of resources. The result of matchLabels and
/// matchExpressions are ANDed. An empty label selector matches all objects. A null
/// label selector matches no objects.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpAddressPoolServiceAllocationServiceSelectors {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<IpAddressPoolServiceAllocationServiceSelectorsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpAddressPoolServiceAllocationServiceSelectorsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// IPAddressPoolStatus defines the observed state of IPAddressPool.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct IpAddressPoolStatus {
    /// AssignedIPv4 is the number of assigned IPv4 addresses.
    #[serde(rename = "assignedIPv4")]
    pub assigned_i_pv4: i64,
    /// AssignedIPv6 is the number of assigned IPv6 addresses.
    #[serde(rename = "assignedIPv6")]
    pub assigned_i_pv6: i64,
    /// AvailableIPv4 is the number of available IPv4 addresses.
    #[serde(rename = "availableIPv4")]
    pub available_i_pv4: i64,
    /// AvailableIPv6 is the number of available IPv6 addresses.
    #[serde(rename = "availableIPv6")]
    pub available_i_pv6: i64,
}

