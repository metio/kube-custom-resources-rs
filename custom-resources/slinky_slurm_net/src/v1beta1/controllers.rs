// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/SlinkyProject/slurm-operator/slinky.slurm.net/v1beta1/controllers.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ControllerSpec defines the desired state of Controller
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "slinky.slurm.net", version = "v1beta1", kind = "Controller", plural = "controllers")]
#[kube(namespaced)]
#[kube(status = "ControllerStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ControllerSpec {
    /// accountingRef is a reference to the Accounting CR to which this has membership.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accountingRef")]
    pub accounting_ref: Option<ControllerAccountingRef>,
    /// The Slurm ClusterName, which uniquely identifies the Slurm Cluster to
    /// itself and accounting.
    /// Ref: <https://slurm.schedmd.com/slurm.conf.html#OPT_ClusterName>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterName")]
    pub cluster_name: Option<String>,
    /// ConfigFileRefs is a list of ConfigMap references containing files to be mounted in `/etc/slurm`.
    /// Ref: <https://slurm.schedmd.com/slurm.conf.html>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configFileRefs")]
    pub config_file_refs: Option<Vec<ControllerConfigFileRefs>>,
    /// EpilogScriptRefs is a list of epilog scripts to be mounted in `/etc/slurm`.
    /// Ref: <https://slurm.schedmd.com/prolog_epilog.html>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "epilogScriptRefs")]
    pub epilog_script_refs: Option<Vec<ControllerEpilogScriptRefs>>,
    /// EpilogSlurmctldScriptRefs is a list of EpilogSlurmctld scripts to be mounted in `/etc/slurm`.
    /// Ref: <https://slurm.schedmd.com/slurm.conf.html#OPT_EpilogSlurmctld>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "epilogSlurmctldScriptRefs")]
    pub epilog_slurmctld_script_refs: Option<Vec<ControllerEpilogSlurmctldScriptRefs>>,
    /// external indicates if this component is external to Kubernetes or not.
    /// If true, then externalConfig is used and other fields are ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub external: Option<bool>,
    /// ExternalConfig describes how to communicate with this external component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalConfig")]
    pub external_config: Option<ControllerExternalConfig>,
    /// ExtraConf is appended onto the end of the `slurm.conf` file.
    /// Ref: <https://slurm.schedmd.com/slurm.conf.html>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraConf")]
    pub extra_conf: Option<String>,
    /// Slurm `auth/jwt` JWT HS256 key authentication.
    #[serde(rename = "jwtHs256KeyRef")]
    pub jwt_hs256_key_ref: ControllerJwtHs256KeyRef,
    /// The logfile sidecar configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logfile: Option<BTreeMap<String, serde_json::Value>>,
    /// Metrics defines the metric collection configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<ControllerMetrics>,
    /// Persistence defines a persistent volume for the slurm controller to store its save-state.
    /// Used to recover from system failures or from pod upgrades.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub persistence: Option<ControllerPersistence>,
    /// PrologScriptRefs is a list of prolog scripts to be mounted in `/etc/slurm`.
    /// Ref: <https://slurm.schedmd.com/prolog_epilog.html>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prologScriptRefs")]
    pub prolog_script_refs: Option<Vec<ControllerPrologScriptRefs>>,
    /// PrologSlurmctldScriptRefs is a list of PrologSlurmctld scripts to be mounted in `/etc/slurm`.
    /// Ref: <https://slurm.schedmd.com/slurm.conf.html#OPT_PrologSlurmctld>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prologSlurmctldScriptRefs")]
    pub prolog_slurmctld_script_refs: Option<Vec<ControllerPrologSlurmctldScriptRefs>>,
    /// The reconfigure container configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconfigure: Option<BTreeMap<String, serde_json::Value>>,
    /// Service defines a template for a Kubernetes Service object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<ControllerService>,
    /// Slurm `auth/slurm` key authentication.
    #[serde(rename = "slurmKeyRef")]
    pub slurm_key_ref: ControllerSlurmKeyRef,
    /// The slurmctld container configuration.
    /// See corev1.Container spec.
    /// Ref: <https://github.com/kubernetes/api/blob/master/core/v1/types.go#L2885>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slurmctld: Option<BTreeMap<String, serde_json::Value>>,
    /// Template is the object that describes the pod that will be created if
    /// insufficient replicas are detected.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<ControllerTemplate>,
}

/// accountingRef is a reference to the Accounting CR to which this has membership.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerAccountingRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ObjectReference is a reference to an object.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerConfigFileRefs {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ObjectReference is a reference to an object.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerEpilogScriptRefs {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ObjectReference is a reference to an object.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerEpilogSlurmctldScriptRefs {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ExternalConfig describes how to communicate with this external component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerExternalConfig {
    /// Host defines the hostname or IP address to communicate with.
    pub host: String,
    /// Port defines the port to communicate over.
    pub port: i64,
}

/// Slurm `auth/jwt` JWT HS256 key authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerJwtHs256KeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Metrics defines the metric collection configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerMetrics {
    /// Enabled controls if metrics will be configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// ServiceMonitor defines a Prometheus service monitor to metrics discovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceMonitor")]
    pub service_monitor: Option<ControllerMetricsServiceMonitor>,
}

/// ServiceMonitor defines a Prometheus service monitor to metrics discovery.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerMetricsServiceMonitor {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled controls if metrics will be configured.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// endpoints to scrape.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<Vec<ControllerMetricsServiceMonitorEndpoints>>,
    /// interval at which Prometheus scrapes the metrics from the target.
    /// 
    /// If empty, Prometheus uses the global scrape interval.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// scrapeTimeout defines the timeout after which Prometheus considers the scrape to be failed.
    /// 
    /// If empty, Prometheus uses the global scrape timeout unless it is less
    /// than the target's scrape interval value in which the latter is used.
    /// The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerMetricsServiceMonitorEndpoints {
    /// interval at which Prometheus scrapes the metrics from the target.
    /// 
    /// If empty, the local global value will be used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// path defines the HTTP path from which to scrape for metrics.
    pub path: String,
    /// scrapeTimeout defines the timeout after which Prometheus considers the scrape to be failed.
    /// 
    /// If empty, the local global value will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
}

/// Persistence defines a persistent volume for the slurm controller to store its save-state.
/// Used to recover from system failures or from pod upgrades.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerPersistence {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ControllerPersistenceDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ControllerPersistenceDataSourceRef>,
    /// Enabled controls if the optional accounting subsystem is enabled.
    pub enabled: bool,
    /// ExistingClaim is the name of an existing `PersistentVolumeClaim` to use instead.
    /// If this is not empty, then certain other fields will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "existingClaim")]
    pub existing_claim: Option<String>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ControllerPersistenceResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ControllerPersistenceSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string or nil value indicates that no
    /// VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
    /// this field can be reset to its previous value (including nil) to cancel the modification.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerPersistenceDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerPersistenceDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerPersistenceResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerPersistenceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ControllerPersistenceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerPersistenceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ObjectReference is a reference to an object.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerPrologScriptRefs {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// ObjectReference is a reference to an object.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerPrologSlurmctldScriptRefs {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Service defines a template for a Kubernetes Service object.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerService {
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ControllerServiceMetadata>,
    /// The port on each node on which this service is exposed when type is
    /// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
    /// specified, in-range, and not in use it will be used, otherwise the
    /// operation will fail.  If not specified, a port will be allocated if this
    /// Service requires one.  If this field is specified when creating a
    /// Service which does not need it, creation will fail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i64>,
    /// The external service port number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// ServiceSpec describes the attributes that a user creates on a service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

/// Standard object's metadata.
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerServiceMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Slurm `auth/slurm` key authentication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerSlurmKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Template is the object that describes the pod that will be created if
/// insufficient replicas are detected.
/// More info: <https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerTemplate {
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ControllerTemplateMetadata>,
    /// PodSpec is a description of a pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

/// Standard object's metadata.
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerTemplateMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// ControllerStatus defines the observed state of Controller
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ControllerStatus {
    /// Represents the latest available observations of a Controller's current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

