// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/argoproj-labs/argocd-operator/argoproj.io/v1beta1/argocds.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ArgoCDSpec defines the desired state of ArgoCD
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "argoproj.io", version = "v1beta1", kind = "ArgoCD", plural = "argocds")]
#[kube(namespaced)]
#[kube(status = "ArgoCdStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ArgoCdSpec {
    /// AggregatedClusterRoles will allow users to have aggregated ClusterRoles for a cluster scoped instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "aggregatedClusterRoles")]
    pub aggregated_cluster_roles: Option<bool>,
    /// ApplicationInstanceLabelKey is the key name where Argo CD injects the app name as a tracking label.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationInstanceLabelKey")]
    pub application_instance_label_key: Option<String>,
    /// ArgoCDApplicationSet defines whether the Argo CD ApplicationSet controller should be installed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSet")]
    pub application_set: Option<ArgoCdApplicationSet>,
    /// ArgoCDAgent defines configurations for the ArgoCD Agent component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "argoCDAgent")]
    pub argo_cd_agent: Option<ArgoCdArgoCdAgent>,
    /// Banner defines an additional banner to be displayed in Argo CD UI
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub banner: Option<ArgoCdBanner>,
    /// CmdParams specifies command-line parameters for the Argo CD components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cmdParams")]
    pub cmd_params: Option<BTreeMap<String, String>>,
    /// Deprecated: ConfigManagementPlugins field is no longer supported. Argo CD now requires plugins to be defined as sidecar containers of repo server component. See '.spec.repo.sidecarContainers'. ConfigManagementPlugins was previously used to specify additional config management plugins.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configManagementPlugins")]
    pub config_management_plugins: Option<String>,
    /// Controller defines the Application Controller options for ArgoCD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub controller: Option<ArgoCdController>,
    /// DefaultClusterScopedRoleDisabled will disable creation of default ClusterRoles for a cluster scoped instance.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultClusterScopedRoleDisabled")]
    pub default_cluster_scoped_role_disabled: Option<bool>,
    /// DisableAdmin will disable the admin user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableAdmin")]
    pub disable_admin: Option<bool>,
    /// ExtraConfig can be used to add fields to Argo CD configmap that are not supported by Argo CD CRD.
    /// 
    /// Note: ExtraConfig takes precedence over Argo CD CRD.
    /// For example, A user sets `argocd.Spec.DisableAdmin` = true and also
    /// `a.Spec.ExtraConfig["admin.enabled"]` = true. In this case, operator updates
    /// Argo CD Configmap as follows -> argocd-cm.Data["admin.enabled"] = true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraConfig")]
    pub extra_config: Option<BTreeMap<String, String>>,
    /// GAAnonymizeUsers toggles user IDs being hashed before sending to google analytics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gaAnonymizeUsers")]
    pub ga_anonymize_users: Option<bool>,
    /// GATrackingID is the google analytics tracking ID to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gaTrackingID")]
    pub ga_tracking_id: Option<String>,
    /// Deprecated: Grafana defines the Grafana server options for ArgoCD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grafana: Option<ArgoCdGrafana>,
    /// HA options for High Availability support for the Redis component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ha: Option<ArgoCdHa>,
    /// HelpChatText is the text for getting chat help, defaults to "Chat now!"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "helpChatText")]
    pub help_chat_text: Option<String>,
    /// HelpChatURL is the URL for getting chat help, this will typically be your Slack channel for support.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "helpChatURL")]
    pub help_chat_url: Option<String>,
    /// Image is the ArgoCD container image for all ArgoCD components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// ImageUpdater defines whether the Argo CD ImageUpdater controller should be installed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageUpdater")]
    pub image_updater: Option<ArgoCdImageUpdater>,
    /// Import is the import/restore options for ArgoCD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub import: Option<ArgoCdImport>,
    /// Deprecated: InitialRepositories to configure Argo CD with upon creation of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialRepositories")]
    pub initial_repositories: Option<String>,
    /// InitialSSHKnownHosts defines the SSH known hosts data upon creation of the cluster for connecting Git repositories via SSH.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialSSHKnownHosts")]
    pub initial_ssh_known_hosts: Option<ArgoCdInitialSshKnownHosts>,
    /// InstallationID uniquely identifies an Argo CD instance in multi-instance clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "installationID")]
    pub installation_id: Option<String>,
    /// KustomizeBuildOptions is used to specify build options/parameters to use with `kustomize build`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kustomizeBuildOptions")]
    pub kustomize_build_options: Option<String>,
    /// KustomizeVersions is a listing of configured versions of Kustomize to be made available within ArgoCD.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kustomizeVersions")]
    pub kustomize_versions: Option<Vec<ArgoCdKustomizeVersions>>,
    /// LocalUsers is a listing of local users to be created by the operator for the purpose of issuing ArgoCD API keys.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localUsers")]
    pub local_users: Option<Vec<ArgoCdLocalUsers>>,
    /// Monitoring defines whether workload status monitoring configuration for this instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monitoring: Option<ArgoCdMonitoring>,
    /// NamespaceManagement defines the list of namespaces that Argo CD is allowed to manage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceManagement")]
    pub namespace_management: Option<Vec<ArgoCdNamespaceManagement>>,
    /// NodePlacement defines NodeSelectors and Taints for Argo CD workloads
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePlacement")]
    pub node_placement: Option<ArgoCdNodePlacement>,
    /// Notifications defines whether the Argo CD Notifications controller should be installed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notifications: Option<ArgoCdNotifications>,
    /// OIDCConfig is the OIDC configuration as an alternative to dex.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oidcConfig")]
    pub oidc_config: Option<String>,
    /// Prometheus defines the Prometheus server options for ArgoCD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prometheus: Option<ArgoCdPrometheus>,
    /// RBAC defines the RBAC configuration for Argo CD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbac: Option<ArgoCdRbac>,
    /// Redis defines the Redis server options for ArgoCD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis: Option<ArgoCdRedis>,
    /// Repo defines the repo server options for Argo CD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repo: Option<ArgoCdRepo>,
    /// Deprecated: RepositoryCredentials are the Git pull credentials to configure Argo CD with upon creation of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repositoryCredentials")]
    pub repository_credentials: Option<String>,
    /// ResourceActions customizes resource action behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceActions")]
    pub resource_actions: Option<Vec<ArgoCdResourceActions>>,
    /// ResourceExclusions is used to completely ignore entire classes of resource group/kinds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceExclusions")]
    pub resource_exclusions: Option<String>,
    /// ResourceHealthChecks customizes resource health check behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceHealthChecks")]
    pub resource_health_checks: Option<Vec<ArgoCdResourceHealthChecks>>,
    /// ResourceIgnoreDifferences customizes resource ignore difference behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceIgnoreDifferences")]
    pub resource_ignore_differences: Option<ArgoCdResourceIgnoreDifferences>,
    /// ResourceInclusions is used to only include specific group/kinds in the
    /// reconciliation process.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceInclusions")]
    pub resource_inclusions: Option<String>,
    /// ResourceTrackingMethod defines how Argo CD should track resources that it manages
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceTrackingMethod")]
    pub resource_tracking_method: Option<String>,
    /// Server defines the options for the ArgoCD Server component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server: Option<ArgoCdServer>,
    /// SourceNamespaces defines the namespaces application resources are allowed to be created in
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceNamespaces")]
    pub source_namespaces: Option<Vec<String>>,
    /// SSO defines the Single Sign-on configuration for Argo CD
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sso: Option<ArgoCdSso>,
    /// StatusBadgeEnabled toggles application status badge feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statusBadgeEnabled")]
    pub status_badge_enabled: Option<bool>,
    /// TLS defines the TLS options for ArgoCD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ArgoCdTls>,
    /// UsersAnonymousEnabled toggles anonymous user access.
    /// The anonymous users get default role permissions specified argocd-rbac-cm.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersAnonymousEnabled")]
    pub users_anonymous_enabled: Option<bool>,
    /// Version is the tag to use with the ArgoCD container image for all ArgoCD components.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// ArgoCDApplicationSet defines whether the Argo CD ApplicationSet controller should be installed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSet {
    /// Custom annotations to pods deployed by the operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled is the flag to enable the Application Set Controller during ArgoCD installation. (optional, default `true`)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Env lets you specify environment for applicationSet controller pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdApplicationSetEnv>>,
    /// ExtraCommandArgs allows users to pass command line arguments to ApplicationSet controller.
    /// They get added to default command line arguments provided by the operator.
    /// Please note that the command line arguments provided as part of ExtraCommandArgs
    /// will not overwrite the default command line arguments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraCommandArgs")]
    pub extra_command_args: Option<Vec<String>>,
    /// Image is the Argo CD ApplicationSet image (optional)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Custom labels to pods deployed by the operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// LogLevel describes the log level that should be used by the ApplicationSet controller. Defaults to ArgoCDDefaultLogLevel if not set.  Valid options are debug,info, error, and warn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// LogFormat refers to the log format used by the ApplicationSet component. Defaults to ArgoCDDefaultLogFormat if not configured. Valid options are text or json.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logformat: Option<ArgoCdApplicationSetLogformat>,
    /// Resources defines the Compute Resources required by the container for ApplicationSet.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdApplicationSetResources>,
    /// SCMProviders defines the list of allowed custom SCM provider API URLs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scmProviders")]
    pub scm_providers: Option<Vec<String>>,
    /// SCMRootCAConfigMap is the name of the config map that stores the Gitlab SCM Provider's TLS certificate which will be mounted on the ApplicationSet Controller (optional).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scmRootCAConfigMap")]
    pub scm_root_ca_config_map: Option<String>,
    /// SourceNamespaces defines the namespaces applicationset resources are allowed to be created in
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceNamespaces")]
    pub source_namespaces: Option<Vec<String>>,
    /// Version is the Argo CD ApplicationSet image tag. (optional)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// VolumeMounts adds volumeMounts to the Argo CD ApplicationSet Controller container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdApplicationSetVolumeMounts>>,
    /// Volumes adds volumes to the Argo CD ApplicationSet Controller container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<ArgoCdApplicationSetVolumes>>,
    /// WebhookServerSpec defines the options for the ApplicationSet Webhook Server component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookServer")]
    pub webhook_server: Option<ArgoCdApplicationSetWebhookServer>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdApplicationSetEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdApplicationSetEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdApplicationSetEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdApplicationSetEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdApplicationSetEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ArgoCDApplicationSet defines whether the Argo CD ApplicationSet controller should be installed.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdApplicationSetLogformat {
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "json")]
    Json,
}

/// Resources defines the Compute Resources required by the container for ApplicationSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdApplicationSetResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumes {
    /// awsElasticBlockStore represents an AWS Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
    /// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsElasticBlockStore")]
    pub aws_elastic_block_store: Option<ArgoCdApplicationSetVolumesAwsElasticBlockStore>,
    /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
    /// are redirected to the disk.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureDisk")]
    pub azure_disk: Option<ArgoCdApplicationSetVolumesAzureDisk>,
    /// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
    /// are redirected to the file.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureFile")]
    pub azure_file: Option<ArgoCdApplicationSetVolumesAzureFile>,
    /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
    /// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephfs: Option<ArgoCdApplicationSetVolumesCephfs>,
    /// cinder represents a cinder volume attached and mounted on kubelets host machine.
    /// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
    /// are redirected to the cinder.csi.openstack.org CSI driver.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cinder: Option<ArgoCdApplicationSetVolumesCinder>,
    /// configMap represents a configMap that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdApplicationSetVolumesConfigMap>,
    /// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<ArgoCdApplicationSetVolumesCsi>,
    /// downwardAPI represents downward API about the pod that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdApplicationSetVolumesDownwardApi>,
    /// emptyDir represents a temporary directory that shares a pod's lifetime.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<ArgoCdApplicationSetVolumesEmptyDir>,
    /// ephemeral represents a volume that is handled by a cluster storage driver.
    /// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    /// and deleted when the pod is removed.
    /// 
    /// Use this if:
    /// a) the volume is only needed while the pod runs,
    /// b) features of normal volumes like restoring from snapshot or capacity
    ///    tracking are needed,
    /// c) the storage driver is specified through a storage class, and
    /// d) the storage driver supports dynamic volume provisioning through
    ///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
    ///    information on the connection between this volume type
    ///    and PersistentVolumeClaim).
    /// 
    /// Use PersistentVolumeClaim or one of the vendor-specific
    /// APIs for volumes that persist for longer than the lifecycle
    /// of an individual pod.
    /// 
    /// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    /// be used that way - see the documentation of the driver for
    /// more information.
    /// 
    /// A pod can use both types of ephemeral volumes and
    /// persistent volumes at the same time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<ArgoCdApplicationSetVolumesEphemeral>,
    /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fc: Option<ArgoCdApplicationSetVolumesFc>,
    /// flexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flexVolume")]
    pub flex_volume: Option<ArgoCdApplicationSetVolumesFlexVolume>,
    /// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
    /// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flocker: Option<ArgoCdApplicationSetVolumesFlocker>,
    /// gcePersistentDisk represents a GCE Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
    /// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDisk")]
    pub gce_persistent_disk: Option<ArgoCdApplicationSetVolumesGcePersistentDisk>,
    /// gitRepo represents a git repository at a particular revision.
    /// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    /// into the Pod's container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitRepo")]
    pub git_repo: Option<ArgoCdApplicationSetVolumesGitRepo>,
    /// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    /// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glusterfs: Option<ArgoCdApplicationSetVolumesGlusterfs>,
    /// hostPath represents a pre-existing file or directory on the host
    /// machine that is directly exposed to the container. This is generally
    /// used for system agents or other privileged things that are allowed
    /// to see the host machine. Most containers will NOT need this.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<ArgoCdApplicationSetVolumesHostPath>,
    /// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
    /// The volume is resolved at pod startup depending on which PullPolicy value is provided:
    /// 
    /// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// 
    /// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
    /// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
    /// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
    /// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
    /// The volume will be mounted read-only (ro) and non-executable files (noexec).
    /// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
    /// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<ArgoCdApplicationSetVolumesImage>,
    /// iscsi represents an ISCSI Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iscsi: Option<ArgoCdApplicationSetVolumesIscsi>,
    /// name of the volume.
    /// Must be a DNS_LABEL and unique within the pod.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    pub name: String,
    /// nfs represents an NFS mount on the host that shares a pod's lifetime
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nfs: Option<ArgoCdApplicationSetVolumesNfs>,
    /// persistentVolumeClaimVolumeSource represents a reference to a
    /// PersistentVolumeClaim in the same namespace.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<ArgoCdApplicationSetVolumesPersistentVolumeClaim>,
    /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
    /// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "photonPersistentDisk")]
    pub photon_persistent_disk: Option<ArgoCdApplicationSetVolumesPhotonPersistentDisk>,
    /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
    /// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
    /// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
    /// is on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portworxVolume")]
    pub portworx_volume: Option<ArgoCdApplicationSetVolumesPortworxVolume>,
    /// projected items for all in one resources secrets, configmaps, and downward API
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<ArgoCdApplicationSetVolumesProjected>,
    /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
    /// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quobyte: Option<ArgoCdApplicationSetVolumesQuobyte>,
    /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
    /// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbd: Option<ArgoCdApplicationSetVolumesRbd>,
    /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    /// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scaleIO")]
    pub scale_io: Option<ArgoCdApplicationSetVolumesScaleIo>,
    /// secret represents a secret that should populate this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdApplicationSetVolumesSecret>,
    /// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    /// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storageos: Option<ArgoCdApplicationSetVolumesStorageos>,
    /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
    /// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
    /// are redirected to the csi.vsphere.vmware.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vsphereVolume")]
    pub vsphere_volume: Option<ArgoCdApplicationSetVolumesVsphereVolume>,
}

/// awsElasticBlockStore represents an AWS Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
/// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesAwsElasticBlockStore {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// readOnly value true will force the readOnly setting in VolumeMounts.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
/// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
/// are redirected to the disk.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesAzureDisk {
    /// cachingMode is the Host Caching mode: None, Read Only, Read Write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachingMode")]
    pub caching_mode: Option<String>,
    /// diskName is the Name of the data disk in the blob storage
    #[serde(rename = "diskName")]
    pub disk_name: String,
    /// diskURI is the URI of data disk in the blob storage
    #[serde(rename = "diskURI")]
    pub disk_uri: String,
    /// fsType is Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
/// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
/// are redirected to the file.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesAzureFile {
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretName is the  name of secret that contains Azure Storage Account Name and Key
    #[serde(rename = "secretName")]
    pub secret_name: String,
    /// shareName is the azure share Name
    #[serde(rename = "shareName")]
    pub share_name: String,
}

/// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
/// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesCephfs {
    /// monitors is Required: Monitors is a collection of Ceph monitors
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretFile")]
    pub secret_file: Option<String>,
    /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdApplicationSetVolumesCephfsSecretRef>,
    /// user is optional: User is the rados user name, default is admin
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
/// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesCephfsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// cinder represents a cinder volume attached and mounted on kubelets host machine.
/// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
/// are redirected to the cinder.csi.openstack.org CSI driver.
/// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesCinder {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is optional: points to a secret object containing parameters used to connect
    /// to OpenStack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdApplicationSetVolumesCinderSecretRef>,
    /// volumeID used to identify the volume in cinder.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// secretRef is optional: points to a secret object containing parameters used to connect
/// to OpenStack.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesCinderSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// configMap represents a configMap that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesConfigMap {
    /// defaultMode is optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdApplicationSetVolumesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesCsi {
    /// driver is the name of the CSI driver that handles this volume.
    /// Consult with your admin for the correct name as registered in the cluster.
    pub driver: String,
    /// fsType to mount. Ex. "ext4", "xfs", "ntfs".
    /// If not provided, the empty value is passed to the associated CSI driver
    /// which will determine the default filesystem to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// nodePublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// NodePublishVolume and NodeUnpublishVolume calls.
    /// This field is optional, and  may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secret references are passed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePublishSecretRef")]
    pub node_publish_secret_ref: Option<ArgoCdApplicationSetVolumesCsiNodePublishSecretRef>,
    /// readOnly specifies a read-only configuration for the volume.
    /// Defaults to false (read/write).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeAttributes stores driver-specific properties that are passed to the CSI
    /// driver. Consult your driver's documentation for supported values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributes")]
    pub volume_attributes: Option<BTreeMap<String, String>>,
}

/// nodePublishSecretRef is a reference to the secret object containing
/// sensitive information to pass to the CSI driver to complete the CSI
/// NodePublishVolume and NodeUnpublishVolume calls.
/// This field is optional, and  may be empty if no secret is required. If the
/// secret object contains more than one secret, all secret references are passed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesCsiNodePublishSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// downwardAPI represents downward API about the pod that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesDownwardApi {
    /// Optional: mode bits to use on created files by default. Must be a
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// Items is a list of downward API volume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdApplicationSetVolumesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdApplicationSetVolumesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdApplicationSetVolumesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// emptyDir represents a temporary directory that shares a pod's lifetime.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEmptyDir {
    /// medium represents what type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

/// ephemeral represents a volume that is handled by a cluster storage driver.
/// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
/// and deleted when the pod is removed.
/// 
/// Use this if:
/// a) the volume is only needed while the pod runs,
/// b) features of normal volumes like restoring from snapshot or capacity
///    tracking are needed,
/// c) the storage driver is specified through a storage class, and
/// d) the storage driver supports dynamic volume provisioning through
///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
///    information on the connection between this volume type
///    and PersistentVolumeClaim).
/// 
/// Use PersistentVolumeClaim or one of the vendor-specific
/// APIs for volumes that persist for longer than the lifecycle
/// of an individual pod.
/// 
/// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
/// be used that way - see the documentation of the driver for
/// more information.
/// 
/// A pod can use both types of ephemeral volumes and
/// persistent volumes at the same time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEphemeral {
    /// Will be used to create a stand-alone PVC to provision the volume.
    /// The pod in which this EphemeralVolumeSource is embedded will be the
    /// owner of the PVC, i.e. the PVC will be deleted together with the
    /// pod.  The name of the PVC will be `<pod name>-<volume name>` where
    /// `<volume name>` is the name from the `PodSpec.Volumes` array
    /// entry. Pod validation will reject the pod if the concatenated name
    /// is not valid for a PVC (for example, too long).
    /// 
    /// An existing PVC with that name that is not owned by the pod
    /// will *not* be used for the pod to avoid using an unrelated
    /// volume by mistake. Starting the pod is then blocked until
    /// the unrelated PVC is removed. If such a pre-created PVC is
    /// meant to be used by the pod, the PVC has to updated with an
    /// owner reference to the pod once the pod exists. Normally
    /// this should not be necessary, but it may be useful when
    /// manually reconstructing a broken cluster.
    /// 
    /// This field is read-only and no changes will be made by Kubernetes
    /// to the PVC after it has been created.
    /// 
    /// Required, must not be nil.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplate>,
}

/// Will be used to create a stand-alone PVC to provision the volume.
/// The pod in which this EphemeralVolumeSource is embedded will be the
/// owner of the PVC, i.e. the PVC will be deleted together with the
/// pod.  The name of the PVC will be `<pod name>-<volume name>` where
/// `<volume name>` is the name from the `PodSpec.Volumes` array
/// entry. Pod validation will reject the pod if the concatenated name
/// is not valid for a PVC (for example, too long).
/// 
/// An existing PVC with that name that is not owned by the pod
/// will *not* be used for the pod to avoid using an unrelated
/// volume by mistake. Starting the pod is then blocked until
/// the unrelated PVC is removed. If such a pre-created PVC is
/// meant to be used by the pod, the PVC has to updated with an
/// owner reference to the pod once the pod exists. Normally
/// this should not be necessary, but it may be useful when
/// manually reconstructing a broken cluster.
/// 
/// This field is read-only and no changes will be made by Kubernetes
/// to the PVC after it has been created.
/// 
/// Required, must not be nil.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplate {
    /// May contain labels and annotations that will be copied into the PVC
    /// when creating it. No other fields are allowed and will be rejected during
    /// validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateMetadata>,
    /// The specification for the PersistentVolumeClaim. The entire content is
    /// copied unchanged into the PVC that gets created from this
    /// template. The same fields as in a PersistentVolumeClaim
    /// are also valid here.
    pub spec: ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpec,
}

/// May contain labels and annotations that will be copied into the PVC
/// when creating it. No other fields are allowed and will be rejected during
/// validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateMetadata {
}

/// The specification for the PersistentVolumeClaim. The entire content is
/// copied unchanged into the PVC that gets created from this
/// template. The same fields as in a PersistentVolumeClaim
/// are also valid here.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    /// (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesFc {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// lun is Optional: FC target lun number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lun: Option<i32>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// targetWWNs is Optional: FC target worldwide names (WWNs)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetWWNs")]
    pub target_ww_ns: Option<Vec<String>>,
    /// wwids Optional: FC volume world wide identifiers (wwids)
    /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wwids: Option<Vec<String>>,
}

/// flexVolume represents a generic volume resource that is
/// provisioned/attached using an exec based plugin.
/// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesFlexVolume {
    /// driver is the name of the driver to use for this volume.
    pub driver: String,
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// options is Optional: this field holds extra command options if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<BTreeMap<String, String>>,
    /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is Optional: secretRef is reference to the secret object containing
    /// sensitive information to pass to the plugin scripts. This may be
    /// empty if no secret object is specified. If the secret object
    /// contains more than one secret, all secrets are passed to the plugin
    /// scripts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdApplicationSetVolumesFlexVolumeSecretRef>,
}

/// secretRef is Optional: secretRef is reference to the secret object containing
/// sensitive information to pass to the plugin scripts. This may be
/// empty if no secret object is specified. If the secret object
/// contains more than one secret, all secrets are passed to the plugin
/// scripts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesFlexVolumeSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
/// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesFlocker {
    /// datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
    /// should be considered as deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetName")]
    pub dataset_name: Option<String>,
    /// datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetUUID")]
    pub dataset_uuid: Option<String>,
}

/// gcePersistentDisk represents a GCE Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
/// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesGcePersistentDisk {
    /// fsType is filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(rename = "pdName")]
    pub pd_name: String,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// gitRepo represents a git repository at a particular revision.
/// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
/// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
/// into the Pod's container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesGitRepo {
    /// directory is the target directory name.
    /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    /// git repository.  Otherwise, if specified, the volume will contain the git repository in
    /// the subdirectory with the given name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    /// repository is the URL
    pub repository: String,
    /// revision is the commit hash for the specified revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub revision: Option<String>,
}

/// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
/// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesGlusterfs {
    /// endpoints is the endpoint name that details Glusterfs topology.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub endpoints: String,
    /// path is the Glusterfs volume path.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub path: String,
    /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// hostPath represents a pre-existing file or directory on the host
/// machine that is directly exposed to the container. This is generally
/// used for system agents or other privileged things that are allowed
/// to see the host machine. Most containers will NOT need this.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesHostPath {
    /// path of the directory on the host.
    /// If the path is a symlink, it will follow the link to the real path.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    pub path: String,
    /// type for HostPath Volume
    /// Defaults to ""
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
/// The volume is resolved at pod startup depending on which PullPolicy value is provided:
/// 
/// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
/// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
/// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
/// 
/// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
/// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
/// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
/// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
/// The volume will be mounted read-only (ro) and non-executable files (noexec).
/// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
/// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesImage {
    /// Policy for pulling OCI objects. Possible values are:
    /// Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// Required: Image or artifact reference to be used.
    /// Behaves in the same way as pod.spec.containers[*].image.
    /// Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reference: Option<String>,
}

/// iscsi represents an ISCSI Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesIscsi {
    /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthDiscovery")]
    pub chap_auth_discovery: Option<bool>,
    /// chapAuthSession defines whether support iSCSI Session CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthSession")]
    pub chap_auth_session: Option<bool>,
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#iscsi>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// initiatorName is the custom iSCSI Initiator Name.
    /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    /// <target portal>:<volume name> will be created for the connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initiatorName")]
    pub initiator_name: Option<String>,
    /// iqn is the target iSCSI Qualified Name.
    pub iqn: String,
    /// iscsiInterface is the interface Name that uses an iSCSI transport.
    /// Defaults to 'default' (tcp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iscsiInterface")]
    pub iscsi_interface: Option<String>,
    /// lun represents iSCSI Target Lun number.
    pub lun: i32,
    /// portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub portals: Option<Vec<String>>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdApplicationSetVolumesIscsiSecretRef>,
    /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(rename = "targetPortal")]
    pub target_portal: String,
}

/// secretRef is the CHAP Secret for iSCSI target and initiator authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesIscsiSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// nfs represents an NFS mount on the host that shares a pod's lifetime
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesNfs {
    /// path that is exported by the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub path: String,
    /// readOnly here will force the NFS export to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// server is the hostname or IP address of the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub server: String,
}

/// persistentVolumeClaimVolumeSource represents a reference to a
/// PersistentVolumeClaim in the same namespace.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesPersistentVolumeClaim {
    /// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(rename = "claimName")]
    pub claim_name: String,
    /// readOnly Will force the ReadOnly setting in VolumeMounts.
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
/// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesPhotonPersistentDisk {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// pdID is the ID that identifies Photon Controller persistent disk
    #[serde(rename = "pdID")]
    pub pd_id: String,
}

/// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
/// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
/// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
/// is on.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesPortworxVolume {
    /// fSType represents the filesystem type to mount
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID uniquely identifies a Portworx volume
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// projected items for all in one resources secrets, configmaps, and downward API
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjected {
    /// defaultMode are the mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// sources is the list of volume projections. Each entry in this list
    /// handles one source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ArgoCdApplicationSetVolumesProjectedSources>>,
}

/// Projection that may be projected along with other supported volume types.
/// Exactly one of these fields must be set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSources {
    /// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
    /// of ClusterTrustBundle objects in an auto-updating file.
    /// 
    /// Alpha, gated by the ClusterTrustBundleProjection feature gate.
    /// 
    /// ClusterTrustBundle objects can either be selected by name, or by the
    /// combination of signer name and a label selector.
    /// 
    /// Kubelet performs aggressive normalization of the PEM contents written
    /// into the pod filesystem.  Esoteric PEM features such as inter-block
    /// comments and block headers are stripped.  Certificates are deduplicated.
    /// The ordering of certificates within the file is arbitrary, and Kubelet
    /// may change the order over time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<ArgoCdApplicationSetVolumesProjectedSourcesClusterTrustBundle>,
    /// configMap information about the configMap data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdApplicationSetVolumesProjectedSourcesConfigMap>,
    /// downwardAPI information about the downwardAPI data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdApplicationSetVolumesProjectedSourcesDownwardApi>,
    /// secret information about the secret data to project
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdApplicationSetVolumesProjectedSourcesSecret>,
    /// serviceAccountToken is information about the serviceAccountToken data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<ArgoCdApplicationSetVolumesProjectedSourcesServiceAccountToken>,
}

/// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
/// of ClusterTrustBundle objects in an auto-updating file.
/// 
/// Alpha, gated by the ClusterTrustBundleProjection feature gate.
/// 
/// ClusterTrustBundle objects can either be selected by name, or by the
/// combination of signer name and a label selector.
/// 
/// Kubelet performs aggressive normalization of the PEM contents written
/// into the pod filesystem.  Esoteric PEM features such as inter-block
/// comments and block headers are stripped.  Certificates are deduplicated.
/// The ordering of certificates within the file is arbitrary, and Kubelet
/// may change the order over time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesClusterTrustBundle {
    /// Select all ClusterTrustBundles that match this label selector.  Only has
    /// effect if signerName is set.  Mutually-exclusive with name.  If unset,
    /// interpreted as "match nothing".  If set but empty, interpreted as "match
    /// everything".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ArgoCdApplicationSetVolumesProjectedSourcesClusterTrustBundleLabelSelector>,
    /// Select a single ClusterTrustBundle by object name.  Mutually-exclusive
    /// with signerName and labelSelector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// If true, don't block pod startup if the referenced ClusterTrustBundle(s)
    /// aren't available.  If using name, then the named ClusterTrustBundle is
    /// allowed not to exist.  If using signerName, then the combination of
    /// signerName and labelSelector is allowed to match zero
    /// ClusterTrustBundles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Relative path from the volume root to write the bundle.
    pub path: String,
    /// Select all ClusterTrustBundles that match this signer name.
    /// Mutually-exclusive with name.  The contents of all selected
    /// ClusterTrustBundles will be unified and deduplicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

/// Select all ClusterTrustBundles that match this label selector.  Only has
/// effect if signerName is set.  Mutually-exclusive with name.  If unset,
/// interpreted as "match nothing".  If set but empty, interpreted as "match
/// everything".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesClusterTrustBundleLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdApplicationSetVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// configMap information about the configMap data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesConfigMap {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdApplicationSetVolumesProjectedSourcesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// downwardAPI information about the downwardAPI data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesDownwardApi {
    /// Items is a list of DownwardAPIVolume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdApplicationSetVolumesProjectedSourcesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdApplicationSetVolumesProjectedSourcesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdApplicationSetVolumesProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// secret information about the secret data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesSecret {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdApplicationSetVolumesProjectedSourcesSecretItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional field specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// serviceAccountToken is information about the serviceAccountToken data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesProjectedSourcesServiceAccountToken {
    /// audience is the intended audience of the token. A recipient of a token
    /// must identify itself with an identifier specified in the audience of the
    /// token, and otherwise should reject the token. The audience defaults to the
    /// identifier of the apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// expirationSeconds is the requested duration of validity of the service
    /// account token. As the token approaches expiration, the kubelet volume
    /// plugin will proactively rotate the service account token. The kubelet will
    /// start trying to rotate the token if the token is older than 80 percent of
    /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
    /// and must be at least 10 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    /// path is the path relative to the mount point of the file to project the
    /// token into.
    pub path: String,
}

/// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
/// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesQuobyte {
    /// group to map volume access to
    /// Default is no group
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// readOnly here will force the Quobyte volume to be mounted with read-only permissions.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// registry represents a single or multiple Quobyte Registry services
    /// specified as a string as host:port pair (multiple entries are separated with commas)
    /// which acts as the central registry for volumes
    pub registry: String,
    /// tenant owning the given Quobyte volume in the Backend
    /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant: Option<String>,
    /// user to map volume access to
    /// Defaults to serivceaccount user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// volume is a string that references an already created Quobyte volume by name.
    pub volume: String,
}

/// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
/// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesRbd {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#rbd>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// image is the rados image name.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub image: String,
    /// keyring is the path to key ring for RBDUser.
    /// Default is /etc/ceph/keyring.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyring: Option<String>,
    /// monitors is a collection of Ceph monitors.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// pool is the rados pool name.
    /// Default is rbd.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is name of the authentication secret for RBDUser. If provided
    /// overrides keyring.
    /// Default is nil.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdApplicationSetVolumesRbdSecretRef>,
    /// user is the rados user name.
    /// Default is admin.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is name of the authentication secret for RBDUser. If provided
/// overrides keyring.
/// Default is nil.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesRbdSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
/// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesScaleIo {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// Default is "xfs".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// gateway is the host address of the ScaleIO API Gateway.
    pub gateway: String,
    /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protectionDomain")]
    pub protection_domain: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef references to the secret for ScaleIO user and other
    /// sensitive information. If this is not provided, Login operation will fail.
    #[serde(rename = "secretRef")]
    pub secret_ref: ArgoCdApplicationSetVolumesScaleIoSecretRef,
    /// sslEnabled Flag enable/disable SSL communication with Gateway, default false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslEnabled")]
    pub ssl_enabled: Option<bool>,
    /// storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    /// Default is ThinProvisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageMode")]
    pub storage_mode: Option<String>,
    /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    /// system is the name of the storage system as configured in ScaleIO.
    pub system: String,
    /// volumeName is the name of a volume already created in the ScaleIO system
    /// that is associated with this volume source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// secretRef references to the secret for ScaleIO user and other
/// sensitive information. If this is not provided, Login operation will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesScaleIoSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// secret represents a secret that should populate this volume.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesSecret {
    /// defaultMode is Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values
    /// for mode bits. Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items If unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdApplicationSetVolumesSecretItems>>,
    /// optional field specify whether the Secret or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// secretName is the name of the secret in the pod's namespace to use.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
/// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesStorageos {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef specifies the secret to use for obtaining the StorageOS API
    /// credentials.  If not specified, default values will be attempted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdApplicationSetVolumesStorageosSecretRef>,
    /// volumeName is the human-readable name of the StorageOS volume.  Volume
    /// names are only unique within a namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
    /// volumeNamespace specifies the scope of the volume within StorageOS.  If no
    /// namespace is specified then the Pod's namespace will be used.  This allows the
    /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    /// Set VolumeName to any name to override the default behaviour.
    /// Set to "default" if you are not using namespaces within StorageOS.
    /// Namespaces that do not pre-exist within StorageOS will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeNamespace")]
    pub volume_namespace: Option<String>,
}

/// secretRef specifies the secret to use for obtaining the StorageOS API
/// credentials.  If not specified, default values will be attempted.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesStorageosSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
/// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
/// are redirected to the csi.vsphere.vmware.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetVolumesVsphereVolume {
    /// fsType is filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyID")]
    pub storage_policy_id: Option<String>,
    /// storagePolicyName is the storage Policy Based Management (SPBM) profile name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyName")]
    pub storage_policy_name: Option<String>,
    /// volumePath is the path that identifies vSphere volume vmdk
    #[serde(rename = "volumePath")]
    pub volume_path: String,
}

/// WebhookServerSpec defines the options for the ApplicationSet Webhook Server component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetWebhookServer {
    /// Host is the hostname to use for Ingress/Route resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Ingress defines the desired state for an Ingress for the Application set webhook component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<ArgoCdApplicationSetWebhookServerIngress>,
    /// Route defines the desired state for an OpenShift Route for the Application set webhook component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<ArgoCdApplicationSetWebhookServerRoute>,
}

/// Ingress defines the desired state for an Ingress for the Application set webhook component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetWebhookServerIngress {
    /// Annotations is the map of annotations to apply to the Ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled will toggle the creation of the Ingress.
    pub enabled: bool,
    /// IngressClassName for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Path used for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// TLS configuration. Currently the Ingress only supports a single TLS
    /// port, 443. If multiple members of this list specify different hosts, they
    /// will be multiplexed on the same port according to the hostname specified
    /// through the SNI TLS extension, if the ingress controller fulfilling the
    /// ingress supports SNI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<Vec<ArgoCdApplicationSetWebhookServerIngressTls>>,
}

/// IngressTLS describes the transport layer security associated with an ingress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetWebhookServerIngressTls {
    /// hosts is a list of hosts included in the TLS certificate. The values in
    /// this list must match the name/s used in the tlsSecret. Defaults to the
    /// wildcard host setting for the loadbalancer controller fulfilling this
    /// Ingress, if left unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    /// secretName is the name of the secret used to terminate TLS traffic on
    /// port 443. Field is left optional to allow TLS routing based on SNI
    /// hostname alone. If the SNI host in a listener conflicts with the "Host"
    /// header field used by an IngressRule, the SNI host is used for termination
    /// and value of the "Host" header is used for routing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Route defines the desired state for an OpenShift Route for the Application set webhook component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetWebhookServerRoute {
    /// Annotations is the map of annotations to use for the Route resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled will toggle the creation of the OpenShift Route.
    pub enabled: bool,
    /// Labels is the map of labels to use for the Route resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Path the router watches for, to route traffic for to the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// TLS provides the ability to configure certificates and termination for the Route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ArgoCdApplicationSetWebhookServerRouteTls>,
    /// WildcardPolicy if any for the route. Currently only 'Subdomain' or 'None' is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wildcardPolicy")]
    pub wildcard_policy: Option<String>,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ArgoCdApplicationSetWebhookServerRouteTls {
    /// caCertificate provides the cert authority certificate contents
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificate")]
    pub ca_certificate: Option<String>,
    /// certificate provides certificate contents. This should be a single serving certificate, not a certificate
    /// chain. Do not include a CA certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// destinationCACertificate provides the contents of the ca certificate of the final destination.  When using reencrypt
    /// termination this file should be provided in order to have routers use it for health checks on the secure connection.
    /// If this field is not specified, the router may provide its own destination CA and perform hostname validation using
    /// the short service name (service.namespace.svc), which allows infrastructure generated certificates to automatically
    /// verify.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationCACertificate")]
    pub destination_ca_certificate: Option<String>,
    /// externalCertificate provides certificate contents as a secret reference.
    /// This should be a single serving certificate, not a certificate
    /// chain. Do not include a CA certificate. The secret referenced should
    /// be present in the same namespace as that of the Route.
    /// Forbidden when `certificate` is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalCertificate")]
    pub external_certificate: Option<ArgoCdApplicationSetWebhookServerRouteTlsExternalCertificate>,
    /// insecureEdgeTerminationPolicy indicates the desired behavior for insecure connections to a route. While
    /// each router may make its own decisions on which ports to expose, this is normally port 80.
    /// 
    /// * Allow - traffic is sent to the server on the insecure port (edge/reencrypt terminations only) (default).
    /// * None - no traffic is allowed on the insecure port.
    /// * Redirect - clients are redirected to the secure port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureEdgeTerminationPolicy")]
    pub insecure_edge_termination_policy: Option<ArgoCdApplicationSetWebhookServerRouteTlsInsecureEdgeTerminationPolicy>,
    /// key provides key file contents
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// termination indicates termination type.
    /// 
    /// * edge - TLS termination is done by the router and http is used to communicate with the backend (default)
    /// * passthrough - Traffic is sent straight to the destination without the router providing TLS termination
    /// * reencrypt - TLS termination is done by the router and https is used to communicate with the backend
    /// 
    /// Note: passthrough termination is incompatible with httpHeader actions
    pub termination: ArgoCdApplicationSetWebhookServerRouteTlsTermination,
}

/// externalCertificate provides certificate contents as a secret reference.
/// This should be a single serving certificate, not a certificate
/// chain. Do not include a CA certificate. The secret referenced should
/// be present in the same namespace as that of the Route.
/// Forbidden when `certificate` is set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdApplicationSetWebhookServerRouteTlsExternalCertificate {
    /// name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdApplicationSetWebhookServerRouteTlsInsecureEdgeTerminationPolicy {
    Allow,
    None,
    Redirect,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdApplicationSetWebhookServerRouteTlsTermination {
    #[serde(rename = "edge")]
    Edge,
    #[serde(rename = "reencrypt")]
    Reencrypt,
    #[serde(rename = "passthrough")]
    Passthrough,
}

/// ArgoCDAgent defines configurations for the ArgoCD Agent component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgent {
    /// Principal defines configurations for the Principal component of Argo CD Agent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub principal: Option<ArgoCdArgoCdAgentPrincipal>,
}

/// Principal defines configurations for the Principal component of Argo CD Agent.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipal {
    /// Enabled is the flag to enable the Principal component during Argo CD installation. (optional, default `false`)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// JWT defines the JWT options for the Principal component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<ArgoCdArgoCdAgentPrincipalJwt>,
    /// Namespace is the configuration for the Principal component namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<ArgoCdArgoCdAgentPrincipalNamespace>,
    /// Redis defines the Redis options for the Principal component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis: Option<ArgoCdArgoCdAgentPrincipalRedis>,
    /// ResourceProxy defines the Resource Proxy options for the Principal component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceProxy")]
    pub resource_proxy: Option<ArgoCdArgoCdAgentPrincipalResourceProxy>,
    /// Server defines the server options for the Principal component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server: Option<ArgoCdArgoCdAgentPrincipalServer>,
    /// TLS defines the TLS options for the Principal component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ArgoCdArgoCdAgentPrincipalTls>,
}

/// JWT defines the JWT options for the Principal component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalJwt {
    /// InsecureGenerate is the flag to allow the principal to generate its own private key for signing JWT tokens (insecure).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureGenerate")]
    pub insecure_generate: Option<bool>,
    /// SecretName is the name of the secret containing the JWT signing key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Namespace is the configuration for the Principal component namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalNamespace {
    /// AllowedNamespaces is a list of namespaces the principal shall watch and process Argo CD resources in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedNamespaces")]
    pub allowed_namespaces: Option<Vec<String>>,
    /// EnableNamespaceCreate is the flag to enable namespace creation for agents.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableNamespaceCreate")]
    pub enable_namespace_create: Option<bool>,
    /// NamespaceCreateLabels is the set of labels to apply to namespaces created for agents. Ex: "foo=bar,bar=baz"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceCreateLabels")]
    pub namespace_create_labels: Option<Vec<String>>,
    /// NamespaceCreatePattern is a regexp pattern to restrict the names of namespaces to be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceCreatePattern")]
    pub namespace_create_pattern: Option<String>,
}

/// Redis defines the Redis options for the Principal component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalRedis {
    /// CompressionType is the compression type to be used by Redis.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compressionType")]
    pub compression_type: Option<String>,
    /// ServerAddress is the address of the Redis server to be used by the Principal component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverAddress")]
    pub server_address: Option<String>,
}

/// ResourceProxy defines the Resource Proxy options for the Principal component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalResourceProxy {
    /// CASecretName is the name of the secret containing the CA certificate for the resource proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caSecretName")]
    pub ca_secret_name: Option<String>,
    /// SecretName is the name of the secret containing the TLS certificate and key for the resource proxy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Server defines the server options for the Principal component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalServer {
    /// Auth is the authentication method for the Principal component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth: Option<String>,
    /// EnableWebSocket is the flag to enable the WebSocket on gRPC to stream events to the Agent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableWebSocket")]
    pub enable_web_socket: Option<bool>,
    /// Env lets you specify environment for principal pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdArgoCdAgentPrincipalServerEnv>>,
    /// Image is the name of Argo CD Agent image
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// KeepAliveMinInterval is the minimum interval between keep-alive messages sent by the Agent to the Principal.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepAliveMinInterval")]
    pub keep_alive_min_interval: Option<String>,
    /// LogFormat refers to the log format used by the Principal component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    pub log_format: Option<String>,
    /// LogLevel refers to the log level used by the Principal component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalServerEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdArgoCdAgentPrincipalServerEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalServerEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdArgoCdAgentPrincipalServerEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdArgoCdAgentPrincipalServerEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdArgoCdAgentPrincipalServerEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdArgoCdAgentPrincipalServerEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalServerEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalServerEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalServerEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalServerEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// TLS defines the TLS options for the Principal component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdArgoCdAgentPrincipalTls {
    /// InsecureGenerate is the flag to allow the principal to generate its own set of TLS cert and key on startup when none are configured
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureGenerate")]
    pub insecure_generate: Option<bool>,
    /// RootCASecretName is the name of the secret containing the root CA TLS certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootCASecretName")]
    pub root_ca_secret_name: Option<String>,
    /// SecretName is The name of the secret containing the TLS certificate and key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Banner defines an additional banner to be displayed in Argo CD UI
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdBanner {
    /// Content defines the banner message content to display
    pub content: String,
    /// Permanent defines if the banner should be displayed permanently or only for a certain period of time
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permanent: Option<bool>,
    /// Position defines the position of the banner in the UI
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<String>,
    /// URL defines an optional URL to be used as banner message link
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Controller defines the Application Controller options for ArgoCD.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdController {
    /// Custom annotations to pods deployed by the operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// AppSync is used to control the sync frequency, by default the ArgoCD
    /// controller polls Git every 3m.
    /// 
    /// Set this to a duration, e.g. 10m or 600s to control the synchronisation
    /// frequency.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appSync")]
    pub app_sync: Option<String>,
    /// Enabled is the flag to enable the Application Controller during ArgoCD installation. (optional, default `true`)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Env lets you specify environment for application controller pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdControllerEnv>>,
    /// Extra Command arguments allows users to pass command line arguments to controller workload. They get added to default command line arguments provided
    /// by the operator.
    /// Please note that the command line arguments provided as part of ExtraCommandArgs will not overwrite the default command line arguments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraCommandArgs")]
    pub extra_command_args: Option<Vec<String>>,
    /// InitContainers defines the list of initialization containers for the Application Controller component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<ArgoCdControllerInitContainers>>,
    /// Custom labels to pods deployed by the operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// LogFormat refers to the log format used by the Application Controller component. Defaults to ArgoCDDefaultLogFormat if not configured. Valid options are text or json.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    pub log_format: Option<String>,
    /// LogLevel refers to the log level used by the Application Controller component. Defaults to ArgoCDDefaultLogLevel if not configured. Valid options are debug, info, error, and warn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// ParallelismLimit defines the limit for parallel kubectl operations
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parallelismLimit")]
    pub parallelism_limit: Option<i32>,
    /// Processors contains the options for the Application Controller processors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub processors: Option<ArgoCdControllerProcessors>,
    /// Resources defines the Compute Resources required by the container for the Application Controller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdControllerResources>,
    /// RespectRBAC restricts controller from discovering/syncing specific resources, Defaults is empty if not configured. Valid options are strict and normal.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "respectRBAC")]
    pub respect_rbac: Option<String>,
    /// Sharding contains the options for the Application Controller sharding configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sharding: Option<ArgoCdControllerSharding>,
    /// SidecarContainers defines the list of sidecar containers for the controller deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sidecarContainers")]
    pub sidecar_containers: Option<Vec<ArgoCdControllerSidecarContainers>>,
    /// VolumeMounts adds volumeMounts to the Argo CD Controller container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdControllerVolumeMounts>>,
    /// Volumes adds volumes to the Argo CD Controller container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<ArgoCdControllerVolumes>>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdControllerEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdControllerEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdControllerEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdControllerEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdControllerEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainers {
    /// Arguments to the entrypoint.
    /// The container image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The container image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdControllerInitContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ArgoCdControllerInitContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ArgoCdControllerInitContainersLifecycle>,
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ArgoCdControllerInitContainersLivenessProbe>,
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    pub name: String,
    /// List of ports to expose from the container. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Modifying this array with strategic merge patch may corrupt the data.
    /// For more information See <https://github.com/kubernetes/kubernetes/issues/108255.>
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ArgoCdControllerInitContainersPorts>>,
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ArgoCdControllerInitContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<ArgoCdControllerInitContainersResizePolicy>>,
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdControllerInitContainersResources>,
    /// RestartPolicy defines the restart behavior of individual containers in a pod.
    /// This field may only be set for init containers, and the only allowed value is "Always".
    /// For non-init containers or when this field is not specified,
    /// the restart behavior is defined by the Pod's restart policy and the container type.
    /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
    /// this init container will be continually restarted on
    /// exit until all regular containers have terminated. Once all regular
    /// containers have completed, all init containers with restartPolicy "Always"
    /// will be shut down. This lifecycle differs from normal init containers and
    /// is often referred to as a "sidecar" container. Although this init
    /// container still starts in the init container sequence, it does not wait
    /// for the container to complete before proceeding to the next init
    /// container. Instead, the next init container starts immediately after this
    /// init container is started, or after any startupProbe has successfully
    /// completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ArgoCdControllerInitContainersSecurityContext>,
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ArgoCdControllerInitContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ArgoCdControllerInitContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdControllerInitContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdControllerInitContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdControllerInitContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdControllerInitContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdControllerInitContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdControllerInitContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps or Secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ArgoCdControllerInitContainersEnvFromConfigMapRef>,
    /// Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdControllerInitContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersEnvFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Actions that the management system should take in response to container lifecycle events.
/// Cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ArgoCdControllerInitContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ArgoCdControllerInitContainersLifecyclePreStop>,
    /// StopSignal defines which signal will be sent to a container when it is being stopped.
    /// If not specified, the default is defined by the container runtime in use.
    /// StopSignal can only be set for Pods with a non-empty .spec.os.name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stopSignal")]
    pub stop_signal: Option<String>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePostStart {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerInitContainersLifecyclePostStartExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerInitContainersLifecyclePostStartHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdControllerInitContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerInitContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerInitContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePreStop {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerInitContainersLifecyclePreStopExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerInitContainersLifecyclePreStopHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdControllerInitContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerInitContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerInitContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Periodic probe of container liveness.
/// Container will be restarted if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLivenessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerInitContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdControllerInitContainersLivenessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerInitContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerInitContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerInitContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Periodic probe of container service readiness.
/// Container will be removed from service endpoints if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersReadinessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerInitContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdControllerInitContainersReadinessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerInitContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerInitContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerInitContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Compute Resources required by this container.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdControllerInitContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// SecurityContext defines the security options the container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
/// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// appArmorProfile is the AppArmor options to use by this container. If set, this profile
    /// overrides the pod's appArmorProfile.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appArmorProfile")]
    pub app_armor_profile: Option<ArgoCdControllerInitContainersSecurityContextAppArmorProfile>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ArgoCdControllerInitContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default value is Default which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ArgoCdControllerInitContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ArgoCdControllerInitContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ArgoCdControllerInitContainersSecurityContextWindowsOptions>,
}

/// appArmorProfile is the AppArmor options to use by this container. If set, this profile
/// overrides the pod's appArmorProfile.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersSecurityContextAppArmorProfile {
    /// localhostProfile indicates a profile loaded on the node that should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must match the loaded name of the profile.
    /// Must be set if and only if type is "Localhost".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of AppArmor profile will be applied.
    /// Valid options are:
    ///   Localhost - a profile pre-loaded on the node.
    ///   RuntimeDefault - the container runtime's default profile.
    ///   Unconfined - no AppArmor enforcement.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// StartupProbe indicates that the Pod has successfully initialized.
/// If specified, no other probes are executed until this completes successfully.
/// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
/// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
/// when it might take a long time to load data or warm a cache, than during steady-state operation.
/// This cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersStartupProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerInitContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdControllerInitContainersStartupProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerInitContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerInitContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerInitContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerInitContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Processors contains the options for the Application Controller processors.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerProcessors {
    /// Operation is the number of application operation processors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation: Option<i32>,
    /// Status is the number of application status processors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<i32>,
}

/// Resources defines the Compute Resources required by the container for the Application Controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdControllerResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Sharding contains the options for the Application Controller sharding configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSharding {
    /// ClustersPerShard defines the maximum number of clusters managed by each argocd shard
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clustersPerShard")]
    pub clusters_per_shard: Option<i32>,
    /// DynamicScalingEnabled defines whether dynamic scaling should be enabled for Application Controller component
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicScalingEnabled")]
    pub dynamic_scaling_enabled: Option<bool>,
    /// Enabled defines whether sharding should be enabled on the Application Controller component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// MaxShards defines the maximum number of shards at any given point
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxShards")]
    pub max_shards: Option<i32>,
    /// MinShards defines the minimum number of shards at any given point
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minShards")]
    pub min_shards: Option<i32>,
    /// Replicas defines the number of replicas to run in the Application controller shard.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
}

/// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainers {
    /// Arguments to the entrypoint.
    /// The container image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The container image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdControllerSidecarContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ArgoCdControllerSidecarContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ArgoCdControllerSidecarContainersLifecycle>,
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ArgoCdControllerSidecarContainersLivenessProbe>,
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    pub name: String,
    /// List of ports to expose from the container. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Modifying this array with strategic merge patch may corrupt the data.
    /// For more information See <https://github.com/kubernetes/kubernetes/issues/108255.>
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ArgoCdControllerSidecarContainersPorts>>,
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ArgoCdControllerSidecarContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<ArgoCdControllerSidecarContainersResizePolicy>>,
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdControllerSidecarContainersResources>,
    /// RestartPolicy defines the restart behavior of individual containers in a pod.
    /// This field may only be set for init containers, and the only allowed value is "Always".
    /// For non-init containers or when this field is not specified,
    /// the restart behavior is defined by the Pod's restart policy and the container type.
    /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
    /// this init container will be continually restarted on
    /// exit until all regular containers have terminated. Once all regular
    /// containers have completed, all init containers with restartPolicy "Always"
    /// will be shut down. This lifecycle differs from normal init containers and
    /// is often referred to as a "sidecar" container. Although this init
    /// container still starts in the init container sequence, it does not wait
    /// for the container to complete before proceeding to the next init
    /// container. Instead, the next init container starts immediately after this
    /// init container is started, or after any startupProbe has successfully
    /// completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ArgoCdControllerSidecarContainersSecurityContext>,
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ArgoCdControllerSidecarContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ArgoCdControllerSidecarContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdControllerSidecarContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdControllerSidecarContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdControllerSidecarContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdControllerSidecarContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdControllerSidecarContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdControllerSidecarContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps or Secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ArgoCdControllerSidecarContainersEnvFromConfigMapRef>,
    /// Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdControllerSidecarContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersEnvFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Actions that the management system should take in response to container lifecycle events.
/// Cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ArgoCdControllerSidecarContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ArgoCdControllerSidecarContainersLifecyclePreStop>,
    /// StopSignal defines which signal will be sent to a container when it is being stopped.
    /// If not specified, the default is defined by the container runtime in use.
    /// StopSignal can only be set for Pods with a non-empty .spec.os.name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stopSignal")]
    pub stop_signal: Option<String>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePostStart {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerSidecarContainersLifecyclePostStartExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerSidecarContainersLifecyclePostStartHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdControllerSidecarContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerSidecarContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerSidecarContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePreStop {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerSidecarContainersLifecyclePreStopExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerSidecarContainersLifecyclePreStopHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdControllerSidecarContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerSidecarContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerSidecarContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Periodic probe of container liveness.
/// Container will be restarted if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLivenessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerSidecarContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdControllerSidecarContainersLivenessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerSidecarContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerSidecarContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerSidecarContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Periodic probe of container service readiness.
/// Container will be removed from service endpoints if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersReadinessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerSidecarContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdControllerSidecarContainersReadinessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerSidecarContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerSidecarContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerSidecarContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Compute Resources required by this container.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdControllerSidecarContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// SecurityContext defines the security options the container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
/// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// appArmorProfile is the AppArmor options to use by this container. If set, this profile
    /// overrides the pod's appArmorProfile.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appArmorProfile")]
    pub app_armor_profile: Option<ArgoCdControllerSidecarContainersSecurityContextAppArmorProfile>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ArgoCdControllerSidecarContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default value is Default which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ArgoCdControllerSidecarContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ArgoCdControllerSidecarContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ArgoCdControllerSidecarContainersSecurityContextWindowsOptions>,
}

/// appArmorProfile is the AppArmor options to use by this container. If set, this profile
/// overrides the pod's appArmorProfile.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersSecurityContextAppArmorProfile {
    /// localhostProfile indicates a profile loaded on the node that should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must match the loaded name of the profile.
    /// Must be set if and only if type is "Localhost".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of AppArmor profile will be applied.
    /// Valid options are:
    ///   Localhost - a profile pre-loaded on the node.
    ///   RuntimeDefault - the container runtime's default profile.
    ///   Unconfined - no AppArmor enforcement.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// StartupProbe indicates that the Pod has successfully initialized.
/// If specified, no other probes are executed until this completes successfully.
/// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
/// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
/// when it might take a long time to load data or warm a cache, than during steady-state operation.
/// This cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersStartupProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdControllerSidecarContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdControllerSidecarContainersStartupProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdControllerSidecarContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdControllerSidecarContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdControllerSidecarContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerSidecarContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumes {
    /// awsElasticBlockStore represents an AWS Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
    /// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsElasticBlockStore")]
    pub aws_elastic_block_store: Option<ArgoCdControllerVolumesAwsElasticBlockStore>,
    /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
    /// are redirected to the disk.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureDisk")]
    pub azure_disk: Option<ArgoCdControllerVolumesAzureDisk>,
    /// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
    /// are redirected to the file.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureFile")]
    pub azure_file: Option<ArgoCdControllerVolumesAzureFile>,
    /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
    /// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephfs: Option<ArgoCdControllerVolumesCephfs>,
    /// cinder represents a cinder volume attached and mounted on kubelets host machine.
    /// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
    /// are redirected to the cinder.csi.openstack.org CSI driver.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cinder: Option<ArgoCdControllerVolumesCinder>,
    /// configMap represents a configMap that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdControllerVolumesConfigMap>,
    /// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<ArgoCdControllerVolumesCsi>,
    /// downwardAPI represents downward API about the pod that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdControllerVolumesDownwardApi>,
    /// emptyDir represents a temporary directory that shares a pod's lifetime.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<ArgoCdControllerVolumesEmptyDir>,
    /// ephemeral represents a volume that is handled by a cluster storage driver.
    /// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    /// and deleted when the pod is removed.
    /// 
    /// Use this if:
    /// a) the volume is only needed while the pod runs,
    /// b) features of normal volumes like restoring from snapshot or capacity
    ///    tracking are needed,
    /// c) the storage driver is specified through a storage class, and
    /// d) the storage driver supports dynamic volume provisioning through
    ///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
    ///    information on the connection between this volume type
    ///    and PersistentVolumeClaim).
    /// 
    /// Use PersistentVolumeClaim or one of the vendor-specific
    /// APIs for volumes that persist for longer than the lifecycle
    /// of an individual pod.
    /// 
    /// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    /// be used that way - see the documentation of the driver for
    /// more information.
    /// 
    /// A pod can use both types of ephemeral volumes and
    /// persistent volumes at the same time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<ArgoCdControllerVolumesEphemeral>,
    /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fc: Option<ArgoCdControllerVolumesFc>,
    /// flexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flexVolume")]
    pub flex_volume: Option<ArgoCdControllerVolumesFlexVolume>,
    /// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
    /// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flocker: Option<ArgoCdControllerVolumesFlocker>,
    /// gcePersistentDisk represents a GCE Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
    /// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDisk")]
    pub gce_persistent_disk: Option<ArgoCdControllerVolumesGcePersistentDisk>,
    /// gitRepo represents a git repository at a particular revision.
    /// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    /// into the Pod's container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitRepo")]
    pub git_repo: Option<ArgoCdControllerVolumesGitRepo>,
    /// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    /// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glusterfs: Option<ArgoCdControllerVolumesGlusterfs>,
    /// hostPath represents a pre-existing file or directory on the host
    /// machine that is directly exposed to the container. This is generally
    /// used for system agents or other privileged things that are allowed
    /// to see the host machine. Most containers will NOT need this.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<ArgoCdControllerVolumesHostPath>,
    /// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
    /// The volume is resolved at pod startup depending on which PullPolicy value is provided:
    /// 
    /// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// 
    /// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
    /// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
    /// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
    /// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
    /// The volume will be mounted read-only (ro) and non-executable files (noexec).
    /// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
    /// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<ArgoCdControllerVolumesImage>,
    /// iscsi represents an ISCSI Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iscsi: Option<ArgoCdControllerVolumesIscsi>,
    /// name of the volume.
    /// Must be a DNS_LABEL and unique within the pod.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    pub name: String,
    /// nfs represents an NFS mount on the host that shares a pod's lifetime
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nfs: Option<ArgoCdControllerVolumesNfs>,
    /// persistentVolumeClaimVolumeSource represents a reference to a
    /// PersistentVolumeClaim in the same namespace.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<ArgoCdControllerVolumesPersistentVolumeClaim>,
    /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
    /// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "photonPersistentDisk")]
    pub photon_persistent_disk: Option<ArgoCdControllerVolumesPhotonPersistentDisk>,
    /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
    /// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
    /// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
    /// is on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portworxVolume")]
    pub portworx_volume: Option<ArgoCdControllerVolumesPortworxVolume>,
    /// projected items for all in one resources secrets, configmaps, and downward API
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<ArgoCdControllerVolumesProjected>,
    /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
    /// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quobyte: Option<ArgoCdControllerVolumesQuobyte>,
    /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
    /// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbd: Option<ArgoCdControllerVolumesRbd>,
    /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    /// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scaleIO")]
    pub scale_io: Option<ArgoCdControllerVolumesScaleIo>,
    /// secret represents a secret that should populate this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdControllerVolumesSecret>,
    /// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    /// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storageos: Option<ArgoCdControllerVolumesStorageos>,
    /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
    /// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
    /// are redirected to the csi.vsphere.vmware.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vsphereVolume")]
    pub vsphere_volume: Option<ArgoCdControllerVolumesVsphereVolume>,
}

/// awsElasticBlockStore represents an AWS Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
/// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesAwsElasticBlockStore {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// readOnly value true will force the readOnly setting in VolumeMounts.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
/// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
/// are redirected to the disk.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesAzureDisk {
    /// cachingMode is the Host Caching mode: None, Read Only, Read Write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachingMode")]
    pub caching_mode: Option<String>,
    /// diskName is the Name of the data disk in the blob storage
    #[serde(rename = "diskName")]
    pub disk_name: String,
    /// diskURI is the URI of data disk in the blob storage
    #[serde(rename = "diskURI")]
    pub disk_uri: String,
    /// fsType is Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
/// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
/// are redirected to the file.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesAzureFile {
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretName is the  name of secret that contains Azure Storage Account Name and Key
    #[serde(rename = "secretName")]
    pub secret_name: String,
    /// shareName is the azure share Name
    #[serde(rename = "shareName")]
    pub share_name: String,
}

/// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
/// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesCephfs {
    /// monitors is Required: Monitors is a collection of Ceph monitors
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretFile")]
    pub secret_file: Option<String>,
    /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdControllerVolumesCephfsSecretRef>,
    /// user is optional: User is the rados user name, default is admin
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
/// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesCephfsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// cinder represents a cinder volume attached and mounted on kubelets host machine.
/// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
/// are redirected to the cinder.csi.openstack.org CSI driver.
/// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesCinder {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is optional: points to a secret object containing parameters used to connect
    /// to OpenStack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdControllerVolumesCinderSecretRef>,
    /// volumeID used to identify the volume in cinder.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// secretRef is optional: points to a secret object containing parameters used to connect
/// to OpenStack.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesCinderSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// configMap represents a configMap that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesConfigMap {
    /// defaultMode is optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdControllerVolumesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesCsi {
    /// driver is the name of the CSI driver that handles this volume.
    /// Consult with your admin for the correct name as registered in the cluster.
    pub driver: String,
    /// fsType to mount. Ex. "ext4", "xfs", "ntfs".
    /// If not provided, the empty value is passed to the associated CSI driver
    /// which will determine the default filesystem to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// nodePublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// NodePublishVolume and NodeUnpublishVolume calls.
    /// This field is optional, and  may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secret references are passed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePublishSecretRef")]
    pub node_publish_secret_ref: Option<ArgoCdControllerVolumesCsiNodePublishSecretRef>,
    /// readOnly specifies a read-only configuration for the volume.
    /// Defaults to false (read/write).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeAttributes stores driver-specific properties that are passed to the CSI
    /// driver. Consult your driver's documentation for supported values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributes")]
    pub volume_attributes: Option<BTreeMap<String, String>>,
}

/// nodePublishSecretRef is a reference to the secret object containing
/// sensitive information to pass to the CSI driver to complete the CSI
/// NodePublishVolume and NodeUnpublishVolume calls.
/// This field is optional, and  may be empty if no secret is required. If the
/// secret object contains more than one secret, all secret references are passed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesCsiNodePublishSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// downwardAPI represents downward API about the pod that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesDownwardApi {
    /// Optional: mode bits to use on created files by default. Must be a
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// Items is a list of downward API volume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdControllerVolumesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdControllerVolumesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdControllerVolumesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// emptyDir represents a temporary directory that shares a pod's lifetime.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEmptyDir {
    /// medium represents what type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

/// ephemeral represents a volume that is handled by a cluster storage driver.
/// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
/// and deleted when the pod is removed.
/// 
/// Use this if:
/// a) the volume is only needed while the pod runs,
/// b) features of normal volumes like restoring from snapshot or capacity
///    tracking are needed,
/// c) the storage driver is specified through a storage class, and
/// d) the storage driver supports dynamic volume provisioning through
///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
///    information on the connection between this volume type
///    and PersistentVolumeClaim).
/// 
/// Use PersistentVolumeClaim or one of the vendor-specific
/// APIs for volumes that persist for longer than the lifecycle
/// of an individual pod.
/// 
/// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
/// be used that way - see the documentation of the driver for
/// more information.
/// 
/// A pod can use both types of ephemeral volumes and
/// persistent volumes at the same time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEphemeral {
    /// Will be used to create a stand-alone PVC to provision the volume.
    /// The pod in which this EphemeralVolumeSource is embedded will be the
    /// owner of the PVC, i.e. the PVC will be deleted together with the
    /// pod.  The name of the PVC will be `<pod name>-<volume name>` where
    /// `<volume name>` is the name from the `PodSpec.Volumes` array
    /// entry. Pod validation will reject the pod if the concatenated name
    /// is not valid for a PVC (for example, too long).
    /// 
    /// An existing PVC with that name that is not owned by the pod
    /// will *not* be used for the pod to avoid using an unrelated
    /// volume by mistake. Starting the pod is then blocked until
    /// the unrelated PVC is removed. If such a pre-created PVC is
    /// meant to be used by the pod, the PVC has to updated with an
    /// owner reference to the pod once the pod exists. Normally
    /// this should not be necessary, but it may be useful when
    /// manually reconstructing a broken cluster.
    /// 
    /// This field is read-only and no changes will be made by Kubernetes
    /// to the PVC after it has been created.
    /// 
    /// Required, must not be nil.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<ArgoCdControllerVolumesEphemeralVolumeClaimTemplate>,
}

/// Will be used to create a stand-alone PVC to provision the volume.
/// The pod in which this EphemeralVolumeSource is embedded will be the
/// owner of the PVC, i.e. the PVC will be deleted together with the
/// pod.  The name of the PVC will be `<pod name>-<volume name>` where
/// `<volume name>` is the name from the `PodSpec.Volumes` array
/// entry. Pod validation will reject the pod if the concatenated name
/// is not valid for a PVC (for example, too long).
/// 
/// An existing PVC with that name that is not owned by the pod
/// will *not* be used for the pod to avoid using an unrelated
/// volume by mistake. Starting the pod is then blocked until
/// the unrelated PVC is removed. If such a pre-created PVC is
/// meant to be used by the pod, the PVC has to updated with an
/// owner reference to the pod once the pod exists. Normally
/// this should not be necessary, but it may be useful when
/// manually reconstructing a broken cluster.
/// 
/// This field is read-only and no changes will be made by Kubernetes
/// to the PVC after it has been created.
/// 
/// Required, must not be nil.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEphemeralVolumeClaimTemplate {
    /// May contain labels and annotations that will be copied into the PVC
    /// when creating it. No other fields are allowed and will be rejected during
    /// validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ArgoCdControllerVolumesEphemeralVolumeClaimTemplateMetadata>,
    /// The specification for the PersistentVolumeClaim. The entire content is
    /// copied unchanged into the PVC that gets created from this
    /// template. The same fields as in a PersistentVolumeClaim
    /// are also valid here.
    pub spec: ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpec,
}

/// May contain labels and annotations that will be copied into the PVC
/// when creating it. No other fields are allowed and will be rejected during
/// validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEphemeralVolumeClaimTemplateMetadata {
}

/// The specification for the PersistentVolumeClaim. The entire content is
/// copied unchanged into the PVC that gets created from this
/// template. The same fields as in a PersistentVolumeClaim
/// are also valid here.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    /// (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesFc {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// lun is Optional: FC target lun number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lun: Option<i32>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// targetWWNs is Optional: FC target worldwide names (WWNs)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetWWNs")]
    pub target_ww_ns: Option<Vec<String>>,
    /// wwids Optional: FC volume world wide identifiers (wwids)
    /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wwids: Option<Vec<String>>,
}

/// flexVolume represents a generic volume resource that is
/// provisioned/attached using an exec based plugin.
/// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesFlexVolume {
    /// driver is the name of the driver to use for this volume.
    pub driver: String,
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// options is Optional: this field holds extra command options if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<BTreeMap<String, String>>,
    /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is Optional: secretRef is reference to the secret object containing
    /// sensitive information to pass to the plugin scripts. This may be
    /// empty if no secret object is specified. If the secret object
    /// contains more than one secret, all secrets are passed to the plugin
    /// scripts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdControllerVolumesFlexVolumeSecretRef>,
}

/// secretRef is Optional: secretRef is reference to the secret object containing
/// sensitive information to pass to the plugin scripts. This may be
/// empty if no secret object is specified. If the secret object
/// contains more than one secret, all secrets are passed to the plugin
/// scripts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesFlexVolumeSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
/// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesFlocker {
    /// datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
    /// should be considered as deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetName")]
    pub dataset_name: Option<String>,
    /// datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetUUID")]
    pub dataset_uuid: Option<String>,
}

/// gcePersistentDisk represents a GCE Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
/// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesGcePersistentDisk {
    /// fsType is filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(rename = "pdName")]
    pub pd_name: String,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// gitRepo represents a git repository at a particular revision.
/// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
/// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
/// into the Pod's container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesGitRepo {
    /// directory is the target directory name.
    /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    /// git repository.  Otherwise, if specified, the volume will contain the git repository in
    /// the subdirectory with the given name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    /// repository is the URL
    pub repository: String,
    /// revision is the commit hash for the specified revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub revision: Option<String>,
}

/// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
/// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesGlusterfs {
    /// endpoints is the endpoint name that details Glusterfs topology.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub endpoints: String,
    /// path is the Glusterfs volume path.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub path: String,
    /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// hostPath represents a pre-existing file or directory on the host
/// machine that is directly exposed to the container. This is generally
/// used for system agents or other privileged things that are allowed
/// to see the host machine. Most containers will NOT need this.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesHostPath {
    /// path of the directory on the host.
    /// If the path is a symlink, it will follow the link to the real path.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    pub path: String,
    /// type for HostPath Volume
    /// Defaults to ""
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
/// The volume is resolved at pod startup depending on which PullPolicy value is provided:
/// 
/// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
/// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
/// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
/// 
/// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
/// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
/// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
/// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
/// The volume will be mounted read-only (ro) and non-executable files (noexec).
/// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
/// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesImage {
    /// Policy for pulling OCI objects. Possible values are:
    /// Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// Required: Image or artifact reference to be used.
    /// Behaves in the same way as pod.spec.containers[*].image.
    /// Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reference: Option<String>,
}

/// iscsi represents an ISCSI Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesIscsi {
    /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthDiscovery")]
    pub chap_auth_discovery: Option<bool>,
    /// chapAuthSession defines whether support iSCSI Session CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthSession")]
    pub chap_auth_session: Option<bool>,
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#iscsi>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// initiatorName is the custom iSCSI Initiator Name.
    /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    /// <target portal>:<volume name> will be created for the connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initiatorName")]
    pub initiator_name: Option<String>,
    /// iqn is the target iSCSI Qualified Name.
    pub iqn: String,
    /// iscsiInterface is the interface Name that uses an iSCSI transport.
    /// Defaults to 'default' (tcp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iscsiInterface")]
    pub iscsi_interface: Option<String>,
    /// lun represents iSCSI Target Lun number.
    pub lun: i32,
    /// portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub portals: Option<Vec<String>>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdControllerVolumesIscsiSecretRef>,
    /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(rename = "targetPortal")]
    pub target_portal: String,
}

/// secretRef is the CHAP Secret for iSCSI target and initiator authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesIscsiSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// nfs represents an NFS mount on the host that shares a pod's lifetime
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesNfs {
    /// path that is exported by the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub path: String,
    /// readOnly here will force the NFS export to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// server is the hostname or IP address of the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub server: String,
}

/// persistentVolumeClaimVolumeSource represents a reference to a
/// PersistentVolumeClaim in the same namespace.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesPersistentVolumeClaim {
    /// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(rename = "claimName")]
    pub claim_name: String,
    /// readOnly Will force the ReadOnly setting in VolumeMounts.
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
/// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesPhotonPersistentDisk {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// pdID is the ID that identifies Photon Controller persistent disk
    #[serde(rename = "pdID")]
    pub pd_id: String,
}

/// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
/// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
/// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
/// is on.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesPortworxVolume {
    /// fSType represents the filesystem type to mount
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID uniquely identifies a Portworx volume
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// projected items for all in one resources secrets, configmaps, and downward API
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjected {
    /// defaultMode are the mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// sources is the list of volume projections. Each entry in this list
    /// handles one source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ArgoCdControllerVolumesProjectedSources>>,
}

/// Projection that may be projected along with other supported volume types.
/// Exactly one of these fields must be set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSources {
    /// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
    /// of ClusterTrustBundle objects in an auto-updating file.
    /// 
    /// Alpha, gated by the ClusterTrustBundleProjection feature gate.
    /// 
    /// ClusterTrustBundle objects can either be selected by name, or by the
    /// combination of signer name and a label selector.
    /// 
    /// Kubelet performs aggressive normalization of the PEM contents written
    /// into the pod filesystem.  Esoteric PEM features such as inter-block
    /// comments and block headers are stripped.  Certificates are deduplicated.
    /// The ordering of certificates within the file is arbitrary, and Kubelet
    /// may change the order over time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<ArgoCdControllerVolumesProjectedSourcesClusterTrustBundle>,
    /// configMap information about the configMap data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdControllerVolumesProjectedSourcesConfigMap>,
    /// downwardAPI information about the downwardAPI data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdControllerVolumesProjectedSourcesDownwardApi>,
    /// secret information about the secret data to project
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdControllerVolumesProjectedSourcesSecret>,
    /// serviceAccountToken is information about the serviceAccountToken data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<ArgoCdControllerVolumesProjectedSourcesServiceAccountToken>,
}

/// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
/// of ClusterTrustBundle objects in an auto-updating file.
/// 
/// Alpha, gated by the ClusterTrustBundleProjection feature gate.
/// 
/// ClusterTrustBundle objects can either be selected by name, or by the
/// combination of signer name and a label selector.
/// 
/// Kubelet performs aggressive normalization of the PEM contents written
/// into the pod filesystem.  Esoteric PEM features such as inter-block
/// comments and block headers are stripped.  Certificates are deduplicated.
/// The ordering of certificates within the file is arbitrary, and Kubelet
/// may change the order over time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesClusterTrustBundle {
    /// Select all ClusterTrustBundles that match this label selector.  Only has
    /// effect if signerName is set.  Mutually-exclusive with name.  If unset,
    /// interpreted as "match nothing".  If set but empty, interpreted as "match
    /// everything".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ArgoCdControllerVolumesProjectedSourcesClusterTrustBundleLabelSelector>,
    /// Select a single ClusterTrustBundle by object name.  Mutually-exclusive
    /// with signerName and labelSelector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// If true, don't block pod startup if the referenced ClusterTrustBundle(s)
    /// aren't available.  If using name, then the named ClusterTrustBundle is
    /// allowed not to exist.  If using signerName, then the combination of
    /// signerName and labelSelector is allowed to match zero
    /// ClusterTrustBundles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Relative path from the volume root to write the bundle.
    pub path: String,
    /// Select all ClusterTrustBundles that match this signer name.
    /// Mutually-exclusive with name.  The contents of all selected
    /// ClusterTrustBundles will be unified and deduplicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

/// Select all ClusterTrustBundles that match this label selector.  Only has
/// effect if signerName is set.  Mutually-exclusive with name.  If unset,
/// interpreted as "match nothing".  If set but empty, interpreted as "match
/// everything".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesClusterTrustBundleLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdControllerVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// configMap information about the configMap data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesConfigMap {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdControllerVolumesProjectedSourcesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// downwardAPI information about the downwardAPI data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesDownwardApi {
    /// Items is a list of DownwardAPIVolume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdControllerVolumesProjectedSourcesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdControllerVolumesProjectedSourcesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdControllerVolumesProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// secret information about the secret data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesSecret {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdControllerVolumesProjectedSourcesSecretItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional field specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// serviceAccountToken is information about the serviceAccountToken data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesProjectedSourcesServiceAccountToken {
    /// audience is the intended audience of the token. A recipient of a token
    /// must identify itself with an identifier specified in the audience of the
    /// token, and otherwise should reject the token. The audience defaults to the
    /// identifier of the apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// expirationSeconds is the requested duration of validity of the service
    /// account token. As the token approaches expiration, the kubelet volume
    /// plugin will proactively rotate the service account token. The kubelet will
    /// start trying to rotate the token if the token is older than 80 percent of
    /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
    /// and must be at least 10 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    /// path is the path relative to the mount point of the file to project the
    /// token into.
    pub path: String,
}

/// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
/// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesQuobyte {
    /// group to map volume access to
    /// Default is no group
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// readOnly here will force the Quobyte volume to be mounted with read-only permissions.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// registry represents a single or multiple Quobyte Registry services
    /// specified as a string as host:port pair (multiple entries are separated with commas)
    /// which acts as the central registry for volumes
    pub registry: String,
    /// tenant owning the given Quobyte volume in the Backend
    /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant: Option<String>,
    /// user to map volume access to
    /// Defaults to serivceaccount user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// volume is a string that references an already created Quobyte volume by name.
    pub volume: String,
}

/// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
/// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesRbd {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#rbd>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// image is the rados image name.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub image: String,
    /// keyring is the path to key ring for RBDUser.
    /// Default is /etc/ceph/keyring.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyring: Option<String>,
    /// monitors is a collection of Ceph monitors.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// pool is the rados pool name.
    /// Default is rbd.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is name of the authentication secret for RBDUser. If provided
    /// overrides keyring.
    /// Default is nil.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdControllerVolumesRbdSecretRef>,
    /// user is the rados user name.
    /// Default is admin.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is name of the authentication secret for RBDUser. If provided
/// overrides keyring.
/// Default is nil.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesRbdSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
/// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesScaleIo {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// Default is "xfs".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// gateway is the host address of the ScaleIO API Gateway.
    pub gateway: String,
    /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protectionDomain")]
    pub protection_domain: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef references to the secret for ScaleIO user and other
    /// sensitive information. If this is not provided, Login operation will fail.
    #[serde(rename = "secretRef")]
    pub secret_ref: ArgoCdControllerVolumesScaleIoSecretRef,
    /// sslEnabled Flag enable/disable SSL communication with Gateway, default false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslEnabled")]
    pub ssl_enabled: Option<bool>,
    /// storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    /// Default is ThinProvisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageMode")]
    pub storage_mode: Option<String>,
    /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    /// system is the name of the storage system as configured in ScaleIO.
    pub system: String,
    /// volumeName is the name of a volume already created in the ScaleIO system
    /// that is associated with this volume source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// secretRef references to the secret for ScaleIO user and other
/// sensitive information. If this is not provided, Login operation will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesScaleIoSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// secret represents a secret that should populate this volume.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesSecret {
    /// defaultMode is Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values
    /// for mode bits. Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items If unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdControllerVolumesSecretItems>>,
    /// optional field specify whether the Secret or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// secretName is the name of the secret in the pod's namespace to use.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
/// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesStorageos {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef specifies the secret to use for obtaining the StorageOS API
    /// credentials.  If not specified, default values will be attempted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdControllerVolumesStorageosSecretRef>,
    /// volumeName is the human-readable name of the StorageOS volume.  Volume
    /// names are only unique within a namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
    /// volumeNamespace specifies the scope of the volume within StorageOS.  If no
    /// namespace is specified then the Pod's namespace will be used.  This allows the
    /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    /// Set VolumeName to any name to override the default behaviour.
    /// Set to "default" if you are not using namespaces within StorageOS.
    /// Namespaces that do not pre-exist within StorageOS will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeNamespace")]
    pub volume_namespace: Option<String>,
}

/// secretRef specifies the secret to use for obtaining the StorageOS API
/// credentials.  If not specified, default values will be attempted.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesStorageosSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
/// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
/// are redirected to the csi.vsphere.vmware.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdControllerVolumesVsphereVolume {
    /// fsType is filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyID")]
    pub storage_policy_id: Option<String>,
    /// storagePolicyName is the storage Policy Based Management (SPBM) profile name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyName")]
    pub storage_policy_name: Option<String>,
    /// volumePath is the path that identifies vSphere volume vmdk
    #[serde(rename = "volumePath")]
    pub volume_path: String,
}

/// Deprecated: Grafana defines the Grafana server options for ArgoCD.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdGrafana {
    /// Enabled will toggle Grafana support globally for ArgoCD.
    pub enabled: bool,
    /// Host is the hostname to use for Ingress/Route resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Image is the Grafana container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Ingress defines the desired state for an Ingress for the Grafana component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<ArgoCdGrafanaIngress>,
    /// Resources defines the Compute Resources required by the container for Grafana.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdGrafanaResources>,
    /// Route defines the desired state for an OpenShift Route for the Grafana component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<ArgoCdGrafanaRoute>,
    /// Size is the replica count for the Grafana Deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,
    /// Version is the Grafana container image tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Ingress defines the desired state for an Ingress for the Grafana component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdGrafanaIngress {
    /// Annotations is the map of annotations to apply to the Ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled will toggle the creation of the Ingress.
    pub enabled: bool,
    /// IngressClassName for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Path used for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// TLS configuration. Currently the Ingress only supports a single TLS
    /// port, 443. If multiple members of this list specify different hosts, they
    /// will be multiplexed on the same port according to the hostname specified
    /// through the SNI TLS extension, if the ingress controller fulfilling the
    /// ingress supports SNI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<Vec<ArgoCdGrafanaIngressTls>>,
}

/// IngressTLS describes the transport layer security associated with an ingress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdGrafanaIngressTls {
    /// hosts is a list of hosts included in the TLS certificate. The values in
    /// this list must match the name/s used in the tlsSecret. Defaults to the
    /// wildcard host setting for the loadbalancer controller fulfilling this
    /// Ingress, if left unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    /// secretName is the name of the secret used to terminate TLS traffic on
    /// port 443. Field is left optional to allow TLS routing based on SNI
    /// hostname alone. If the SNI host in a listener conflicts with the "Host"
    /// header field used by an IngressRule, the SNI host is used for termination
    /// and value of the "Host" header is used for routing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Resources defines the Compute Resources required by the container for Grafana.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdGrafanaResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdGrafanaResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdGrafanaResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Route defines the desired state for an OpenShift Route for the Grafana component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdGrafanaRoute {
    /// Annotations is the map of annotations to use for the Route resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled will toggle the creation of the OpenShift Route.
    pub enabled: bool,
    /// Labels is the map of labels to use for the Route resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Path the router watches for, to route traffic for to the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// TLS provides the ability to configure certificates and termination for the Route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ArgoCdGrafanaRouteTls>,
    /// WildcardPolicy if any for the route. Currently only 'Subdomain' or 'None' is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wildcardPolicy")]
    pub wildcard_policy: Option<String>,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ArgoCdGrafanaRouteTls {
    /// caCertificate provides the cert authority certificate contents
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificate")]
    pub ca_certificate: Option<String>,
    /// certificate provides certificate contents. This should be a single serving certificate, not a certificate
    /// chain. Do not include a CA certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// destinationCACertificate provides the contents of the ca certificate of the final destination.  When using reencrypt
    /// termination this file should be provided in order to have routers use it for health checks on the secure connection.
    /// If this field is not specified, the router may provide its own destination CA and perform hostname validation using
    /// the short service name (service.namespace.svc), which allows infrastructure generated certificates to automatically
    /// verify.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationCACertificate")]
    pub destination_ca_certificate: Option<String>,
    /// externalCertificate provides certificate contents as a secret reference.
    /// This should be a single serving certificate, not a certificate
    /// chain. Do not include a CA certificate. The secret referenced should
    /// be present in the same namespace as that of the Route.
    /// Forbidden when `certificate` is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalCertificate")]
    pub external_certificate: Option<ArgoCdGrafanaRouteTlsExternalCertificate>,
    /// insecureEdgeTerminationPolicy indicates the desired behavior for insecure connections to a route. While
    /// each router may make its own decisions on which ports to expose, this is normally port 80.
    /// 
    /// * Allow - traffic is sent to the server on the insecure port (edge/reencrypt terminations only) (default).
    /// * None - no traffic is allowed on the insecure port.
    /// * Redirect - clients are redirected to the secure port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureEdgeTerminationPolicy")]
    pub insecure_edge_termination_policy: Option<ArgoCdGrafanaRouteTlsInsecureEdgeTerminationPolicy>,
    /// key provides key file contents
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// termination indicates termination type.
    /// 
    /// * edge - TLS termination is done by the router and http is used to communicate with the backend (default)
    /// * passthrough - Traffic is sent straight to the destination without the router providing TLS termination
    /// * reencrypt - TLS termination is done by the router and https is used to communicate with the backend
    /// 
    /// Note: passthrough termination is incompatible with httpHeader actions
    pub termination: ArgoCdGrafanaRouteTlsTermination,
}

/// externalCertificate provides certificate contents as a secret reference.
/// This should be a single serving certificate, not a certificate
/// chain. Do not include a CA certificate. The secret referenced should
/// be present in the same namespace as that of the Route.
/// Forbidden when `certificate` is set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdGrafanaRouteTlsExternalCertificate {
    /// name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdGrafanaRouteTlsInsecureEdgeTerminationPolicy {
    Allow,
    None,
    Redirect,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdGrafanaRouteTlsTermination {
    #[serde(rename = "edge")]
    Edge,
    #[serde(rename = "reencrypt")]
    Reencrypt,
    #[serde(rename = "passthrough")]
    Passthrough,
}

/// HA options for High Availability support for the Redis component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdHa {
    /// Enabled will toggle HA support globally for Argo CD.
    pub enabled: bool,
    /// RedisProxyImage is the Redis HAProxy container image.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redisProxyImage")]
    pub redis_proxy_image: Option<String>,
    /// RedisProxyVersion is the Redis HAProxy container image tag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redisProxyVersion")]
    pub redis_proxy_version: Option<String>,
    /// Resources defines the Compute Resources required by the container for HA.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdHaResources>,
}

/// Resources defines the Compute Resources required by the container for HA.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdHaResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdHaResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdHaResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// ImageUpdater defines whether the Argo CD ImageUpdater controller should be installed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImageUpdater {
    /// Enabled defines whether argocd image updater controller should be deployed or not
    pub enabled: bool,
    /// Env let you specify environment variables for ImageUpdater pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdImageUpdaterEnv>>,
    /// Resources defines the Compute Resources required by the container for Argo CD Image Updater.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdImageUpdaterResources>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImageUpdaterEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdImageUpdaterEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImageUpdaterEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdImageUpdaterEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdImageUpdaterEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdImageUpdaterEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdImageUpdaterEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImageUpdaterEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImageUpdaterEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImageUpdaterEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImageUpdaterEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Resources defines the Compute Resources required by the container for Argo CD Image Updater.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImageUpdaterResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdImageUpdaterResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImageUpdaterResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Import is the import/restore options for ArgoCD.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdImport {
    /// Name of an ArgoCDExport from which to import data.
    pub name: String,
    /// Namespace for the ArgoCDExport, defaults to the same namespace as the ArgoCD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// InitialSSHKnownHosts defines the SSH known hosts data upon creation of the cluster for connecting Git repositories via SSH.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdInitialSshKnownHosts {
    /// ExcludeDefaultHosts describes whether you would like to include the default
    /// list of SSH Known Hosts provided by ArgoCD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub excludedefaulthosts: Option<bool>,
    /// Keys describes a custom set of SSH Known Hosts that you would like to
    /// have included in your ArgoCD server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keys: Option<String>,
}

/// KustomizeVersionSpec is used to specify information about a kustomize version to be used within ArgoCD.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdKustomizeVersions {
    /// Path is the path to a configured kustomize version on the filesystem of your repo server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Version is a configured kustomize version in the format of vX.Y.Z
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// LocalUserSpec is used to specify information about an ArgoCD local user to be created by the operator.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdLocalUsers {
    /// ApiKey defines whether or not the user is configured to use an ArgoCD API
    /// key. Default is true
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<bool>,
    /// AutoRenewToken specifies if a new token is to be issued once the existing
    /// one has expired. Default is true
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "autoRenewToken")]
    pub auto_renew_token: Option<bool>,
    /// Enabled defines whether or not this local user is enabled. Default is
    /// true
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Login defines whether or not the user is configured to be able to login. Default is false
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub login: Option<bool>,
    /// Name of the local user
    pub name: String,
    /// TokenLifetime defines the how long the token issued to this user is valid
    /// for. An empty string or the value 0 indicates an infinite lifetime.
    /// Examples: "30m", "8760h"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenLifetime")]
    pub token_lifetime: Option<String>,
}

/// Monitoring defines whether workload status monitoring configuration for this instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdMonitoring {
    /// DisableMetrics field can be used to enable or disable the collection of Metrics on Openshift
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableMetrics")]
    pub disable_metrics: Option<bool>,
    /// Enabled defines whether workload status monitoring is enabled for this instance or not
    pub enabled: bool,
}

/// NamespaceManagement defines the namespace management settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNamespaceManagement {
    /// Whether the namespace can be managed by ArgoCD
    #[serde(rename = "allowManagedBy")]
    pub allow_managed_by: bool,
    /// Name of the namespace or pattern to be managed
    pub name: String,
}

/// NodePlacement defines NodeSelectors and Taints for Argo CD workloads
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNodePlacement {
    /// NodeSelector is a field of PodSpec, it is a map of key value pairs used for node selection
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Tolerations allow the pods to schedule onto nodes with matching taints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<ArgoCdNodePlacementTolerations>>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNodePlacementTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Notifications defines whether the Argo CD Notifications controller should be installed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNotifications {
    /// Enabled defines whether argocd-notifications controller should be deployed or not
    pub enabled: bool,
    /// Env let you specify environment variables for Notifications pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdNotificationsEnv>>,
    /// Image is the Argo CD Notifications image (optional)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// LogLevel describes the log level that should be used by the argocd-notifications. Defaults to ArgoCDDefaultLogLevel if not set.  Valid options are debug,info, error, and warn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// LogFormat refers to the log format used by the argocd-notifications. Defaults to ArgoCDDefaultLogFormat if not configured. Valid options are text or json.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logformat: Option<ArgoCdNotificationsLogformat>,
    /// Replicas defines the number of replicas to run for notifications-controller
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines the Compute Resources required by the container for Argo CD Notifications.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdNotificationsResources>,
    /// Version is the Argo CD Notifications image tag. (optional)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNotificationsEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdNotificationsEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNotificationsEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdNotificationsEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdNotificationsEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdNotificationsEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdNotificationsEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNotificationsEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNotificationsEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNotificationsEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNotificationsEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Notifications defines whether the Argo CD Notifications controller should be installed.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdNotificationsLogformat {
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "json")]
    Json,
}

/// Resources defines the Compute Resources required by the container for Argo CD Notifications.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNotificationsResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdNotificationsResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdNotificationsResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Prometheus defines the Prometheus server options for ArgoCD.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdPrometheus {
    /// Enabled will toggle Prometheus support globally for ArgoCD.
    pub enabled: bool,
    /// Host is the hostname to use for Ingress/Route resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Ingress defines the desired state for an Ingress for the Prometheus component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<ArgoCdPrometheusIngress>,
    /// Route defines the desired state for an OpenShift Route for the Prometheus component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<ArgoCdPrometheusRoute>,
    /// Size is the replica count for the Prometheus StatefulSet.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,
}

/// Ingress defines the desired state for an Ingress for the Prometheus component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdPrometheusIngress {
    /// Annotations is the map of annotations to apply to the Ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled will toggle the creation of the Ingress.
    pub enabled: bool,
    /// IngressClassName for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Path used for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// TLS configuration. Currently the Ingress only supports a single TLS
    /// port, 443. If multiple members of this list specify different hosts, they
    /// will be multiplexed on the same port according to the hostname specified
    /// through the SNI TLS extension, if the ingress controller fulfilling the
    /// ingress supports SNI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<Vec<ArgoCdPrometheusIngressTls>>,
}

/// IngressTLS describes the transport layer security associated with an ingress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdPrometheusIngressTls {
    /// hosts is a list of hosts included in the TLS certificate. The values in
    /// this list must match the name/s used in the tlsSecret. Defaults to the
    /// wildcard host setting for the loadbalancer controller fulfilling this
    /// Ingress, if left unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    /// secretName is the name of the secret used to terminate TLS traffic on
    /// port 443. Field is left optional to allow TLS routing based on SNI
    /// hostname alone. If the SNI host in a listener conflicts with the "Host"
    /// header field used by an IngressRule, the SNI host is used for termination
    /// and value of the "Host" header is used for routing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Route defines the desired state for an OpenShift Route for the Prometheus component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdPrometheusRoute {
    /// Annotations is the map of annotations to use for the Route resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled will toggle the creation of the OpenShift Route.
    pub enabled: bool,
    /// Labels is the map of labels to use for the Route resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Path the router watches for, to route traffic for to the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// TLS provides the ability to configure certificates and termination for the Route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ArgoCdPrometheusRouteTls>,
    /// WildcardPolicy if any for the route. Currently only 'Subdomain' or 'None' is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wildcardPolicy")]
    pub wildcard_policy: Option<String>,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ArgoCdPrometheusRouteTls {
    /// caCertificate provides the cert authority certificate contents
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificate")]
    pub ca_certificate: Option<String>,
    /// certificate provides certificate contents. This should be a single serving certificate, not a certificate
    /// chain. Do not include a CA certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// destinationCACertificate provides the contents of the ca certificate of the final destination.  When using reencrypt
    /// termination this file should be provided in order to have routers use it for health checks on the secure connection.
    /// If this field is not specified, the router may provide its own destination CA and perform hostname validation using
    /// the short service name (service.namespace.svc), which allows infrastructure generated certificates to automatically
    /// verify.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationCACertificate")]
    pub destination_ca_certificate: Option<String>,
    /// externalCertificate provides certificate contents as a secret reference.
    /// This should be a single serving certificate, not a certificate
    /// chain. Do not include a CA certificate. The secret referenced should
    /// be present in the same namespace as that of the Route.
    /// Forbidden when `certificate` is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalCertificate")]
    pub external_certificate: Option<ArgoCdPrometheusRouteTlsExternalCertificate>,
    /// insecureEdgeTerminationPolicy indicates the desired behavior for insecure connections to a route. While
    /// each router may make its own decisions on which ports to expose, this is normally port 80.
    /// 
    /// * Allow - traffic is sent to the server on the insecure port (edge/reencrypt terminations only) (default).
    /// * None - no traffic is allowed on the insecure port.
    /// * Redirect - clients are redirected to the secure port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureEdgeTerminationPolicy")]
    pub insecure_edge_termination_policy: Option<ArgoCdPrometheusRouteTlsInsecureEdgeTerminationPolicy>,
    /// key provides key file contents
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// termination indicates termination type.
    /// 
    /// * edge - TLS termination is done by the router and http is used to communicate with the backend (default)
    /// * passthrough - Traffic is sent straight to the destination without the router providing TLS termination
    /// * reencrypt - TLS termination is done by the router and https is used to communicate with the backend
    /// 
    /// Note: passthrough termination is incompatible with httpHeader actions
    pub termination: ArgoCdPrometheusRouteTlsTermination,
}

/// externalCertificate provides certificate contents as a secret reference.
/// This should be a single serving certificate, not a certificate
/// chain. Do not include a CA certificate. The secret referenced should
/// be present in the same namespace as that of the Route.
/// Forbidden when `certificate` is set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdPrometheusRouteTlsExternalCertificate {
    /// name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdPrometheusRouteTlsInsecureEdgeTerminationPolicy {
    Allow,
    None,
    Redirect,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdPrometheusRouteTlsTermination {
    #[serde(rename = "edge")]
    Edge,
    #[serde(rename = "reencrypt")]
    Reencrypt,
    #[serde(rename = "passthrough")]
    Passthrough,
}

/// RBAC defines the RBAC configuration for Argo CD.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRbac {
    /// DefaultPolicy is the name of the default role which Argo CD will falls back to, when
    /// authorizing API requests (optional). If omitted or empty, users may be still be able to login,
    /// but will see no apps, projects, etc...
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultPolicy")]
    pub default_policy: Option<String>,
    /// Policy is CSV containing user-defined RBAC policies and role definitions.
    /// Policy rules are in the form:
    ///   p, subject, resource, action, object, effect
    /// Role definitions and bindings are in the form:
    ///   g, subject, inherited-subject
    /// See <https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/rbac.md> for additional information.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<String>,
    /// PolicyMatcherMode configures the matchers function mode for casbin.
    /// There are two options for this, 'glob' for glob matcher or 'regex' for regex matcher.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "policyMatcherMode")]
    pub policy_matcher_mode: Option<String>,
    /// Scopes controls which OIDC scopes to examine during rbac enforcement (in addition to `sub` scope).
    /// If omitted, defaults to: '[groups]'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<String>,
}

/// Redis defines the Redis server options for ArgoCD.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRedis {
    /// AutoTLS specifies the method to use for automatic TLS configuration for the redis server
    /// The value specified here can currently be:
    /// - openshift - Use the OpenShift service CA to request TLS config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autotls: Option<String>,
    /// DisableTLSVerification defines whether redis server API should be accessed using strict TLS validation
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableTLSVerification")]
    pub disable_tls_verification: Option<bool>,
    /// Enabled is the flag to enable Redis during ArgoCD installation. (optional, default `true`)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Image is the Redis container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Remote specifies the remote URL of the Redis container. (optional, by default, a local instance managed by the operator is used.)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remote: Option<String>,
    /// Resources defines the Compute Resources required by the container for Redis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdRedisResources>,
    /// Version is the Redis container image tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Resources defines the Compute Resources required by the container for Redis.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRedisResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdRedisResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRedisResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Repo defines the repo server options for Argo CD.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepo {
    /// Custom annotations to pods deployed by the operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// AutoTLS specifies the method to use for automatic TLS configuration for the repo server
    /// The value specified here can currently be:
    /// - openshift - Use the OpenShift service CA to request TLS config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autotls: Option<String>,
    /// Enabled is the flag to enable Repo Server during ArgoCD installation. (optional, default `true`)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Env lets you specify environment for repo server pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdRepoEnv>>,
    /// ExecTimeout specifies the timeout in seconds for tool execution
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "execTimeout")]
    pub exec_timeout: Option<i64>,
    /// Extra Command arguments allows users to pass command line arguments to repo server workload. They get added to default command line arguments provided
    /// by the operator.
    /// Please note that the command line arguments provided as part of ExtraRepoCommandArgs will not overwrite the default command line arguments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraRepoCommandArgs")]
    pub extra_repo_command_args: Option<Vec<String>>,
    /// Image is the ArgoCD Repo Server container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// InitContainers defines the list of initialization containers for the repo server deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<ArgoCdRepoInitContainers>>,
    /// Custom labels to pods deployed by the operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// LogFormat describes the log format that should be used by the Repo Server. Defaults to ArgoCDDefaultLogFormat if not configured. Valid options are text or json.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    pub log_format: Option<String>,
    /// LogLevel describes the log level that should be used by the Repo Server. Defaults to ArgoCDDefaultLogLevel if not set.  Valid options are debug, info, error, and warn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// MountSAToken describes whether you would like to have the Repo server mount the service account token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mountsatoken: Option<bool>,
    /// Remote specifies the remote URL of the Repo Server container. (optional, by default, a local instance managed by the operator is used.)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remote: Option<String>,
    /// Replicas defines the number of replicas for argocd-repo-server. Value should be greater than or equal to 0. Default is nil.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines the Compute Resources required by the container for Redis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdRepoResources>,
    /// ServiceAccount defines the ServiceAccount user that you would like the Repo server to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub serviceaccount: Option<String>,
    /// SidecarContainers defines the list of sidecar containers for the repo
    /// server deployment. If the image field is omitted from a SidecarContainer,
    /// the image for the repo server will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sidecarContainers")]
    pub sidecar_containers: Option<Vec<ArgoCdRepoSidecarContainers>>,
    /// VerifyTLS defines whether repo server API should be accessed using strict TLS validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verifytls: Option<bool>,
    /// Version is the ArgoCD Repo Server container image tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// VolumeMounts adds volumeMounts to the repo server container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdRepoVolumeMounts>>,
    /// Volumes adds volumes to the repo server deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<ArgoCdRepoVolumes>>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdRepoEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdRepoEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdRepoEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdRepoEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdRepoEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainers {
    /// Arguments to the entrypoint.
    /// The container image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The container image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdRepoInitContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ArgoCdRepoInitContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ArgoCdRepoInitContainersLifecycle>,
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ArgoCdRepoInitContainersLivenessProbe>,
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    pub name: String,
    /// List of ports to expose from the container. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Modifying this array with strategic merge patch may corrupt the data.
    /// For more information See <https://github.com/kubernetes/kubernetes/issues/108255.>
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ArgoCdRepoInitContainersPorts>>,
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ArgoCdRepoInitContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<ArgoCdRepoInitContainersResizePolicy>>,
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdRepoInitContainersResources>,
    /// RestartPolicy defines the restart behavior of individual containers in a pod.
    /// This field may only be set for init containers, and the only allowed value is "Always".
    /// For non-init containers or when this field is not specified,
    /// the restart behavior is defined by the Pod's restart policy and the container type.
    /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
    /// this init container will be continually restarted on
    /// exit until all regular containers have terminated. Once all regular
    /// containers have completed, all init containers with restartPolicy "Always"
    /// will be shut down. This lifecycle differs from normal init containers and
    /// is often referred to as a "sidecar" container. Although this init
    /// container still starts in the init container sequence, it does not wait
    /// for the container to complete before proceeding to the next init
    /// container. Instead, the next init container starts immediately after this
    /// init container is started, or after any startupProbe has successfully
    /// completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ArgoCdRepoInitContainersSecurityContext>,
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ArgoCdRepoInitContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ArgoCdRepoInitContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdRepoInitContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdRepoInitContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdRepoInitContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdRepoInitContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdRepoInitContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdRepoInitContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps or Secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ArgoCdRepoInitContainersEnvFromConfigMapRef>,
    /// Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdRepoInitContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersEnvFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Actions that the management system should take in response to container lifecycle events.
/// Cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ArgoCdRepoInitContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ArgoCdRepoInitContainersLifecyclePreStop>,
    /// StopSignal defines which signal will be sent to a container when it is being stopped.
    /// If not specified, the default is defined by the container runtime in use.
    /// StopSignal can only be set for Pods with a non-empty .spec.os.name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stopSignal")]
    pub stop_signal: Option<String>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePostStart {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoInitContainersLifecyclePostStartExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoInitContainersLifecyclePostStartHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdRepoInitContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoInitContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoInitContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePreStop {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoInitContainersLifecyclePreStopExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoInitContainersLifecyclePreStopHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdRepoInitContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoInitContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoInitContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Periodic probe of container liveness.
/// Container will be restarted if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLivenessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoInitContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdRepoInitContainersLivenessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoInitContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoInitContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoInitContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Periodic probe of container service readiness.
/// Container will be removed from service endpoints if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersReadinessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoInitContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdRepoInitContainersReadinessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoInitContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoInitContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoInitContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Compute Resources required by this container.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdRepoInitContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// SecurityContext defines the security options the container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
/// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// appArmorProfile is the AppArmor options to use by this container. If set, this profile
    /// overrides the pod's appArmorProfile.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appArmorProfile")]
    pub app_armor_profile: Option<ArgoCdRepoInitContainersSecurityContextAppArmorProfile>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ArgoCdRepoInitContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default value is Default which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ArgoCdRepoInitContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ArgoCdRepoInitContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ArgoCdRepoInitContainersSecurityContextWindowsOptions>,
}

/// appArmorProfile is the AppArmor options to use by this container. If set, this profile
/// overrides the pod's appArmorProfile.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersSecurityContextAppArmorProfile {
    /// localhostProfile indicates a profile loaded on the node that should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must match the loaded name of the profile.
    /// Must be set if and only if type is "Localhost".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of AppArmor profile will be applied.
    /// Valid options are:
    ///   Localhost - a profile pre-loaded on the node.
    ///   RuntimeDefault - the container runtime's default profile.
    ///   Unconfined - no AppArmor enforcement.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// StartupProbe indicates that the Pod has successfully initialized.
/// If specified, no other probes are executed until this completes successfully.
/// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
/// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
/// when it might take a long time to load data or warm a cache, than during steady-state operation.
/// This cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersStartupProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoInitContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdRepoInitContainersStartupProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoInitContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoInitContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoInitContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoInitContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Resources defines the Compute Resources required by the container for Redis.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdRepoResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainers {
    /// Arguments to the entrypoint.
    /// The container image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The container image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdRepoSidecarContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ArgoCdRepoSidecarContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ArgoCdRepoSidecarContainersLifecycle>,
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ArgoCdRepoSidecarContainersLivenessProbe>,
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    pub name: String,
    /// List of ports to expose from the container. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Modifying this array with strategic merge patch may corrupt the data.
    /// For more information See <https://github.com/kubernetes/kubernetes/issues/108255.>
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ArgoCdRepoSidecarContainersPorts>>,
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ArgoCdRepoSidecarContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<ArgoCdRepoSidecarContainersResizePolicy>>,
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdRepoSidecarContainersResources>,
    /// RestartPolicy defines the restart behavior of individual containers in a pod.
    /// This field may only be set for init containers, and the only allowed value is "Always".
    /// For non-init containers or when this field is not specified,
    /// the restart behavior is defined by the Pod's restart policy and the container type.
    /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
    /// this init container will be continually restarted on
    /// exit until all regular containers have terminated. Once all regular
    /// containers have completed, all init containers with restartPolicy "Always"
    /// will be shut down. This lifecycle differs from normal init containers and
    /// is often referred to as a "sidecar" container. Although this init
    /// container still starts in the init container sequence, it does not wait
    /// for the container to complete before proceeding to the next init
    /// container. Instead, the next init container starts immediately after this
    /// init container is started, or after any startupProbe has successfully
    /// completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ArgoCdRepoSidecarContainersSecurityContext>,
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ArgoCdRepoSidecarContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ArgoCdRepoSidecarContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdRepoSidecarContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdRepoSidecarContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdRepoSidecarContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdRepoSidecarContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdRepoSidecarContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdRepoSidecarContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps or Secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ArgoCdRepoSidecarContainersEnvFromConfigMapRef>,
    /// Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdRepoSidecarContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersEnvFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Actions that the management system should take in response to container lifecycle events.
/// Cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ArgoCdRepoSidecarContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ArgoCdRepoSidecarContainersLifecyclePreStop>,
    /// StopSignal defines which signal will be sent to a container when it is being stopped.
    /// If not specified, the default is defined by the container runtime in use.
    /// StopSignal can only be set for Pods with a non-empty .spec.os.name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stopSignal")]
    pub stop_signal: Option<String>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePostStart {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoSidecarContainersLifecyclePostStartExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoSidecarContainersLifecyclePostStartHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdRepoSidecarContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoSidecarContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoSidecarContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePreStop {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoSidecarContainersLifecyclePreStopExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoSidecarContainersLifecyclePreStopHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdRepoSidecarContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoSidecarContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoSidecarContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Periodic probe of container liveness.
/// Container will be restarted if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLivenessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoSidecarContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdRepoSidecarContainersLivenessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoSidecarContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoSidecarContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoSidecarContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Periodic probe of container service readiness.
/// Container will be removed from service endpoints if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersReadinessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoSidecarContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdRepoSidecarContainersReadinessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoSidecarContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoSidecarContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoSidecarContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Compute Resources required by this container.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdRepoSidecarContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// SecurityContext defines the security options the container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
/// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// appArmorProfile is the AppArmor options to use by this container. If set, this profile
    /// overrides the pod's appArmorProfile.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appArmorProfile")]
    pub app_armor_profile: Option<ArgoCdRepoSidecarContainersSecurityContextAppArmorProfile>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ArgoCdRepoSidecarContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default value is Default which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ArgoCdRepoSidecarContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ArgoCdRepoSidecarContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ArgoCdRepoSidecarContainersSecurityContextWindowsOptions>,
}

/// appArmorProfile is the AppArmor options to use by this container. If set, this profile
/// overrides the pod's appArmorProfile.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersSecurityContextAppArmorProfile {
    /// localhostProfile indicates a profile loaded on the node that should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must match the loaded name of the profile.
    /// Must be set if and only if type is "Localhost".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of AppArmor profile will be applied.
    /// Valid options are:
    ///   Localhost - a profile pre-loaded on the node.
    ///   RuntimeDefault - the container runtime's default profile.
    ///   Unconfined - no AppArmor enforcement.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// StartupProbe indicates that the Pod has successfully initialized.
/// If specified, no other probes are executed until this completes successfully.
/// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
/// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
/// when it might take a long time to load data or warm a cache, than during steady-state operation.
/// This cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersStartupProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdRepoSidecarContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdRepoSidecarContainersStartupProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdRepoSidecarContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdRepoSidecarContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdRepoSidecarContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoSidecarContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumes {
    /// awsElasticBlockStore represents an AWS Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
    /// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsElasticBlockStore")]
    pub aws_elastic_block_store: Option<ArgoCdRepoVolumesAwsElasticBlockStore>,
    /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
    /// are redirected to the disk.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureDisk")]
    pub azure_disk: Option<ArgoCdRepoVolumesAzureDisk>,
    /// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
    /// are redirected to the file.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureFile")]
    pub azure_file: Option<ArgoCdRepoVolumesAzureFile>,
    /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
    /// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephfs: Option<ArgoCdRepoVolumesCephfs>,
    /// cinder represents a cinder volume attached and mounted on kubelets host machine.
    /// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
    /// are redirected to the cinder.csi.openstack.org CSI driver.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cinder: Option<ArgoCdRepoVolumesCinder>,
    /// configMap represents a configMap that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdRepoVolumesConfigMap>,
    /// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<ArgoCdRepoVolumesCsi>,
    /// downwardAPI represents downward API about the pod that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdRepoVolumesDownwardApi>,
    /// emptyDir represents a temporary directory that shares a pod's lifetime.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<ArgoCdRepoVolumesEmptyDir>,
    /// ephemeral represents a volume that is handled by a cluster storage driver.
    /// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    /// and deleted when the pod is removed.
    /// 
    /// Use this if:
    /// a) the volume is only needed while the pod runs,
    /// b) features of normal volumes like restoring from snapshot or capacity
    ///    tracking are needed,
    /// c) the storage driver is specified through a storage class, and
    /// d) the storage driver supports dynamic volume provisioning through
    ///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
    ///    information on the connection between this volume type
    ///    and PersistentVolumeClaim).
    /// 
    /// Use PersistentVolumeClaim or one of the vendor-specific
    /// APIs for volumes that persist for longer than the lifecycle
    /// of an individual pod.
    /// 
    /// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    /// be used that way - see the documentation of the driver for
    /// more information.
    /// 
    /// A pod can use both types of ephemeral volumes and
    /// persistent volumes at the same time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<ArgoCdRepoVolumesEphemeral>,
    /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fc: Option<ArgoCdRepoVolumesFc>,
    /// flexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flexVolume")]
    pub flex_volume: Option<ArgoCdRepoVolumesFlexVolume>,
    /// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
    /// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flocker: Option<ArgoCdRepoVolumesFlocker>,
    /// gcePersistentDisk represents a GCE Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
    /// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDisk")]
    pub gce_persistent_disk: Option<ArgoCdRepoVolumesGcePersistentDisk>,
    /// gitRepo represents a git repository at a particular revision.
    /// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    /// into the Pod's container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitRepo")]
    pub git_repo: Option<ArgoCdRepoVolumesGitRepo>,
    /// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    /// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glusterfs: Option<ArgoCdRepoVolumesGlusterfs>,
    /// hostPath represents a pre-existing file or directory on the host
    /// machine that is directly exposed to the container. This is generally
    /// used for system agents or other privileged things that are allowed
    /// to see the host machine. Most containers will NOT need this.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<ArgoCdRepoVolumesHostPath>,
    /// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
    /// The volume is resolved at pod startup depending on which PullPolicy value is provided:
    /// 
    /// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// 
    /// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
    /// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
    /// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
    /// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
    /// The volume will be mounted read-only (ro) and non-executable files (noexec).
    /// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
    /// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<ArgoCdRepoVolumesImage>,
    /// iscsi represents an ISCSI Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iscsi: Option<ArgoCdRepoVolumesIscsi>,
    /// name of the volume.
    /// Must be a DNS_LABEL and unique within the pod.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    pub name: String,
    /// nfs represents an NFS mount on the host that shares a pod's lifetime
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nfs: Option<ArgoCdRepoVolumesNfs>,
    /// persistentVolumeClaimVolumeSource represents a reference to a
    /// PersistentVolumeClaim in the same namespace.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<ArgoCdRepoVolumesPersistentVolumeClaim>,
    /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
    /// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "photonPersistentDisk")]
    pub photon_persistent_disk: Option<ArgoCdRepoVolumesPhotonPersistentDisk>,
    /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
    /// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
    /// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
    /// is on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portworxVolume")]
    pub portworx_volume: Option<ArgoCdRepoVolumesPortworxVolume>,
    /// projected items for all in one resources secrets, configmaps, and downward API
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<ArgoCdRepoVolumesProjected>,
    /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
    /// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quobyte: Option<ArgoCdRepoVolumesQuobyte>,
    /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
    /// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbd: Option<ArgoCdRepoVolumesRbd>,
    /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    /// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scaleIO")]
    pub scale_io: Option<ArgoCdRepoVolumesScaleIo>,
    /// secret represents a secret that should populate this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdRepoVolumesSecret>,
    /// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    /// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storageos: Option<ArgoCdRepoVolumesStorageos>,
    /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
    /// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
    /// are redirected to the csi.vsphere.vmware.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vsphereVolume")]
    pub vsphere_volume: Option<ArgoCdRepoVolumesVsphereVolume>,
}

/// awsElasticBlockStore represents an AWS Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
/// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesAwsElasticBlockStore {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// readOnly value true will force the readOnly setting in VolumeMounts.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
/// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
/// are redirected to the disk.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesAzureDisk {
    /// cachingMode is the Host Caching mode: None, Read Only, Read Write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachingMode")]
    pub caching_mode: Option<String>,
    /// diskName is the Name of the data disk in the blob storage
    #[serde(rename = "diskName")]
    pub disk_name: String,
    /// diskURI is the URI of data disk in the blob storage
    #[serde(rename = "diskURI")]
    pub disk_uri: String,
    /// fsType is Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
/// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
/// are redirected to the file.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesAzureFile {
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretName is the  name of secret that contains Azure Storage Account Name and Key
    #[serde(rename = "secretName")]
    pub secret_name: String,
    /// shareName is the azure share Name
    #[serde(rename = "shareName")]
    pub share_name: String,
}

/// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
/// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesCephfs {
    /// monitors is Required: Monitors is a collection of Ceph monitors
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretFile")]
    pub secret_file: Option<String>,
    /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdRepoVolumesCephfsSecretRef>,
    /// user is optional: User is the rados user name, default is admin
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
/// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesCephfsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// cinder represents a cinder volume attached and mounted on kubelets host machine.
/// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
/// are redirected to the cinder.csi.openstack.org CSI driver.
/// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesCinder {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is optional: points to a secret object containing parameters used to connect
    /// to OpenStack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdRepoVolumesCinderSecretRef>,
    /// volumeID used to identify the volume in cinder.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// secretRef is optional: points to a secret object containing parameters used to connect
/// to OpenStack.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesCinderSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// configMap represents a configMap that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesConfigMap {
    /// defaultMode is optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdRepoVolumesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesCsi {
    /// driver is the name of the CSI driver that handles this volume.
    /// Consult with your admin for the correct name as registered in the cluster.
    pub driver: String,
    /// fsType to mount. Ex. "ext4", "xfs", "ntfs".
    /// If not provided, the empty value is passed to the associated CSI driver
    /// which will determine the default filesystem to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// nodePublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// NodePublishVolume and NodeUnpublishVolume calls.
    /// This field is optional, and  may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secret references are passed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePublishSecretRef")]
    pub node_publish_secret_ref: Option<ArgoCdRepoVolumesCsiNodePublishSecretRef>,
    /// readOnly specifies a read-only configuration for the volume.
    /// Defaults to false (read/write).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeAttributes stores driver-specific properties that are passed to the CSI
    /// driver. Consult your driver's documentation for supported values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributes")]
    pub volume_attributes: Option<BTreeMap<String, String>>,
}

/// nodePublishSecretRef is a reference to the secret object containing
/// sensitive information to pass to the CSI driver to complete the CSI
/// NodePublishVolume and NodeUnpublishVolume calls.
/// This field is optional, and  may be empty if no secret is required. If the
/// secret object contains more than one secret, all secret references are passed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesCsiNodePublishSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// downwardAPI represents downward API about the pod that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesDownwardApi {
    /// Optional: mode bits to use on created files by default. Must be a
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// Items is a list of downward API volume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdRepoVolumesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdRepoVolumesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdRepoVolumesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// emptyDir represents a temporary directory that shares a pod's lifetime.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEmptyDir {
    /// medium represents what type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

/// ephemeral represents a volume that is handled by a cluster storage driver.
/// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
/// and deleted when the pod is removed.
/// 
/// Use this if:
/// a) the volume is only needed while the pod runs,
/// b) features of normal volumes like restoring from snapshot or capacity
///    tracking are needed,
/// c) the storage driver is specified through a storage class, and
/// d) the storage driver supports dynamic volume provisioning through
///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
///    information on the connection between this volume type
///    and PersistentVolumeClaim).
/// 
/// Use PersistentVolumeClaim or one of the vendor-specific
/// APIs for volumes that persist for longer than the lifecycle
/// of an individual pod.
/// 
/// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
/// be used that way - see the documentation of the driver for
/// more information.
/// 
/// A pod can use both types of ephemeral volumes and
/// persistent volumes at the same time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEphemeral {
    /// Will be used to create a stand-alone PVC to provision the volume.
    /// The pod in which this EphemeralVolumeSource is embedded will be the
    /// owner of the PVC, i.e. the PVC will be deleted together with the
    /// pod.  The name of the PVC will be `<pod name>-<volume name>` where
    /// `<volume name>` is the name from the `PodSpec.Volumes` array
    /// entry. Pod validation will reject the pod if the concatenated name
    /// is not valid for a PVC (for example, too long).
    /// 
    /// An existing PVC with that name that is not owned by the pod
    /// will *not* be used for the pod to avoid using an unrelated
    /// volume by mistake. Starting the pod is then blocked until
    /// the unrelated PVC is removed. If such a pre-created PVC is
    /// meant to be used by the pod, the PVC has to updated with an
    /// owner reference to the pod once the pod exists. Normally
    /// this should not be necessary, but it may be useful when
    /// manually reconstructing a broken cluster.
    /// 
    /// This field is read-only and no changes will be made by Kubernetes
    /// to the PVC after it has been created.
    /// 
    /// Required, must not be nil.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<ArgoCdRepoVolumesEphemeralVolumeClaimTemplate>,
}

/// Will be used to create a stand-alone PVC to provision the volume.
/// The pod in which this EphemeralVolumeSource is embedded will be the
/// owner of the PVC, i.e. the PVC will be deleted together with the
/// pod.  The name of the PVC will be `<pod name>-<volume name>` where
/// `<volume name>` is the name from the `PodSpec.Volumes` array
/// entry. Pod validation will reject the pod if the concatenated name
/// is not valid for a PVC (for example, too long).
/// 
/// An existing PVC with that name that is not owned by the pod
/// will *not* be used for the pod to avoid using an unrelated
/// volume by mistake. Starting the pod is then blocked until
/// the unrelated PVC is removed. If such a pre-created PVC is
/// meant to be used by the pod, the PVC has to updated with an
/// owner reference to the pod once the pod exists. Normally
/// this should not be necessary, but it may be useful when
/// manually reconstructing a broken cluster.
/// 
/// This field is read-only and no changes will be made by Kubernetes
/// to the PVC after it has been created.
/// 
/// Required, must not be nil.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEphemeralVolumeClaimTemplate {
    /// May contain labels and annotations that will be copied into the PVC
    /// when creating it. No other fields are allowed and will be rejected during
    /// validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ArgoCdRepoVolumesEphemeralVolumeClaimTemplateMetadata>,
    /// The specification for the PersistentVolumeClaim. The entire content is
    /// copied unchanged into the PVC that gets created from this
    /// template. The same fields as in a PersistentVolumeClaim
    /// are also valid here.
    pub spec: ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpec,
}

/// May contain labels and annotations that will be copied into the PVC
/// when creating it. No other fields are allowed and will be rejected during
/// validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEphemeralVolumeClaimTemplateMetadata {
}

/// The specification for the PersistentVolumeClaim. The entire content is
/// copied unchanged into the PVC that gets created from this
/// template. The same fields as in a PersistentVolumeClaim
/// are also valid here.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    /// (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesFc {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// lun is Optional: FC target lun number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lun: Option<i32>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// targetWWNs is Optional: FC target worldwide names (WWNs)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetWWNs")]
    pub target_ww_ns: Option<Vec<String>>,
    /// wwids Optional: FC volume world wide identifiers (wwids)
    /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wwids: Option<Vec<String>>,
}

/// flexVolume represents a generic volume resource that is
/// provisioned/attached using an exec based plugin.
/// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesFlexVolume {
    /// driver is the name of the driver to use for this volume.
    pub driver: String,
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// options is Optional: this field holds extra command options if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<BTreeMap<String, String>>,
    /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is Optional: secretRef is reference to the secret object containing
    /// sensitive information to pass to the plugin scripts. This may be
    /// empty if no secret object is specified. If the secret object
    /// contains more than one secret, all secrets are passed to the plugin
    /// scripts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdRepoVolumesFlexVolumeSecretRef>,
}

/// secretRef is Optional: secretRef is reference to the secret object containing
/// sensitive information to pass to the plugin scripts. This may be
/// empty if no secret object is specified. If the secret object
/// contains more than one secret, all secrets are passed to the plugin
/// scripts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesFlexVolumeSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
/// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesFlocker {
    /// datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
    /// should be considered as deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetName")]
    pub dataset_name: Option<String>,
    /// datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetUUID")]
    pub dataset_uuid: Option<String>,
}

/// gcePersistentDisk represents a GCE Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
/// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesGcePersistentDisk {
    /// fsType is filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(rename = "pdName")]
    pub pd_name: String,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// gitRepo represents a git repository at a particular revision.
/// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
/// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
/// into the Pod's container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesGitRepo {
    /// directory is the target directory name.
    /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    /// git repository.  Otherwise, if specified, the volume will contain the git repository in
    /// the subdirectory with the given name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    /// repository is the URL
    pub repository: String,
    /// revision is the commit hash for the specified revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub revision: Option<String>,
}

/// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
/// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesGlusterfs {
    /// endpoints is the endpoint name that details Glusterfs topology.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub endpoints: String,
    /// path is the Glusterfs volume path.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub path: String,
    /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// hostPath represents a pre-existing file or directory on the host
/// machine that is directly exposed to the container. This is generally
/// used for system agents or other privileged things that are allowed
/// to see the host machine. Most containers will NOT need this.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesHostPath {
    /// path of the directory on the host.
    /// If the path is a symlink, it will follow the link to the real path.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    pub path: String,
    /// type for HostPath Volume
    /// Defaults to ""
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
/// The volume is resolved at pod startup depending on which PullPolicy value is provided:
/// 
/// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
/// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
/// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
/// 
/// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
/// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
/// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
/// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
/// The volume will be mounted read-only (ro) and non-executable files (noexec).
/// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
/// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesImage {
    /// Policy for pulling OCI objects. Possible values are:
    /// Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// Required: Image or artifact reference to be used.
    /// Behaves in the same way as pod.spec.containers[*].image.
    /// Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reference: Option<String>,
}

/// iscsi represents an ISCSI Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesIscsi {
    /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthDiscovery")]
    pub chap_auth_discovery: Option<bool>,
    /// chapAuthSession defines whether support iSCSI Session CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthSession")]
    pub chap_auth_session: Option<bool>,
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#iscsi>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// initiatorName is the custom iSCSI Initiator Name.
    /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    /// <target portal>:<volume name> will be created for the connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initiatorName")]
    pub initiator_name: Option<String>,
    /// iqn is the target iSCSI Qualified Name.
    pub iqn: String,
    /// iscsiInterface is the interface Name that uses an iSCSI transport.
    /// Defaults to 'default' (tcp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iscsiInterface")]
    pub iscsi_interface: Option<String>,
    /// lun represents iSCSI Target Lun number.
    pub lun: i32,
    /// portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub portals: Option<Vec<String>>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdRepoVolumesIscsiSecretRef>,
    /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(rename = "targetPortal")]
    pub target_portal: String,
}

/// secretRef is the CHAP Secret for iSCSI target and initiator authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesIscsiSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// nfs represents an NFS mount on the host that shares a pod's lifetime
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesNfs {
    /// path that is exported by the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub path: String,
    /// readOnly here will force the NFS export to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// server is the hostname or IP address of the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub server: String,
}

/// persistentVolumeClaimVolumeSource represents a reference to a
/// PersistentVolumeClaim in the same namespace.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesPersistentVolumeClaim {
    /// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(rename = "claimName")]
    pub claim_name: String,
    /// readOnly Will force the ReadOnly setting in VolumeMounts.
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
/// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesPhotonPersistentDisk {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// pdID is the ID that identifies Photon Controller persistent disk
    #[serde(rename = "pdID")]
    pub pd_id: String,
}

/// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
/// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
/// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
/// is on.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesPortworxVolume {
    /// fSType represents the filesystem type to mount
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID uniquely identifies a Portworx volume
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// projected items for all in one resources secrets, configmaps, and downward API
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjected {
    /// defaultMode are the mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// sources is the list of volume projections. Each entry in this list
    /// handles one source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ArgoCdRepoVolumesProjectedSources>>,
}

/// Projection that may be projected along with other supported volume types.
/// Exactly one of these fields must be set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSources {
    /// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
    /// of ClusterTrustBundle objects in an auto-updating file.
    /// 
    /// Alpha, gated by the ClusterTrustBundleProjection feature gate.
    /// 
    /// ClusterTrustBundle objects can either be selected by name, or by the
    /// combination of signer name and a label selector.
    /// 
    /// Kubelet performs aggressive normalization of the PEM contents written
    /// into the pod filesystem.  Esoteric PEM features such as inter-block
    /// comments and block headers are stripped.  Certificates are deduplicated.
    /// The ordering of certificates within the file is arbitrary, and Kubelet
    /// may change the order over time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<ArgoCdRepoVolumesProjectedSourcesClusterTrustBundle>,
    /// configMap information about the configMap data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdRepoVolumesProjectedSourcesConfigMap>,
    /// downwardAPI information about the downwardAPI data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdRepoVolumesProjectedSourcesDownwardApi>,
    /// secret information about the secret data to project
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdRepoVolumesProjectedSourcesSecret>,
    /// serviceAccountToken is information about the serviceAccountToken data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<ArgoCdRepoVolumesProjectedSourcesServiceAccountToken>,
}

/// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
/// of ClusterTrustBundle objects in an auto-updating file.
/// 
/// Alpha, gated by the ClusterTrustBundleProjection feature gate.
/// 
/// ClusterTrustBundle objects can either be selected by name, or by the
/// combination of signer name and a label selector.
/// 
/// Kubelet performs aggressive normalization of the PEM contents written
/// into the pod filesystem.  Esoteric PEM features such as inter-block
/// comments and block headers are stripped.  Certificates are deduplicated.
/// The ordering of certificates within the file is arbitrary, and Kubelet
/// may change the order over time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesClusterTrustBundle {
    /// Select all ClusterTrustBundles that match this label selector.  Only has
    /// effect if signerName is set.  Mutually-exclusive with name.  If unset,
    /// interpreted as "match nothing".  If set but empty, interpreted as "match
    /// everything".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ArgoCdRepoVolumesProjectedSourcesClusterTrustBundleLabelSelector>,
    /// Select a single ClusterTrustBundle by object name.  Mutually-exclusive
    /// with signerName and labelSelector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// If true, don't block pod startup if the referenced ClusterTrustBundle(s)
    /// aren't available.  If using name, then the named ClusterTrustBundle is
    /// allowed not to exist.  If using signerName, then the combination of
    /// signerName and labelSelector is allowed to match zero
    /// ClusterTrustBundles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Relative path from the volume root to write the bundle.
    pub path: String,
    /// Select all ClusterTrustBundles that match this signer name.
    /// Mutually-exclusive with name.  The contents of all selected
    /// ClusterTrustBundles will be unified and deduplicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

/// Select all ClusterTrustBundles that match this label selector.  Only has
/// effect if signerName is set.  Mutually-exclusive with name.  If unset,
/// interpreted as "match nothing".  If set but empty, interpreted as "match
/// everything".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesClusterTrustBundleLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdRepoVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// configMap information about the configMap data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesConfigMap {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdRepoVolumesProjectedSourcesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// downwardAPI information about the downwardAPI data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesDownwardApi {
    /// Items is a list of DownwardAPIVolume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdRepoVolumesProjectedSourcesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdRepoVolumesProjectedSourcesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdRepoVolumesProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// secret information about the secret data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesSecret {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdRepoVolumesProjectedSourcesSecretItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional field specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// serviceAccountToken is information about the serviceAccountToken data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesProjectedSourcesServiceAccountToken {
    /// audience is the intended audience of the token. A recipient of a token
    /// must identify itself with an identifier specified in the audience of the
    /// token, and otherwise should reject the token. The audience defaults to the
    /// identifier of the apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// expirationSeconds is the requested duration of validity of the service
    /// account token. As the token approaches expiration, the kubelet volume
    /// plugin will proactively rotate the service account token. The kubelet will
    /// start trying to rotate the token if the token is older than 80 percent of
    /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
    /// and must be at least 10 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    /// path is the path relative to the mount point of the file to project the
    /// token into.
    pub path: String,
}

/// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
/// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesQuobyte {
    /// group to map volume access to
    /// Default is no group
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// readOnly here will force the Quobyte volume to be mounted with read-only permissions.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// registry represents a single or multiple Quobyte Registry services
    /// specified as a string as host:port pair (multiple entries are separated with commas)
    /// which acts as the central registry for volumes
    pub registry: String,
    /// tenant owning the given Quobyte volume in the Backend
    /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant: Option<String>,
    /// user to map volume access to
    /// Defaults to serivceaccount user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// volume is a string that references an already created Quobyte volume by name.
    pub volume: String,
}

/// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
/// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesRbd {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#rbd>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// image is the rados image name.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub image: String,
    /// keyring is the path to key ring for RBDUser.
    /// Default is /etc/ceph/keyring.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyring: Option<String>,
    /// monitors is a collection of Ceph monitors.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// pool is the rados pool name.
    /// Default is rbd.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is name of the authentication secret for RBDUser. If provided
    /// overrides keyring.
    /// Default is nil.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdRepoVolumesRbdSecretRef>,
    /// user is the rados user name.
    /// Default is admin.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is name of the authentication secret for RBDUser. If provided
/// overrides keyring.
/// Default is nil.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesRbdSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
/// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesScaleIo {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// Default is "xfs".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// gateway is the host address of the ScaleIO API Gateway.
    pub gateway: String,
    /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protectionDomain")]
    pub protection_domain: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef references to the secret for ScaleIO user and other
    /// sensitive information. If this is not provided, Login operation will fail.
    #[serde(rename = "secretRef")]
    pub secret_ref: ArgoCdRepoVolumesScaleIoSecretRef,
    /// sslEnabled Flag enable/disable SSL communication with Gateway, default false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslEnabled")]
    pub ssl_enabled: Option<bool>,
    /// storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    /// Default is ThinProvisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageMode")]
    pub storage_mode: Option<String>,
    /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    /// system is the name of the storage system as configured in ScaleIO.
    pub system: String,
    /// volumeName is the name of a volume already created in the ScaleIO system
    /// that is associated with this volume source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// secretRef references to the secret for ScaleIO user and other
/// sensitive information. If this is not provided, Login operation will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesScaleIoSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// secret represents a secret that should populate this volume.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesSecret {
    /// defaultMode is Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values
    /// for mode bits. Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items If unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdRepoVolumesSecretItems>>,
    /// optional field specify whether the Secret or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// secretName is the name of the secret in the pod's namespace to use.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
/// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesStorageos {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef specifies the secret to use for obtaining the StorageOS API
    /// credentials.  If not specified, default values will be attempted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdRepoVolumesStorageosSecretRef>,
    /// volumeName is the human-readable name of the StorageOS volume.  Volume
    /// names are only unique within a namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
    /// volumeNamespace specifies the scope of the volume within StorageOS.  If no
    /// namespace is specified then the Pod's namespace will be used.  This allows the
    /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    /// Set VolumeName to any name to override the default behaviour.
    /// Set to "default" if you are not using namespaces within StorageOS.
    /// Namespaces that do not pre-exist within StorageOS will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeNamespace")]
    pub volume_namespace: Option<String>,
}

/// secretRef specifies the secret to use for obtaining the StorageOS API
/// credentials.  If not specified, default values will be attempted.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesStorageosSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
/// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
/// are redirected to the csi.vsphere.vmware.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdRepoVolumesVsphereVolume {
    /// fsType is filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyID")]
    pub storage_policy_id: Option<String>,
    /// storagePolicyName is the storage Policy Based Management (SPBM) profile name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyName")]
    pub storage_policy_name: Option<String>,
    /// volumePath is the path that identifies vSphere volume vmdk
    #[serde(rename = "volumePath")]
    pub volume_path: String,
}

/// Resource Customization for custom action
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdResourceActions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
}

/// Resource Customization for custom health check
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdResourceHealthChecks {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub check: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
}

/// ResourceIgnoreDifferences customizes resource ignore difference behavior.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdResourceIgnoreDifferences {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<ArgoCdResourceIgnoreDifferencesAll>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceIdentifiers")]
    pub resource_identifiers: Option<Vec<ArgoCdResourceIgnoreDifferencesResourceIdentifiers>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdResourceIgnoreDifferencesAll {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jqPathExpressions")]
    pub jq_path_expressions: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPointers")]
    pub json_pointers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedFieldsManagers")]
    pub managed_fields_managers: Option<Vec<String>>,
}

/// Resource Customization fields for ignore difference
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdResourceIgnoreDifferencesResourceIdentifiers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub customization: Option<ArgoCdResourceIgnoreDifferencesResourceIdentifiersCustomization>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdResourceIgnoreDifferencesResourceIdentifiersCustomization {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jqPathExpressions")]
    pub jq_path_expressions: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jsonPointers")]
    pub json_pointers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "managedFieldsManagers")]
    pub managed_fields_managers: Option<Vec<String>>,
}

/// Server defines the options for the ArgoCD Server component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServer {
    /// Custom annotations to pods deployed by the operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Autoscale defines the autoscale options for the Argo CD Server component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autoscale: Option<ArgoCdServerAutoscale>,
    /// EnableRolloutsUI will add the Argo Rollouts UI extension in ArgoCD Dashboard.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRolloutsUI")]
    pub enable_rollouts_ui: Option<bool>,
    /// Enabled is the flag to enable ArgoCD Server during ArgoCD installation. (optional, default `true`)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Env lets you specify environment for API server pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdServerEnv>>,
    /// Extra Command arguments that would append to the Argo CD server command.
    /// ExtraCommandArgs will not be added, if one of these commands is already part of the server command
    /// with same or different value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraCommandArgs")]
    pub extra_command_args: Option<Vec<String>>,
    /// GRPC defines the state for the Argo CD Server GRPC options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdServerGrpc>,
    /// Host is the hostname to use for Ingress/Route resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Ingress defines the desired state for an Ingress for the Argo CD Server component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<ArgoCdServerIngress>,
    /// InitContainers defines the list of initialization containers for the Argo CD Server component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<ArgoCdServerInitContainers>>,
    /// Insecure toggles the insecure flag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// Custom labels to pods deployed by the operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// LogFormat refers to the log level to be used by the ArgoCD Server component. Defaults to ArgoCDDefaultLogFormat if not configured. Valid options are text or json.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFormat")]
    pub log_format: Option<String>,
    /// LogLevel refers to the log level to be used by the ArgoCD Server component. Defaults to ArgoCDDefaultLogLevel if not set.  Valid options are debug, info, error, and warn.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logLevel")]
    pub log_level: Option<String>,
    /// Replicas defines the number of replicas for argocd-server. Default is nil. Value should be greater than or equal to 0. Value will be ignored if Autoscaler is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Resources defines the Compute Resources required by the container for the Argo CD server component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdServerResources>,
    /// Route defines the desired state for an OpenShift Route for the Argo CD Server component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub route: Option<ArgoCdServerRoute>,
    /// Service defines the options for the Service backing the ArgoCD Server component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<ArgoCdServerService>,
    /// SidecarContainers defines the list of sidecar containers for the server deployment
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sidecarContainers")]
    pub sidecar_containers: Option<Vec<ArgoCdServerSidecarContainers>>,
    /// VolumeMounts adds volumeMounts to the Argo CD Server container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdServerVolumeMounts>>,
    /// Volumes adds volumes to the Argo CD Server container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<ArgoCdServerVolumes>>,
}

/// Autoscale defines the autoscale options for the Argo CD Server component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerAutoscale {
    /// Enabled will toggle autoscaling support for the Argo CD Server component.
    pub enabled: bool,
    /// HPA defines the HorizontalPodAutoscaler options for the Argo CD Server component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hpa: Option<ArgoCdServerAutoscaleHpa>,
}

/// HPA defines the HorizontalPodAutoscaler options for the Argo CD Server component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerAutoscaleHpa {
    /// maxReplicas is the upper limit for the number of pods that can be set by the autoscaler; cannot be smaller than MinReplicas.
    #[serde(rename = "maxReplicas")]
    pub max_replicas: i32,
    /// minReplicas is the lower limit for the number of replicas to which the autoscaler
    /// can scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the
    /// alpha feature gate HPAScaleToZero is enabled and at least one Object or External
    /// metric is configured.  Scaling is active as long as at least one metric value is
    /// available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReplicas")]
    pub min_replicas: Option<i32>,
    /// reference to scaled resource; horizontal pod autoscaler will learn the current resource consumption
    /// and will set the desired number of pods by using its Scale subresource.
    #[serde(rename = "scaleTargetRef")]
    pub scale_target_ref: ArgoCdServerAutoscaleHpaScaleTargetRef,
    /// targetCPUUtilizationPercentage is the target average CPU utilization (represented as a percentage of requested CPU) over all the pods;
    /// if not specified the default autoscaling policy will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetCPUUtilizationPercentage")]
    pub target_cpu_utilization_percentage: Option<i32>,
}

/// reference to scaled resource; horizontal pod autoscaler will learn the current resource consumption
/// and will set the desired number of pods by using its Scale subresource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerAutoscaleHpaScaleTargetRef {
    /// apiVersion is the API version of the referent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// kind is the kind of the referent; More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds>
    pub kind: String,
    /// name is the name of the referent; More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    pub name: String,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdServerEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdServerEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdServerEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdServerEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdServerEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// GRPC defines the state for the Argo CD Server GRPC options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerGrpc {
    /// Host is the hostname to use for Ingress/Route resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Ingress defines the desired state for the Argo CD Server GRPC Ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<ArgoCdServerGrpcIngress>,
}

/// Ingress defines the desired state for the Argo CD Server GRPC Ingress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerGrpcIngress {
    /// Annotations is the map of annotations to apply to the Ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled will toggle the creation of the Ingress.
    pub enabled: bool,
    /// IngressClassName for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Path used for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// TLS configuration. Currently the Ingress only supports a single TLS
    /// port, 443. If multiple members of this list specify different hosts, they
    /// will be multiplexed on the same port according to the hostname specified
    /// through the SNI TLS extension, if the ingress controller fulfilling the
    /// ingress supports SNI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<Vec<ArgoCdServerGrpcIngressTls>>,
}

/// IngressTLS describes the transport layer security associated with an ingress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerGrpcIngressTls {
    /// hosts is a list of hosts included in the TLS certificate. The values in
    /// this list must match the name/s used in the tlsSecret. Defaults to the
    /// wildcard host setting for the loadbalancer controller fulfilling this
    /// Ingress, if left unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    /// secretName is the name of the secret used to terminate TLS traffic on
    /// port 443. Field is left optional to allow TLS routing based on SNI
    /// hostname alone. If the SNI host in a listener conflicts with the "Host"
    /// header field used by an IngressRule, the SNI host is used for termination
    /// and value of the "Host" header is used for routing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Ingress defines the desired state for an Ingress for the Argo CD Server component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerIngress {
    /// Annotations is the map of annotations to apply to the Ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled will toggle the creation of the Ingress.
    pub enabled: bool,
    /// IngressClassName for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressClassName")]
    pub ingress_class_name: Option<String>,
    /// Path used for the Ingress resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// TLS configuration. Currently the Ingress only supports a single TLS
    /// port, 443. If multiple members of this list specify different hosts, they
    /// will be multiplexed on the same port according to the hostname specified
    /// through the SNI TLS extension, if the ingress controller fulfilling the
    /// ingress supports SNI.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<Vec<ArgoCdServerIngressTls>>,
}

/// IngressTLS describes the transport layer security associated with an ingress.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerIngressTls {
    /// hosts is a list of hosts included in the TLS certificate. The values in
    /// this list must match the name/s used in the tlsSecret. Defaults to the
    /// wildcard host setting for the loadbalancer controller fulfilling this
    /// Ingress, if left unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<Vec<String>>,
    /// secretName is the name of the secret used to terminate TLS traffic on
    /// port 443. Field is left optional to allow TLS routing based on SNI
    /// hostname alone. If the SNI host in a listener conflicts with the "Host"
    /// header field used by an IngressRule, the SNI host is used for termination
    /// and value of the "Host" header is used for routing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainers {
    /// Arguments to the entrypoint.
    /// The container image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The container image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdServerInitContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ArgoCdServerInitContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ArgoCdServerInitContainersLifecycle>,
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ArgoCdServerInitContainersLivenessProbe>,
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    pub name: String,
    /// List of ports to expose from the container. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Modifying this array with strategic merge patch may corrupt the data.
    /// For more information See <https://github.com/kubernetes/kubernetes/issues/108255.>
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ArgoCdServerInitContainersPorts>>,
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ArgoCdServerInitContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<ArgoCdServerInitContainersResizePolicy>>,
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdServerInitContainersResources>,
    /// RestartPolicy defines the restart behavior of individual containers in a pod.
    /// This field may only be set for init containers, and the only allowed value is "Always".
    /// For non-init containers or when this field is not specified,
    /// the restart behavior is defined by the Pod's restart policy and the container type.
    /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
    /// this init container will be continually restarted on
    /// exit until all regular containers have terminated. Once all regular
    /// containers have completed, all init containers with restartPolicy "Always"
    /// will be shut down. This lifecycle differs from normal init containers and
    /// is often referred to as a "sidecar" container. Although this init
    /// container still starts in the init container sequence, it does not wait
    /// for the container to complete before proceeding to the next init
    /// container. Instead, the next init container starts immediately after this
    /// init container is started, or after any startupProbe has successfully
    /// completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ArgoCdServerInitContainersSecurityContext>,
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ArgoCdServerInitContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ArgoCdServerInitContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdServerInitContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdServerInitContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdServerInitContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdServerInitContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdServerInitContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdServerInitContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps or Secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ArgoCdServerInitContainersEnvFromConfigMapRef>,
    /// Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdServerInitContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersEnvFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Actions that the management system should take in response to container lifecycle events.
/// Cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ArgoCdServerInitContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ArgoCdServerInitContainersLifecyclePreStop>,
    /// StopSignal defines which signal will be sent to a container when it is being stopped.
    /// If not specified, the default is defined by the container runtime in use.
    /// StopSignal can only be set for Pods with a non-empty .spec.os.name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stopSignal")]
    pub stop_signal: Option<String>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePostStart {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerInitContainersLifecyclePostStartExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerInitContainersLifecyclePostStartHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdServerInitContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerInitContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerInitContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePreStop {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerInitContainersLifecyclePreStopExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerInitContainersLifecyclePreStopHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdServerInitContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerInitContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerInitContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Periodic probe of container liveness.
/// Container will be restarted if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLivenessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerInitContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdServerInitContainersLivenessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerInitContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerInitContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerInitContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Periodic probe of container service readiness.
/// Container will be removed from service endpoints if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersReadinessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerInitContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdServerInitContainersReadinessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerInitContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerInitContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerInitContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Compute Resources required by this container.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdServerInitContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// SecurityContext defines the security options the container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
/// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// appArmorProfile is the AppArmor options to use by this container. If set, this profile
    /// overrides the pod's appArmorProfile.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appArmorProfile")]
    pub app_armor_profile: Option<ArgoCdServerInitContainersSecurityContextAppArmorProfile>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ArgoCdServerInitContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default value is Default which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ArgoCdServerInitContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ArgoCdServerInitContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ArgoCdServerInitContainersSecurityContextWindowsOptions>,
}

/// appArmorProfile is the AppArmor options to use by this container. If set, this profile
/// overrides the pod's appArmorProfile.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersSecurityContextAppArmorProfile {
    /// localhostProfile indicates a profile loaded on the node that should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must match the loaded name of the profile.
    /// Must be set if and only if type is "Localhost".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of AppArmor profile will be applied.
    /// Valid options are:
    ///   Localhost - a profile pre-loaded on the node.
    ///   RuntimeDefault - the container runtime's default profile.
    ///   Unconfined - no AppArmor enforcement.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// StartupProbe indicates that the Pod has successfully initialized.
/// If specified, no other probes are executed until this completes successfully.
/// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
/// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
/// when it might take a long time to load data or warm a cache, than during steady-state operation.
/// This cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersStartupProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerInitContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdServerInitContainersStartupProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerInitContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerInitContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerInitContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerInitContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Resources defines the Compute Resources required by the container for the Argo CD server component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdServerResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// Route defines the desired state for an OpenShift Route for the Argo CD Server component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerRoute {
    /// Annotations is the map of annotations to use for the Route resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Enabled will toggle the creation of the OpenShift Route.
    pub enabled: bool,
    /// Labels is the map of labels to use for the Route resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Path the router watches for, to route traffic for to the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// TLS provides the ability to configure certificates and termination for the Route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ArgoCdServerRouteTls>,
    /// WildcardPolicy if any for the route. Currently only 'Subdomain' or 'None' is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wildcardPolicy")]
    pub wildcard_policy: Option<String>,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ArgoCdServerRouteTls {
    /// caCertificate provides the cert authority certificate contents
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertificate")]
    pub ca_certificate: Option<String>,
    /// certificate provides certificate contents. This should be a single serving certificate, not a certificate
    /// chain. Do not include a CA certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    /// destinationCACertificate provides the contents of the ca certificate of the final destination.  When using reencrypt
    /// termination this file should be provided in order to have routers use it for health checks on the secure connection.
    /// If this field is not specified, the router may provide its own destination CA and perform hostname validation using
    /// the short service name (service.namespace.svc), which allows infrastructure generated certificates to automatically
    /// verify.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "destinationCACertificate")]
    pub destination_ca_certificate: Option<String>,
    /// externalCertificate provides certificate contents as a secret reference.
    /// This should be a single serving certificate, not a certificate
    /// chain. Do not include a CA certificate. The secret referenced should
    /// be present in the same namespace as that of the Route.
    /// Forbidden when `certificate` is set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalCertificate")]
    pub external_certificate: Option<ArgoCdServerRouteTlsExternalCertificate>,
    /// insecureEdgeTerminationPolicy indicates the desired behavior for insecure connections to a route. While
    /// each router may make its own decisions on which ports to expose, this is normally port 80.
    /// 
    /// * Allow - traffic is sent to the server on the insecure port (edge/reencrypt terminations only) (default).
    /// * None - no traffic is allowed on the insecure port.
    /// * Redirect - clients are redirected to the secure port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureEdgeTerminationPolicy")]
    pub insecure_edge_termination_policy: Option<ArgoCdServerRouteTlsInsecureEdgeTerminationPolicy>,
    /// key provides key file contents
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// termination indicates termination type.
    /// 
    /// * edge - TLS termination is done by the router and http is used to communicate with the backend (default)
    /// * passthrough - Traffic is sent straight to the destination without the router providing TLS termination
    /// * reencrypt - TLS termination is done by the router and https is used to communicate with the backend
    /// 
    /// Note: passthrough termination is incompatible with httpHeader actions
    pub termination: ArgoCdServerRouteTlsTermination,
}

/// externalCertificate provides certificate contents as a secret reference.
/// This should be a single serving certificate, not a certificate
/// chain. Do not include a CA certificate. The secret referenced should
/// be present in the same namespace as that of the Route.
/// Forbidden when `certificate` is set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerRouteTlsExternalCertificate {
    /// name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdServerRouteTlsInsecureEdgeTerminationPolicy {
    Allow,
    None,
    Redirect,
    #[serde(rename = "")]
    KopiumEmpty,
}

/// TLS provides the ability to configure certificates and termination for the Route.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ArgoCdServerRouteTlsTermination {
    #[serde(rename = "edge")]
    Edge,
    #[serde(rename = "reencrypt")]
    Reencrypt,
    #[serde(rename = "passthrough")]
    Passthrough,
}

/// Service defines the options for the Service backing the ArgoCD Server component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerService {
    /// Type is the ServiceType to use for the Service resource.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainers {
    /// Arguments to the entrypoint.
    /// The container image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The container image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdServerSidecarContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ArgoCdServerSidecarContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ArgoCdServerSidecarContainersLifecycle>,
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ArgoCdServerSidecarContainersLivenessProbe>,
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    pub name: String,
    /// List of ports to expose from the container. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Modifying this array with strategic merge patch may corrupt the data.
    /// For more information See <https://github.com/kubernetes/kubernetes/issues/108255.>
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ArgoCdServerSidecarContainersPorts>>,
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ArgoCdServerSidecarContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<ArgoCdServerSidecarContainersResizePolicy>>,
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdServerSidecarContainersResources>,
    /// RestartPolicy defines the restart behavior of individual containers in a pod.
    /// This field may only be set for init containers, and the only allowed value is "Always".
    /// For non-init containers or when this field is not specified,
    /// the restart behavior is defined by the Pod's restart policy and the container type.
    /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
    /// this init container will be continually restarted on
    /// exit until all regular containers have terminated. Once all regular
    /// containers have completed, all init containers with restartPolicy "Always"
    /// will be shut down. This lifecycle differs from normal init containers and
    /// is often referred to as a "sidecar" container. Although this init
    /// container still starts in the init container sequence, it does not wait
    /// for the container to complete before proceeding to the next init
    /// container. Instead, the next init container starts immediately after this
    /// init container is started, or after any startupProbe has successfully
    /// completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ArgoCdServerSidecarContainersSecurityContext>,
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ArgoCdServerSidecarContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ArgoCdServerSidecarContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdServerSidecarContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdServerSidecarContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdServerSidecarContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdServerSidecarContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdServerSidecarContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdServerSidecarContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps or Secrets
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ArgoCdServerSidecarContainersEnvFromConfigMapRef>,
    /// Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdServerSidecarContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersEnvFromSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Actions that the management system should take in response to container lifecycle events.
/// Cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ArgoCdServerSidecarContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ArgoCdServerSidecarContainersLifecyclePreStop>,
    /// StopSignal defines which signal will be sent to a container when it is being stopped.
    /// If not specified, the default is defined by the container runtime in use.
    /// StopSignal can only be set for Pods with a non-empty .spec.os.name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stopSignal")]
    pub stop_signal: Option<String>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePostStart {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerSidecarContainersLifecyclePostStartExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerSidecarContainersLifecyclePostStartHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdServerSidecarContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerSidecarContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerSidecarContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePreStop {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerSidecarContainersLifecyclePreStopExec>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerSidecarContainersLifecyclePreStopHttpGet>,
    /// Sleep represents a duration that the container should sleep.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ArgoCdServerSidecarContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for backward compatibility. There is no validation of this field and
    /// lifecycle hooks will fail at runtime when it is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerSidecarContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerSidecarContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents a duration that the container should sleep.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for backward compatibility. There is no validation of this field and
/// lifecycle hooks will fail at runtime when it is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Periodic probe of container liveness.
/// Container will be restarted if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLivenessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerSidecarContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdServerSidecarContainersLivenessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerSidecarContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerSidecarContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerSidecarContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Periodic probe of container service readiness.
/// Container will be removed from service endpoints if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersReadinessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerSidecarContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdServerSidecarContainersReadinessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerSidecarContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerSidecarContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerSidecarContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Compute Resources required by this container.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdServerSidecarContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// SecurityContext defines the security options the container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
/// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// appArmorProfile is the AppArmor options to use by this container. If set, this profile
    /// overrides the pod's appArmorProfile.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appArmorProfile")]
    pub app_armor_profile: Option<ArgoCdServerSidecarContainersSecurityContextAppArmorProfile>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ArgoCdServerSidecarContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default value is Default which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ArgoCdServerSidecarContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ArgoCdServerSidecarContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ArgoCdServerSidecarContainersSecurityContextWindowsOptions>,
}

/// appArmorProfile is the AppArmor options to use by this container. If set, this profile
/// overrides the pod's appArmorProfile.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersSecurityContextAppArmorProfile {
    /// localhostProfile indicates a profile loaded on the node that should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must match the loaded name of the profile.
    /// Must be set if and only if type is "Localhost".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of AppArmor profile will be applied.
    /// Valid options are:
    ///   Localhost - a profile pre-loaded on the node.
    ///   RuntimeDefault - the container runtime's default profile.
    ///   Unconfined - no AppArmor enforcement.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// StartupProbe indicates that the Pod has successfully initialized.
/// If specified, no other probes are executed until this completes successfully.
/// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
/// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
/// when it might take a long time to load data or warm a cache, than during steady-state operation.
/// This cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersStartupProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ArgoCdServerSidecarContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ArgoCdServerSidecarContainersStartupProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ArgoCdServerSidecarContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ArgoCdServerSidecarContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ArgoCdServerSidecarContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerSidecarContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumes {
    /// awsElasticBlockStore represents an AWS Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
    /// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsElasticBlockStore")]
    pub aws_elastic_block_store: Option<ArgoCdServerVolumesAwsElasticBlockStore>,
    /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
    /// are redirected to the disk.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureDisk")]
    pub azure_disk: Option<ArgoCdServerVolumesAzureDisk>,
    /// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
    /// are redirected to the file.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureFile")]
    pub azure_file: Option<ArgoCdServerVolumesAzureFile>,
    /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
    /// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephfs: Option<ArgoCdServerVolumesCephfs>,
    /// cinder represents a cinder volume attached and mounted on kubelets host machine.
    /// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
    /// are redirected to the cinder.csi.openstack.org CSI driver.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cinder: Option<ArgoCdServerVolumesCinder>,
    /// configMap represents a configMap that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdServerVolumesConfigMap>,
    /// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<ArgoCdServerVolumesCsi>,
    /// downwardAPI represents downward API about the pod that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdServerVolumesDownwardApi>,
    /// emptyDir represents a temporary directory that shares a pod's lifetime.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<ArgoCdServerVolumesEmptyDir>,
    /// ephemeral represents a volume that is handled by a cluster storage driver.
    /// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    /// and deleted when the pod is removed.
    /// 
    /// Use this if:
    /// a) the volume is only needed while the pod runs,
    /// b) features of normal volumes like restoring from snapshot or capacity
    ///    tracking are needed,
    /// c) the storage driver is specified through a storage class, and
    /// d) the storage driver supports dynamic volume provisioning through
    ///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
    ///    information on the connection between this volume type
    ///    and PersistentVolumeClaim).
    /// 
    /// Use PersistentVolumeClaim or one of the vendor-specific
    /// APIs for volumes that persist for longer than the lifecycle
    /// of an individual pod.
    /// 
    /// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    /// be used that way - see the documentation of the driver for
    /// more information.
    /// 
    /// A pod can use both types of ephemeral volumes and
    /// persistent volumes at the same time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<ArgoCdServerVolumesEphemeral>,
    /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fc: Option<ArgoCdServerVolumesFc>,
    /// flexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flexVolume")]
    pub flex_volume: Option<ArgoCdServerVolumesFlexVolume>,
    /// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
    /// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flocker: Option<ArgoCdServerVolumesFlocker>,
    /// gcePersistentDisk represents a GCE Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
    /// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDisk")]
    pub gce_persistent_disk: Option<ArgoCdServerVolumesGcePersistentDisk>,
    /// gitRepo represents a git repository at a particular revision.
    /// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    /// into the Pod's container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitRepo")]
    pub git_repo: Option<ArgoCdServerVolumesGitRepo>,
    /// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    /// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glusterfs: Option<ArgoCdServerVolumesGlusterfs>,
    /// hostPath represents a pre-existing file or directory on the host
    /// machine that is directly exposed to the container. This is generally
    /// used for system agents or other privileged things that are allowed
    /// to see the host machine. Most containers will NOT need this.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<ArgoCdServerVolumesHostPath>,
    /// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
    /// The volume is resolved at pod startup depending on which PullPolicy value is provided:
    /// 
    /// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// 
    /// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
    /// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
    /// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
    /// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
    /// The volume will be mounted read-only (ro) and non-executable files (noexec).
    /// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
    /// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<ArgoCdServerVolumesImage>,
    /// iscsi represents an ISCSI Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iscsi: Option<ArgoCdServerVolumesIscsi>,
    /// name of the volume.
    /// Must be a DNS_LABEL and unique within the pod.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    pub name: String,
    /// nfs represents an NFS mount on the host that shares a pod's lifetime
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nfs: Option<ArgoCdServerVolumesNfs>,
    /// persistentVolumeClaimVolumeSource represents a reference to a
    /// PersistentVolumeClaim in the same namespace.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<ArgoCdServerVolumesPersistentVolumeClaim>,
    /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
    /// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "photonPersistentDisk")]
    pub photon_persistent_disk: Option<ArgoCdServerVolumesPhotonPersistentDisk>,
    /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
    /// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
    /// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
    /// is on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portworxVolume")]
    pub portworx_volume: Option<ArgoCdServerVolumesPortworxVolume>,
    /// projected items for all in one resources secrets, configmaps, and downward API
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<ArgoCdServerVolumesProjected>,
    /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
    /// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quobyte: Option<ArgoCdServerVolumesQuobyte>,
    /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
    /// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbd: Option<ArgoCdServerVolumesRbd>,
    /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    /// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scaleIO")]
    pub scale_io: Option<ArgoCdServerVolumesScaleIo>,
    /// secret represents a secret that should populate this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdServerVolumesSecret>,
    /// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    /// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storageos: Option<ArgoCdServerVolumesStorageos>,
    /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
    /// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
    /// are redirected to the csi.vsphere.vmware.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vsphereVolume")]
    pub vsphere_volume: Option<ArgoCdServerVolumesVsphereVolume>,
}

/// awsElasticBlockStore represents an AWS Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
/// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesAwsElasticBlockStore {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// readOnly value true will force the readOnly setting in VolumeMounts.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
/// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
/// are redirected to the disk.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesAzureDisk {
    /// cachingMode is the Host Caching mode: None, Read Only, Read Write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachingMode")]
    pub caching_mode: Option<String>,
    /// diskName is the Name of the data disk in the blob storage
    #[serde(rename = "diskName")]
    pub disk_name: String,
    /// diskURI is the URI of data disk in the blob storage
    #[serde(rename = "diskURI")]
    pub disk_uri: String,
    /// fsType is Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
/// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
/// are redirected to the file.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesAzureFile {
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretName is the  name of secret that contains Azure Storage Account Name and Key
    #[serde(rename = "secretName")]
    pub secret_name: String,
    /// shareName is the azure share Name
    #[serde(rename = "shareName")]
    pub share_name: String,
}

/// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
/// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesCephfs {
    /// monitors is Required: Monitors is a collection of Ceph monitors
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretFile")]
    pub secret_file: Option<String>,
    /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdServerVolumesCephfsSecretRef>,
    /// user is optional: User is the rados user name, default is admin
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
/// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesCephfsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// cinder represents a cinder volume attached and mounted on kubelets host machine.
/// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
/// are redirected to the cinder.csi.openstack.org CSI driver.
/// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesCinder {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is optional: points to a secret object containing parameters used to connect
    /// to OpenStack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdServerVolumesCinderSecretRef>,
    /// volumeID used to identify the volume in cinder.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// secretRef is optional: points to a secret object containing parameters used to connect
/// to OpenStack.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesCinderSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// configMap represents a configMap that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesConfigMap {
    /// defaultMode is optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdServerVolumesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesCsi {
    /// driver is the name of the CSI driver that handles this volume.
    /// Consult with your admin for the correct name as registered in the cluster.
    pub driver: String,
    /// fsType to mount. Ex. "ext4", "xfs", "ntfs".
    /// If not provided, the empty value is passed to the associated CSI driver
    /// which will determine the default filesystem to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// nodePublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// NodePublishVolume and NodeUnpublishVolume calls.
    /// This field is optional, and  may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secret references are passed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePublishSecretRef")]
    pub node_publish_secret_ref: Option<ArgoCdServerVolumesCsiNodePublishSecretRef>,
    /// readOnly specifies a read-only configuration for the volume.
    /// Defaults to false (read/write).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeAttributes stores driver-specific properties that are passed to the CSI
    /// driver. Consult your driver's documentation for supported values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributes")]
    pub volume_attributes: Option<BTreeMap<String, String>>,
}

/// nodePublishSecretRef is a reference to the secret object containing
/// sensitive information to pass to the CSI driver to complete the CSI
/// NodePublishVolume and NodeUnpublishVolume calls.
/// This field is optional, and  may be empty if no secret is required. If the
/// secret object contains more than one secret, all secret references are passed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesCsiNodePublishSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// downwardAPI represents downward API about the pod that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesDownwardApi {
    /// Optional: mode bits to use on created files by default. Must be a
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// Items is a list of downward API volume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdServerVolumesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdServerVolumesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdServerVolumesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// emptyDir represents a temporary directory that shares a pod's lifetime.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEmptyDir {
    /// medium represents what type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

/// ephemeral represents a volume that is handled by a cluster storage driver.
/// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
/// and deleted when the pod is removed.
/// 
/// Use this if:
/// a) the volume is only needed while the pod runs,
/// b) features of normal volumes like restoring from snapshot or capacity
///    tracking are needed,
/// c) the storage driver is specified through a storage class, and
/// d) the storage driver supports dynamic volume provisioning through
///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
///    information on the connection between this volume type
///    and PersistentVolumeClaim).
/// 
/// Use PersistentVolumeClaim or one of the vendor-specific
/// APIs for volumes that persist for longer than the lifecycle
/// of an individual pod.
/// 
/// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
/// be used that way - see the documentation of the driver for
/// more information.
/// 
/// A pod can use both types of ephemeral volumes and
/// persistent volumes at the same time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEphemeral {
    /// Will be used to create a stand-alone PVC to provision the volume.
    /// The pod in which this EphemeralVolumeSource is embedded will be the
    /// owner of the PVC, i.e. the PVC will be deleted together with the
    /// pod.  The name of the PVC will be `<pod name>-<volume name>` where
    /// `<volume name>` is the name from the `PodSpec.Volumes` array
    /// entry. Pod validation will reject the pod if the concatenated name
    /// is not valid for a PVC (for example, too long).
    /// 
    /// An existing PVC with that name that is not owned by the pod
    /// will *not* be used for the pod to avoid using an unrelated
    /// volume by mistake. Starting the pod is then blocked until
    /// the unrelated PVC is removed. If such a pre-created PVC is
    /// meant to be used by the pod, the PVC has to updated with an
    /// owner reference to the pod once the pod exists. Normally
    /// this should not be necessary, but it may be useful when
    /// manually reconstructing a broken cluster.
    /// 
    /// This field is read-only and no changes will be made by Kubernetes
    /// to the PVC after it has been created.
    /// 
    /// Required, must not be nil.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<ArgoCdServerVolumesEphemeralVolumeClaimTemplate>,
}

/// Will be used to create a stand-alone PVC to provision the volume.
/// The pod in which this EphemeralVolumeSource is embedded will be the
/// owner of the PVC, i.e. the PVC will be deleted together with the
/// pod.  The name of the PVC will be `<pod name>-<volume name>` where
/// `<volume name>` is the name from the `PodSpec.Volumes` array
/// entry. Pod validation will reject the pod if the concatenated name
/// is not valid for a PVC (for example, too long).
/// 
/// An existing PVC with that name that is not owned by the pod
/// will *not* be used for the pod to avoid using an unrelated
/// volume by mistake. Starting the pod is then blocked until
/// the unrelated PVC is removed. If such a pre-created PVC is
/// meant to be used by the pod, the PVC has to updated with an
/// owner reference to the pod once the pod exists. Normally
/// this should not be necessary, but it may be useful when
/// manually reconstructing a broken cluster.
/// 
/// This field is read-only and no changes will be made by Kubernetes
/// to the PVC after it has been created.
/// 
/// Required, must not be nil.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEphemeralVolumeClaimTemplate {
    /// May contain labels and annotations that will be copied into the PVC
    /// when creating it. No other fields are allowed and will be rejected during
    /// validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ArgoCdServerVolumesEphemeralVolumeClaimTemplateMetadata>,
    /// The specification for the PersistentVolumeClaim. The entire content is
    /// copied unchanged into the PVC that gets created from this
    /// template. The same fields as in a PersistentVolumeClaim
    /// are also valid here.
    pub spec: ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpec,
}

/// May contain labels and annotations that will be copied into the PVC
/// when creating it. No other fields are allowed and will be rejected during
/// validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEphemeralVolumeClaimTemplateMetadata {
}

/// The specification for the PersistentVolumeClaim. The entire content is
/// copied unchanged into the PVC that gets created from this
/// template. The same fields as in a PersistentVolumeClaim
/// are also valid here.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    /// (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesFc {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// lun is Optional: FC target lun number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lun: Option<i32>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// targetWWNs is Optional: FC target worldwide names (WWNs)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetWWNs")]
    pub target_ww_ns: Option<Vec<String>>,
    /// wwids Optional: FC volume world wide identifiers (wwids)
    /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wwids: Option<Vec<String>>,
}

/// flexVolume represents a generic volume resource that is
/// provisioned/attached using an exec based plugin.
/// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesFlexVolume {
    /// driver is the name of the driver to use for this volume.
    pub driver: String,
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// options is Optional: this field holds extra command options if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<BTreeMap<String, String>>,
    /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is Optional: secretRef is reference to the secret object containing
    /// sensitive information to pass to the plugin scripts. This may be
    /// empty if no secret object is specified. If the secret object
    /// contains more than one secret, all secrets are passed to the plugin
    /// scripts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdServerVolumesFlexVolumeSecretRef>,
}

/// secretRef is Optional: secretRef is reference to the secret object containing
/// sensitive information to pass to the plugin scripts. This may be
/// empty if no secret object is specified. If the secret object
/// contains more than one secret, all secrets are passed to the plugin
/// scripts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesFlexVolumeSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
/// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesFlocker {
    /// datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
    /// should be considered as deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetName")]
    pub dataset_name: Option<String>,
    /// datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetUUID")]
    pub dataset_uuid: Option<String>,
}

/// gcePersistentDisk represents a GCE Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
/// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesGcePersistentDisk {
    /// fsType is filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(rename = "pdName")]
    pub pd_name: String,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// gitRepo represents a git repository at a particular revision.
/// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
/// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
/// into the Pod's container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesGitRepo {
    /// directory is the target directory name.
    /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    /// git repository.  Otherwise, if specified, the volume will contain the git repository in
    /// the subdirectory with the given name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    /// repository is the URL
    pub repository: String,
    /// revision is the commit hash for the specified revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub revision: Option<String>,
}

/// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
/// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesGlusterfs {
    /// endpoints is the endpoint name that details Glusterfs topology.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub endpoints: String,
    /// path is the Glusterfs volume path.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub path: String,
    /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// hostPath represents a pre-existing file or directory on the host
/// machine that is directly exposed to the container. This is generally
/// used for system agents or other privileged things that are allowed
/// to see the host machine. Most containers will NOT need this.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesHostPath {
    /// path of the directory on the host.
    /// If the path is a symlink, it will follow the link to the real path.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    pub path: String,
    /// type for HostPath Volume
    /// Defaults to ""
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
/// The volume is resolved at pod startup depending on which PullPolicy value is provided:
/// 
/// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
/// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
/// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
/// 
/// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
/// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
/// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
/// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
/// The volume will be mounted read-only (ro) and non-executable files (noexec).
/// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
/// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesImage {
    /// Policy for pulling OCI objects. Possible values are:
    /// Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// Required: Image or artifact reference to be used.
    /// Behaves in the same way as pod.spec.containers[*].image.
    /// Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reference: Option<String>,
}

/// iscsi represents an ISCSI Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesIscsi {
    /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthDiscovery")]
    pub chap_auth_discovery: Option<bool>,
    /// chapAuthSession defines whether support iSCSI Session CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthSession")]
    pub chap_auth_session: Option<bool>,
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#iscsi>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// initiatorName is the custom iSCSI Initiator Name.
    /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    /// <target portal>:<volume name> will be created for the connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initiatorName")]
    pub initiator_name: Option<String>,
    /// iqn is the target iSCSI Qualified Name.
    pub iqn: String,
    /// iscsiInterface is the interface Name that uses an iSCSI transport.
    /// Defaults to 'default' (tcp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iscsiInterface")]
    pub iscsi_interface: Option<String>,
    /// lun represents iSCSI Target Lun number.
    pub lun: i32,
    /// portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub portals: Option<Vec<String>>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdServerVolumesIscsiSecretRef>,
    /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(rename = "targetPortal")]
    pub target_portal: String,
}

/// secretRef is the CHAP Secret for iSCSI target and initiator authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesIscsiSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// nfs represents an NFS mount on the host that shares a pod's lifetime
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesNfs {
    /// path that is exported by the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub path: String,
    /// readOnly here will force the NFS export to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// server is the hostname or IP address of the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub server: String,
}

/// persistentVolumeClaimVolumeSource represents a reference to a
/// PersistentVolumeClaim in the same namespace.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesPersistentVolumeClaim {
    /// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(rename = "claimName")]
    pub claim_name: String,
    /// readOnly Will force the ReadOnly setting in VolumeMounts.
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
/// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesPhotonPersistentDisk {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// pdID is the ID that identifies Photon Controller persistent disk
    #[serde(rename = "pdID")]
    pub pd_id: String,
}

/// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
/// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
/// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
/// is on.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesPortworxVolume {
    /// fSType represents the filesystem type to mount
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID uniquely identifies a Portworx volume
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// projected items for all in one resources secrets, configmaps, and downward API
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjected {
    /// defaultMode are the mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// sources is the list of volume projections. Each entry in this list
    /// handles one source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ArgoCdServerVolumesProjectedSources>>,
}

/// Projection that may be projected along with other supported volume types.
/// Exactly one of these fields must be set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSources {
    /// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
    /// of ClusterTrustBundle objects in an auto-updating file.
    /// 
    /// Alpha, gated by the ClusterTrustBundleProjection feature gate.
    /// 
    /// ClusterTrustBundle objects can either be selected by name, or by the
    /// combination of signer name and a label selector.
    /// 
    /// Kubelet performs aggressive normalization of the PEM contents written
    /// into the pod filesystem.  Esoteric PEM features such as inter-block
    /// comments and block headers are stripped.  Certificates are deduplicated.
    /// The ordering of certificates within the file is arbitrary, and Kubelet
    /// may change the order over time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<ArgoCdServerVolumesProjectedSourcesClusterTrustBundle>,
    /// configMap information about the configMap data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdServerVolumesProjectedSourcesConfigMap>,
    /// downwardAPI information about the downwardAPI data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdServerVolumesProjectedSourcesDownwardApi>,
    /// secret information about the secret data to project
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdServerVolumesProjectedSourcesSecret>,
    /// serviceAccountToken is information about the serviceAccountToken data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<ArgoCdServerVolumesProjectedSourcesServiceAccountToken>,
}

/// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
/// of ClusterTrustBundle objects in an auto-updating file.
/// 
/// Alpha, gated by the ClusterTrustBundleProjection feature gate.
/// 
/// ClusterTrustBundle objects can either be selected by name, or by the
/// combination of signer name and a label selector.
/// 
/// Kubelet performs aggressive normalization of the PEM contents written
/// into the pod filesystem.  Esoteric PEM features such as inter-block
/// comments and block headers are stripped.  Certificates are deduplicated.
/// The ordering of certificates within the file is arbitrary, and Kubelet
/// may change the order over time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesClusterTrustBundle {
    /// Select all ClusterTrustBundles that match this label selector.  Only has
    /// effect if signerName is set.  Mutually-exclusive with name.  If unset,
    /// interpreted as "match nothing".  If set but empty, interpreted as "match
    /// everything".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ArgoCdServerVolumesProjectedSourcesClusterTrustBundleLabelSelector>,
    /// Select a single ClusterTrustBundle by object name.  Mutually-exclusive
    /// with signerName and labelSelector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// If true, don't block pod startup if the referenced ClusterTrustBundle(s)
    /// aren't available.  If using name, then the named ClusterTrustBundle is
    /// allowed not to exist.  If using signerName, then the combination of
    /// signerName and labelSelector is allowed to match zero
    /// ClusterTrustBundles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Relative path from the volume root to write the bundle.
    pub path: String,
    /// Select all ClusterTrustBundles that match this signer name.
    /// Mutually-exclusive with name.  The contents of all selected
    /// ClusterTrustBundles will be unified and deduplicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

/// Select all ClusterTrustBundles that match this label selector.  Only has
/// effect if signerName is set.  Mutually-exclusive with name.  If unset,
/// interpreted as "match nothing".  If set but empty, interpreted as "match
/// everything".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesClusterTrustBundleLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdServerVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// configMap information about the configMap data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesConfigMap {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdServerVolumesProjectedSourcesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// downwardAPI information about the downwardAPI data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesDownwardApi {
    /// Items is a list of DownwardAPIVolume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdServerVolumesProjectedSourcesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdServerVolumesProjectedSourcesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdServerVolumesProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// secret information about the secret data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesSecret {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdServerVolumesProjectedSourcesSecretItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional field specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// serviceAccountToken is information about the serviceAccountToken data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesProjectedSourcesServiceAccountToken {
    /// audience is the intended audience of the token. A recipient of a token
    /// must identify itself with an identifier specified in the audience of the
    /// token, and otherwise should reject the token. The audience defaults to the
    /// identifier of the apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// expirationSeconds is the requested duration of validity of the service
    /// account token. As the token approaches expiration, the kubelet volume
    /// plugin will proactively rotate the service account token. The kubelet will
    /// start trying to rotate the token if the token is older than 80 percent of
    /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
    /// and must be at least 10 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    /// path is the path relative to the mount point of the file to project the
    /// token into.
    pub path: String,
}

/// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
/// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesQuobyte {
    /// group to map volume access to
    /// Default is no group
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// readOnly here will force the Quobyte volume to be mounted with read-only permissions.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// registry represents a single or multiple Quobyte Registry services
    /// specified as a string as host:port pair (multiple entries are separated with commas)
    /// which acts as the central registry for volumes
    pub registry: String,
    /// tenant owning the given Quobyte volume in the Backend
    /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant: Option<String>,
    /// user to map volume access to
    /// Defaults to serivceaccount user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// volume is a string that references an already created Quobyte volume by name.
    pub volume: String,
}

/// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
/// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesRbd {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#rbd>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// image is the rados image name.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub image: String,
    /// keyring is the path to key ring for RBDUser.
    /// Default is /etc/ceph/keyring.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyring: Option<String>,
    /// monitors is a collection of Ceph monitors.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// pool is the rados pool name.
    /// Default is rbd.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is name of the authentication secret for RBDUser. If provided
    /// overrides keyring.
    /// Default is nil.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdServerVolumesRbdSecretRef>,
    /// user is the rados user name.
    /// Default is admin.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is name of the authentication secret for RBDUser. If provided
/// overrides keyring.
/// Default is nil.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesRbdSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
/// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesScaleIo {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// Default is "xfs".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// gateway is the host address of the ScaleIO API Gateway.
    pub gateway: String,
    /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protectionDomain")]
    pub protection_domain: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef references to the secret for ScaleIO user and other
    /// sensitive information. If this is not provided, Login operation will fail.
    #[serde(rename = "secretRef")]
    pub secret_ref: ArgoCdServerVolumesScaleIoSecretRef,
    /// sslEnabled Flag enable/disable SSL communication with Gateway, default false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslEnabled")]
    pub ssl_enabled: Option<bool>,
    /// storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    /// Default is ThinProvisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageMode")]
    pub storage_mode: Option<String>,
    /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    /// system is the name of the storage system as configured in ScaleIO.
    pub system: String,
    /// volumeName is the name of a volume already created in the ScaleIO system
    /// that is associated with this volume source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// secretRef references to the secret for ScaleIO user and other
/// sensitive information. If this is not provided, Login operation will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesScaleIoSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// secret represents a secret that should populate this volume.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesSecret {
    /// defaultMode is Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values
    /// for mode bits. Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items If unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdServerVolumesSecretItems>>,
    /// optional field specify whether the Secret or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// secretName is the name of the secret in the pod's namespace to use.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
/// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesStorageos {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef specifies the secret to use for obtaining the StorageOS API
    /// credentials.  If not specified, default values will be attempted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdServerVolumesStorageosSecretRef>,
    /// volumeName is the human-readable name of the StorageOS volume.  Volume
    /// names are only unique within a namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
    /// volumeNamespace specifies the scope of the volume within StorageOS.  If no
    /// namespace is specified then the Pod's namespace will be used.  This allows the
    /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    /// Set VolumeName to any name to override the default behaviour.
    /// Set to "default" if you are not using namespaces within StorageOS.
    /// Namespaces that do not pre-exist within StorageOS will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeNamespace")]
    pub volume_namespace: Option<String>,
}

/// secretRef specifies the secret to use for obtaining the StorageOS API
/// credentials.  If not specified, default values will be attempted.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesStorageosSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
/// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
/// are redirected to the csi.vsphere.vmware.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdServerVolumesVsphereVolume {
    /// fsType is filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyID")]
    pub storage_policy_id: Option<String>,
    /// storagePolicyName is the storage Policy Based Management (SPBM) profile name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyName")]
    pub storage_policy_name: Option<String>,
    /// volumePath is the path that identifies vSphere volume vmdk
    #[serde(rename = "volumePath")]
    pub volume_path: String,
}

/// SSO defines the Single Sign-on configuration for Argo CD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSso {
    /// Dex contains the configuration for Argo CD dex authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dex: Option<ArgoCdSsoDex>,
    /// Keycloak contains the configuration for Argo CD keycloak authentication
    /// Removed: This field is no longer supported and the related functionality has been removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keycloak: Option<ArgoCdSsoKeycloak>,
    /// Provider installs and configures the given SSO Provider with Argo CD.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
}

/// Dex contains the configuration for Argo CD dex authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDex {
    /// Config is the dex connector configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<String>,
    /// Env lets you specify environment variables for Dex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ArgoCdSsoDexEnv>>,
    /// Optional list of required groups a user must be a member of
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
    /// Image is the Dex container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// OpenShiftOAuth enables OpenShift OAuth authentication for the Dex server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openShiftOAuth")]
    pub open_shift_o_auth: Option<bool>,
    /// Resources defines the Compute Resources required by the container for Dex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdSsoDexResources>,
    /// Version is the Dex container image tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// VolumeMounts adds volumeMounts to the dex server container
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ArgoCdSsoDexVolumeMounts>>,
    /// Volumes adds volumes to the dex server container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<ArgoCdSsoDexVolumes>>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ArgoCdSsoDexEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ArgoCdSsoDexEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdSsoDexEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdSsoDexEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ArgoCdSsoDexEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Resources defines the Compute Resources required by the container for Dex.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdSsoDexResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    /// (which defaults to None).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// RecursiveReadOnly specifies whether read-only mounts should be handled
    /// recursively.
    /// 
    /// If ReadOnly is false, this field has no meaning and must be unspecified.
    /// 
    /// If ReadOnly is true, and this field is set to Disabled, the mount is not made
    /// recursively read-only.  If this field is set to IfPossible, the mount is made
    /// recursively read-only, if it is supported by the container runtime.  If this
    /// field is set to Enabled, the mount is made recursively read-only if it is
    /// supported by the container runtime, otherwise the pod will not be started and
    /// an error will be generated to indicate the reason.
    /// 
    /// If this field is set to IfPossible or Enabled, MountPropagation must be set to
    /// None (or be unspecified, which defaults to None).
    /// 
    /// If this field is not specified, it is treated as an equivalent of Disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recursiveReadOnly")]
    pub recursive_read_only: Option<String>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumes {
    /// awsElasticBlockStore represents an AWS Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
    /// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsElasticBlockStore")]
    pub aws_elastic_block_store: Option<ArgoCdSsoDexVolumesAwsElasticBlockStore>,
    /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
    /// are redirected to the disk.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureDisk")]
    pub azure_disk: Option<ArgoCdSsoDexVolumesAzureDisk>,
    /// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
    /// are redirected to the file.csi.azure.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureFile")]
    pub azure_file: Option<ArgoCdSsoDexVolumesAzureFile>,
    /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
    /// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephfs: Option<ArgoCdSsoDexVolumesCephfs>,
    /// cinder represents a cinder volume attached and mounted on kubelets host machine.
    /// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
    /// are redirected to the cinder.csi.openstack.org CSI driver.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cinder: Option<ArgoCdSsoDexVolumesCinder>,
    /// configMap represents a configMap that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdSsoDexVolumesConfigMap>,
    /// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<ArgoCdSsoDexVolumesCsi>,
    /// downwardAPI represents downward API about the pod that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdSsoDexVolumesDownwardApi>,
    /// emptyDir represents a temporary directory that shares a pod's lifetime.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<ArgoCdSsoDexVolumesEmptyDir>,
    /// ephemeral represents a volume that is handled by a cluster storage driver.
    /// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    /// and deleted when the pod is removed.
    /// 
    /// Use this if:
    /// a) the volume is only needed while the pod runs,
    /// b) features of normal volumes like restoring from snapshot or capacity
    ///    tracking are needed,
    /// c) the storage driver is specified through a storage class, and
    /// d) the storage driver supports dynamic volume provisioning through
    ///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
    ///    information on the connection between this volume type
    ///    and PersistentVolumeClaim).
    /// 
    /// Use PersistentVolumeClaim or one of the vendor-specific
    /// APIs for volumes that persist for longer than the lifecycle
    /// of an individual pod.
    /// 
    /// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    /// be used that way - see the documentation of the driver for
    /// more information.
    /// 
    /// A pod can use both types of ephemeral volumes and
    /// persistent volumes at the same time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<ArgoCdSsoDexVolumesEphemeral>,
    /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fc: Option<ArgoCdSsoDexVolumesFc>,
    /// flexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flexVolume")]
    pub flex_volume: Option<ArgoCdSsoDexVolumesFlexVolume>,
    /// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
    /// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flocker: Option<ArgoCdSsoDexVolumesFlocker>,
    /// gcePersistentDisk represents a GCE Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
    /// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDisk")]
    pub gce_persistent_disk: Option<ArgoCdSsoDexVolumesGcePersistentDisk>,
    /// gitRepo represents a git repository at a particular revision.
    /// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    /// into the Pod's container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitRepo")]
    pub git_repo: Option<ArgoCdSsoDexVolumesGitRepo>,
    /// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    /// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glusterfs: Option<ArgoCdSsoDexVolumesGlusterfs>,
    /// hostPath represents a pre-existing file or directory on the host
    /// machine that is directly exposed to the container. This is generally
    /// used for system agents or other privileged things that are allowed
    /// to see the host machine. Most containers will NOT need this.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<ArgoCdSsoDexVolumesHostPath>,
    /// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
    /// The volume is resolved at pod startup depending on which PullPolicy value is provided:
    /// 
    /// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// 
    /// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
    /// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
    /// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
    /// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
    /// The volume will be mounted read-only (ro) and non-executable files (noexec).
    /// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
    /// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<ArgoCdSsoDexVolumesImage>,
    /// iscsi represents an ISCSI Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iscsi: Option<ArgoCdSsoDexVolumesIscsi>,
    /// name of the volume.
    /// Must be a DNS_LABEL and unique within the pod.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    pub name: String,
    /// nfs represents an NFS mount on the host that shares a pod's lifetime
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nfs: Option<ArgoCdSsoDexVolumesNfs>,
    /// persistentVolumeClaimVolumeSource represents a reference to a
    /// PersistentVolumeClaim in the same namespace.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<ArgoCdSsoDexVolumesPersistentVolumeClaim>,
    /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
    /// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "photonPersistentDisk")]
    pub photon_persistent_disk: Option<ArgoCdSsoDexVolumesPhotonPersistentDisk>,
    /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
    /// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
    /// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
    /// is on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portworxVolume")]
    pub portworx_volume: Option<ArgoCdSsoDexVolumesPortworxVolume>,
    /// projected items for all in one resources secrets, configmaps, and downward API
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<ArgoCdSsoDexVolumesProjected>,
    /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
    /// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quobyte: Option<ArgoCdSsoDexVolumesQuobyte>,
    /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
    /// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbd: Option<ArgoCdSsoDexVolumesRbd>,
    /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    /// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scaleIO")]
    pub scale_io: Option<ArgoCdSsoDexVolumesScaleIo>,
    /// secret represents a secret that should populate this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdSsoDexVolumesSecret>,
    /// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    /// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storageos: Option<ArgoCdSsoDexVolumesStorageos>,
    /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
    /// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
    /// are redirected to the csi.vsphere.vmware.com CSI driver.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vsphereVolume")]
    pub vsphere_volume: Option<ArgoCdSsoDexVolumesVsphereVolume>,
}

/// awsElasticBlockStore represents an AWS Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
/// awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesAwsElasticBlockStore {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// readOnly value true will force the readOnly setting in VolumeMounts.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
/// Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
/// are redirected to the disk.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesAzureDisk {
    /// cachingMode is the Host Caching mode: None, Read Only, Read Write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachingMode")]
    pub caching_mode: Option<String>,
    /// diskName is the Name of the data disk in the blob storage
    #[serde(rename = "diskName")]
    pub disk_name: String,
    /// diskURI is the URI of data disk in the blob storage
    #[serde(rename = "diskURI")]
    pub disk_uri: String,
    /// fsType is Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
/// Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
/// are redirected to the file.csi.azure.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesAzureFile {
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretName is the  name of secret that contains Azure Storage Account Name and Key
    #[serde(rename = "secretName")]
    pub secret_name: String,
    /// shareName is the azure share Name
    #[serde(rename = "shareName")]
    pub share_name: String,
}

/// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
/// Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesCephfs {
    /// monitors is Required: Monitors is a collection of Ceph monitors
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretFile")]
    pub secret_file: Option<String>,
    /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdSsoDexVolumesCephfsSecretRef>,
    /// user is optional: User is the rados user name, default is admin
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
/// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesCephfsSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// cinder represents a cinder volume attached and mounted on kubelets host machine.
/// Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
/// are redirected to the cinder.csi.openstack.org CSI driver.
/// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesCinder {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is optional: points to a secret object containing parameters used to connect
    /// to OpenStack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdSsoDexVolumesCinderSecretRef>,
    /// volumeID used to identify the volume in cinder.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// secretRef is optional: points to a secret object containing parameters used to connect
/// to OpenStack.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesCinderSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// configMap represents a configMap that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesConfigMap {
    /// defaultMode is optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdSsoDexVolumesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesCsi {
    /// driver is the name of the CSI driver that handles this volume.
    /// Consult with your admin for the correct name as registered in the cluster.
    pub driver: String,
    /// fsType to mount. Ex. "ext4", "xfs", "ntfs".
    /// If not provided, the empty value is passed to the associated CSI driver
    /// which will determine the default filesystem to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// nodePublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// NodePublishVolume and NodeUnpublishVolume calls.
    /// This field is optional, and  may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secret references are passed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePublishSecretRef")]
    pub node_publish_secret_ref: Option<ArgoCdSsoDexVolumesCsiNodePublishSecretRef>,
    /// readOnly specifies a read-only configuration for the volume.
    /// Defaults to false (read/write).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeAttributes stores driver-specific properties that are passed to the CSI
    /// driver. Consult your driver's documentation for supported values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributes")]
    pub volume_attributes: Option<BTreeMap<String, String>>,
}

/// nodePublishSecretRef is a reference to the secret object containing
/// sensitive information to pass to the CSI driver to complete the CSI
/// NodePublishVolume and NodeUnpublishVolume calls.
/// This field is optional, and  may be empty if no secret is required. If the
/// secret object contains more than one secret, all secret references are passed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesCsiNodePublishSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// downwardAPI represents downward API about the pod that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesDownwardApi {
    /// Optional: mode bits to use on created files by default. Must be a
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// Items is a list of downward API volume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdSsoDexVolumesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdSsoDexVolumesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdSsoDexVolumesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// emptyDir represents a temporary directory that shares a pod's lifetime.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEmptyDir {
    /// medium represents what type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

/// ephemeral represents a volume that is handled by a cluster storage driver.
/// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
/// and deleted when the pod is removed.
/// 
/// Use this if:
/// a) the volume is only needed while the pod runs,
/// b) features of normal volumes like restoring from snapshot or capacity
///    tracking are needed,
/// c) the storage driver is specified through a storage class, and
/// d) the storage driver supports dynamic volume provisioning through
///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
///    information on the connection between this volume type
///    and PersistentVolumeClaim).
/// 
/// Use PersistentVolumeClaim or one of the vendor-specific
/// APIs for volumes that persist for longer than the lifecycle
/// of an individual pod.
/// 
/// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
/// be used that way - see the documentation of the driver for
/// more information.
/// 
/// A pod can use both types of ephemeral volumes and
/// persistent volumes at the same time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEphemeral {
    /// Will be used to create a stand-alone PVC to provision the volume.
    /// The pod in which this EphemeralVolumeSource is embedded will be the
    /// owner of the PVC, i.e. the PVC will be deleted together with the
    /// pod.  The name of the PVC will be `<pod name>-<volume name>` where
    /// `<volume name>` is the name from the `PodSpec.Volumes` array
    /// entry. Pod validation will reject the pod if the concatenated name
    /// is not valid for a PVC (for example, too long).
    /// 
    /// An existing PVC with that name that is not owned by the pod
    /// will *not* be used for the pod to avoid using an unrelated
    /// volume by mistake. Starting the pod is then blocked until
    /// the unrelated PVC is removed. If such a pre-created PVC is
    /// meant to be used by the pod, the PVC has to updated with an
    /// owner reference to the pod once the pod exists. Normally
    /// this should not be necessary, but it may be useful when
    /// manually reconstructing a broken cluster.
    /// 
    /// This field is read-only and no changes will be made by Kubernetes
    /// to the PVC after it has been created.
    /// 
    /// Required, must not be nil.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplate>,
}

/// Will be used to create a stand-alone PVC to provision the volume.
/// The pod in which this EphemeralVolumeSource is embedded will be the
/// owner of the PVC, i.e. the PVC will be deleted together with the
/// pod.  The name of the PVC will be `<pod name>-<volume name>` where
/// `<volume name>` is the name from the `PodSpec.Volumes` array
/// entry. Pod validation will reject the pod if the concatenated name
/// is not valid for a PVC (for example, too long).
/// 
/// An existing PVC with that name that is not owned by the pod
/// will *not* be used for the pod to avoid using an unrelated
/// volume by mistake. Starting the pod is then blocked until
/// the unrelated PVC is removed. If such a pre-created PVC is
/// meant to be used by the pod, the PVC has to updated with an
/// owner reference to the pod once the pod exists. Normally
/// this should not be necessary, but it may be useful when
/// manually reconstructing a broken cluster.
/// 
/// This field is read-only and no changes will be made by Kubernetes
/// to the PVC after it has been created.
/// 
/// Required, must not be nil.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplate {
    /// May contain labels and annotations that will be copied into the PVC
    /// when creating it. No other fields are allowed and will be rejected during
    /// validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateMetadata>,
    /// The specification for the PersistentVolumeClaim. The entire content is
    /// copied unchanged into the PVC that gets created from this
    /// template. The same fields as in a PersistentVolumeClaim
    /// are also valid here.
    pub spec: ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpec,
}

/// May contain labels and annotations that will be copied into the PVC
/// when creating it. No other fields are allowed and will be rejected during
/// validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateMetadata {
}

/// The specification for the PersistentVolumeClaim. The entire content is
/// copied unchanged into the PVC that gets created from this
/// template. The same fields as in a PersistentVolumeClaim
/// are also valid here.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    /// (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesFc {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// lun is Optional: FC target lun number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lun: Option<i32>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// targetWWNs is Optional: FC target worldwide names (WWNs)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetWWNs")]
    pub target_ww_ns: Option<Vec<String>>,
    /// wwids Optional: FC volume world wide identifiers (wwids)
    /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wwids: Option<Vec<String>>,
}

/// flexVolume represents a generic volume resource that is
/// provisioned/attached using an exec based plugin.
/// Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesFlexVolume {
    /// driver is the name of the driver to use for this volume.
    pub driver: String,
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// options is Optional: this field holds extra command options if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<BTreeMap<String, String>>,
    /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is Optional: secretRef is reference to the secret object containing
    /// sensitive information to pass to the plugin scripts. This may be
    /// empty if no secret object is specified. If the secret object
    /// contains more than one secret, all secrets are passed to the plugin
    /// scripts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdSsoDexVolumesFlexVolumeSecretRef>,
}

/// secretRef is Optional: secretRef is reference to the secret object containing
/// sensitive information to pass to the plugin scripts. This may be
/// empty if no secret object is specified. If the secret object
/// contains more than one secret, all secrets are passed to the plugin
/// scripts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesFlexVolumeSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
/// Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesFlocker {
    /// datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
    /// should be considered as deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetName")]
    pub dataset_name: Option<String>,
    /// datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetUUID")]
    pub dataset_uuid: Option<String>,
}

/// gcePersistentDisk represents a GCE Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
/// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesGcePersistentDisk {
    /// fsType is filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(rename = "pdName")]
    pub pd_name: String,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// gitRepo represents a git repository at a particular revision.
/// Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
/// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
/// into the Pod's container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesGitRepo {
    /// directory is the target directory name.
    /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    /// git repository.  Otherwise, if specified, the volume will contain the git repository in
    /// the subdirectory with the given name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    /// repository is the URL
    pub repository: String,
    /// revision is the commit hash for the specified revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub revision: Option<String>,
}

/// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
/// Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesGlusterfs {
    /// endpoints is the endpoint name that details Glusterfs topology.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub endpoints: String,
    /// path is the Glusterfs volume path.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub path: String,
    /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// hostPath represents a pre-existing file or directory on the host
/// machine that is directly exposed to the container. This is generally
/// used for system agents or other privileged things that are allowed
/// to see the host machine. Most containers will NOT need this.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesHostPath {
    /// path of the directory on the host.
    /// If the path is a symlink, it will follow the link to the real path.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    pub path: String,
    /// type for HostPath Volume
    /// Defaults to ""
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
/// The volume is resolved at pod startup depending on which PullPolicy value is provided:
/// 
/// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
/// - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
/// - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
/// 
/// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
/// A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
/// The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
/// The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
/// The volume will be mounted read-only (ro) and non-executable files (noexec).
/// Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
/// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesImage {
    /// Policy for pulling OCI objects. Possible values are:
    /// Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    /// Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    /// IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullPolicy")]
    pub pull_policy: Option<String>,
    /// Required: Image or artifact reference to be used.
    /// Behaves in the same way as pod.spec.containers[*].image.
    /// Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reference: Option<String>,
}

/// iscsi represents an ISCSI Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesIscsi {
    /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthDiscovery")]
    pub chap_auth_discovery: Option<bool>,
    /// chapAuthSession defines whether support iSCSI Session CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthSession")]
    pub chap_auth_session: Option<bool>,
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#iscsi>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// initiatorName is the custom iSCSI Initiator Name.
    /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    /// <target portal>:<volume name> will be created for the connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initiatorName")]
    pub initiator_name: Option<String>,
    /// iqn is the target iSCSI Qualified Name.
    pub iqn: String,
    /// iscsiInterface is the interface Name that uses an iSCSI transport.
    /// Defaults to 'default' (tcp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iscsiInterface")]
    pub iscsi_interface: Option<String>,
    /// lun represents iSCSI Target Lun number.
    pub lun: i32,
    /// portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub portals: Option<Vec<String>>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdSsoDexVolumesIscsiSecretRef>,
    /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(rename = "targetPortal")]
    pub target_portal: String,
}

/// secretRef is the CHAP Secret for iSCSI target and initiator authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesIscsiSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// nfs represents an NFS mount on the host that shares a pod's lifetime
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesNfs {
    /// path that is exported by the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub path: String,
    /// readOnly here will force the NFS export to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// server is the hostname or IP address of the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub server: String,
}

/// persistentVolumeClaimVolumeSource represents a reference to a
/// PersistentVolumeClaim in the same namespace.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesPersistentVolumeClaim {
    /// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(rename = "claimName")]
    pub claim_name: String,
    /// readOnly Will force the ReadOnly setting in VolumeMounts.
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
/// Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesPhotonPersistentDisk {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// pdID is the ID that identifies Photon Controller persistent disk
    #[serde(rename = "pdID")]
    pub pd_id: String,
}

/// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
/// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
/// are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
/// is on.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesPortworxVolume {
    /// fSType represents the filesystem type to mount
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID uniquely identifies a Portworx volume
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// projected items for all in one resources secrets, configmaps, and downward API
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjected {
    /// defaultMode are the mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// sources is the list of volume projections. Each entry in this list
    /// handles one source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ArgoCdSsoDexVolumesProjectedSources>>,
}

/// Projection that may be projected along with other supported volume types.
/// Exactly one of these fields must be set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSources {
    /// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
    /// of ClusterTrustBundle objects in an auto-updating file.
    /// 
    /// Alpha, gated by the ClusterTrustBundleProjection feature gate.
    /// 
    /// ClusterTrustBundle objects can either be selected by name, or by the
    /// combination of signer name and a label selector.
    /// 
    /// Kubelet performs aggressive normalization of the PEM contents written
    /// into the pod filesystem.  Esoteric PEM features such as inter-block
    /// comments and block headers are stripped.  Certificates are deduplicated.
    /// The ordering of certificates within the file is arbitrary, and Kubelet
    /// may change the order over time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<ArgoCdSsoDexVolumesProjectedSourcesClusterTrustBundle>,
    /// configMap information about the configMap data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ArgoCdSsoDexVolumesProjectedSourcesConfigMap>,
    /// downwardAPI information about the downwardAPI data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ArgoCdSsoDexVolumesProjectedSourcesDownwardApi>,
    /// secret information about the secret data to project
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ArgoCdSsoDexVolumesProjectedSourcesSecret>,
    /// serviceAccountToken is information about the serviceAccountToken data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<ArgoCdSsoDexVolumesProjectedSourcesServiceAccountToken>,
}

/// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
/// of ClusterTrustBundle objects in an auto-updating file.
/// 
/// Alpha, gated by the ClusterTrustBundleProjection feature gate.
/// 
/// ClusterTrustBundle objects can either be selected by name, or by the
/// combination of signer name and a label selector.
/// 
/// Kubelet performs aggressive normalization of the PEM contents written
/// into the pod filesystem.  Esoteric PEM features such as inter-block
/// comments and block headers are stripped.  Certificates are deduplicated.
/// The ordering of certificates within the file is arbitrary, and Kubelet
/// may change the order over time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesClusterTrustBundle {
    /// Select all ClusterTrustBundles that match this label selector.  Only has
    /// effect if signerName is set.  Mutually-exclusive with name.  If unset,
    /// interpreted as "match nothing".  If set but empty, interpreted as "match
    /// everything".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ArgoCdSsoDexVolumesProjectedSourcesClusterTrustBundleLabelSelector>,
    /// Select a single ClusterTrustBundle by object name.  Mutually-exclusive
    /// with signerName and labelSelector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// If true, don't block pod startup if the referenced ClusterTrustBundle(s)
    /// aren't available.  If using name, then the named ClusterTrustBundle is
    /// allowed not to exist.  If using signerName, then the combination of
    /// signerName and labelSelector is allowed to match zero
    /// ClusterTrustBundles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Relative path from the volume root to write the bundle.
    pub path: String,
    /// Select all ClusterTrustBundles that match this signer name.
    /// Mutually-exclusive with name.  The contents of all selected
    /// ClusterTrustBundles will be unified and deduplicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

/// Select all ClusterTrustBundles that match this label selector.  Only has
/// effect if signerName is set.  Mutually-exclusive with name.  If unset,
/// interpreted as "match nothing".  If set but empty, interpreted as "match
/// everything".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesClusterTrustBundleLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdSsoDexVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// configMap information about the configMap data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesConfigMap {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdSsoDexVolumesProjectedSourcesConfigMapItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// downwardAPI information about the downwardAPI data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesDownwardApi {
    /// Items is a list of DownwardAPIVolume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdSsoDexVolumesProjectedSourcesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ArgoCdSsoDexVolumesProjectedSourcesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ArgoCdSsoDexVolumesProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// secret information about the secret data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesSecret {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdSsoDexVolumesProjectedSourcesSecretItems>>,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional field specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// serviceAccountToken is information about the serviceAccountToken data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesProjectedSourcesServiceAccountToken {
    /// audience is the intended audience of the token. A recipient of a token
    /// must identify itself with an identifier specified in the audience of the
    /// token, and otherwise should reject the token. The audience defaults to the
    /// identifier of the apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// expirationSeconds is the requested duration of validity of the service
    /// account token. As the token approaches expiration, the kubelet volume
    /// plugin will proactively rotate the service account token. The kubelet will
    /// start trying to rotate the token if the token is older than 80 percent of
    /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
    /// and must be at least 10 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    /// path is the path relative to the mount point of the file to project the
    /// token into.
    pub path: String,
}

/// quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
/// Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesQuobyte {
    /// group to map volume access to
    /// Default is no group
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// readOnly here will force the Quobyte volume to be mounted with read-only permissions.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// registry represents a single or multiple Quobyte Registry services
    /// specified as a string as host:port pair (multiple entries are separated with commas)
    /// which acts as the central registry for volumes
    pub registry: String,
    /// tenant owning the given Quobyte volume in the Backend
    /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant: Option<String>,
    /// user to map volume access to
    /// Defaults to serivceaccount user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// volume is a string that references an already created Quobyte volume by name.
    pub volume: String,
}

/// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
/// Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesRbd {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#rbd>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// image is the rados image name.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub image: String,
    /// keyring is the path to key ring for RBDUser.
    /// Default is /etc/ceph/keyring.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyring: Option<String>,
    /// monitors is a collection of Ceph monitors.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// pool is the rados pool name.
    /// Default is rbd.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is name of the authentication secret for RBDUser. If provided
    /// overrides keyring.
    /// Default is nil.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdSsoDexVolumesRbdSecretRef>,
    /// user is the rados user name.
    /// Default is admin.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is name of the authentication secret for RBDUser. If provided
/// overrides keyring.
/// Default is nil.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesRbdSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
/// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesScaleIo {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// Default is "xfs".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// gateway is the host address of the ScaleIO API Gateway.
    pub gateway: String,
    /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protectionDomain")]
    pub protection_domain: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef references to the secret for ScaleIO user and other
    /// sensitive information. If this is not provided, Login operation will fail.
    #[serde(rename = "secretRef")]
    pub secret_ref: ArgoCdSsoDexVolumesScaleIoSecretRef,
    /// sslEnabled Flag enable/disable SSL communication with Gateway, default false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslEnabled")]
    pub ssl_enabled: Option<bool>,
    /// storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    /// Default is ThinProvisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageMode")]
    pub storage_mode: Option<String>,
    /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    /// system is the name of the storage system as configured in ScaleIO.
    pub system: String,
    /// volumeName is the name of a volume already created in the ScaleIO system
    /// that is associated with this volume source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// secretRef references to the secret for ScaleIO user and other
/// sensitive information. If this is not provided, Login operation will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesScaleIoSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// secret represents a secret that should populate this volume.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesSecret {
    /// defaultMode is Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values
    /// for mode bits. Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items If unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ArgoCdSsoDexVolumesSecretItems>>,
    /// optional field specify whether the Secret or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// secretName is the name of the secret in the pod's namespace to use.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
/// Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesStorageos {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef specifies the secret to use for obtaining the StorageOS API
    /// credentials.  If not specified, default values will be attempted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ArgoCdSsoDexVolumesStorageosSecretRef>,
    /// volumeName is the human-readable name of the StorageOS volume.  Volume
    /// names are only unique within a namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
    /// volumeNamespace specifies the scope of the volume within StorageOS.  If no
    /// namespace is specified then the Pod's namespace will be used.  This allows the
    /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    /// Set VolumeName to any name to override the default behaviour.
    /// Set to "default" if you are not using namespaces within StorageOS.
    /// Namespaces that do not pre-exist within StorageOS will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeNamespace")]
    pub volume_namespace: Option<String>,
}

/// secretRef specifies the secret to use for obtaining the StorageOS API
/// credentials.  If not specified, default values will be attempted.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesStorageosSecretRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
/// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
/// are redirected to the csi.vsphere.vmware.com CSI driver.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoDexVolumesVsphereVolume {
    /// fsType is filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyID")]
    pub storage_policy_id: Option<String>,
    /// storagePolicyName is the storage Policy Based Management (SPBM) profile name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyName")]
    pub storage_policy_name: Option<String>,
    /// volumePath is the path that identifies vSphere volume vmdk
    #[serde(rename = "volumePath")]
    pub volume_path: String,
}

/// Keycloak contains the configuration for Argo CD keycloak authentication
/// Removed: This field is no longer supported and the related functionality has been removed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoKeycloak {
    /// Host is the hostname to use for Ingress/Route resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Image is the Keycloak container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Resources defines the Compute Resources required by the container for Keycloak.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdSsoKeycloakResources>,
    /// Custom root CA certificate for communicating with the Keycloak OIDC provider
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootCA")]
    pub root_ca: Option<String>,
    /// VerifyTLS set to false disables strict TLS validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verifyTLS")]
    pub verify_tls: Option<bool>,
    /// Version is the Keycloak container image tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Resources defines the Compute Resources required by the container for Keycloak.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoKeycloakResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ArgoCdSsoKeycloakResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdSsoKeycloakResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
    /// Request is the name chosen for a request in the referenced claim.
    /// If empty, everything from the claim is made available, otherwise
    /// only the result of this request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<String>,
}

/// TLS defines the TLS options for ArgoCD.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdTls {
    /// CA defines the CA options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ArgoCdTlsCa>,
    /// InitialCerts defines custom TLS certificates upon creation of the cluster for connecting Git repositories via HTTPS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialCerts")]
    pub initial_certs: Option<BTreeMap<String, String>>,
}

/// CA defines the CA options.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdTlsCa {
    /// ConfigMapName is the name of the ConfigMap containing the CA Certificate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapName")]
    pub config_map_name: Option<String>,
    /// SecretName is the name of the Secret containing the CA Certificate and Key.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// ArgoCDStatus defines the observed state of ArgoCD
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ArgoCdStatus {
    /// ApplicationController is a simple, high-level summary of where the Argo CD application controller component is in its lifecycle.
    /// There are four possible ApplicationController values:
    /// Pending: The Argo CD application controller component has been accepted by the Kubernetes system, but one or more of the required resources have not been created.
    /// Running: All of the required Pods for the Argo CD application controller component are in a Ready state.
    /// Failed: At least one of the  Argo CD application controller component Pods had a failure.
    /// Unknown: The state of the Argo CD application controller component could not be obtained.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationController")]
    pub application_controller: Option<String>,
    /// ApplicationSetController is a simple, high-level summary of where the Argo CD applicationSet controller component is in its lifecycle.
    /// There are four possible ApplicationSetController values:
    /// Pending: The Argo CD applicationSet controller component has been accepted by the Kubernetes system, but one or more of the required resources have not been created.
    /// Running: All of the required Pods for the Argo CD applicationSet controller component are in a Ready state.
    /// Failed: At least one of the  Argo CD applicationSet controller component Pods had a failure.
    /// Unknown: The state of the Argo CD applicationSet controller component could not be obtained.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "applicationSetController")]
    pub application_set_controller: Option<String>,
    /// Conditions is an array of the ArgoCD's status conditions
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// Host is the hostname of the Ingress.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// NotificationsController is a simple, high-level summary of where the Argo CD notifications controller component is in its lifecycle.
    /// There are four possible NotificationsController values:
    /// Pending: The Argo CD notifications controller component has been accepted by the Kubernetes system, but one or more of the required resources have not been created.
    /// Running: All of the required Pods for the Argo CD notifications controller component are in a Ready state.
    /// Failed: At least one of the  Argo CD notifications controller component Pods had a failure.
    /// Unknown: The state of the Argo CD notifications controller component could not be obtained.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "notificationsController")]
    pub notifications_controller: Option<String>,
    /// Phase is a simple, high-level summary of where the ArgoCD is in its lifecycle.
    /// There are four possible phase values:
    /// Pending: The ArgoCD has been accepted by the Kubernetes system, but one or more of the required resources have not been created.
    /// Available: All of the resources for the ArgoCD are ready.
    /// Failed: At least one resource has experienced a failure.
    /// Unknown: The state of the ArgoCD phase could not be obtained.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
    /// Redis is a simple, high-level summary of where the Argo CD Redis component is in its lifecycle.
    /// There are four possible redis values:
    /// Pending: The Argo CD Redis component has been accepted by the Kubernetes system, but one or more of the required resources have not been created.
    /// Running: All of the required Pods for the Argo CD Redis component are in a Ready state.
    /// Failed: At least one of the  Argo CD Redis component Pods had a failure.
    /// Unknown: The state of the Argo CD Redis component could not be obtained.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redis: Option<String>,
    /// RedisTLSChecksum contains the SHA256 checksum of the latest known state of tls.crt and tls.key in the argocd-operator-redis-tls secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "redisTLSChecksum")]
    pub redis_tls_checksum: Option<String>,
    /// Repo is a simple, high-level summary of where the Argo CD Repo component is in its lifecycle.
    /// There are four possible repo values:
    /// Pending: The Argo CD Repo component has been accepted by the Kubernetes system, but one or more of the required resources have not been created.
    /// Running: All of the required Pods for the Argo CD Repo component are in a Ready state.
    /// Failed: At least one of the  Argo CD Repo component Pods had a failure.
    /// Unknown: The state of the Argo CD Repo component could not be obtained.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repo: Option<String>,
    /// RepoTLSChecksum contains the SHA256 checksum of the latest known state of tls.crt and tls.key in the argocd-repo-server-tls secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoTLSChecksum")]
    pub repo_tls_checksum: Option<String>,
    /// Server is a simple, high-level summary of where the Argo CD server component is in its lifecycle.
    /// There are four possible server values:
    /// Pending: The Argo CD server component has been accepted by the Kubernetes system, but one or more of the required resources have not been created.
    /// Running: All of the required Pods for the Argo CD server component are in a Ready state.
    /// Failed: At least one of the  Argo CD server component Pods had a failure.
    /// Unknown: The state of the Argo CD server component could not be obtained.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server: Option<String>,
    /// SSO is a simple, high-level summary of where the Argo CD SSO(Dex/Keycloak) component is in its lifecycle.
    /// There are four possible sso values:
    /// Pending: The Argo CD SSO component has been accepted by the Kubernetes system, but one or more of the required resources have not been created.
    /// Running: All of the required Pods for the Argo CD SSO component are in a Ready state.
    /// Failed: At least one of the  Argo CD SSO component Pods had a failure.
    /// Unknown: The state of the Argo CD SSO component could not be obtained.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sso: Option<String>,
}

