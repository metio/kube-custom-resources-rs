// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/nats-io/nack/jetstream.nats.io/v1beta2/streams.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "jetstream.nats.io", version = "v1beta2", kind = "Stream", plural = "streams")]
#[kube(namespaced)]
#[kube(status = "StreamStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct StreamSpec {
    /// Name of the account to which the Stream belongs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account: Option<String>,
    /// When true, allow higher performance, direct access to get individual messages.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowDirect")]
    pub allow_direct: Option<bool>,
    /// When true, allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowRollup")]
    pub allow_rollup: Option<bool>,
    /// Stream specific compression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compression: Option<StreamCompression>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "consumerLimits")]
    pub consumer_limits: Option<StreamConsumerLimits>,
    /// NATS user credentials for connecting to servers. Please make sure your controller has mounted the creds on this path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creds: Option<String>,
    /// When true, restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyDelete")]
    pub deny_delete: Option<bool>,
    /// When true, restricts the ability to purge a stream via the API. Cannot be changed once set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "denyPurge")]
    pub deny_purge: Option<bool>,
    /// The description of the stream.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// When a Stream reach it's limits either old messages are deleted or new ones are denied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discard: Option<StreamDiscard>,
    /// Applies discard policy on a per-subject basis. Requires discard policy 'new' and 'maxMsgs' to be set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discardPerSubject")]
    pub discard_per_subject: Option<bool>,
    /// The duration window to track duplicate messages for.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "duplicateWindow")]
    pub duplicate_window: Option<String>,
    /// Sequence number from which the Stream will start.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "firstSequence")]
    pub first_sequence: Option<f64>,
    /// Maximum age of any message in the stream, expressed in Go's time.Duration format. Empty for unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    pub max_age: Option<String>,
    /// How big the Stream may be, when the combined stream size exceeds this old messages are removed. -1 for unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxBytes")]
    pub max_bytes: Option<i64>,
    /// How many Consumers can be defined for a given Stream. -1 for unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxConsumers")]
    pub max_consumers: Option<i64>,
    /// The largest message that will be accepted by the Stream. -1 for unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxMsgSize")]
    pub max_msg_size: Option<i64>,
    /// How many messages may be in a Stream, oldest messages will be removed if the Stream exceeds this size. -1 for unlimited.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxMsgs")]
    pub max_msgs: Option<i64>,
    /// The maximum number of messages per subject.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxMsgsPerSubject")]
    pub max_msgs_per_subject: Option<i64>,
    /// Additional Stream metadata.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, String>>,
    /// A stream mirror.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<StreamMirror>,
    /// When true, enables direct access to messages from the origin stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mirrorDirect")]
    pub mirror_direct: Option<bool>,
    /// A unique name for the Stream.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// NATS user NKey for connecting to servers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nkey: Option<String>,
    /// Disables acknowledging messages that are received by the Stream.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "noAck")]
    pub no_ack: Option<bool>,
    /// A stream's placement.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub placement: Option<StreamPlacement>,
    /// When true, the managed Stream will not be deleted when the resource is deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preventDelete")]
    pub prevent_delete: Option<bool>,
    /// When true, the managed Stream will not be updated when the resource is updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preventUpdate")]
    pub prevent_update: Option<bool>,
    /// How many replicas to keep for each message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i64>,
    /// Republish configuration of the stream.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub republish: Option<StreamRepublish>,
    /// How messages are retained in the Stream, once this is exceeded old messages are removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retention: Option<StreamRetention>,
    /// Seal an existing stream so no new messages may be added.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sealed: Option<bool>,
    /// A list of servers for creating stream.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub servers: Option<Vec<String>>,
    /// A stream's sources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<StreamSources>>,
    /// The storage backend to use for the Stream.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<StreamStorage>,
    /// SubjectTransform is for applying a subject transform (to matching messages) when a new message is received.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectTransform")]
    pub subject_transform: Option<StreamSubjectTransform>,
    /// A list of subjects to consume, supports wildcards.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<String>>,
    /// A client's TLS certs and keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<StreamTls>,
    /// When true, the KV Store will initiate TLS before server INFO.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsFirst")]
    pub tls_first: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum StreamCompression {
    #[serde(rename = "s2")]
    S2,
    #[serde(rename = "none")]
    None,
    #[serde(rename = "")]
    KopiumEmpty,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamConsumerLimits {
    /// The duration of inactivity after which a consumer is considered inactive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inactiveThreshold")]
    pub inactive_threshold: Option<String>,
    /// Maximum number of outstanding unacknowledged messages.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAckPending")]
    pub max_ack_pending: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum StreamDiscard {
    #[serde(rename = "old")]
    Old,
    #[serde(rename = "new")]
    New,
}

/// A stream mirror.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamMirror {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalApiPrefix")]
    pub external_api_prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalDeliverPrefix")]
    pub external_deliver_prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterSubject")]
    pub filter_subject: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "optStartSeq")]
    pub opt_start_seq: Option<i64>,
    /// Time format must be RFC3339.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "optStartTime")]
    pub opt_start_time: Option<String>,
    /// List of subject transforms for this mirror.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectTransforms")]
    pub subject_transforms: Option<Vec<StreamMirrorSubjectTransforms>>,
}

/// A subject transform pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamMirrorSubjectTransforms {
    /// Destination subject.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dest: Option<String>,
    /// Source subject.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// A stream's placement.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamPlacement {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
}

/// Republish configuration of the stream.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamRepublish {
    /// Messages will be additionally published to this subject.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub destination: Option<String>,
    /// Messages will be published from this subject to the destination subject.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum StreamRetention {
    #[serde(rename = "limits")]
    Limits,
    #[serde(rename = "interest")]
    Interest,
    #[serde(rename = "workqueue")]
    Workqueue,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamSources {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalApiPrefix")]
    pub external_api_prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalDeliverPrefix")]
    pub external_deliver_prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterSubject")]
    pub filter_subject: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "optStartSeq")]
    pub opt_start_seq: Option<i64>,
    /// Time format must be RFC3339.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "optStartTime")]
    pub opt_start_time: Option<String>,
    /// List of subject transforms for this mirror.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectTransforms")]
    pub subject_transforms: Option<Vec<StreamSourcesSubjectTransforms>>,
}

/// A subject transform pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamSourcesSubjectTransforms {
    /// Destination subject.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dest: Option<String>,
    /// Source subject.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum StreamStorage {
    #[serde(rename = "file")]
    File,
    #[serde(rename = "memory")]
    Memory,
}

/// SubjectTransform is for applying a subject transform (to matching messages) when a new message is received.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamSubjectTransform {
    /// Destination subject to transform into.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dest: Option<String>,
    /// Source subject.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// A client's TLS certs and keys.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamTls {
    /// A client's cert filepath. Should be mounted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientCert")]
    pub client_cert: Option<String>,
    /// A client's key filepath. Should be mounted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientKey")]
    pub client_key: Option<String>,
    /// A list of filepaths to CAs. Should be mounted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rootCas")]
    pub root_cas: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct StreamStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

