// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/nats-io/nack/jetstream.nats.io/v1beta1/consumers.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "jetstream.nats.io", version = "v1beta1", kind = "Consumer", plural = "consumers")]
#[kube(namespaced)]
#[kube(status = "ConsumerStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ConsumerSpec {
    /// How messages should be acknowledged.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackPolicy")]
    pub ack_policy: Option<ConsumerAckPolicy>,
    /// How long to allow messages to remain un-acknowledged before attempting redelivery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackWait")]
    pub ack_wait: Option<String>,
    /// The name of a queue group.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliverGroup")]
    pub deliver_group: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliverPolicy")]
    pub deliver_policy: Option<ConsumerDeliverPolicy>,
    /// The subject to deliver observed messages, when not set, a pull-based Consumer is created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deliverSubject")]
    pub deliver_subject: Option<String>,
    /// The description of the consumer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The name of the Consumer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "durableName")]
    pub durable_name: Option<String>,
    /// Select only a specific incoming subjects, supports wildcards.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterSubject")]
    pub filter_subject: Option<String>,
    /// Enables flow control.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flowControl")]
    pub flow_control: Option<bool>,
    /// The interval used to deliver idle heartbeats for push-based consumers, in Go's time.Duration format.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "heartbeatInterval")]
    pub heartbeat_interval: Option<String>,
    /// Maximum pending Acks before consumers are paused.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAckPending")]
    pub max_ack_pending: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDeliver")]
    pub max_deliver: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "optStartSeq")]
    pub opt_start_seq: Option<i64>,
    /// Time format must be RFC3339.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "optStartTime")]
    pub opt_start_time: Option<String>,
    /// Rate at which messages will be delivered to clients, expressed in bit per second.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rateLimitBps")]
    pub rate_limit_bps: Option<i64>,
    /// How messages are sent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replayPolicy")]
    pub replay_policy: Option<ConsumerReplayPolicy>,
    /// What percentage of acknowledgements should be samples for observability.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleFreq")]
    pub sample_freq: Option<String>,
    /// The name of the Stream to create the Consumer in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "streamName")]
    pub stream_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ConsumerAckPolicy {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "all")]
    All,
    #[serde(rename = "explicit")]
    Explicit,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ConsumerDeliverPolicy {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "last")]
    Last,
    #[serde(rename = "new")]
    New,
    #[serde(rename = "byStartSequence")]
    ByStartSequence,
    #[serde(rename = "byStartTime")]
    ByStartTime,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ConsumerReplayPolicy {
    #[serde(rename = "instant")]
    Instant,
    #[serde(rename = "original")]
    Original,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ConsumerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

