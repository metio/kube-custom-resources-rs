// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/Kuadrant/kuadrant-operator/kuadrant.io/v1beta2/authpolicies.yaml
// kopium version: 0.22.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// RouteSelectors - implicit default validation
/// RouteSelectors - explicit default validation
/// RouteSelectors - explicit overrides validation
/// Mutual Exclusivity Validation
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "kuadrant.io", version = "v1beta2", kind = "AuthPolicy", plural = "authpolicies")]
#[kube(namespaced)]
#[kube(status = "AuthPolicyStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct AuthPolicySpec {
    /// Defaults define explicit default values for this policy and for policies inheriting this policy.
    /// Defaults are mutually exclusive with implicit defaults defined by AuthPolicyCommonSpec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<AuthPolicyDefaults>,
    /// Overrides define explicit override values for this policy.
    /// Overrides are mutually exclusive with explicit and implicit defaults defined by AuthPolicyCommonSpec.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<AuthPolicyOverrides>,
    /// Named sets of patterns that can be referred in `when` conditions and in pattern-matching authorization policy rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patterns: Option<BTreeMap<String, Vec<AuthPolicyPatterns>>>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the external authorization service.
    /// At least one selected HTTPRoute rule must match to trigger the AuthPolicy.
    /// If no route selectors are specified, the AuthPolicy will be enforced at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyRouteSelectors>>,
    /// The auth rules of the policy.
    /// See Authorino's AuthConfig CRD for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<AuthPolicyRules>,
    /// TargetRef identifies an API object to apply policy to.
    #[serde(rename = "targetRef")]
    pub target_ref: AuthPolicyTargetRef,
    /// Overall conditions for the AuthPolicy to be enforced.
    /// If omitted, the AuthPolicy will be enforced at all requests to the protected routes.
    /// If present, all conditions must match for the AuthPolicy to be enforced; otherwise, the authorization service skips the AuthPolicy and returns to the auth request with status OK.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyWhen>>,
}

/// Defaults define explicit default values for this policy and for policies inheriting this policy.
/// Defaults are mutually exclusive with implicit defaults defined by AuthPolicyCommonSpec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaults {
    /// Named sets of patterns that can be referred in `when` conditions and in pattern-matching authorization policy rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patterns: Option<BTreeMap<String, Vec<AuthPolicyDefaultsPatterns>>>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the external authorization service.
    /// At least one selected HTTPRoute rule must match to trigger the AuthPolicy.
    /// If no route selectors are specified, the AuthPolicy will be enforced at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyDefaultsRouteSelectors>>,
    /// The auth rules of the policy.
    /// See Authorino's AuthConfig CRD for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<AuthPolicyDefaultsRules>,
    /// Overall conditions for the AuthPolicy to be enforced.
    /// If omitted, the AuthPolicy will be enforced at all requests to the protected routes.
    /// If present, all conditions must match for the AuthPolicy to be enforced; otherwise, the authorization service skips the AuthPolicy and returns to the auth request with status OK.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsWhen>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsPatterns {
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsPatternsOperator>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyDefaultsRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyDefaultsRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyDefaultsRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyDefaultsRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

/// The auth rules of the policy.
/// See Authorino's AuthConfig CRD for more details.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRules {
    /// Authentication configs.
    /// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthentication>>,
    /// Authorization policies.
    /// All policies MUST evaluate to "allowed = true" for the auth request be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthorization>>,
    /// Callback functions.
    /// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callbacks: Option<BTreeMap<String, AuthPolicyDefaultsRulesCallbacks>>,
    /// Metadata sources.
    /// Authorino fetches auth metadata as JSON from sources specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, AuthPolicyDefaultsRulesMetadata>>,
    /// Response items.
    /// Authorino builds custom responses to the client of the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<AuthPolicyDefaultsRulesResponse>,
}

/// Authentication configs.
/// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthentication {
    /// Anonymous access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anonymous: Option<AuthPolicyDefaultsRulesAuthenticationAnonymous>,
    /// Authentication based on API keys stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<AuthPolicyDefaultsRulesAuthenticationApiKey>,
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesAuthenticationCache>,
    /// Defines where credentials are required to be passed in the request for authentication based on this config.
    /// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyDefaultsRulesAuthenticationCredentials>,
    /// Set default property values (claims) for the resolved identity object, that are set before appending the object to
    /// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthenticationDefaults>>,
    /// Authentication based on JWT tokens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<AuthPolicyDefaultsRulesAuthenticationJwt>,
    /// Authentication by Kubernetes token review.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesTokenReview")]
    pub kubernetes_token_review: Option<AuthPolicyDefaultsRulesAuthenticationKubernetesTokenReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Authentication by OAuth2 token introspection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauth2Introspection")]
    pub oauth2_introspection: Option<AuthPolicyDefaultsRulesAuthenticationOauth2Introspection>,
    /// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
    /// before appending the object to the authorization JSON.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthenticationOverrides>>,
    /// Identity object extracted from the context.
    /// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyDefaultsRulesAuthenticationPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyDefaultsRulesAuthenticationRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesAuthenticationWhen>>,
    /// Authentication based on client X.509 certificates.
    /// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x509: Option<AuthPolicyDefaultsRulesAuthenticationX509>,
}

/// Anonymous access.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationAnonymous {
}

/// Authentication based on API keys stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationApiKey {
    /// Whether Authorino should look for API key secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
    pub selector: AuthPolicyDefaultsRulesAuthenticationApiKeySelector,
}

/// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationApiKeySelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyDefaultsRulesAuthenticationApiKeySelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationApiKeySelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesAuthenticationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Defines where credentials are required to be passed in the request for authentication based on this config.
/// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyDefaultsRulesAuthenticationCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyDefaultsRulesAuthenticationCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyDefaultsRulesAuthenticationCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyDefaultsRulesAuthenticationCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationCredentialsQueryString {
    pub name: String,
}

/// Set default property values (claims) for the resolved identity object, that are set before appending the object to
/// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationDefaults {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authentication based on JWT tokens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationJwt {
    /// URL of the issuer of the JWT.
    /// If `jwksUrl` is omitted, Authorino will append the path to the OpenID Connect Well-Known Discovery endpoint
    /// (i.e. "/.well-known/openid-configuration") to this URL, to discover the OIDC configuration where to obtain
    /// the "jkws_uri" claim from.
    /// The value must coincide with the value of  the "iss" (issuer) claim of the discovered OpenID Connect configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUrl")]
    pub issuer_url: Option<String>,
    /// Decides how long to wait before refreshing the JWKS (in seconds).
    /// If omitted, Authorino will never refresh the JWKS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Authentication by Kubernetes token review.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationKubernetesTokenReview {
    /// The list of audiences (scopes) that must be claimed in a Kubernetes authentication token supplied in the request, and reviewed by Authorino.
    /// If omitted, Authorino will review tokens expecting the host name of the requested protected service amongst the audiences.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
}

/// Authentication by OAuth2 token introspection.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationOauth2Introspection {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyDefaultsRulesAuthenticationOauth2IntrospectionCredentialsRef,
    /// The full URL of the token introspection endpoint.
    pub endpoint: String,
    /// The token type hint for the token introspection.
    /// If omitted, it defaults to "access_token".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenTypeHint")]
    pub token_type_hint: Option<String>,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationOauth2IntrospectionCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it <https://github.com/kubernetes-sigs/kubebuilder/issues/3896.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
/// before appending the object to the authorization JSON.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationOverrides {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Identity object extracted from the context.
/// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    pub selector: String,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthenticationRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesAuthenticationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthenticationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authentication based on client X.509 certificates.
/// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationX509 {
    /// Whether Authorino should look for TLS secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
    /// clients trying to authenticate to this service
    pub selector: AuthPolicyDefaultsRulesAuthenticationX509Selector,
}

/// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
/// clients trying to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationX509Selector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyDefaultsRulesAuthenticationX509SelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthenticationX509SelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Authorization policies.
/// All policies MUST evaluate to "allowed = true" for the auth request be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorization {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesAuthorizationCache>,
    /// Authorization by Kubernetes SubjectAccessReview
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSubjectAccessReview")]
    pub kubernetes_subject_access_review: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Open Policy Agent (OPA) Rego policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opa: Option<AuthPolicyDefaultsRulesAuthorizationOpa>,
    /// Pattern-matching authorization rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternMatching")]
    pub pattern_matching: Option<AuthPolicyDefaultsRulesAuthorizationPatternMatching>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyDefaultsRulesAuthorizationRouteSelectors>>,
    /// Authorization decision delegated to external Authzed/SpiceDB server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spicedb: Option<AuthPolicyDefaultsRulesAuthorizationSpicedb>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesAuthorizationWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesAuthorizationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authorization by Kubernetes SubjectAccessReview
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReview {
    /// Groups the user must be a member of or, if `user` is omitted, the groups to check for authorization in the Kubernetes RBAC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
    /// Use resourceAttributes to check permissions on Kubernetes resources.
    /// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceAttributes")]
    pub resource_attributes: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes>,
    /// User to check for authorization in the Kubernetes RBAC.
    /// Omit it to check for group authorization only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewUser>,
}

/// Use resourceAttributes to check permissions on Kubernetes resources.
/// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes {
    /// API group of the resource.
    /// Use '*' for all API groups.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup>,
    /// Resource name
    /// Omit it to check for authorization on all resources of the specified kind.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName>,
    /// Namespace where the user must have permissions on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace>,
    /// Resource kind
    /// Use '*' for all resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource>,
    /// Subresource kind
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource>,
    /// Verb to check for authorization on the resource.
    /// Use '*' for all verbs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verb: Option<AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb>,
}

/// API group of the resource.
/// Use '*' for all API groups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource name
/// Omit it to check for authorization on all resources of the specified kind.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Namespace where the user must have permissions on the resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource kind
/// Use '*' for all resource kinds.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Subresource kind
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Verb to check for authorization on the resource.
/// Use '*' for all verbs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// User to check for authorization in the Kubernetes RBAC.
/// Omit it to check for group authorization only.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationKubernetesSubjectAccessReviewUser {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Open Policy Agent (OPA) Rego policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpa {
    /// Returns the value of all Rego rules in the virtual document. Values can be read in subsequent evaluators/phases of the Auth Pipeline.
    /// Otherwise, only the default `allow` rule will be exposed.
    /// Returning all Rego rules can affect performance of OPA policies during reconciliation (policy precompile) and at runtime.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allValues")]
    pub all_values: Option<bool>,
    /// Settings for fetching the OPA policy from an external registry.
    /// Use it alternatively to 'rego'.
    /// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
    /// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalPolicy")]
    pub external_policy: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicy>,
    /// Authorization policy as a Rego language document.
    /// The Rego document must include the "allow" condition, set by Authorino to "false" by default (i.e. requests are unauthorized unless changed).
    /// The Rego document must NOT include the "package" declaration in line 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rego: Option<String>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicy {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicySharedSecretRef>,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by <https://pkg.go.dev/github.com/tidwall/gjson> and selects value from the authorization JSON.
    /// E.g. <https://ext-auth-server.io/metadata?p={request.path}>
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationOpaExternalPolicySharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Pattern-matching authorization rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationPatternMatching {
    pub patterns: Vec<AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatterns>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatterns {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatternsOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationPatternMatchingPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

/// Authorization decision delegated to external Authzed/SpiceDB server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedb {
    /// Hostname and port number to the GRPC interface of the SpiceDB server (e.g. spicedb:50051).
    pub endpoint: String,
    /// Insecure HTTP connection (i.e. disables TLS verification)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// The name of the permission (or relation) on which to execute the check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbPermission>,
    /// The resource on which to check the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbResource>,
    /// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbSharedSecretRef>,
    /// The subject that will be checked for the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbSubject>,
}

/// The name of the permission (or relation) on which to execute the check.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbPermission {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// The resource on which to check the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbResource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbResourceKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbResourceName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbResourceKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbResourceName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// The subject that will be checked for the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbSubject {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbSubjectKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyDefaultsRulesAuthorizationSpicedbSubjectName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbSubjectKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationSpicedbSubjectName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesAuthorizationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesAuthorizationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesAuthorizationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Callback functions.
/// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacks {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesCallbacksCache>,
    /// Settings of the external HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyDefaultsRulesCallbacksHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyDefaultsRulesCallbacksRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesCallbacksWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesCallbacksCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesCallbacksHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyDefaultsRulesCallbacksHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyDefaultsRulesCallbacksHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesCallbacksHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesCallbacksHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyDefaultsRulesCallbacksHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyDefaultsRulesCallbacksHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by <https://pkg.go.dev/github.com/tidwall/gjson> and selects value from the authorization JSON.
    /// E.g. <https://ext-auth-server.io/metadata?p={request.path}>
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyDefaultsRulesCallbacksHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyDefaultsRulesCallbacksHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesCallbacksWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesCallbacksWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesCallbacksWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Metadata sources.
/// Authorino fetches auth metadata as JSON from sources specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesMetadataCache>,
    /// External source of auth metadata via HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyDefaultsRulesMetadataHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyDefaultsRulesMetadataRouteSelectors>>,
    /// User-Managed Access (UMA) source of resource data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uma: Option<AuthPolicyDefaultsRulesMetadataUma>,
    /// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userInfo")]
    pub user_info: Option<AuthPolicyDefaultsRulesMetadataUserInfo>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesMetadataWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesMetadataHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyDefaultsRulesMetadataHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyDefaultsRulesMetadataHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyDefaultsRulesMetadataHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesMetadataHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesMetadataHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyDefaultsRulesMetadataHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyDefaultsRulesMetadataHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by <https://pkg.go.dev/github.com/tidwall/gjson> and selects value from the authorization JSON.
    /// E.g. <https://ext-auth-server.io/metadata?p={request.path}>
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyDefaultsRulesMetadataHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyDefaultsRulesMetadataHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyDefaultsRulesMetadataHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyDefaultsRulesMetadataHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyDefaultsRulesMetadataHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyDefaultsRulesMetadataRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

/// User-Managed Access (UMA) source of resource data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataUma {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyDefaultsRulesMetadataUmaCredentialsRef,
    /// The endpoint of the UMA server.
    /// The value must coincide with the "issuer" claim of the UMA config discovered from the well-known uma configuration endpoint.
    pub endpoint: String,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataUmaCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it <https://github.com/kubernetes-sigs/kubebuilder/issues/3896.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataUserInfo {
    /// The name of an OIDC-enabled JWT authentication config whose OpenID Connect configuration discovered includes the OIDC "userinfo_endpoint" claim.
    #[serde(rename = "identitySource")]
    pub identity_source: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Response items.
/// Authorino builds custom responses to the client of the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponse {
    /// Response items to be included in the auth response when the request is authenticated and authorized.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub success: Option<AuthPolicyDefaultsRulesResponseSuccess>,
    /// Customizations on the denial status attributes when the request is unauthenticated.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 401 Unauthorized
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthenticated: Option<AuthPolicyDefaultsRulesResponseUnauthenticated>,
    /// Customizations on the denial status attributes when the request is unauthorized.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 403 Forbidden
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthorized: Option<AuthPolicyDefaultsRulesResponseUnauthorized>,
}

/// Response items to be included in the auth response when the request is authenticated and authorized.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccess {
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
    /// See <https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicMetadata")]
    pub dynamic_metadata: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessDynamicMetadata>>,
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessHeaders>>,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
/// See <https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataJson {
    pub properties: BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeaders {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyDefaultsRulesResponseSuccessHeadersCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersJson {
    pub properties: BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessHeadersJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsRulesResponseSuccessHeadersWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessHeadersWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Customizations on the denial status attributes when the request is unauthenticated.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 401 Unauthorized
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthenticated {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesResponseUnauthenticatedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseUnauthenticatedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyDefaultsRulesResponseUnauthenticatedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthenticatedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthenticatedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthenticatedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Customizations on the denial status attributes when the request is unauthorized.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 403 Forbidden
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthorized {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyDefaultsRulesResponseUnauthorizedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyDefaultsRulesResponseUnauthorizedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyDefaultsRulesResponseUnauthorizedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthorizedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthorizedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsRulesResponseUnauthorizedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyDefaultsWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyDefaultsWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyDefaultsWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Overrides define explicit override values for this policy.
/// Overrides are mutually exclusive with explicit and implicit defaults defined by AuthPolicyCommonSpec.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverrides {
    /// Named sets of patterns that can be referred in `when` conditions and in pattern-matching authorization policy rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patterns: Option<BTreeMap<String, Vec<AuthPolicyOverridesPatterns>>>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the external authorization service.
    /// At least one selected HTTPRoute rule must match to trigger the AuthPolicy.
    /// If no route selectors are specified, the AuthPolicy will be enforced at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyOverridesRouteSelectors>>,
    /// The auth rules of the policy.
    /// See Authorino's AuthConfig CRD for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<AuthPolicyOverridesRules>,
    /// Overall conditions for the AuthPolicy to be enforced.
    /// If omitted, the AuthPolicy will be enforced at all requests to the protected routes.
    /// If present, all conditions must match for the AuthPolicy to be enforced; otherwise, the authorization service skips the AuthPolicy and returns to the auth request with status OK.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesWhen>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesPatterns {
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesPatternsOperator>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyOverridesRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyOverridesRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyOverridesRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyOverridesRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

/// The auth rules of the policy.
/// See Authorino's AuthConfig CRD for more details.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRules {
    /// Authentication configs.
    /// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthentication>>,
    /// Authorization policies.
    /// All policies MUST evaluate to "allowed = true" for the auth request be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthorization>>,
    /// Callback functions.
    /// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callbacks: Option<BTreeMap<String, AuthPolicyOverridesRulesCallbacks>>,
    /// Metadata sources.
    /// Authorino fetches auth metadata as JSON from sources specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, AuthPolicyOverridesRulesMetadata>>,
    /// Response items.
    /// Authorino builds custom responses to the client of the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<AuthPolicyOverridesRulesResponse>,
}

/// Authentication configs.
/// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthentication {
    /// Anonymous access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anonymous: Option<AuthPolicyOverridesRulesAuthenticationAnonymous>,
    /// Authentication based on API keys stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<AuthPolicyOverridesRulesAuthenticationApiKey>,
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesAuthenticationCache>,
    /// Defines where credentials are required to be passed in the request for authentication based on this config.
    /// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyOverridesRulesAuthenticationCredentials>,
    /// Set default property values (claims) for the resolved identity object, that are set before appending the object to
    /// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthenticationDefaults>>,
    /// Authentication based on JWT tokens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<AuthPolicyOverridesRulesAuthenticationJwt>,
    /// Authentication by Kubernetes token review.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesTokenReview")]
    pub kubernetes_token_review: Option<AuthPolicyOverridesRulesAuthenticationKubernetesTokenReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Authentication by OAuth2 token introspection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauth2Introspection")]
    pub oauth2_introspection: Option<AuthPolicyOverridesRulesAuthenticationOauth2Introspection>,
    /// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
    /// before appending the object to the authorization JSON.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthenticationOverrides>>,
    /// Identity object extracted from the context.
    /// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyOverridesRulesAuthenticationPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyOverridesRulesAuthenticationRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesAuthenticationWhen>>,
    /// Authentication based on client X.509 certificates.
    /// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x509: Option<AuthPolicyOverridesRulesAuthenticationX509>,
}

/// Anonymous access.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationAnonymous {
}

/// Authentication based on API keys stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationApiKey {
    /// Whether Authorino should look for API key secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
    pub selector: AuthPolicyOverridesRulesAuthenticationApiKeySelector,
}

/// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationApiKeySelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyOverridesRulesAuthenticationApiKeySelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationApiKeySelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesAuthenticationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Defines where credentials are required to be passed in the request for authentication based on this config.
/// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyOverridesRulesAuthenticationCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyOverridesRulesAuthenticationCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyOverridesRulesAuthenticationCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyOverridesRulesAuthenticationCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationCredentialsQueryString {
    pub name: String,
}

/// Set default property values (claims) for the resolved identity object, that are set before appending the object to
/// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationDefaults {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authentication based on JWT tokens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationJwt {
    /// URL of the issuer of the JWT.
    /// If `jwksUrl` is omitted, Authorino will append the path to the OpenID Connect Well-Known Discovery endpoint
    /// (i.e. "/.well-known/openid-configuration") to this URL, to discover the OIDC configuration where to obtain
    /// the "jkws_uri" claim from.
    /// The value must coincide with the value of  the "iss" (issuer) claim of the discovered OpenID Connect configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUrl")]
    pub issuer_url: Option<String>,
    /// Decides how long to wait before refreshing the JWKS (in seconds).
    /// If omitted, Authorino will never refresh the JWKS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Authentication by Kubernetes token review.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationKubernetesTokenReview {
    /// The list of audiences (scopes) that must be claimed in a Kubernetes authentication token supplied in the request, and reviewed by Authorino.
    /// If omitted, Authorino will review tokens expecting the host name of the requested protected service amongst the audiences.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
}

/// Authentication by OAuth2 token introspection.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationOauth2Introspection {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef,
    /// The full URL of the token introspection endpoint.
    pub endpoint: String,
    /// The token type hint for the token introspection.
    /// If omitted, it defaults to "access_token".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenTypeHint")]
    pub token_type_hint: Option<String>,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it <https://github.com/kubernetes-sigs/kubebuilder/issues/3896.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
/// before appending the object to the authorization JSON.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationOverrides {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Identity object extracted from the context.
/// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    pub selector: String,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesAuthenticationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthenticationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authentication based on client X.509 certificates.
/// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationX509 {
    /// Whether Authorino should look for TLS secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
    /// clients trying to authenticate to this service
    pub selector: AuthPolicyOverridesRulesAuthenticationX509Selector,
}

/// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
/// clients trying to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationX509Selector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyOverridesRulesAuthenticationX509SelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthenticationX509SelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Authorization policies.
/// All policies MUST evaluate to "allowed = true" for the auth request be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorization {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesAuthorizationCache>,
    /// Authorization by Kubernetes SubjectAccessReview
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSubjectAccessReview")]
    pub kubernetes_subject_access_review: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Open Policy Agent (OPA) Rego policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opa: Option<AuthPolicyOverridesRulesAuthorizationOpa>,
    /// Pattern-matching authorization rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternMatching")]
    pub pattern_matching: Option<AuthPolicyOverridesRulesAuthorizationPatternMatching>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyOverridesRulesAuthorizationRouteSelectors>>,
    /// Authorization decision delegated to external Authzed/SpiceDB server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spicedb: Option<AuthPolicyOverridesRulesAuthorizationSpicedb>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesAuthorizationWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesAuthorizationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authorization by Kubernetes SubjectAccessReview
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReview {
    /// Groups the user must be a member of or, if `user` is omitted, the groups to check for authorization in the Kubernetes RBAC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
    /// Use resourceAttributes to check permissions on Kubernetes resources.
    /// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceAttributes")]
    pub resource_attributes: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes>,
    /// User to check for authorization in the Kubernetes RBAC.
    /// Omit it to check for group authorization only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser>,
}

/// Use resourceAttributes to check permissions on Kubernetes resources.
/// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes {
    /// API group of the resource.
    /// Use '*' for all API groups.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup>,
    /// Resource name
    /// Omit it to check for authorization on all resources of the specified kind.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName>,
    /// Namespace where the user must have permissions on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace>,
    /// Resource kind
    /// Use '*' for all resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource>,
    /// Subresource kind
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource>,
    /// Verb to check for authorization on the resource.
    /// Use '*' for all verbs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verb: Option<AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb>,
}

/// API group of the resource.
/// Use '*' for all API groups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource name
/// Omit it to check for authorization on all resources of the specified kind.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Namespace where the user must have permissions on the resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource kind
/// Use '*' for all resource kinds.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Subresource kind
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Verb to check for authorization on the resource.
/// Use '*' for all verbs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// User to check for authorization in the Kubernetes RBAC.
/// Omit it to check for group authorization only.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Open Policy Agent (OPA) Rego policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpa {
    /// Returns the value of all Rego rules in the virtual document. Values can be read in subsequent evaluators/phases of the Auth Pipeline.
    /// Otherwise, only the default `allow` rule will be exposed.
    /// Returning all Rego rules can affect performance of OPA policies during reconciliation (policy precompile) and at runtime.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allValues")]
    pub all_values: Option<bool>,
    /// Settings for fetching the OPA policy from an external registry.
    /// Use it alternatively to 'rego'.
    /// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
    /// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalPolicy")]
    pub external_policy: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicy>,
    /// Authorization policy as a Rego language document.
    /// The Rego document must include the "allow" condition, set by Authorino to "false" by default (i.e. requests are unauthorized unless changed).
    /// The Rego document must NOT include the "package" declaration in line 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rego: Option<String>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicy {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef>,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by <https://pkg.go.dev/github.com/tidwall/gjson> and selects value from the authorization JSON.
    /// E.g. <https://ext-auth-server.io/metadata?p={request.path}>
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Pattern-matching authorization rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationPatternMatching {
    pub patterns: Vec<AuthPolicyOverridesRulesAuthorizationPatternMatchingPatterns>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationPatternMatchingPatterns {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesAuthorizationPatternMatchingPatternsOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationPatternMatchingPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

/// Authorization decision delegated to external Authzed/SpiceDB server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedb {
    /// Hostname and port number to the GRPC interface of the SpiceDB server (e.g. spicedb:50051).
    pub endpoint: String,
    /// Insecure HTTP connection (i.e. disables TLS verification)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// The name of the permission (or relation) on which to execute the check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<AuthPolicyOverridesRulesAuthorizationSpicedbPermission>,
    /// The resource on which to check the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyOverridesRulesAuthorizationSpicedbResource>,
    /// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyOverridesRulesAuthorizationSpicedbSharedSecretRef>,
    /// The subject that will be checked for the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<AuthPolicyOverridesRulesAuthorizationSpicedbSubject>,
}

/// The name of the permission (or relation) on which to execute the check.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbPermission {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// The resource on which to check the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbResource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyOverridesRulesAuthorizationSpicedbResourceKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyOverridesRulesAuthorizationSpicedbResourceName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbResourceKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbResourceName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// The subject that will be checked for the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbSubject {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyOverridesRulesAuthorizationSpicedbSubjectKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyOverridesRulesAuthorizationSpicedbSubjectName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbSubjectKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationSpicedbSubjectName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesAuthorizationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesAuthorizationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesAuthorizationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Callback functions.
/// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacks {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesCallbacksCache>,
    /// Settings of the external HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyOverridesRulesCallbacksHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyOverridesRulesCallbacksRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesCallbacksWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesCallbacksCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesCallbacksHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyOverridesRulesCallbacksHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyOverridesRulesCallbacksHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyOverridesRulesCallbacksHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesCallbacksHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesCallbacksHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyOverridesRulesCallbacksHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyOverridesRulesCallbacksHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by <https://pkg.go.dev/github.com/tidwall/gjson> and selects value from the authorization JSON.
    /// E.g. <https://ext-auth-server.io/metadata?p={request.path}>
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyOverridesRulesCallbacksHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyOverridesRulesCallbacksHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyOverridesRulesCallbacksHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyOverridesRulesCallbacksHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyOverridesRulesCallbacksHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyOverridesRulesCallbacksRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesCallbacksWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesCallbacksWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesCallbacksWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Metadata sources.
/// Authorino fetches auth metadata as JSON from sources specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesMetadataCache>,
    /// External source of auth metadata via HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyOverridesRulesMetadataHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyOverridesRulesMetadataRouteSelectors>>,
    /// User-Managed Access (UMA) source of resource data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uma: Option<AuthPolicyOverridesRulesMetadataUma>,
    /// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userInfo")]
    pub user_info: Option<AuthPolicyOverridesRulesMetadataUserInfo>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesMetadataWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesMetadataHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyOverridesRulesMetadataHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyOverridesRulesMetadataHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyOverridesRulesMetadataHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesMetadataHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesMetadataHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyOverridesRulesMetadataHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyOverridesRulesMetadataHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by <https://pkg.go.dev/github.com/tidwall/gjson> and selects value from the authorization JSON.
    /// E.g. <https://ext-auth-server.io/metadata?p={request.path}>
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyOverridesRulesMetadataHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyOverridesRulesMetadataHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyOverridesRulesMetadataHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyOverridesRulesMetadataHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyOverridesRulesMetadataHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyOverridesRulesMetadataRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

/// User-Managed Access (UMA) source of resource data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataUma {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyOverridesRulesMetadataUmaCredentialsRef,
    /// The endpoint of the UMA server.
    /// The value must coincide with the "issuer" claim of the UMA config discovered from the well-known uma configuration endpoint.
    pub endpoint: String,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataUmaCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it <https://github.com/kubernetes-sigs/kubebuilder/issues/3896.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataUserInfo {
    /// The name of an OIDC-enabled JWT authentication config whose OpenID Connect configuration discovered includes the OIDC "userinfo_endpoint" claim.
    #[serde(rename = "identitySource")]
    pub identity_source: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Response items.
/// Authorino builds custom responses to the client of the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponse {
    /// Response items to be included in the auth response when the request is authenticated and authorized.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub success: Option<AuthPolicyOverridesRulesResponseSuccess>,
    /// Customizations on the denial status attributes when the request is unauthenticated.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 401 Unauthorized
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthenticated: Option<AuthPolicyOverridesRulesResponseUnauthenticated>,
    /// Customizations on the denial status attributes when the request is unauthorized.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 403 Forbidden
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthorized: Option<AuthPolicyOverridesRulesResponseUnauthorized>,
}

/// Response items to be included in the auth response when the request is authenticated and authorized.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccess {
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
    /// See <https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicMetadata")]
    pub dynamic_metadata: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessDynamicMetadata>>,
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessHeaders>>,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
/// See <https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesResponseSuccessDynamicMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataJson {
    pub properties: BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessDynamicMetadataJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeaders {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyOverridesRulesResponseSuccessHeadersCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyOverridesRulesResponseSuccessHeadersJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyOverridesRulesResponseSuccessHeadersPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyOverridesRulesResponseSuccessHeadersWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyOverridesRulesResponseSuccessHeadersWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyOverridesRulesResponseSuccessHeadersCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersJson {
    pub properties: BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessHeadersJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesRulesResponseSuccessHeadersWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessHeadersWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseSuccessHeadersWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Customizations on the denial status attributes when the request is unauthenticated.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 401 Unauthorized
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthenticated {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesResponseUnauthenticatedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseUnauthenticatedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyOverridesRulesResponseUnauthenticatedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthenticatedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthenticatedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthenticatedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Customizations on the denial status attributes when the request is unauthorized.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 403 Forbidden
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthorized {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyOverridesRulesResponseUnauthorizedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyOverridesRulesResponseUnauthorizedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyOverridesRulesResponseUnauthorizedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthorizedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthorizedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesRulesResponseUnauthorizedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyOverridesWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyOverridesWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyOverridesWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyPatterns {
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyPatternsOperator>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

/// The auth rules of the policy.
/// See Authorino's AuthConfig CRD for more details.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRules {
    /// Authentication configs.
    /// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<BTreeMap<String, AuthPolicyRulesAuthentication>>,
    /// Authorization policies.
    /// All policies MUST evaluate to "allowed = true" for the auth request be successful.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<BTreeMap<String, AuthPolicyRulesAuthorization>>,
    /// Callback functions.
    /// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub callbacks: Option<BTreeMap<String, AuthPolicyRulesCallbacks>>,
    /// Metadata sources.
    /// Authorino fetches auth metadata as JSON from sources specified in this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, AuthPolicyRulesMetadata>>,
    /// Response items.
    /// Authorino builds custom responses to the client of the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<AuthPolicyRulesResponse>,
}

/// Authentication configs.
/// At least one config MUST evaluate to a valid identity object for the auth request to be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthentication {
    /// Anonymous access.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anonymous: Option<AuthPolicyRulesAuthenticationAnonymous>,
    /// Authentication based on API keys stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<AuthPolicyRulesAuthenticationApiKey>,
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesAuthenticationCache>,
    /// Defines where credentials are required to be passed in the request for authentication based on this config.
    /// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyRulesAuthenticationCredentials>,
    /// Set default property values (claims) for the resolved identity object, that are set before appending the object to
    /// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<BTreeMap<String, AuthPolicyRulesAuthenticationDefaults>>,
    /// Authentication based on JWT tokens.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<AuthPolicyRulesAuthenticationJwt>,
    /// Authentication by Kubernetes token review.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesTokenReview")]
    pub kubernetes_token_review: Option<AuthPolicyRulesAuthenticationKubernetesTokenReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Authentication by OAuth2 token introspection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oauth2Introspection")]
    pub oauth2_introspection: Option<AuthPolicyRulesAuthenticationOauth2Introspection>,
    /// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
    /// before appending the object to the authorization JSON.
    /// It requires the resolved identity object to always be a JSON object.
    /// Do not use this option with identity objects of other JSON types (array, string, etc).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<BTreeMap<String, AuthPolicyRulesAuthenticationOverrides>>,
    /// Identity object extracted from the context.
    /// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyRulesAuthenticationPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyRulesAuthenticationRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesAuthenticationWhen>>,
    /// Authentication based on client X.509 certificates.
    /// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x509: Option<AuthPolicyRulesAuthenticationX509>,
}

/// Anonymous access.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationAnonymous {
}

/// Authentication based on API keys stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationApiKey {
    /// Whether Authorino should look for API key secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
    pub selector: AuthPolicyRulesAuthenticationApiKeySelector,
}

/// Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationApiKeySelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyRulesAuthenticationApiKeySelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationApiKeySelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesAuthenticationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Defines where credentials are required to be passed in the request for authentication based on this config.
/// If omitted, it defaults to credentials passed in the HTTP Authorization header and the "Bearer" prefix prepended to the secret credential value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyRulesAuthenticationCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyRulesAuthenticationCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyRulesAuthenticationCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyRulesAuthenticationCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationCredentialsQueryString {
    pub name: String,
}

/// Set default property values (claims) for the resolved identity object, that are set before appending the object to
/// the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationDefaults {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authentication based on JWT tokens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationJwt {
    /// URL of the issuer of the JWT.
    /// If `jwksUrl` is omitted, Authorino will append the path to the OpenID Connect Well-Known Discovery endpoint
    /// (i.e. "/.well-known/openid-configuration") to this URL, to discover the OIDC configuration where to obtain
    /// the "jkws_uri" claim from.
    /// The value must coincide with the value of  the "iss" (issuer) claim of the discovered OpenID Connect configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerUrl")]
    pub issuer_url: Option<String>,
    /// Decides how long to wait before refreshing the JWKS (in seconds).
    /// If omitted, Authorino will never refresh the JWKS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Authentication by Kubernetes token review.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationKubernetesTokenReview {
    /// The list of audiences (scopes) that must be claimed in a Kubernetes authentication token supplied in the request, and reviewed by Authorino.
    /// If omitted, Authorino will review tokens expecting the host name of the requested protected service amongst the audiences.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audiences: Option<Vec<String>>,
}

/// Authentication by OAuth2 token introspection.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationOauth2Introspection {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyRulesAuthenticationOauth2IntrospectionCredentialsRef,
    /// The full URL of the token introspection endpoint.
    pub endpoint: String,
    /// The token type hint for the token introspection.
    /// If omitted, it defaults to "access_token".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenTypeHint")]
    pub token_type_hint: Option<String>,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationOauth2IntrospectionCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it <https://github.com/kubernetes-sigs/kubebuilder/issues/3896.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Overrides the resolved identity object by setting the additional properties (claims) specified in this config,
/// before appending the object to the authorization JSON.
/// It requires the resolved identity object to always be a JSON object.
/// Do not use this option with identity objects of other JSON types (array, string, etc).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationOverrides {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Identity object extracted from the context.
/// Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    pub selector: String,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyRulesAuthenticationRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyRulesAuthenticationRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesAuthenticationRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyRulesAuthenticationRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyRulesAuthenticationRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesAuthenticationRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthenticationRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthenticationRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesAuthenticationRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthenticationRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesAuthenticationRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthenticationRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesAuthenticationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthenticationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authentication based on client X.509 certificates.
/// The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationX509 {
    /// Whether Authorino should look for TLS secrets in all namespaces or only in the same namespace as the AuthConfig.
    /// Enabling this option in namespaced Authorino instances has no effect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allNamespaces")]
    pub all_namespaces: Option<bool>,
    /// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
    /// clients trying to authenticate to this service
    pub selector: AuthPolicyRulesAuthenticationX509Selector,
}

/// Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate
/// clients trying to authenticate to this service
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationX509Selector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<AuthPolicyRulesAuthenticationX509SelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthenticationX509SelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Authorization policies.
/// All policies MUST evaluate to "allowed = true" for the auth request be successful.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorization {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesAuthorizationCache>,
    /// Authorization by Kubernetes SubjectAccessReview
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesSubjectAccessReview")]
    pub kubernetes_subject_access_review: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReview>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Open Policy Agent (OPA) Rego policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opa: Option<AuthPolicyRulesAuthorizationOpa>,
    /// Pattern-matching authorization rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternMatching")]
    pub pattern_matching: Option<AuthPolicyRulesAuthorizationPatternMatching>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyRulesAuthorizationRouteSelectors>>,
    /// Authorization decision delegated to external Authzed/SpiceDB server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spicedb: Option<AuthPolicyRulesAuthorizationSpicedb>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesAuthorizationWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesAuthorizationCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Authorization by Kubernetes SubjectAccessReview
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReview {
    /// Groups the user must be a member of or, if `user` is omitted, the groups to check for authorization in the Kubernetes RBAC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
    /// Use resourceAttributes to check permissions on Kubernetes resources.
    /// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceAttributes")]
    pub resource_attributes: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes>,
    /// User to check for authorization in the Kubernetes RBAC.
    /// Omit it to check for group authorization only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewUser>,
}

/// Use resourceAttributes to check permissions on Kubernetes resources.
/// If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes {
    /// API group of the resource.
    /// Use '*' for all API groups.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup>,
    /// Resource name
    /// Omit it to check for authorization on all resources of the specified kind.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName>,
    /// Namespace where the user must have permissions on the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace>,
    /// Resource kind
    /// Use '*' for all resource kinds.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource>,
    /// Subresource kind
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subresource: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource>,
    /// Verb to check for authorization on the resource.
    /// Use '*' for all verbs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verb: Option<AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb>,
}

/// API group of the resource.
/// Use '*' for all API groups.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource name
/// Omit it to check for authorization on all resources of the specified kind.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Namespace where the user must have permissions on the resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Resource kind
/// Use '*' for all resource kinds.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Subresource kind
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Verb to check for authorization on the resource.
/// Use '*' for all verbs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// User to check for authorization in the Kubernetes RBAC.
/// Omit it to check for group authorization only.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationKubernetesSubjectAccessReviewUser {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Open Policy Agent (OPA) Rego policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpa {
    /// Returns the value of all Rego rules in the virtual document. Values can be read in subsequent evaluators/phases of the Auth Pipeline.
    /// Otherwise, only the default `allow` rule will be exposed.
    /// Returning all Rego rules can affect performance of OPA policies during reconciliation (policy precompile) and at runtime.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allValues")]
    pub all_values: Option<bool>,
    /// Settings for fetching the OPA policy from an external registry.
    /// Use it alternatively to 'rego'.
    /// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
    /// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalPolicy")]
    pub external_policy: Option<AuthPolicyRulesAuthorizationOpaExternalPolicy>,
    /// Authorization policy as a Rego language document.
    /// The Rego document must include the "allow" condition, set by Authorino to "false" by default (i.e. requests are unauthorized unless changed).
    /// The Rego document must NOT include the "package" declaration in line 1.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rego: Option<String>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicy {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyRulesAuthorizationOpaExternalPolicyBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesAuthorizationOpaExternalPolicyHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyRulesAuthorizationOpaExternalPolicySharedSecretRef>,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by <https://pkg.go.dev/github.com/tidwall/gjson> and selects value from the authorization JSON.
    /// E.g. <https://ext-auth-server.io/metadata?p={request.path}>
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationOpaExternalPolicyContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings for fetching the OPA policy from an external registry.
/// Use it alternatively to 'rego'.
/// For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters',
/// 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationOpaExternalPolicyMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationOpaExternalPolicySharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Pattern-matching authorization rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationPatternMatching {
    pub patterns: Vec<AuthPolicyRulesAuthorizationPatternMatchingPatterns>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationPatternMatchingPatterns {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesAuthorizationPatternMatchingPatternsOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationPatternMatchingPatternsOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyRulesAuthorizationRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyRulesAuthorizationRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesAuthorizationRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyRulesAuthorizationRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyRulesAuthorizationRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesAuthorizationRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesAuthorizationRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesAuthorizationRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

/// Authorization decision delegated to external Authzed/SpiceDB server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedb {
    /// Hostname and port number to the GRPC interface of the SpiceDB server (e.g. spicedb:50051).
    pub endpoint: String,
    /// Insecure HTTP connection (i.e. disables TLS verification)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<bool>,
    /// The name of the permission (or relation) on which to execute the check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permission: Option<AuthPolicyRulesAuthorizationSpicedbPermission>,
    /// The resource on which to check the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<AuthPolicyRulesAuthorizationSpicedbResource>,
    /// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyRulesAuthorizationSpicedbSharedSecretRef>,
    /// The subject that will be checked for the permission or relation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<AuthPolicyRulesAuthorizationSpicedbSubject>,
}

/// The name of the permission (or relation) on which to execute the check.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbPermission {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// The resource on which to check the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbResource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyRulesAuthorizationSpicedbResourceKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyRulesAuthorizationSpicedbResourceName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbResourceKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbResourceName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// The subject that will be checked for the permission or relation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbSubject {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<AuthPolicyRulesAuthorizationSpicedbSubjectKind>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<AuthPolicyRulesAuthorizationSpicedbSubjectName>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbSubjectKind {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationSpicedbSubjectName {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesAuthorizationWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesAuthorizationWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesAuthorizationWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Callback functions.
/// Authorino sends callbacks at the end of the auth pipeline to the endpoints specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacks {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesCallbacksCache>,
    /// Settings of the external HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyRulesCallbacksHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyRulesCallbacksRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesCallbacksWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesCallbacksCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesCallbacksHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyRulesCallbacksHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyRulesCallbacksHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyRulesCallbacksHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesCallbacksHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesCallbacksHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyRulesCallbacksHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyRulesCallbacksHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by <https://pkg.go.dev/github.com/tidwall/gjson> and selects value from the authorization JSON.
    /// E.g. <https://ext-auth-server.io/metadata?p={request.path}>
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyRulesCallbacksHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyRulesCallbacksHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyRulesCallbacksHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyRulesCallbacksHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Settings of the external HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyRulesCallbacksHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyRulesCallbacksRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyRulesCallbacksRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesCallbacksRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyRulesCallbacksRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyRulesCallbacksRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesCallbacksRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesCallbacksRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesCallbacksRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesCallbacksWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesCallbacksWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesCallbacksWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Metadata sources.
/// Authorino fetches auth metadata as JSON from sources specified in this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesMetadataCache>,
    /// External source of auth metadata via HTTP request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<AuthPolicyRulesMetadataHttp>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyRulesMetadataRouteSelectors>>,
    /// User-Managed Access (UMA) source of resource data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uma: Option<AuthPolicyRulesMetadataUma>,
    /// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userInfo")]
    pub user_info: Option<AuthPolicyRulesMetadataUserInfo>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesMetadataWhen>>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttp {
    /// Raw body of the HTTP request.
    /// Supersedes 'bodyParameters'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesMetadataHttpBody>,
    /// Custom parameters to encode in the body of the HTTP request.
    /// Superseded by 'body'; use either one or the other.
    /// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bodyParameters")]
    pub body_parameters: Option<BTreeMap<String, AuthPolicyRulesMetadataHttpBodyParameters>>,
    /// Content-Type of the request body. Shapes how 'bodyParameters' are encoded.
    /// Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<AuthPolicyRulesMetadataHttpContentType>,
    /// Defines where client credentials will be passed in the request to the service.
    /// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<AuthPolicyRulesMetadataHttpCredentials>,
    /// Custom headers in the HTTP request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesMetadataHttpHeaders>>,
    /// HTTP verb used in the request to the service. Accepted values: GET (default), POST.
    /// When the request method is POST, the authorization JSON is passed in the body of the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesMetadataHttpMethod>,
    /// Authentication with the HTTP service by OAuth2 Client Credentials grant.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<AuthPolicyRulesMetadataHttpOauth2>,
    /// Reference to a Secret key whose value will be passed by Authorino in the request.
    /// The HTTP service can use the shared secret to authenticate the origin of the request.
    /// Ignored if used together with oauth2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharedSecretRef")]
    pub shared_secret_ref: Option<AuthPolicyRulesMetadataHttpSharedSecretRef>,
    /// Endpoint URL of the HTTP service.
    /// The value can include variable placeholders in the format "{selector}", where "selector" is any pattern supported
    /// by <https://pkg.go.dev/github.com/tidwall/gjson> and selects value from the authorization JSON.
    /// E.g. <https://ext-auth-server.io/metadata?p={request.path}>
    pub url: String,
}

/// Raw body of the HTTP request.
/// Supersedes 'bodyParameters'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Custom parameters to encode in the body of the HTTP request.
/// Superseded by 'body'; use either one or the other.
/// Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpBodyParameters {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataHttpContentType {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}

/// Defines where client credentials will be passed in the request to the service.
/// If omitted, it defaults to client credentials passed in the HTTP Authorization header and the "Bearer" prefix expected prepended to the secret value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentials {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizationHeader")]
    pub authorization_header: Option<AuthPolicyRulesMetadataHttpCredentialsAuthorizationHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<AuthPolicyRulesMetadataHttpCredentialsCookie>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customHeader")]
    pub custom_header: Option<AuthPolicyRulesMetadataHttpCredentialsCustomHeader>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryString")]
    pub query_string: Option<AuthPolicyRulesMetadataHttpCredentialsQueryString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentialsAuthorizationHeader {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentialsCookie {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentialsCustomHeader {
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpCredentialsQueryString {
    pub name: String,
}

/// Custom headers in the HTTP request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// External source of auth metadata via HTTP request
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "PATCH")]
    Patch,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "TRACE")]
    Trace,
}

/// Authentication with the HTTP service by OAuth2 Client Credentials grant.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpOauth2 {
    /// Caches and reuses the token until expired.
    /// Set it to false to force fetch the token at every authorization request regardless of expiration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<bool>,
    /// OAuth2 Client ID.
    #[serde(rename = "clientId")]
    pub client_id: String,
    /// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
    #[serde(rename = "clientSecretRef")]
    pub client_secret_ref: AuthPolicyRulesMetadataHttpOauth2ClientSecretRef,
    /// Optional extra parameters for the requests to the token URL.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraParams")]
    pub extra_params: Option<BTreeMap<String, String>>,
    /// Optional scopes for the client credentials grant, if supported by he OAuth2 server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// Token endpoint URL of the OAuth2 resource server.
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpOauth2ClientSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// Reference to a Secret key whose value will be passed by Authorino in the request.
/// The HTTP service can use the shared secret to authenticate the origin of the request.
/// Ignored if used together with oauth2.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataHttpSharedSecretRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// The name of the secret in the Authorino's namespace to select from.
    pub name: String,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyRulesMetadataRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyRulesMetadataRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesMetadataRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyRulesMetadataRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyRulesMetadataRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesMetadataRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesMetadataRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesMetadataRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

/// User-Managed Access (UMA) source of resource data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataUma {
    /// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
    #[serde(rename = "credentialsRef")]
    pub credentials_ref: AuthPolicyRulesMetadataUmaCredentialsRef,
    /// The endpoint of the UMA server.
    /// The value must coincide with the "issuer" claim of the UMA config discovered from the well-known uma configuration endpoint.
    pub endpoint: String,
}

/// Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataUmaCredentialsRef {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Drop `kubebuilder:default` when controller-gen doesn't need it <https://github.com/kubernetes-sigs/kubebuilder/issues/3896.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataUserInfo {
    /// The name of an OIDC-enabled JWT authentication config whose OpenID Connect configuration discovered includes the OIDC "userinfo_endpoint" claim.
    #[serde(rename = "identitySource")]
    pub identity_source: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Response items.
/// Authorino builds custom responses to the client of the auth request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponse {
    /// Response items to be included in the auth response when the request is authenticated and authorized.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub success: Option<AuthPolicyRulesResponseSuccess>,
    /// Customizations on the denial status attributes when the request is unauthenticated.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 401 Unauthorized
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthenticated: Option<AuthPolicyRulesResponseUnauthenticated>,
    /// Customizations on the denial status attributes when the request is unauthorized.
    /// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
    /// Default: 403 Forbidden
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub unauthorized: Option<AuthPolicyRulesResponseUnauthorized>,
}

/// Response items to be included in the auth response when the request is authenticated and authorized.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata and/or inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccess {
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
    /// See <https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dynamicMetadata")]
    pub dynamic_metadata: Option<BTreeMap<String, AuthPolicyRulesResponseSuccessDynamicMetadata>>,
    /// Custom success response items wrapped as HTTP headers.
    /// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesResponseSuccessHeaders>>,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata.
/// See <https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadata {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesResponseSuccessDynamicMetadataCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyRulesResponseSuccessDynamicMetadataJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyRulesResponseSuccessDynamicMetadataPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesResponseSuccessDynamicMetadataWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyRulesResponseSuccessDynamicMetadataWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesResponseSuccessDynamicMetadataCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataJson {
    pub properties: BTreeMap<String, AuthPolicyRulesResponseSuccessDynamicMetadataJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesResponseSuccessDynamicMetadataWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessDynamicMetadataWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyRulesResponseSuccessDynamicMetadataWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Custom success response items wrapped as HTTP headers.
/// For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeaders {
    /// Caching options for the resolved object returned when applying this config.
    /// Omit it to avoid caching objects for this config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cache: Option<AuthPolicyRulesResponseSuccessHeadersCache>,
    /// JSON object
    /// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub json: Option<AuthPolicyRulesResponseSuccessHeadersJson>,
    /// The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object).
    /// If omitted, it will be set to the name of the response config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Whether this config should generate individual observability metrics
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metrics: Option<bool>,
    /// Plain text content
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plain: Option<AuthPolicyRulesResponseSuccessHeadersPlain>,
    /// Priority group of the config.
    /// All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// Top-level route selectors.
    /// If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule.
    /// At least one selected HTTPRoute rule must match to trigger the auth rule.
    /// If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectors")]
    pub route_selectors: Option<Vec<AuthPolicyRulesResponseSuccessHeadersRouteSelectors>>,
    /// Conditions for Authorino to enforce this config.
    /// If omitted, the config will be enforced for all requests.
    /// If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub when: Option<Vec<AuthPolicyRulesResponseSuccessHeadersWhen>>,
    /// Authorino Festival Wristband token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wristband: Option<AuthPolicyRulesResponseSuccessHeadersWristband>,
}

/// Caching options for the resolved object returned when applying this config.
/// Omit it to avoid caching objects for this config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersCache {
    /// Key used to store the entry in the cache.
    /// The resolved key must be unique within the scope of this particular config.
    pub key: AuthPolicyRulesResponseSuccessHeadersCacheKey,
    /// Duration (in seconds) of the external data in the cache before pulled again from the source.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

/// Key used to store the entry in the cache.
/// The resolved key must be unique within the scope of this particular config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersCacheKey {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// JSON object
/// Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersJson {
    pub properties: BTreeMap<String, AuthPolicyRulesResponseSuccessHeadersJsonProperties>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersJsonProperties {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Plain text content
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersPlain {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// RouteSelector defines semantics for matching an HTTP request based on conditions
/// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersRouteSelectors {
    /// Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// Matches define conditions used for matching the rule against incoming HTTP requests.
    /// <https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub matches: Option<Vec<AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatches>>,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatches {
    /// Headers specifies HTTP request header matchers. Multiple match values are
    /// ANDed together, meaning, a request must match all the specified headers
    /// to select the route.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders>>,
    /// Method specifies HTTP method matcher.
    /// When specified, this route will be matched only if the request has the
    /// specified method.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesMethod>,
    /// Path specifies a HTTP request path matcher. If this field is not
    /// specified, a default prefix match on the "/" path is provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesPath>,
    /// QueryParams specifies HTTP query parameter matchers. Multiple match
    /// values are ANDed together, meaning, a request must match all the
    /// specified query parameters to select the route.
    /// 
    /// 
    /// Support: Extended
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "queryParams")]
    pub query_params: Option<Vec<AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams>>,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders {
    /// Name is the name of the HTTP Header to be matched. Name matching MUST be
    /// case insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2).>
    /// 
    /// 
    /// If multiple entries specify equivalent header names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent header name MUST be ignored. Due to the
    /// case-insensitivity of header names, "foo" and "Foo" are considered
    /// equivalent.
    /// 
    /// 
    /// When a header is repeated in an HTTP request, it is
    /// implementation-specific behavior as to how this is represented.
    /// Generally, proxies should follow the guidance from the RFC:
    /// <https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2> regarding
    /// processing a repeated header, with special handling for "Set-Cookie".
    pub name: String,
    /// Type specifies how to match against the value of the header.
    /// 
    /// 
    /// Support: Core (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression HeaderMatchType has implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other dialects
    /// of regular expressions. Please read the implementation's documentation to
    /// determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersType>,
    /// Value is the value of HTTP Header to be matched.
    pub value: String,
}

/// HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
/// headers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersType {
    Exact,
    RegularExpression,
}

/// HTTPRouteMatch defines the predicate used to match requests to a given
/// action. Multiple match types are ANDed together, i.e. the match will
/// evaluate to true only if all conditions are satisfied.
/// 
/// 
/// For example, the match below will match a HTTP request only if its path
/// starts with `/foo` AND it contains the `version: v1` header:
/// 
/// 
/// ```text
/// match:
/// 
/// 
/// 	path:
/// 	  value: "/foo"
/// 	headers:
/// 	- name: "version"
/// 	  value "v1"
/// 
/// 
/// ```
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "CONNECT")]
    Connect,
    #[serde(rename = "OPTIONS")]
    Options,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesPath {
    /// Type specifies how to match against the path Value.
    /// 
    /// 
    /// Support: Core (Exact, PathPrefix)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesPathType>,
    /// Value of the HTTP path to match against.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Path specifies a HTTP request path matcher. If this field is not
/// specified, a default prefix match on the "/" path is provided.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesPathType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams {
    /// Name is the name of the HTTP query param to be matched. This must be an
    /// exact string match. (See
    /// <https://tools.ietf.org/html/rfc7230#section-2.7.3).>
    /// 
    /// 
    /// If multiple entries specify equivalent query param names, only the first
    /// entry with an equivalent name MUST be considered for a match. Subsequent
    /// entries with an equivalent query param name MUST be ignored.
    /// 
    /// 
    /// If a query param is repeated in an HTTP request, the behavior is
    /// purposely left undefined, since different data planes have different
    /// capabilities. However, it is *recommended* that implementations should
    /// match against the first value of the param if the data plane supports it,
    /// as this behavior is expected in other load balancing contexts outside of
    /// the Gateway API.
    /// 
    /// 
    /// Users SHOULD NOT route traffic based on repeated query params to guard
    /// themselves against potential differences in the implementations.
    pub name: String,
    /// Type specifies how to match against the value of the query parameter.
    /// 
    /// 
    /// Support: Extended (Exact)
    /// 
    /// 
    /// Support: Implementation-specific (RegularExpression)
    /// 
    /// 
    /// Since RegularExpression QueryParamMatchType has Implementation-specific
    /// conformance, implementations can support POSIX, PCRE or any other
    /// dialects of regular expressions. Please read the implementation's
    /// documentation to determine the supported dialect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsType>,
    /// Value is the value of HTTP query param to be matched.
    pub value: String,
}

/// HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
/// query parameters.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsType {
    Exact,
    RegularExpression,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyRulesResponseSuccessHeadersWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessHeadersWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

/// Authorino Festival Wristband token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersWristband {
    /// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customClaims")]
    pub custom_claims: Option<BTreeMap<String, AuthPolicyRulesResponseSuccessHeadersWristbandCustomClaims>>,
    /// The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
    pub issuer: String,
    /// Reference by name to Kubernetes secrets and corresponding signing algorithms.
    /// The secrets must contain a `key.pem` entry whose value is the signing key formatted as PEM.
    #[serde(rename = "signingKeyRefs")]
    pub signing_key_refs: Vec<AuthPolicyRulesResponseSuccessHeadersWristbandSigningKeyRefs>,
    /// Time span of the wristband token, in seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tokenDuration")]
    pub token_duration: Option<i64>,
}

/// Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersWristbandCustomClaims {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct AuthPolicyRulesResponseSuccessHeadersWristbandSigningKeyRefs {
    /// Algorithm to sign the wristband token using the signing key provided
    pub algorithm: AuthPolicyRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm,
    /// Name of the signing key.
    /// The value is used to reference the Kubernetes secret that stores the key and in the `kid` claim of the wristband token header.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyRulesResponseSuccessHeadersWristbandSigningKeyRefsAlgorithm {
    #[serde(rename = "ES256")]
    Es256,
    #[serde(rename = "ES384")]
    Es384,
    #[serde(rename = "ES512")]
    Es512,
    #[serde(rename = "RS256")]
    Rs256,
    #[serde(rename = "RS384")]
    Rs384,
    #[serde(rename = "RS512")]
    Rs512,
}

/// Customizations on the denial status attributes when the request is unauthenticated.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 401 Unauthorized
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthenticated {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesResponseUnauthenticatedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesResponseUnauthenticatedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyRulesResponseUnauthenticatedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthenticatedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthenticatedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthenticatedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// Customizations on the denial status attributes when the request is unauthorized.
/// For integration of Authorino via proxy, the proxy must honour the response status attributes specified in this config.
/// Default: 403 Forbidden
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthorized {
    /// HTTP response body to override the default denial body.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<AuthPolicyRulesResponseUnauthorizedBody>,
    /// HTTP status code to override the default denial status code.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
    /// HTTP response headers to override the default denial headers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, AuthPolicyRulesResponseUnauthorizedHeaders>>,
    /// HTTP message to override the default denial message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<AuthPolicyRulesResponseUnauthorizedMessage>,
}

/// HTTP response body to override the default denial body.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthorizedBody {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP response headers to override the default denial headers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthorizedHeaders {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// HTTP message to override the default denial message.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyRulesResponseUnauthorizedMessage {
    /// Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. "Hello, {auth.identity.name}!").
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// The following Authorino custom modifiers are supported: @extract:{sep:" ",pos:0}, @replace{old:"",new:""}, @case:upper|lower, @base64:encode|decode and @strip.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// Static value
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// TargetRef identifies an API object to apply policy to.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyTargetRef {
    /// Group is the group of the target resource.
    pub group: String,
    /// Kind is kind of the target resource.
    pub kind: String,
    /// Name is the name of the target resource.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyWhen {
    /// A list of pattern expressions to be evaluated as a logical AND.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// A list of pattern expressions to be evaluated as a logical OR.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// The binary operator to be applied to the content fetched from the authorization JSON, for comparison with "value".
    /// Possible values are: "eq" (equal to), "neq" (not equal to), "incl" (includes; for arrays), "excl" (excludes; for arrays), "matches" (regex)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<AuthPolicyWhenOperator>,
    /// Reference to a named set of pattern expressions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patternRef")]
    pub pattern_ref: Option<String>,
    /// Path selector to fetch content from the authorization JSON (e.g. 'request.method').
    /// Any pattern supported by <https://pkg.go.dev/github.com/tidwall/gjson> can be used.
    /// Authorino custom JSON path modifiers are also supported.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// The value of reference for the comparison with the content fetched from the authorization JSON.
    /// If used with the "matches" operator, the value must compile to a valid Golang regex.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AuthPolicyWhenOperator {
    #[serde(rename = "eq")]
    Eq,
    #[serde(rename = "neq")]
    Neq,
    #[serde(rename = "incl")]
    Incl,
    #[serde(rename = "excl")]
    Excl,
    #[serde(rename = "matches")]
    Matches,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct AuthPolicyStatus {
    /// Represents the observations of a foo's current state.
    /// Known .status.conditions.type are: "Available"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ObservedGeneration reflects the generation of the most recently observed spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
}

