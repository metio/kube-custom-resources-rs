// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/submariner-io/submariner-operator/submariner.io/v1alpha1/submariners.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// SubmarinerSpec defines the desired state of Submariner.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "submariner.io", version = "v1alpha1", kind = "Submariner", plural = "submariners")]
#[kube(namespaced)]
#[kube(status = "SubmarinerStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct SubmarinerSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "airGappedDeployment")]
    pub air_gapped_deployment: Option<bool>,
    /// Type of broker (must be "k8s").
    pub broker: String,
    /// The broker API URL.
    #[serde(rename = "brokerK8sApiServer")]
    pub broker_k8s_api_server: String,
    /// The broker API Token.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerK8sApiServerToken")]
    pub broker_k8s_api_server_token: Option<String>,
    /// The broker certificate authority.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerK8sCA")]
    pub broker_k8s_ca: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerK8sInsecure")]
    pub broker_k8s_insecure: Option<bool>,
    /// The Broker namespace.
    #[serde(rename = "brokerK8sRemoteNamespace")]
    pub broker_k8s_remote_namespace: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "brokerK8sSecret")]
    pub broker_k8s_secret: Option<String>,
    /// Cable driver implementation - any of [libreswan, wireguard, vxlan].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cableDriver")]
    pub cable_driver: Option<String>,
    /// Enable logging IPsec debugging information.
    #[serde(rename = "ceIPSecDebug")]
    pub ce_ip_sec_debug: bool,
    /// Force UDP encapsulation for IPsec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecForceUDPEncaps")]
    pub ce_ip_sec_force_udp_encaps: Option<bool>,
    /// The IPsec IKE port (500 usually).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecIKEPort")]
    pub ce_ip_sec_ike_port: Option<i64>,
    /// The IPsec NAT traversal port (4500 usually).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecNATTPort")]
    pub ce_ip_sec_natt_port: Option<i64>,
    /// The IPsec Pre-Shared Key which must be identical in all route agents across the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecPSK")]
    pub ce_ip_sec_psk: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecPSKSecret")]
    pub ce_ip_sec_psk_secret: Option<String>,
    /// Enable this cluster as a preferred server for data-plane connections.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ceIPSecPreferredServer")]
    pub ce_ip_sec_preferred_server: Option<bool>,
    /// The cluster CIDR.
    #[serde(rename = "clusterCIDR")]
    pub cluster_cidr: String,
    /// The cluster ID used to identify the tunnels.
    #[serde(rename = "clusterID")]
    pub cluster_id: String,
    /// ClustersetIP CIDR for allocating ClustersetIPs to exported services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clustersetIPCIDR")]
    pub clusterset_ipcidr: Option<String>,
    /// Enable ClustersetIP default for services exported on this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clustersetIPEnabled")]
    pub clusterset_ip_enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "colorCodes")]
    pub color_codes: Option<String>,
    /// The gateway connection health check.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionHealthCheck")]
    pub connection_health_check: Option<SubmarinerConnectionHealthCheck>,
    /// Name of the custom CoreDNS configmap to configure forwarding to Lighthouse.
    /// It should be in <namespace>/<name> format where <namespace> is optional and defaults to kube-system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreDNSCustomConfig")]
    pub core_dns_custom_config: Option<SubmarinerCoreDnsCustomConfig>,
    /// List of domains to use for multi-cluster service discovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "customDomains")]
    pub custom_domains: Option<Vec<String>>,
    /// Enable operator debugging.
    pub debug: bool,
    /// The Global CIDR super-net range for allocating GlobalCIDRs to each cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalCIDR")]
    pub global_cidr: Option<String>,
    /// Halt on certificate error (so the pod gets restarted).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "haltOnCertificateError")]
    pub halt_on_certificate_error: Option<bool>,
    /// Is the cluster a hosted cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostedCluster")]
    pub hosted_cluster: Option<bool>,
    /// Override component images.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageOverrides")]
    pub image_overrides: Option<BTreeMap<String, String>>,
    /// Enable automatic Load Balancer in front of the gateways.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerEnabled")]
    pub load_balancer_enabled: Option<bool>,
    /// The namespace in which to deploy the submariner operator.
    pub namespace: String,
    /// Enable NAT between clusters.
    #[serde(rename = "natEnabled")]
    pub nat_enabled: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// The image repository.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    /// The service CIDR.
    #[serde(rename = "serviceCIDR")]
    pub service_cidr: String,
    /// Enable support for Service Discovery (Lighthouse).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDiscoveryEnabled")]
    pub service_discovery_enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<SubmarinerTolerations>>,
    /// The image tag.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// The gateway connection health check.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerConnectionHealthCheck {
    /// Enable the connection health check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// The interval at which health check pings are sent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "intervalSeconds")]
    pub interval_seconds: Option<i64>,
    /// The maximum number of packets lost at which the health checker will mark the connection as down.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPacketLossCount")]
    pub max_packet_loss_count: Option<i64>,
}

/// Name of the custom CoreDNS configmap to configure forwarding to Lighthouse.
/// It should be in <namespace>/<name> format where <namespace> is optional and defaults to kube-system.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerCoreDnsCustomConfig {
    /// Name of the custom CoreDNS configmap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapName")]
    pub config_map_name: Option<String>,
    /// Namespace of the custom CoreDNS configmap.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// SubmarinerStatus defines the observed state of Submariner.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "airGappedDeployment")]
    pub air_gapped_deployment: Option<bool>,
    /// The current cluster CIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterCIDR")]
    pub cluster_cidr: Option<String>,
    /// The current cluster ID.
    #[serde(rename = "clusterID")]
    pub cluster_id: String,
    /// The current clustersetIP CIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clustersetIPCIDR")]
    pub clusterset_ipcidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "colorCodes")]
    pub color_codes: Option<String>,
    /// Information about the deployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deploymentInfo")]
    pub deployment_info: Option<SubmarinerStatusDeploymentInfo>,
    /// The status of the gateway DaemonSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayDaemonSetStatus")]
    pub gateway_daemon_set_status: Option<SubmarinerStatusGatewayDaemonSetStatus>,
    /// Status of the gateways in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateways: Option<Vec<SubmarinerStatusGateways>>,
    /// The current global CIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalCIDR")]
    pub global_cidr: Option<String>,
    /// The status of the Globalnet DaemonSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalnetDaemonSetStatus")]
    pub globalnet_daemon_set_status: Option<SubmarinerStatusGlobalnetDaemonSetStatus>,
    /// Is the cluster a hosted cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostedCluster")]
    pub hosted_cluster: Option<bool>,
    /// The status of the load balancer DaemonSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerStatus")]
    pub load_balancer_status: Option<SubmarinerStatusLoadBalancerStatus>,
    /// The current NAT status.
    #[serde(rename = "natEnabled")]
    pub nat_enabled: bool,
    /// The current network plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkPlugin")]
    pub network_plugin: Option<String>,
    /// The status of the route agent DaemonSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeAgentDaemonSetStatus")]
    pub route_agent_daemon_set_status: Option<SubmarinerStatusRouteAgentDaemonSetStatus>,
    /// The current service CIDR.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceCIDR")]
    pub service_cidr: Option<String>,
    /// The image version in use by the various Submariner DaemonSets and Deployments.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Information about the deployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusDeploymentInfo {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cloudProvider")]
    pub cloud_provider: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesType")]
    pub kubernetes_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesTypeVersion")]
    pub kubernetes_type_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesVersion")]
    pub kubernetes_version: Option<String>,
}

/// The status of the gateway DaemonSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastResourceVersion")]
    pub last_resource_version: Option<String>,
    #[serde(rename = "mismatchedContainerImages")]
    pub mismatched_container_images: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonReadyContainerStates")]
    pub non_ready_container_states: Option<Vec<SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStates>>,
    /// DaemonSetStatus represents the current status of a daemon set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<SubmarinerStatusGatewayDaemonSetStatusStatus>,
}

/// ContainerState holds a possible state of container.
/// Only one of its members may be specified.
/// If none of them is specified, the default one is ContainerStateWaiting.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStates {
    /// Details about a running container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub running: Option<SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesRunning>,
    /// Details about a terminated container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub terminated: Option<SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesTerminated>,
    /// Details about a waiting container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub waiting: Option<SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesWaiting>,
}

/// Details about a running container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesRunning {
    /// Time at which the container was last (re-)started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a terminated container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesTerminated {
    /// Container's ID in the format '<type>://<container_id>'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerID")]
    pub container_id: Option<String>,
    /// Exit status from the last termination of the container
    #[serde(rename = "exitCode")]
    pub exit_code: i32,
    /// Time at which the container last terminated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finishedAt")]
    pub finished_at: Option<String>,
    /// Message regarding the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// Signal from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<i32>,
    /// Time at which previous execution of the container started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a waiting container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusNonReadyContainerStatesWaiting {
    /// Message regarding why the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// DaemonSetStatus represents the current status of a daemon set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewayDaemonSetStatusStatus {
    /// Count of hash collisions for the DaemonSet. The DaemonSet controller
    /// uses this field as a collision avoidance mechanism when it needs to
    /// create the name for the newest ControllerRevision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collisionCount")]
    pub collision_count: Option<i32>,
    /// Represents the latest available observations of a DaemonSet's current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// The number of nodes that are running at least 1
    /// daemon pod and are supposed to run the daemon pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "currentNumberScheduled")]
    pub current_number_scheduled: i32,
    /// The total number of nodes that should be running the daemon
    /// pod (including nodes correctly running the daemon pod).
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "desiredNumberScheduled")]
    pub desired_number_scheduled: i32,
    /// The number of nodes that should be running the
    /// daemon pod and have one or more of the daemon pod running and
    /// available (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberAvailable")]
    pub number_available: Option<i32>,
    /// The number of nodes that are running the daemon pod, but are
    /// not supposed to run the daemon pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "numberMisscheduled")]
    pub number_misscheduled: i32,
    /// numberReady is the number of nodes that should be running the daemon pod and have one
    /// or more of the daemon pod running with a Ready Condition.
    #[serde(rename = "numberReady")]
    pub number_ready: i32,
    /// The number of nodes that should be running the
    /// daemon pod and have none of the daemon pod running and available
    /// (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberUnavailable")]
    pub number_unavailable: Option<i32>,
    /// The most recent generation observed by the daemon set controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// The total number of nodes that are running updated daemon pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedNumberScheduled")]
    pub updated_number_scheduled: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGateways {
    pub connections: Vec<SubmarinerStatusGatewaysConnections>,
    #[serde(rename = "haStatus")]
    pub ha_status: String,
    #[serde(rename = "localEndpoint")]
    pub local_endpoint: SubmarinerStatusGatewaysLocalEndpoint,
    #[serde(rename = "statusFailure")]
    pub status_failure: String,
    pub version: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewaysConnections {
    pub endpoint: SubmarinerStatusGatewaysConnectionsEndpoint,
    /// LatencySpec describes the round trip time information for a packet
    /// between the gateway pods of two clusters.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "latencyRTT")]
    pub latency_rtt: Option<SubmarinerStatusGatewaysConnectionsLatencyRtt>,
    pub status: String,
    #[serde(rename = "statusMessage")]
    pub status_message: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usingIP")]
    pub using_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usingNAT")]
    pub using_nat: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewaysConnectionsEndpoint {
    pub backend: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backend_config: Option<BTreeMap<String, String>>,
    pub cable_name: String,
    pub cluster_id: String,
    /// Deprecated: Get/SetHealthCheckIP() or, if necessary, HealthCheckIPs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIP")]
    pub health_check_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIPs")]
    pub health_check_i_ps: Option<Vec<String>>,
    pub hostname: String,
    pub nat_enabled: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIPs")]
    pub private_i_ps: Option<Vec<String>>,
    /// Deprecated: Use Get/SetPrivateIP() or, if necessary, PrivateIPs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicIPs")]
    pub public_i_ps: Option<Vec<String>>,
    /// Deprecated: Set/SetPublicIP() or, if necessary, PublicIPs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_ip: Option<String>,
    pub subnets: Vec<String>,
}

/// LatencySpec describes the round trip time information for a packet
/// between the gateway pods of two clusters.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewaysConnectionsLatencyRtt {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub average: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub last: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub min: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdDev")]
    pub std_dev: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGatewaysLocalEndpoint {
    pub backend: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backend_config: Option<BTreeMap<String, String>>,
    pub cable_name: String,
    pub cluster_id: String,
    /// Deprecated: Get/SetHealthCheckIP() or, if necessary, HealthCheckIPs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIP")]
    pub health_check_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckIPs")]
    pub health_check_i_ps: Option<Vec<String>>,
    pub hostname: String,
    pub nat_enabled: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateIPs")]
    pub private_i_ps: Option<Vec<String>>,
    /// Deprecated: Use Get/SetPrivateIP() or, if necessary, PrivateIPs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub private_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publicIPs")]
    pub public_i_ps: Option<Vec<String>>,
    /// Deprecated: Set/SetPublicIP() or, if necessary, PublicIPs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub public_ip: Option<String>,
    pub subnets: Vec<String>,
}

/// The status of the Globalnet DaemonSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastResourceVersion")]
    pub last_resource_version: Option<String>,
    #[serde(rename = "mismatchedContainerImages")]
    pub mismatched_container_images: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonReadyContainerStates")]
    pub non_ready_container_states: Option<Vec<SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStates>>,
    /// DaemonSetStatus represents the current status of a daemon set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<SubmarinerStatusGlobalnetDaemonSetStatusStatus>,
}

/// ContainerState holds a possible state of container.
/// Only one of its members may be specified.
/// If none of them is specified, the default one is ContainerStateWaiting.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStates {
    /// Details about a running container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub running: Option<SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesRunning>,
    /// Details about a terminated container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub terminated: Option<SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesTerminated>,
    /// Details about a waiting container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub waiting: Option<SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesWaiting>,
}

/// Details about a running container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesRunning {
    /// Time at which the container was last (re-)started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a terminated container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesTerminated {
    /// Container's ID in the format '<type>://<container_id>'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerID")]
    pub container_id: Option<String>,
    /// Exit status from the last termination of the container
    #[serde(rename = "exitCode")]
    pub exit_code: i32,
    /// Time at which the container last terminated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finishedAt")]
    pub finished_at: Option<String>,
    /// Message regarding the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// Signal from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<i32>,
    /// Time at which previous execution of the container started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a waiting container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesWaiting {
    /// Message regarding why the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// DaemonSetStatus represents the current status of a daemon set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusGlobalnetDaemonSetStatusStatus {
    /// Count of hash collisions for the DaemonSet. The DaemonSet controller
    /// uses this field as a collision avoidance mechanism when it needs to
    /// create the name for the newest ControllerRevision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collisionCount")]
    pub collision_count: Option<i32>,
    /// Represents the latest available observations of a DaemonSet's current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// The number of nodes that are running at least 1
    /// daemon pod and are supposed to run the daemon pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "currentNumberScheduled")]
    pub current_number_scheduled: i32,
    /// The total number of nodes that should be running the daemon
    /// pod (including nodes correctly running the daemon pod).
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "desiredNumberScheduled")]
    pub desired_number_scheduled: i32,
    /// The number of nodes that should be running the
    /// daemon pod and have one or more of the daemon pod running and
    /// available (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberAvailable")]
    pub number_available: Option<i32>,
    /// The number of nodes that are running the daemon pod, but are
    /// not supposed to run the daemon pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "numberMisscheduled")]
    pub number_misscheduled: i32,
    /// numberReady is the number of nodes that should be running the daemon pod and have one
    /// or more of the daemon pod running with a Ready Condition.
    #[serde(rename = "numberReady")]
    pub number_ready: i32,
    /// The number of nodes that should be running the
    /// daemon pod and have none of the daemon pod running and available
    /// (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberUnavailable")]
    pub number_unavailable: Option<i32>,
    /// The most recent generation observed by the daemon set controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// The total number of nodes that are running updated daemon pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedNumberScheduled")]
    pub updated_number_scheduled: Option<i32>,
}

/// The status of the load balancer DaemonSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusLoadBalancerStatus {
    /// LoadBalancerStatus represents the status of a load-balancer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<SubmarinerStatusLoadBalancerStatusStatus>,
}

/// LoadBalancerStatus represents the status of a load-balancer.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusLoadBalancerStatusStatus {
    /// Ingress is a list containing ingress points for the load-balancer.
    /// Traffic intended for the service should be sent to these ingress points.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<Vec<SubmarinerStatusLoadBalancerStatusStatusIngress>>,
}

/// LoadBalancerIngress represents the status of a load-balancer ingress point:
/// traffic intended for the service should be sent to an ingress point.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusLoadBalancerStatusStatusIngress {
    /// Hostname is set for load-balancer ingress points that are DNS based
    /// (typically AWS load-balancers)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// IP is set for load-balancer ingress points that are IP based
    /// (typically GCE or OpenStack load-balancers)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
    /// IPMode specifies how the load-balancer IP behaves, and may only be specified when the ip field is specified.
    /// Setting this to "VIP" indicates that traffic is delivered to the node with
    /// the destination set to the load-balancer's IP and port.
    /// Setting this to "Proxy" indicates that traffic is delivered to the node or pod with
    /// the destination set to the node's IP and node port or the pod's IP and port.
    /// Service implementations may use this information to adjust traffic routing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipMode")]
    pub ip_mode: Option<String>,
    /// Ports is a list of records of service ports
    /// If used, every port defined in the service should have an entry in it
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<SubmarinerStatusLoadBalancerStatusStatusIngressPorts>>,
}

/// PortStatus represents the error condition of a service port
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusLoadBalancerStatusStatusIngressPorts {
    /// Error is to record the problem with the service port
    /// The format of the error shall comply with the following rules:
    /// - built-in error values shall be specified in this file and those shall use
    ///   CamelCase names
    /// - cloud provider specific error values must have names that comply with the
    ///   format foo.example.com/CamelCase.
    pub error: String,
    /// Port is the port number of the service port of which status is recorded here
    pub port: i32,
    /// Protocol is the protocol of the service port of which status is recorded here
    /// The supported values are: "TCP", "UDP", "SCTP"
    pub protocol: String,
}

/// The status of the route agent DaemonSet.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastResourceVersion")]
    pub last_resource_version: Option<String>,
    #[serde(rename = "mismatchedContainerImages")]
    pub mismatched_container_images: bool,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonReadyContainerStates")]
    pub non_ready_container_states: Option<Vec<SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStates>>,
    /// DaemonSetStatus represents the current status of a daemon set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<SubmarinerStatusRouteAgentDaemonSetStatusStatus>,
}

/// ContainerState holds a possible state of container.
/// Only one of its members may be specified.
/// If none of them is specified, the default one is ContainerStateWaiting.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStates {
    /// Details about a running container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub running: Option<SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesRunning>,
    /// Details about a terminated container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub terminated: Option<SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesTerminated>,
    /// Details about a waiting container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub waiting: Option<SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesWaiting>,
}

/// Details about a running container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesRunning {
    /// Time at which the container was last (re-)started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a terminated container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesTerminated {
    /// Container's ID in the format '<type>://<container_id>'
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerID")]
    pub container_id: Option<String>,
    /// Exit status from the last termination of the container
    #[serde(rename = "exitCode")]
    pub exit_code: i32,
    /// Time at which the container last terminated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finishedAt")]
    pub finished_at: Option<String>,
    /// Message regarding the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// Signal from the last termination of the container
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<i32>,
    /// Time at which previous execution of the container started
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startedAt")]
    pub started_at: Option<String>,
}

/// Details about a waiting container
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesWaiting {
    /// Message regarding why the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// (brief) reason the container is not yet running.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// DaemonSetStatus represents the current status of a daemon set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SubmarinerStatusRouteAgentDaemonSetStatusStatus {
    /// Count of hash collisions for the DaemonSet. The DaemonSet controller
    /// uses this field as a collision avoidance mechanism when it needs to
    /// create the name for the newest ControllerRevision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collisionCount")]
    pub collision_count: Option<i32>,
    /// Represents the latest available observations of a DaemonSet's current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// The number of nodes that are running at least 1
    /// daemon pod and are supposed to run the daemon pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "currentNumberScheduled")]
    pub current_number_scheduled: i32,
    /// The total number of nodes that should be running the daemon
    /// pod (including nodes correctly running the daemon pod).
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "desiredNumberScheduled")]
    pub desired_number_scheduled: i32,
    /// The number of nodes that should be running the
    /// daemon pod and have one or more of the daemon pod running and
    /// available (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberAvailable")]
    pub number_available: Option<i32>,
    /// The number of nodes that are running the daemon pod, but are
    /// not supposed to run the daemon pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
    #[serde(rename = "numberMisscheduled")]
    pub number_misscheduled: i32,
    /// numberReady is the number of nodes that should be running the daemon pod and have one
    /// or more of the daemon pod running with a Ready Condition.
    #[serde(rename = "numberReady")]
    pub number_ready: i32,
    /// The number of nodes that should be running the
    /// daemon pod and have none of the daemon pod running and available
    /// (ready for at least spec.minReadySeconds)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberUnavailable")]
    pub number_unavailable: Option<i32>,
    /// The most recent generation observed by the daemon set controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// The total number of nodes that are running updated daemon pod
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedNumberScheduled")]
    pub updated_number_scheduled: Option<i32>,
}

