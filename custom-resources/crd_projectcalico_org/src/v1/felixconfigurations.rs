// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/projectcalico/calico/crd.projectcalico.org/v1/felixconfigurations.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "crd.projectcalico.org", version = "v1", kind = "FelixConfiguration", plural = "felixconfigurations")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct FelixConfigurationSpec {
    /// AllowIPIPPacketsFromWorkloads controls whether Felix will add a rule to drop IPIP encapsulated traffic
    /// from workloads. [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowIPIPPacketsFromWorkloads")]
    pub allow_ipip_packets_from_workloads: Option<bool>,
    /// AllowVXLANPacketsFromWorkloads controls whether Felix will add a rule to drop VXLAN encapsulated traffic
    /// from workloads. [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowVXLANPacketsFromWorkloads")]
    pub allow_vxlan_packets_from_workloads: Option<bool>,
    /// AWSSrcDstCheck controls whether Felix will try to change the "source/dest check" setting on the EC2 instance
    /// on which it is running. A value of "Disable" will try to disable the source/dest check. Disabling the check
    /// allows for sending workload traffic without encapsulation within the same AWS subnet.
    /// [Default: DoNothing]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsSrcDstCheck")]
    pub aws_src_dst_check: Option<FelixConfigurationAwsSrcDstCheck>,
    /// BPFAttachType controls how are the BPF programs at the network interfaces attached.
    /// By default `TCX` is used where available to enable easier coexistence with 3rd party programs.
    /// `TC` can force the legacy method of attaching via a qdisc. `TCX` falls back to `TC` if `TCX` is not available.
    /// [Default: TCX]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfAttachType")]
    pub bpf_attach_type: Option<FelixConfigurationBpfAttachType>,
    /// BPFCTLBLogFilter specifies, what is logged by connect time load balancer when BPFLogLevel is
    /// debug. Currently has to be specified as 'all' when BPFLogFilters is set
    /// to see CTLB logs.
    /// [Default: unset - means logs are emitted when BPFLogLevel id debug and BPFLogFilters not set.]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfCTLBLogFilter")]
    pub bpf_ctlb_log_filter: Option<String>,
    /// BPFConnectTimeLoadBalancing when in BPF mode, controls whether Felix installs the connect-time load
    /// balancer. The connect-time load balancer is required for the host to be able to reach Kubernetes services
    /// and it improves the performance of pod-to-service connections.When set to TCP, connect time load balancing
    /// is available only for services with TCP ports. [Default: TCP]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfConnectTimeLoadBalancing")]
    pub bpf_connect_time_load_balancing: Option<FelixConfigurationBpfConnectTimeLoadBalancing>,
    /// BPFConnectTimeLoadBalancingEnabled when in BPF mode, controls whether Felix installs the connection-time load
    /// balancer.  The connect-time load balancer is required for the host to be able to reach Kubernetes services
    /// and it improves the performance of pod-to-service connections.  The only reason to disable it is for debugging
    /// purposes.
    /// 
    /// Deprecated: Use BPFConnectTimeLoadBalancing [Default: true]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfConnectTimeLoadBalancingEnabled")]
    pub bpf_connect_time_load_balancing_enabled: Option<bool>,
    /// BPFConntrackLogLevel controls the log level of the BPF conntrack cleanup program, which runs periodically
    /// to clean up expired BPF conntrack entries.
    /// [Default: Off].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfConntrackLogLevel")]
    pub bpf_conntrack_log_level: Option<FelixConfigurationBpfConntrackLogLevel>,
    /// BPFConntrackCleanupMode controls how BPF conntrack entries are cleaned up.  `Auto` will use a BPF program if supported,
    /// falling back to userspace if not.  `Userspace` will always use the userspace cleanup code.  `BPFProgram` will
    /// always use the BPF program (failing if not supported).
    /// 
    /// /To be deprecated in future versions as conntrack map type changed to
    /// lru_hash and userspace cleanup is the only mode that is supported.
    /// [Default: Userspace]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfConntrackMode")]
    pub bpf_conntrack_mode: Option<FelixConfigurationBpfConntrackMode>,
    /// BPFConntrackTimers overrides the default values for the specified conntrack timer if
    /// set. Each value can be either a duration or `Auto` to pick the value from
    /// a Linux conntrack timeout.
    /// 
    /// Configurable timers are: CreationGracePeriod, TCPSynSent,
    /// TCPEstablished, TCPFinsSeen, TCPResetSeen, UDPTimeout, GenericTimeout,
    /// ICMPTimeout.
    /// 
    /// Unset values are replaced by the default values with a warning log for
    /// incorrect values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfConntrackTimeouts")]
    pub bpf_conntrack_timeouts: Option<FelixConfigurationBpfConntrackTimeouts>,
    /// BPFDSROptoutCIDRs is a list of CIDRs which are excluded from DSR. That is, clients
    /// in those CIDRs will access service node ports as if BPFExternalServiceMode was set to
    /// Tunnel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfDSROptoutCIDRs")]
    pub bpf_dsr_optout_cid_rs: Option<Vec<String>>,
    /// BPFDataIfacePattern is a regular expression that controls which interfaces Felix should attach BPF programs to
    /// in order to catch traffic to/from the network.  This needs to match the interfaces that Calico workload traffic
    /// flows over as well as any interfaces that handle incoming traffic to nodeports and services from outside the
    /// cluster.  It should not match the workload interfaces (usually named cali...) or any other special device managed
    /// by Calico itself (e.g., tunnels).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfDataIfacePattern")]
    pub bpf_data_iface_pattern: Option<String>,
    /// BPFDisableGROForIfaces is a regular expression that controls which interfaces Felix should disable the
    /// Generic Receive Offload [GRO] option.  It should not match the workload interfaces (usually named cali...).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfDisableGROForIfaces")]
    pub bpf_disable_gro_for_ifaces: Option<String>,
    /// BPFDisableUnprivileged, if enabled, Felix sets the kernel.unprivileged_bpf_disabled sysctl to disable
    /// unprivileged use of BPF.  This ensures that unprivileged users cannot access Calico's BPF maps and
    /// cannot insert their own BPF programs to interfere with Calico's. [Default: true]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfDisableUnprivileged")]
    pub bpf_disable_unprivileged: Option<bool>,
    /// BPFEnabled, if enabled Felix will use the BPF dataplane. [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfEnabled")]
    pub bpf_enabled: Option<bool>,
    /// BPFEnforceRPF enforce strict RPF on all host interfaces with BPF programs regardless of
    /// what is the per-interfaces or global setting. Possible values are Disabled, Strict
    /// or Loose. [Default: Loose]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfEnforceRPF")]
    pub bpf_enforce_rpf: Option<String>,
    /// BPFExcludeCIDRsFromNAT is a list of CIDRs that are to be excluded from NAT
    /// resolution so that host can handle them. A typical usecase is node local
    /// DNS cache.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfExcludeCIDRsFromNAT")]
    pub bpf_exclude_cid_rs_from_nat: Option<Vec<String>>,
    /// BPFExportBufferSizeMB in BPF mode, controls the buffer size used for sending BPF events to felix.
    /// [Default: 1]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfExportBufferSizeMB")]
    pub bpf_export_buffer_size_mb: Option<i64>,
    /// BPFExtToServiceConnmark in BPF mode, controls a 32bit mark that is set on connections from an
    /// external client to a local service. This mark allows us to control how packets of that
    /// connection are routed within the host and how is routing interpreted by RPF check. [Default: 0]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfExtToServiceConnmark")]
    pub bpf_ext_to_service_connmark: Option<i64>,
    /// BPFExternalServiceMode in BPF mode, controls how connections from outside the cluster to services (node ports
    /// and cluster IPs) are forwarded to remote workloads.  If set to "Tunnel" then both request and response traffic
    /// is tunneled to the remote node.  If set to "DSR", the request traffic is tunneled but the response traffic
    /// is sent directly from the remote node.  In "DSR" mode, the remote node appears to use the IP of the ingress
    /// node; this requires a permissive L2 network.  [Default: Tunnel]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfExternalServiceMode")]
    pub bpf_external_service_mode: Option<String>,
    /// BPFForceTrackPacketsFromIfaces in BPF mode, forces traffic from these interfaces
    /// to skip Calico's iptables NOTRACK rule, allowing traffic from those interfaces to be
    /// tracked by Linux conntrack.  Should only be used for interfaces that are not used for
    /// the Calico fabric.  For example, a docker bridge device for non-Calico-networked
    /// containers. [Default: docker+]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfForceTrackPacketsFromIfaces")]
    pub bpf_force_track_packets_from_ifaces: Option<Vec<String>>,
    /// BPFHostConntrackBypass Controls whether to bypass Linux conntrack in BPF mode for
    /// workloads and services. [Default: true - bypass Linux conntrack]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfHostConntrackBypass")]
    pub bpf_host_conntrack_bypass: Option<bool>,
    /// BPFHostNetworkedNATWithoutCTLB when in BPF mode, controls whether Felix does a NAT without CTLB. This along with BPFConnectTimeLoadBalancing
    /// determines the CTLB behavior. [Default: Enabled]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfHostNetworkedNATWithoutCTLB")]
    pub bpf_host_networked_nat_without_ctlb: Option<FelixConfigurationBpfHostNetworkedNatWithoutCtlb>,
    /// BPFJITHardening controls BPF JIT hardening. When set to "Auto", Felix will set JIT hardening to 1
    /// if it detects the current value is 2 (strict mode that hurts performance). When set to "Strict",
    /// Felix will not modify the JIT hardening setting. [Default: Auto]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfJITHardening")]
    pub bpf_jit_hardening: Option<String>,
    /// BPFKubeProxyHealthzPort, in BPF mode, controls the port that Felix's embedded kube-proxy health check server binds to.
    /// The health check server is used by external load balancers to determine if this node should receive traffic.  [Default: 10256]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfKubeProxyHealthzPort")]
    pub bpf_kube_proxy_healthz_port: Option<i64>,
    /// BPFKubeProxyIptablesCleanupEnabled, if enabled in BPF mode, Felix will proactively clean up the upstream
    /// Kubernetes kube-proxy's iptables chains.  Should only be enabled if kube-proxy is not running.  [Default: true]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfKubeProxyIptablesCleanupEnabled")]
    pub bpf_kube_proxy_iptables_cleanup_enabled: Option<bool>,
    /// BPFKubeProxyMinSyncPeriod, in BPF mode, controls the minimum time between updates to the dataplane for Felix's
    /// embedded kube-proxy.  Lower values give reduced set-up latency.  Higher values reduce Felix CPU usage by
    /// batching up more work.  [Default: 1s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfKubeProxyMinSyncPeriod")]
    pub bpf_kube_proxy_min_sync_period: Option<String>,
    /// BPFL3IfacePattern is a regular expression that allows to list tunnel devices like wireguard or vxlan (i.e., L3 devices)
    /// in addition to BPFDataIfacePattern. That is, tunnel interfaces not created by Calico, that Calico workload traffic flows
    /// over as well as any interfaces that handle incoming traffic to nodeports and services from outside the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfL3IfacePattern")]
    pub bpf_l3_iface_pattern: Option<String>,
    /// BPFLogFilters is a map of key=values where the value is
    /// a pcap filter expression and the key is an interface name with 'all'
    /// denoting all interfaces, 'weps' all workload endpoints and 'heps' all host
    /// endpoints.
    /// 
    /// When specified as an env var, it accepts a comma-separated list of
    /// key=values.
    /// [Default: unset - means all debug logs are emitted]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfLogFilters")]
    pub bpf_log_filters: Option<BTreeMap<String, String>>,
    /// BPFLogLevel controls the log level of the BPF programs when in BPF dataplane mode.  One of "Off", "Info", or
    /// "Debug".  The logs are emitted to the BPF trace pipe, accessible with the command `tc exec bpf debug`.
    /// [Default: Off].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfLogLevel")]
    pub bpf_log_level: Option<String>,
    /// BPFMapSizeConntrack sets the size for the conntrack map.  This map must be large enough to hold
    /// an entry for each active connection.  Warning: changing the size of the conntrack map can cause disruption.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizeConntrack")]
    pub bpf_map_size_conntrack: Option<i64>,
    /// BPFMapSizeConntrackCleanupQueue sets the size for the map used to hold NAT conntrack entries that are queued
    /// for cleanup.  This should be big enough to hold all the NAT entries that expire within one cleanup interval.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizeConntrackCleanupQueue")]
    pub bpf_map_size_conntrack_cleanup_queue: Option<i64>,
    /// BPFMapSizeConntrackScaling controls whether and how we scale the conntrack map size depending
    /// on its usage. 'Disabled' make the size stay at the default or whatever is set by
    /// BPFMapSizeConntrack*. 'DoubleIfFull' doubles the size when the map is pretty much full even
    /// after cleanups. [Default: DoubleIfFull]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizeConntrackScaling")]
    pub bpf_map_size_conntrack_scaling: Option<String>,
    /// BPFMapSizeIPSets sets the size for ipsets map.  The IP sets map must be large enough to hold an entry
    /// for each endpoint matched by every selector in the source/destination matches in network policy.  Selectors
    /// such as "all()" can result in large numbers of entries (one entry per endpoint in that case).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizeIPSets")]
    pub bpf_map_size_ip_sets: Option<i64>,
    /// BPFMapSizeIfState sets the size for ifstate map.  The ifstate map must be large enough to hold an entry
    /// for each device (host + workloads) on a host.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizeIfState")]
    pub bpf_map_size_if_state: Option<i64>,
    /// BPFMapSizeNATAffinity sets the size of the BPF map that stores the affinity of a connection (for services that
    /// enable that feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizeNATAffinity")]
    pub bpf_map_size_nat_affinity: Option<i64>,
    /// BPFMapSizeNATBackend sets the size for NAT back end map.
    /// This is the total number of endpoints. This is mostly
    /// more than the size of the number of services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizeNATBackend")]
    pub bpf_map_size_nat_backend: Option<i64>,
    /// BPFMapSizeNATFrontend sets the size for NAT front end map.
    /// FrontendMap should be large enough to hold an entry for each nodeport,
    /// external IP and each port in each service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizeNATFrontend")]
    pub bpf_map_size_nat_frontend: Option<i64>,
    /// BPFMapSizePerCPUConntrack determines the size of conntrack map based on the number of CPUs. If set to a
    /// non-zero value, overrides BPFMapSizeConntrack with `BPFMapSizePerCPUConntrack * (Number of CPUs)`.
    /// This map must be large enough to hold an entry for each active connection.  Warning: changing the size of the
    /// conntrack map can cause disruption.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizePerCpuConntrack")]
    pub bpf_map_size_per_cpu_conntrack: Option<i64>,
    /// BPFMapSizeRoute sets the size for the routes map.  The routes map should be large enough
    /// to hold one entry per workload and a handful of entries per host (enough to cover its own IPs and
    /// tunnel IPs).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfMapSizeRoute")]
    pub bpf_map_size_route: Option<i64>,
    /// BPFPSNATPorts sets the range from which we randomly pick a port if there is a source port
    /// collision. This should be within the ephemeral range as defined by RFC 6056 (1024–65535) and
    /// preferably outside the  ephemeral ranges used by common operating systems. Linux uses
    /// 32768–60999, while others mostly use the IANA defined range 49152–65535. It is not necessarily
    /// a problem if this range overlaps with the operating systems. Both ends of the range are
    /// inclusive. [Default: 20000:29999]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfPSNATPorts")]
    pub bpf_psnat_ports: Option<IntOrString>,
    /// BPFPolicyDebugEnabled when true, Felix records detailed information
    /// about the BPF policy programs, which can be examined with the calico-bpf command-line tool.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfPolicyDebugEnabled")]
    pub bpf_policy_debug_enabled: Option<bool>,
    /// BPFProfiling controls profiling of BPF programs. At the monent, it can be
    /// Disabled or Enabled. [Default: Disabled]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfProfiling")]
    pub bpf_profiling: Option<FelixConfigurationBpfProfiling>,
    /// BPFRedirectToPeer controls whether traffic may be forwarded directly to the peer side of a workload’s device.
    /// Note that the legacy "L2Only" option is now deprecated and if set it is treated like "Enabled.
    /// Setting this option to "Enabled" allows direct redirection (including from L3 host devices such as IPIP tunnels or WireGuard),
    /// which can improve redirection performance but causes the redirected packets to bypass the host‑side ingress path.
    /// As a result, packet‑capture tools on the host side of the workload device (for example, tcpdump) will not see that traffic. [Default: Enabled]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bpfRedirectToPeer")]
    pub bpf_redirect_to_peer: Option<FelixConfigurationBpfRedirectToPeer>,
    /// CgroupV2Path overrides the default location where to find the cgroup hierarchy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupV2Path")]
    pub cgroup_v2_path: Option<String>,
    /// ChainInsertMode controls whether Felix hooks the kernel's top-level iptables chains by inserting a rule
    /// at the top of the chain or by appending a rule at the bottom. insert is the safe default since it prevents
    /// Calico's rules from being bypassed. If you switch to append mode, be sure that the other rules in the chains
    /// signal acceptance by falling through to the Calico rules, otherwise the Calico policy will be bypassed.
    /// [Default: insert]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chainInsertMode")]
    pub chain_insert_mode: Option<String>,
    /// DataplaneDriver filename of the external dataplane driver to use.  Only used if UseInternalDataplaneDriver
    /// is set to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataplaneDriver")]
    pub dataplane_driver: Option<String>,
    /// DataplaneWatchdogTimeout is the readiness/liveness timeout used for Felix's (internal) dataplane driver.
    /// Deprecated: replaced by the generic HealthTimeoutOverrides.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataplaneWatchdogTimeout")]
    pub dataplane_watchdog_timeout: Option<String>,
    /// DebugDisableLogDropping disables the dropping of log messages when the log buffer is full.  This can
    /// significantly impact performance if log write-out is a bottleneck. [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "debugDisableLogDropping")]
    pub debug_disable_log_dropping: Option<bool>,
    /// DebugHost is the host IP or hostname to bind the debug port to.  Only used
    /// if DebugPort is set. [Default:localhost]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "debugHost")]
    pub debug_host: Option<String>,
    /// DebugMemoryProfilePath is the path to write the memory profile to when triggered by signal.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "debugMemoryProfilePath")]
    pub debug_memory_profile_path: Option<String>,
    /// DebugPort if set, enables Felix's debug HTTP port, which allows memory and CPU profiles
    /// to be retrieved.  The debug port is not secure, it should not be exposed to the internet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "debugPort")]
    pub debug_port: Option<i64>,
    /// DebugSimulateCalcGraphHangAfter is used to simulate a hang in the calculation graph after the specified duration.
    /// This is useful in tests of the watchdog system only!
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "debugSimulateCalcGraphHangAfter")]
    pub debug_simulate_calc_graph_hang_after: Option<String>,
    /// DebugSimulateDataplaneApplyDelay adds an artificial delay to every dataplane operation.  This is useful for
    /// simulating a heavily loaded system for test purposes only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "debugSimulateDataplaneApplyDelay")]
    pub debug_simulate_dataplane_apply_delay: Option<String>,
    /// DebugSimulateDataplaneHangAfter is used to simulate a hang in the dataplane after the specified duration.
    /// This is useful in tests of the watchdog system only!
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "debugSimulateDataplaneHangAfter")]
    pub debug_simulate_dataplane_hang_after: Option<String>,
    /// DefaultEndpointToHostAction controls what happens to traffic that goes from a workload endpoint to the host
    /// itself (after the endpoint's egress policy is applied). By default, Calico blocks traffic from workload
    /// endpoints to the host itself with an iptables "DROP" action. If you want to allow some or all traffic from
    /// endpoint to host, set this parameter to RETURN or ACCEPT. Use RETURN if you have your own rules in the iptables
    /// "INPUT" chain; Calico will insert its rules at the top of that chain, then "RETURN" packets to the "INPUT" chain
    /// once it has completed processing workload endpoint egress policy. Use ACCEPT to unconditionally accept packets
    /// from workloads after processing workload endpoint egress policy. [Default: Drop]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultEndpointToHostAction")]
    pub default_endpoint_to_host_action: Option<String>,
    /// DeviceRouteProtocol controls the protocol to set on routes programmed by Felix. The protocol is an 8-bit label
    /// used to identify the owner of the route.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceRouteProtocol")]
    pub device_route_protocol: Option<i64>,
    /// DeviceRouteSourceAddress IPv4 address to set as the source hint for routes programmed by Felix. When not set
    /// the source address for local traffic from host to workload will be determined by the kernel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceRouteSourceAddress")]
    pub device_route_source_address: Option<String>,
    /// DeviceRouteSourceAddressIPv6 IPv6 address to set as the source hint for routes programmed by Felix. When not set
    /// the source address for local traffic from host to workload will be determined by the kernel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deviceRouteSourceAddressIPv6")]
    pub device_route_source_address_i_pv6: Option<String>,
    /// DisableConntrackInvalidCheck disables the check for invalid connections in conntrack. While the conntrack
    /// invalid check helps to detect malicious traffic, it can also cause issues with certain multi-NIC scenarios.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableConntrackInvalidCheck")]
    pub disable_conntrack_invalid_check: Option<bool>,
    /// EndpointReportingDelay is the delay before Felix reports endpoint status to the datastore. This is only used
    /// by the OpenStack integration. [Default: 1s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointReportingDelay")]
    pub endpoint_reporting_delay: Option<String>,
    /// EndpointReportingEnabled controls whether Felix reports endpoint status to the datastore. This is only used
    /// by the OpenStack integration. [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointReportingEnabled")]
    pub endpoint_reporting_enabled: Option<bool>,
    /// EndpointStatusPathPrefix is the path to the directory where endpoint status will be written. Endpoint status
    /// file reporting is disabled if field is left empty.
    /// 
    /// Chosen directory should match the directory used by the CNI plugin for PodStartupDelay.
    /// [Default: /var/run/calico]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointStatusPathPrefix")]
    pub endpoint_status_path_prefix: Option<String>,
    /// ExternalNodesCIDRList is a list of CIDR's of external, non-Calico nodes from which VXLAN/IPIP overlay traffic
    /// will be allowed.  By default, external tunneled traffic is blocked to reduce attack surface.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalNodesList")]
    pub external_nodes_list: Option<Vec<String>>,
    /// FailsafeInboundHostPorts is a list of ProtoPort struct objects including UDP/TCP/SCTP ports and CIDRs that Felix will
    /// allow incoming traffic to host endpoints on irrespective of the security policy. This is useful to avoid accidentally
    /// cutting off a host with incorrect configuration. For backwards compatibility, if the protocol is not specified,
    /// it defaults to "tcp". If a CIDR is not specified, it will allow traffic from all addresses. To disable all inbound host ports,
    /// use the value "[]". The default value allows ssh access, DHCP, BGP, etcd and the Kubernetes API.
    /// [Default: tcp:22, udp:68, tcp:179, tcp:2379, tcp:2380, tcp:5473, tcp:6443, tcp:6666, tcp:6667 ]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failsafeInboundHostPorts")]
    pub failsafe_inbound_host_ports: Option<Vec<FelixConfigurationFailsafeInboundHostPorts>>,
    /// FailsafeOutboundHostPorts is a list of PortProto struct objects including UDP/TCP/SCTP ports and CIDRs that Felix
    /// will allow outgoing traffic from host endpoints to irrespective of the security policy. This is useful to avoid accidentally
    /// cutting off a host with incorrect configuration. For backwards compatibility, if the protocol is not specified, it defaults
    /// to "tcp". If a CIDR is not specified, it will allow traffic from all addresses. To disable all outbound host ports,
    /// use the value "[]". The default value opens etcd's standard ports to ensure that Felix does not get cut off from etcd
    /// as well as allowing DHCP, DNS, BGP and the Kubernetes API.
    /// [Default: udp:53, udp:67, tcp:179, tcp:2379, tcp:2380, tcp:5473, tcp:6443, tcp:6666, tcp:6667 ]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failsafeOutboundHostPorts")]
    pub failsafe_outbound_host_ports: Option<Vec<FelixConfigurationFailsafeOutboundHostPorts>>,
    /// FeatureDetectOverride is used to override feature detection based on auto-detected platform
    /// capabilities.  Values are specified in a comma separated list with no spaces, example;
    /// "SNATFullyRandom=true,MASQFullyRandom=false,RestoreSupportsLock=". A value of "true" or "false" will
    /// force enable/disable feature, empty or omitted values fall back to auto-detection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "featureDetectOverride")]
    pub feature_detect_override: Option<String>,
    /// FeatureGates is used to enable or disable tech-preview Calico features.
    /// Values are specified in a comma separated list with no spaces, example;
    /// "BPFConnectTimeLoadBalancingWorkaround=enabled,XyZ=false". This is
    /// used to enable features that are not fully production ready.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "featureGates")]
    pub feature_gates: Option<String>,
    /// FloatingIPs configures whether or not Felix will program non-OpenStack floating IP addresses.  (OpenStack-derived
    /// floating IPs are always programmed, regardless of this setting.)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "floatingIPs")]
    pub floating_i_ps: Option<FelixConfigurationFloatingIPs>,
    /// When FlowLogsCollectorDebugTrace is set to true, enables the logs in the collector to be
    /// printed in their entirety.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flowLogsCollectorDebugTrace")]
    pub flow_logs_collector_debug_trace: Option<bool>,
    /// FlowLogsFlushInterval configures the interval at which Felix exports flow logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flowLogsFlushInterval")]
    pub flow_logs_flush_interval: Option<String>,
    /// FlowLogGoldmaneServer is the flow server endpoint to which flow data should be published.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flowLogsGoldmaneServer")]
    pub flow_logs_goldmane_server: Option<String>,
    /// FlowLogsLocalReporter configures local unix socket for reporting flow data from each node. [Default: Disabled]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flowLogsLocalReporter")]
    pub flow_logs_local_reporter: Option<FelixConfigurationFlowLogsLocalReporter>,
    /// Continuous - Felix evaluates active flows on a regular basis to determine the rule
    /// traces in the flow logs. Any policy updates that impact a flow will be reflected in the
    /// pending_policies field, offering a near-real-time view of policy changes across flows.
    /// None - Felix stops evaluating pending traces.
    /// [Default: Continuous]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flowLogsPolicyEvaluationMode")]
    pub flow_logs_policy_evaluation_mode: Option<FelixConfigurationFlowLogsPolicyEvaluationMode>,
    /// GenericXDPEnabled enables Generic XDP so network cards that don't support XDP offload or driver
    /// modes can use XDP. This is not recommended since it doesn't provide better performance than
    /// iptables. [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "genericXDPEnabled")]
    pub generic_xdp_enabled: Option<bool>,
    /// GoGCThreshold Sets the Go runtime's garbage collection threshold.  I.e. the percentage that the heap is
    /// allowed to grow before garbage collection is triggered.  In general, doubling the value halves the CPU time
    /// spent doing GC, but it also doubles peak GC memory overhead.  A special value of -1 can be used
    /// to disable GC entirely; this should only be used in conjunction with the GoMemoryLimitMB setting.
    /// 
    /// This setting is overridden by the GOGC environment variable.
    /// 
    /// [Default: 40]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "goGCThreshold")]
    pub go_gc_threshold: Option<i64>,
    /// GoMaxProcs sets the maximum number of CPUs that the Go runtime will use concurrently.  A value of -1 means
    /// "use the system default"; typically the number of real CPUs on the system.
    /// 
    /// this setting is overridden by the GOMAXPROCS environment variable.
    /// 
    /// [Default: -1]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "goMaxProcs")]
    pub go_max_procs: Option<i64>,
    /// GoMemoryLimitMB sets a (soft) memory limit for the Go runtime in MB.  The Go runtime will try to keep its memory
    /// usage under the limit by triggering GC as needed.  To avoid thrashing, it will exceed the limit if GC starts to
    /// take more than 50% of the process's CPU time.  A value of -1 disables the memory limit.
    /// 
    /// Note that the memory limit, if used, must be considerably less than any hard resource limit set at the container
    /// or pod level.  This is because felix is not the only process that must run in the container or pod.
    /// 
    /// This setting is overridden by the GOMEMLIMIT environment variable.
    /// 
    /// [Default: -1]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "goMemoryLimitMB")]
    pub go_memory_limit_mb: Option<i64>,
    /// HealthEnabled if set to true, enables Felix's health port, which provides readiness and liveness endpoints.
    /// [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthEnabled")]
    pub health_enabled: Option<bool>,
    /// HealthHost is the host that the health server should bind to. [Default: localhost]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthHost")]
    pub health_host: Option<String>,
    /// HealthPort is the TCP port that the health server should bind to. [Default: 9099]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthPort")]
    pub health_port: Option<i64>,
    /// HealthTimeoutOverrides allows the internal watchdog timeouts of individual subcomponents to be
    /// overridden.  This is useful for working around "false positive" liveness timeouts that can occur
    /// in particularly stressful workloads or if CPU is constrained.  For a list of active
    /// subcomponents, see Felix's logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthTimeoutOverrides")]
    pub health_timeout_overrides: Option<Vec<FelixConfigurationHealthTimeoutOverrides>>,
    /// InterfaceExclude A comma-separated list of interface names that should be excluded when Felix is resolving
    /// host endpoints. The default value ensures that Felix ignores Kubernetes' internal `kube-ipvs0` device. If you
    /// want to exclude multiple interface names using a single value, the list supports regular expressions. For
    /// regular expressions you must wrap the value with `/`. For example having values `/^kube/,veth1` will exclude
    /// all interfaces that begin with `kube` and also the interface `veth1`. [Default: kube-ipvs0]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceExclude")]
    pub interface_exclude: Option<String>,
    /// InterfacePrefix is the interface name prefix that identifies workload endpoints and so distinguishes
    /// them from host endpoint interfaces. Note: in environments other than bare metal, the orchestrators
    /// configure this appropriately. For example our Kubernetes and Docker integrations set the 'cali' value,
    /// and our OpenStack integration sets the 'tap' value. [Default: cali]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacePrefix")]
    pub interface_prefix: Option<String>,
    /// InterfaceRefreshInterval is the period at which Felix rescans local interfaces to verify their state.
    /// The rescan can be disabled by setting the interval to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceRefreshInterval")]
    pub interface_refresh_interval: Option<String>,
    /// IPForwarding controls whether Felix sets the host sysctls to enable IP forwarding.  IP forwarding is required
    /// when using Calico for workload networking.  This should be disabled only on hosts where Calico is used solely for
    /// host protection. In BPF mode, due to a kernel interaction, either IPForwarding must be enabled or BPFEnforceRPF
    /// must be disabled. [Default: Enabled]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipForwarding")]
    pub ip_forwarding: Option<FelixConfigurationIpForwarding>,
    /// IPIPEnabled overrides whether Felix should configure an IPIP interface on the host. Optional as Felix
    /// determines this based on the existing IP pools. [Default: nil (unset)]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipipEnabled")]
    pub ipip_enabled: Option<bool>,
    /// IPIPMTU controls the MTU to set on the IPIP tunnel device.  Optional as Felix auto-detects the MTU based on the
    /// MTU of the host's interfaces. [Default: 0 (auto-detect)]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipipMTU")]
    pub ipip_mtu: Option<i64>,
    /// IpsetsRefreshInterval controls the period at which Felix re-checks all IP sets to look for discrepancies.
    /// Set to 0 to disable the periodic refresh. [Default: 90s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipsetsRefreshInterval")]
    pub ipsets_refresh_interval: Option<String>,
    /// IptablesBackend controls which backend of iptables will be used. The default is `Auto`.
    /// 
    /// Warning: changing this on a running system can leave "orphaned" rules in the "other" backend. These
    /// should be cleaned up to avoid confusing interactions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesBackend")]
    pub iptables_backend: Option<String>,
    /// IptablesFilterAllowAction controls what happens to traffic that is accepted by a Felix policy chain in the
    /// iptables filter table (which is used for "normal" policy). The default will immediately `Accept` the traffic. Use
    /// `Return` to send the traffic back up to the system chains for further processing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesFilterAllowAction")]
    pub iptables_filter_allow_action: Option<String>,
    /// IptablesFilterDenyAction controls what happens to traffic that is denied by network policy. By default Calico blocks traffic
    /// with an iptables "DROP" action. If you want to use "REJECT" action instead you can configure it in here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesFilterDenyAction")]
    pub iptables_filter_deny_action: Option<String>,
    /// IptablesLockFilePath is the location of the iptables lock file. You may need to change this
    /// if the lock file is not in its standard location (for example if you have mapped it into Felix's
    /// container at a different path). [Default: /run/xtables.lock]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesLockFilePath")]
    pub iptables_lock_file_path: Option<String>,
    /// IptablesLockProbeInterval when IptablesLockTimeout is enabled: the time that Felix will wait between
    /// attempts to acquire the iptables lock if it is not available. Lower values make Felix more
    /// responsive when the lock is contended, but use more CPU. [Default: 50ms]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesLockProbeInterval")]
    pub iptables_lock_probe_interval: Option<String>,
    /// IptablesLockTimeout is the time that Felix itself will wait for the iptables lock (rather than delegating the
    /// lock handling to the `iptables` command).
    /// 
    /// Deprecated: `iptables-restore` v1.8+ always takes the lock, so enabling this feature results in deadlock.
    /// [Default: 0s disabled]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesLockTimeout")]
    pub iptables_lock_timeout: Option<String>,
    /// IptablesMangleAllowAction controls what happens to traffic that is accepted by a Felix policy chain in the
    /// iptables mangle table (which is used for "pre-DNAT" policy). The default will immediately `Accept` the traffic.
    /// Use `Return` to send the traffic back up to the system chains for further processing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesMangleAllowAction")]
    pub iptables_mangle_allow_action: Option<String>,
    /// IptablesMarkMask is the mask that Felix selects its IPTables Mark bits from. Should be a 32 bit hexadecimal
    /// number with at least 8 bits set, none of which clash with any other mark bits in use on the system.
    /// [Default: 0xffff0000]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesMarkMask")]
    pub iptables_mark_mask: Option<i32>,
    /// This parameter can be used to limit the host interfaces on which Calico will apply SNAT to traffic leaving a
    /// Calico IPAM pool with "NAT outgoing" enabled. This can be useful if you have a main data interface, where
    /// traffic should be SNATted and a secondary device (such as the docker bridge) which is local to the host and
    /// doesn't require SNAT. This parameter uses the iptables interface matching syntax, which allows + as a
    /// wildcard. Most users will not need to set this. Example: if your data interfaces are eth0 and eth1 and you
    /// want to exclude the docker bridge, you could set this to eth+
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesNATOutgoingInterfaceFilter")]
    pub iptables_nat_outgoing_interface_filter: Option<String>,
    /// IptablesPostWriteCheckInterval is the period after Felix has done a write
    /// to the dataplane that it schedules an extra read back in order to check the write was not
    /// clobbered by another process. This should only occur if another application on the system
    /// doesn't respect the iptables lock. [Default: 1s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesPostWriteCheckInterval")]
    pub iptables_post_write_check_interval: Option<String>,
    /// IptablesRefreshInterval is the period at which Felix re-checks the IP sets
    /// in the dataplane to ensure that no other process has accidentally broken Calico's rules.
    /// Set to 0 to disable IP sets refresh. Note: the default for this value is lower than the
    /// other refresh intervals as a workaround for a Linux kernel bug that was fixed in kernel
    /// version 4.11. If you are using v4.11 or greater you may want to set this to, a higher value
    /// to reduce Felix CPU usage. [Default: 10s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iptablesRefreshInterval")]
    pub iptables_refresh_interval: Option<String>,
    /// IPv6Support controls whether Felix enables support for IPv6 (if supported by the in-use dataplane).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6Support")]
    pub ipv6_support: Option<bool>,
    /// KubeNodePortRanges holds list of port ranges used for service node ports. Only used if felix detects kube-proxy running in ipvs mode.
    /// Felix uses these ranges to separate host and workload traffic. [Default: 30000:32767].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeNodePortRanges")]
    pub kube_node_port_ranges: Option<Vec<IntOrString>>,
    /// LogDebugFilenameRegex controls which source code files have their Debug log output included in the logs.
    /// Only logs from files with names that match the given regular expression are included.  The filter only applies
    /// to Debug level logs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logDebugFilenameRegex")]
    pub log_debug_filename_regex: Option<String>,
    /// LogFilePath is the full path to the Felix log. Set to none to disable file logging. [Default: /var/log/calico/felix.log]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logFilePath")]
    pub log_file_path: Option<String>,
    /// LogPrefix is the log prefix that Felix uses when rendering LOG rules. [Default: calico-packet]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logPrefix")]
    pub log_prefix: Option<String>,
    /// LogSeverityFile is the log severity above which logs are sent to the log file. [Default: Info]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logSeverityFile")]
    pub log_severity_file: Option<String>,
    /// LogSeverityScreen is the log severity above which logs are sent to the stdout. [Default: Info]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logSeverityScreen")]
    pub log_severity_screen: Option<String>,
    /// LogSeveritySys is the log severity above which logs are sent to the syslog. Set to None for no logging to syslog.
    /// [Default: Info]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logSeveritySys")]
    pub log_severity_sys: Option<String>,
    /// MaglevMaxEndpointsPerService is the maximum number of endpoints
    /// expected to be part of a single Maglev-enabled service.
    /// 
    /// Influences the size of the per-service Maglev lookup-tables generated by Felix
    /// and thus the amount of memory reserved.
    /// 
    /// [Default: 100]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maglevMaxEndpointsPerService")]
    pub maglev_max_endpoints_per_service: Option<i64>,
    /// MaglevMaxServices is the maximum number of expected Maglev-enabled
    /// services that Felix will allocate lookup-tables for.
    /// 
    /// [Default: 100]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maglevMaxService")]
    pub maglev_max_service: Option<i64>,
    /// MaxIpsetSize is the maximum number of IP addresses that can be stored in an IP set. Not applicable
    /// if using the nftables backend.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxIpsetSize")]
    pub max_ipset_size: Option<i64>,
    /// MetadataAddr is the IP address or domain name of the server that can answer VM queries for
    /// cloud-init metadata. In OpenStack, this corresponds to the machine running nova-api (or in
    /// Ubuntu, nova-api-metadata). A value of none (case-insensitive) means that Felix should not
    /// set up any NAT rule for the metadata path. [Default: 127.0.0.1]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataAddr")]
    pub metadata_addr: Option<String>,
    /// MetadataPort is the port of the metadata server. This, combined with global.MetadataAddr (if
    /// not 'None'), is used to set up a NAT rule, from 169.254.169.254:80 to MetadataAddr:MetadataPort.
    /// In most cases this should not need to be changed [Default: 8775].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metadataPort")]
    pub metadata_port: Option<i64>,
    /// MTUIfacePattern is a regular expression that controls which interfaces Felix should scan in order
    /// to calculate the host's MTU.
    /// This should not match workload interfaces (usually named cali...).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mtuIfacePattern")]
    pub mtu_iface_pattern: Option<String>,
    /// NATOutgoingAddress specifies an address to use when performing source NAT for traffic in a natOutgoing pool that
    /// is leaving the network. By default the address used is an address on the interface the traffic is leaving on
    /// (i.e. it uses the iptables MASQUERADE target).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natOutgoingAddress")]
    pub nat_outgoing_address: Option<String>,
    /// When a IP pool setting `natOutgoing` is true, packets sent from Calico networked containers in this IP pool to destinations will be masqueraded.
    /// Configure which type of destinations is excluded from being masqueraded.
    /// - IPPoolsOnly: destinations outside of this IP pool will be masqueraded.
    /// - IPPoolsAndHostIPs: destinations outside of this IP pool and all hosts will be masqueraded.
    /// [Default: IPPoolsOnly]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natOutgoingExclusions")]
    pub nat_outgoing_exclusions: Option<FelixConfigurationNatOutgoingExclusions>,
    /// NATPortRange specifies the range of ports that is used for port mapping when doing outgoing NAT. When unset the default behavior of the
    /// network stack is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "natPortRange")]
    pub nat_port_range: Option<IntOrString>,
    /// NetlinkTimeout is the timeout when talking to the kernel over the netlink protocol, used for programming
    /// routes, rules, and other kernel objects. [Default: 10s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "netlinkTimeout")]
    pub netlink_timeout: Option<String>,
    /// NftablesFilterAllowAction controls the nftables action that Felix uses to represent the "allow" policy verdict
    /// in the filter table. The default is to `ACCEPT` the traffic, which is a terminal action.  Alternatively,
    /// `RETURN` can be used to return the traffic back to the top-level chain for further processing by your rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nftablesFilterAllowAction")]
    pub nftables_filter_allow_action: Option<String>,
    /// NftablesFilterDenyAction controls what happens to traffic that is denied by network policy. By default, Calico
    /// blocks traffic with a "drop" action. If you want to use a "reject" action instead you can configure it here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nftablesFilterDenyAction")]
    pub nftables_filter_deny_action: Option<String>,
    /// NftablesMangleAllowAction controls the nftables action that Felix uses to represent the "allow" policy verdict
    /// in the mangle table. The default is to `ACCEPT` the traffic, which is a terminal action.  Alternatively,
    /// `RETURN` can be used to return the traffic back to the top-level chain for further processing by your rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nftablesMangleAllowAction")]
    pub nftables_mangle_allow_action: Option<String>,
    /// NftablesMarkMask is the mask that Felix selects its nftables Mark bits from. Should be a 32 bit hexadecimal
    /// number with at least 8 bits set, none of which clash with any other mark bits in use on the system.
    /// [Default: 0xffff0000]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nftablesMarkMask")]
    pub nftables_mark_mask: Option<i32>,
    /// NFTablesMode configures nftables support in Felix. [Default: Disabled]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nftablesMode")]
    pub nftables_mode: Option<FelixConfigurationNftablesMode>,
    /// NftablesRefreshInterval controls the interval at which Felix periodically refreshes the nftables rules. [Default: 90s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nftablesRefreshInterval")]
    pub nftables_refresh_interval: Option<String>,
    /// OpenstackRegion is the name of the region that a particular Felix belongs to. In a multi-region
    /// Calico/OpenStack deployment, this must be configured somehow for each Felix (here in the datamodel,
    /// or in felix.cfg or the environment on each compute node), and must match the [calico]
    /// openstack_region value configured in neutron.conf on each node. [Default: Empty]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "openstackRegion")]
    pub openstack_region: Option<String>,
    /// PolicySyncPathPrefix is used to by Felix to communicate policy changes to external services,
    /// like Application layer policy. [Default: Empty]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "policySyncPathPrefix")]
    pub policy_sync_path_prefix: Option<String>,
    /// ProgramClusterRoutes specifies whether Felix should program IPIP routes instead of BIRD.
    /// Felix always programs VXLAN routes. [Default: Disabled]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "programClusterRoutes")]
    pub program_cluster_routes: Option<FelixConfigurationProgramClusterRoutes>,
    /// PrometheusGoMetricsEnabled disables Go runtime metrics collection, which the Prometheus client does by default, when
    /// set to false. This reduces the number of metrics reported, reducing Prometheus load. [Default: true]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusGoMetricsEnabled")]
    pub prometheus_go_metrics_enabled: Option<bool>,
    /// PrometheusMetricsCAFile defines the absolute path to the TLS CA certificate file used for securing the /metrics endpoint.
    /// This certificate must be valid and accessible by the calico-node process.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusMetricsCAFile")]
    pub prometheus_metrics_ca_file: Option<String>,
    /// PrometheusMetricsCertFile defines the absolute path to the TLS certificate file used for securing the /metrics endpoint.
    /// This certificate must be valid and accessible by the calico-node process.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusMetricsCertFile")]
    pub prometheus_metrics_cert_file: Option<String>,
    /// PrometheusMetricsClientAuth specifies the client authentication type for the /metrics endpoint.
    /// This determines how the server validates client certificates. Default is "RequireAndVerifyClientCert".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusMetricsClientAuth")]
    pub prometheus_metrics_client_auth: Option<String>,
    /// PrometheusMetricsEnabled enables the Prometheus metrics server in Felix if set to true. [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusMetricsEnabled")]
    pub prometheus_metrics_enabled: Option<bool>,
    /// PrometheusMetricsHost is the host that the Prometheus metrics server should bind to. [Default: empty]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusMetricsHost")]
    pub prometheus_metrics_host: Option<String>,
    /// PrometheusMetricsKeyFile defines the absolute path to the private key file corresponding to the TLS certificate
    /// used for securing the /metrics endpoint. The private key must be valid and accessible by the calico-node process.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusMetricsKeyFile")]
    pub prometheus_metrics_key_file: Option<String>,
    /// PrometheusMetricsPort is the TCP port that the Prometheus metrics server should bind to. [Default: 9091]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusMetricsPort")]
    pub prometheus_metrics_port: Option<i64>,
    /// PrometheusProcessMetricsEnabled disables process metrics collection, which the Prometheus client does by default, when
    /// set to false. This reduces the number of metrics reported, reducing Prometheus load. [Default: true]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusProcessMetricsEnabled")]
    pub prometheus_process_metrics_enabled: Option<bool>,
    /// PrometheusWireGuardMetricsEnabled disables wireguard metrics collection, which the Prometheus client does by default, when
    /// set to false. This reduces the number of metrics reported, reducing Prometheus load. [Default: true]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "prometheusWireGuardMetricsEnabled")]
    pub prometheus_wire_guard_metrics_enabled: Option<bool>,
    /// RemoveExternalRoutes Controls whether Felix will remove unexpected routes to workload interfaces. Felix will
    /// always clean up expected routes that use the configured DeviceRouteProtocol.  To add your own routes, you must
    /// use a distinct protocol (in addition to setting this field to false).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "removeExternalRoutes")]
    pub remove_external_routes: Option<bool>,
    /// ReportingInterval is the interval at which Felix reports its status into the datastore or 0 to disable.
    /// Must be non-zero in OpenStack deployments. [Default: 30s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reportingInterval")]
    pub reporting_interval: Option<String>,
    /// ReportingTTL is the time-to-live setting for process-wide status reports. [Default: 90s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reportingTTL")]
    pub reporting_ttl: Option<String>,
    /// RequireMTUFile specifies whether mtu file is required to start the felix.
    /// Optional as to keep the same as previous behavior. [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireMTUFile")]
    pub require_mtu_file: Option<bool>,
    /// RouteRefreshInterval is the period at which Felix re-checks the routes
    /// in the dataplane to ensure that no other process has accidentally broken Calico's rules.
    /// Set to 0 to disable route refresh. [Default: 90s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRefreshInterval")]
    pub route_refresh_interval: Option<String>,
    /// RouteSource configures where Felix gets its routing information.
    /// - WorkloadIPs: use workload endpoints to construct routes.
    /// - CalicoIPAM: the default - use IPAM data to construct routes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSource")]
    pub route_source: Option<String>,
    /// RouteSyncDisabled will disable all operations performed on the route table. Set to true to
    /// run in network-policy mode only.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSyncDisabled")]
    pub route_sync_disabled: Option<bool>,
    /// Deprecated in favor of RouteTableRanges.
    /// Calico programs additional Linux route tables for various purposes.
    /// RouteTableRange specifies the indices of the route tables that Calico should use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeTableRange")]
    pub route_table_range: Option<FelixConfigurationRouteTableRange>,
    /// Calico programs additional Linux route tables for various purposes.
    /// RouteTableRanges specifies a set of table index ranges that Calico should use.
    /// Deprecates`RouteTableRange`, overrides `RouteTableRange`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeTableRanges")]
    pub route_table_ranges: Option<Vec<FelixConfigurationRouteTableRanges>>,
    /// When service IP advertisement is enabled, prevent routing loops to service IPs that are
    /// not in use, by dropping or rejecting packets that do not get DNAT'd by kube-proxy.
    /// Unless set to "Disabled", in which case such routing loops continue to be allowed.
    /// [Default: Drop]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceLoopPrevention")]
    pub service_loop_prevention: Option<String>,
    /// SidecarAccelerationEnabled enables experimental sidecar acceleration [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sidecarAccelerationEnabled")]
    pub sidecar_acceleration_enabled: Option<bool>,
    /// UsageReportingEnabled reports anonymous Calico version number and cluster size to projectcalico.org. Logs warnings returned by the usage
    /// server. For example, if a significant security vulnerability has been discovered in the version of Calico being used. [Default: true]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usageReportingEnabled")]
    pub usage_reporting_enabled: Option<bool>,
    /// UsageReportingInitialDelay controls the minimum delay before Felix makes a report. [Default: 300s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usageReportingInitialDelay")]
    pub usage_reporting_initial_delay: Option<String>,
    /// UsageReportingInterval controls the interval at which Felix makes reports. [Default: 86400s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usageReportingInterval")]
    pub usage_reporting_interval: Option<String>,
    /// UseInternalDataplaneDriver, if true, Felix will use its internal dataplane programming logic.  If false, it
    /// will launch an external dataplane driver and communicate with it over protobuf.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useInternalDataplaneDriver")]
    pub use_internal_dataplane_driver: Option<bool>,
    /// VXLANEnabled overrides whether Felix should create the VXLAN tunnel device for IPv4 VXLAN networking.
    /// Optional as Felix determines this based on the existing IP pools. [Default: nil (unset)]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vxlanEnabled")]
    pub vxlan_enabled: Option<bool>,
    /// VXLANMTU is the MTU to set on the IPv4 VXLAN tunnel device.  Optional as Felix auto-detects the MTU based on the
    /// MTU of the host's interfaces. [Default: 0 (auto-detect)]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vxlanMTU")]
    pub vxlan_mtu: Option<i64>,
    /// VXLANMTUV6 is the MTU to set on the IPv6 VXLAN tunnel device. Optional as Felix auto-detects the MTU based on the
    /// MTU of the host's interfaces. [Default: 0 (auto-detect)]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vxlanMTUV6")]
    pub vxlan_mtuv6: Option<i64>,
    /// VXLANPort is the UDP port number to use for VXLAN traffic. [Default: 4789]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vxlanPort")]
    pub vxlan_port: Option<i64>,
    /// VXLANVNI is the VXLAN VNI to use for VXLAN traffic.  You may need to change this if the default value is
    /// in use on your system. [Default: 4096]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vxlanVNI")]
    pub vxlan_vni: Option<i64>,
    /// WindowsManageFirewallRules configures whether or not Felix will program Windows Firewall rules (to allow inbound access to its own metrics ports). [Default: Disabled]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsManageFirewallRules")]
    pub windows_manage_firewall_rules: Option<FelixConfigurationWindowsManageFirewallRules>,
    /// WireguardEnabled controls whether Wireguard is enabled for IPv4 (encapsulating IPv4 traffic over an IPv4 underlay network). [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardEnabled")]
    pub wireguard_enabled: Option<bool>,
    /// WireguardEnabledV6 controls whether Wireguard is enabled for IPv6 (encapsulating IPv6 traffic over an IPv6 underlay network). [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardEnabledV6")]
    pub wireguard_enabled_v6: Option<bool>,
    /// WireguardHostEncryptionEnabled controls whether Wireguard host-to-host encryption is enabled. [Default: false]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardHostEncryptionEnabled")]
    pub wireguard_host_encryption_enabled: Option<bool>,
    /// WireguardInterfaceName specifies the name to use for the IPv4 Wireguard interface. [Default: wireguard.cali]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardInterfaceName")]
    pub wireguard_interface_name: Option<String>,
    /// WireguardInterfaceNameV6 specifies the name to use for the IPv6 Wireguard interface. [Default: wg-v6.cali]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardInterfaceNameV6")]
    pub wireguard_interface_name_v6: Option<String>,
    /// WireguardPersistentKeepAlive controls Wireguard PersistentKeepalive option. Set 0 to disable. [Default: 0]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardKeepAlive")]
    pub wireguard_keep_alive: Option<String>,
    /// WireguardListeningPort controls the listening port used by IPv4 Wireguard. [Default: 51820]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardListeningPort")]
    pub wireguard_listening_port: Option<i64>,
    /// WireguardListeningPortV6 controls the listening port used by IPv6 Wireguard. [Default: 51821]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardListeningPortV6")]
    pub wireguard_listening_port_v6: Option<i64>,
    /// WireguardMTU controls the MTU on the IPv4 Wireguard interface. See Configuring MTU [Default: 1440]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardMTU")]
    pub wireguard_mtu: Option<i64>,
    /// WireguardMTUV6 controls the MTU on the IPv6 Wireguard interface. See Configuring MTU [Default: 1420]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardMTUV6")]
    pub wireguard_mtuv6: Option<i64>,
    /// WireguardRoutingRulePriority controls the priority value to use for the Wireguard routing rule. [Default: 99]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardRoutingRulePriority")]
    pub wireguard_routing_rule_priority: Option<i64>,
    /// WireguardThreadingEnabled controls whether Wireguard has Threaded NAPI enabled. [Default: false]
    /// This increases the maximum number of packets a Wireguard interface can process.
    /// Consider threaded NAPI only if you have high packets per second workloads that are causing dropping packets due to a saturated `softirq` CPU core.
    /// There is a [known issue](<https://lore.kernel.org/netdev/CALrw=nEoT2emQ0OAYCjM1d_6Xe_kNLSZ6dhjb5FxrLFYh4kozA@mail.gmail.com/T/)> with this setting
    /// that may cause NAPI to get stuck holding the global `rtnl_mutex` when a peer is removed.
    /// Workaround: Make sure your Linux kernel [includes this patch](<https://github.com/torvalds/linux/commit/56364c910691f6d10ba88c964c9041b9ab777bd6)> to unwedge NAPI.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wireguardThreadingEnabled")]
    pub wireguard_threading_enabled: Option<bool>,
    /// WorkloadSourceSpoofing controls whether pods can use the allowedSourcePrefixes annotation to send traffic with a source IP
    /// address that is not theirs. This is disabled by default. When set to "Any", pods can request any prefix.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadSourceSpoofing")]
    pub workload_source_spoofing: Option<String>,
    /// XDPEnabled enables XDP acceleration for suitable untracked incoming deny rules. [Default: true]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "xdpEnabled")]
    pub xdp_enabled: Option<bool>,
    /// XDPRefreshInterval is the period at which Felix re-checks all XDP state to ensure that no
    /// other process has accidentally broken Calico's BPF maps or attached programs. Set to 0 to
    /// disable XDP refresh. [Default: 90s]
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "xdpRefreshInterval")]
    pub xdp_refresh_interval: Option<String>,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationAwsSrcDstCheck {
    DoNothing,
    Enable,
    Disable,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationBpfAttachType {
    #[serde(rename = "TC")]
    Tc,
    #[serde(rename = "TCX")]
    Tcx,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationBpfConnectTimeLoadBalancing {
    #[serde(rename = "TCP")]
    Tcp,
    Enabled,
    Disabled,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationBpfConntrackLogLevel {
    Off,
    Debug,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationBpfConntrackMode {
    Auto,
    Userspace,
    #[serde(rename = "BPFProgram")]
    BpfProgram,
}

/// BPFConntrackTimers overrides the default values for the specified conntrack timer if
/// set. Each value can be either a duration or `Auto` to pick the value from
/// a Linux conntrack timeout.
/// 
/// Configurable timers are: CreationGracePeriod, TCPSynSent,
/// TCPEstablished, TCPFinsSeen, TCPResetSeen, UDPTimeout, GenericTimeout,
/// ICMPTimeout.
/// 
/// Unset values are replaced by the default values with a warning log for
/// incorrect values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct FelixConfigurationBpfConntrackTimeouts {
    /// CreationGracePeriod gives a generic grace period to new connections
    /// before they are considered for cleanup [Default: 10s].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creationGracePeriod")]
    pub creation_grace_period: Option<String>,
    /// GenericTimeout controls how long it takes before considering this
    /// entry for cleanup after the connection became idle. If set to 'Auto', the
    /// value from nf_conntrack_generic_timeout is used. If nil, Calico uses its
    /// own default value. [Default: 10m].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "genericTimeout")]
    pub generic_timeout: Option<String>,
    /// ICMPTimeout controls how long it takes before considering this
    /// entry for cleanup after the connection became idle. If set to 'Auto', the
    /// value from nf_conntrack_icmp_timeout is used. If nil, Calico uses its
    /// own default value. [Default: 5s].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "icmpTimeout")]
    pub icmp_timeout: Option<String>,
    /// TCPEstablished controls how long it takes before considering this entry for
    /// cleanup after the connection became idle. If set to 'Auto', the
    /// value from nf_conntrack_tcp_timeout_established is used. If nil, Calico uses
    /// its own default value. [Default: 1h].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpEstablished")]
    pub tcp_established: Option<String>,
    /// TCPFinsSeen controls how long it takes before considering this entry for
    /// cleanup after the connection was closed gracefully. If set to 'Auto', the
    /// value from nf_conntrack_tcp_timeout_time_wait is used. If nil, Calico uses
    /// its own default value. [Default: Auto].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpFinsSeen")]
    pub tcp_fins_seen: Option<String>,
    /// TCPResetSeen controls how long it takes before considering this entry for
    /// cleanup after the connection was aborted. If nil, Calico uses its own
    /// default value. [Default: 40s].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpResetSeen")]
    pub tcp_reset_seen: Option<String>,
    /// TCPSynSent controls how long it takes before considering this entry for
    /// cleanup after the last SYN without a response. If set to 'Auto', the
    /// value from nf_conntrack_tcp_timeout_syn_sent is used. If nil, Calico uses
    /// its own default value. [Default: 20s].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSynSent")]
    pub tcp_syn_sent: Option<String>,
    /// UDPTimeout controls how long it takes before considering this entry for
    /// cleanup after the connection became idle. If nil, Calico uses its own
    /// default value. [Default: 60s].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "udpTimeout")]
    pub udp_timeout: Option<String>,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationBpfHostNetworkedNatWithoutCtlb {
    Enabled,
    Disabled,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationBpfProfiling {
    Enabled,
    Disabled,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationBpfRedirectToPeer {
    Enabled,
    Disabled,
}

/// ProtoPort is combination of protocol, port, and CIDR. Protocol and port must be specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct FelixConfigurationFailsafeInboundHostPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub net: Option<String>,
    pub port: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// ProtoPort is combination of protocol, port, and CIDR. Protocol and port must be specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct FelixConfigurationFailsafeOutboundHostPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub net: Option<String>,
    pub port: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationFloatingIPs {
    Enabled,
    Disabled,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationFlowLogsLocalReporter {
    Disabled,
    Enabled,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationFlowLogsPolicyEvaluationMode {
    None,
    Continuous,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct FelixConfigurationHealthTimeoutOverrides {
    pub name: String,
    pub timeout: String,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationIpForwarding {
    Enabled,
    Disabled,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationNatOutgoingExclusions {
    #[serde(rename = "IPPoolsOnly")]
    IpPoolsOnly,
    #[serde(rename = "IPPoolsAndHostIPs")]
    IpPoolsAndHostIPs,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationNftablesMode {
    Disabled,
    Enabled,
    Auto,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationProgramClusterRoutes {
    Enabled,
    Disabled,
}

/// Deprecated in favor of RouteTableRanges.
/// Calico programs additional Linux route tables for various purposes.
/// RouteTableRange specifies the indices of the route tables that Calico should use.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct FelixConfigurationRouteTableRange {
    pub max: i64,
    pub min: i64,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct FelixConfigurationRouteTableRanges {
    pub max: i64,
    pub min: i64,
}

/// FelixConfigurationSpec contains the values of the Felix configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum FelixConfigurationWindowsManageFirewallRules {
    Enabled,
    Disabled,
}

