// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/bpfman/bpfman-operator/bpfman.io/v1alpha1/clusterbpfapplicationstates.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ClBpfApplicationStateStatus reflects the status of the ClusterBpfApplicationState on the given node
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatus {
    /// appLoadStatus reflects the status of loading the bpf application on the
    /// given node.
    #[serde(rename = "appLoadStatus")]
    pub app_load_status: String,
    /// Conditions contains the overall status of the ClusterBpfApplicationState
    /// object on the given node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// node is the name of the node for this BpfApplicationStateSpec.
    pub node: String,
    /// programs is a list of bpf programs contained in the parent application.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub programs: Option<Vec<ClusterBpfApplicationStateStatusPrograms>>,
    /// updateCount is the number of times the BpfApplicationState has been updated. Set to 1
    /// when the object is created, then it is incremented prior to each update.
    /// This allows us to verify that the API server has the updated object prior
    /// to starting a new Reconcile operation.
    #[serde(rename = "updateCount")]
    pub update_count: i64,
}

/// ClBpfApplicationProgramState defines the desired state of BpfApplication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterBpfApplicationStateStatusPrograms {
    /// fentry defines the desired state of the application's FentryPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fentry: Option<ClusterBpfApplicationStateStatusProgramsFentry>,
    /// fexit defines the desired state of the application's FexitPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fexit: Option<ClusterBpfApplicationStateStatusProgramsFexit>,
    /// kprobe defines the desired state of the application's KprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kprobe: Option<ClusterBpfApplicationStateStatusProgramsKprobe>,
    /// kretprobe defines the desired state of the application's KprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kretprobe: Option<ClusterBpfApplicationStateStatusProgramsKretprobe>,
    /// name is the name of the function that is the entry point for the BPF
    /// program
    pub name: String,
    /// programId is the id of the program in the kernel.  Not set until the
    /// program is loaded.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "programId")]
    pub program_id: Option<i32>,
    /// programLinkStatus reflects whether all links requested for the program
    /// are in the correct state.
    #[serde(rename = "programLinkStatus")]
    pub program_link_status: String,
    /// tc defines the desired state of the application's TcPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tc: Option<ClusterBpfApplicationStateStatusProgramsTc>,
    /// tcx defines the desired state of the application's TcxPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcx: Option<ClusterBpfApplicationStateStatusProgramsTcx>,
    /// tracepoint defines the desired state of the application's TracepointPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tracepoint: Option<ClusterBpfApplicationStateStatusProgramsTracepoint>,
    /// type specifies the bpf program type
    #[serde(rename = "type")]
    pub r#type: ClusterBpfApplicationStateStatusProgramsType,
    /// uprobe defines the desired state of the application's UprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uprobe: Option<ClusterBpfApplicationStateStatusProgramsUprobe>,
    /// uretprobe defines the desired state of the application's UretprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uretprobe: Option<ClusterBpfApplicationStateStatusProgramsUretprobe>,
    /// xdp defines the desired state of the application's XdpPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub xdp: Option<ClusterBpfApplicationStateStatusProgramsXdp>,
}

/// fentry defines the desired state of the application's FentryPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsFentry {
    /// function is the name of the function to attach the Fentry program to.
    pub function: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsFentryLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsFentryLinks {
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

/// fexit defines the desired state of the application's FexitPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsFexit {
    /// function is the name of the function to attach the Fexit program to.
    pub function: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsFexitLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsFexitLinks {
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

/// kprobe defines the desired state of the application's KprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsKprobe {
    /// List of attach points for the BPF program on the given node. Each entry
    /// in *AttachInfoState represents a specific, unique attach point that is
    /// derived from *AttachInfo by fully expanding any selectors.  Each entry
    /// also contains information about the attach point required by the
    /// reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsKprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsKprobeLinks {
    /// Function to attach the kprobe to.
    pub function: String,
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// Offset added to the address of the function for kprobe.
    pub offset: i64,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

/// kretprobe defines the desired state of the application's KprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsKretprobe {
    /// List of attach points for the BPF program on the given node. Each entry
    /// in *AttachInfoState represents a specific, unique attach point that is
    /// derived from *AttachInfo by fully expanding any selectors.  Each entry
    /// also contains information about the attach point required by the
    /// reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsKretprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsKretprobeLinks {
    /// Function to attach the kprobe to.
    pub function: String,
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

/// tc defines the desired state of the application's TcPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsTc {
    /// links is the List of attach points for the BPF program on the given node. Each entry
    /// in *AttachInfoState represents a specific, unique attach point that is
    /// derived from *AttachInfo by fully expanding any selectors.  Each entry
    /// also contains information about the attached point required by the
    /// reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsTcLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsTcLinks {
    /// direction specifies the direction of traffic the tc program should
    /// attach to for a given network device.
    pub direction: ClusterBpfApplicationStateStatusProgramsTcLinksDirection,
    /// interfaceName is the Interface name to attach the tc program to.
    #[serde(rename = "interfaceName")]
    pub interface_name: String,
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// Optional network namespace to attach the tc program in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "netnsPath")]
    pub netns_path: Option<String>,
    /// priority specifies the priority of the tc program in relation to
    /// other programs of the same type with the same attach point. It is a value
    /// from 0 to 1000 where lower values have higher precedence.
    pub priority: i32,
    /// proceedOn allows the user to call other tc programs in chain on this exit code.
    /// Multiple values are supported by repeating the parameter.
    #[serde(rename = "proceedOn")]
    pub proceed_on: Vec<String>,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterBpfApplicationStateStatusProgramsTcLinksDirection {
    Ingress,
    Egress,
}

/// tcx defines the desired state of the application's TcxPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsTcx {
    /// List of attach points for the BPF program on the given node. Each entry
    /// in *AttachInfoState represents a specific, unique attach point that is
    /// derived from *AttachInfo by fully expanding any selectors.  Each entry
    /// also contains information about the attach point required by the
    /// reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsTcxLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsTcxLinks {
    /// direction specifies the direction of traffic the tcx program should
    /// attach to for a given network device.
    pub direction: ClusterBpfApplicationStateStatusProgramsTcxLinksDirection,
    /// interfaceName is the Interface name to attach the tc program to.
    #[serde(rename = "interfaceName")]
    pub interface_name: String,
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// netnsPath is the network namespace to attach the tcx program in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "netnsPath")]
    pub netns_path: Option<String>,
    /// priority specifies the priority of the tcx program in relation to
    /// other programs of the same type with the same attach point. It is a value
    /// from 0 to 1000 where lower values have higher precedence.
    pub priority: i32,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterBpfApplicationStateStatusProgramsTcxLinksDirection {
    Ingress,
    Egress,
}

/// tracepoint defines the desired state of the application's TracepointPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsTracepoint {
    /// links is the list of attach points for the BPF program on the given node. Each entry
    /// in *AttachInfoState represents a specific, unique attach point that is
    /// derived from *AttachInfo by fully expanding any selectors.  Each entry
    /// also contains information about the attach point required by the
    /// reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsTracepointLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsTracepointLinks {
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// The name of a kernel tracepoint to attach the bpf program to.
    pub name: String,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

/// ClBpfApplicationProgramState defines the desired state of BpfApplication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterBpfApplicationStateStatusProgramsType {
    #[serde(rename = "XDP")]
    Xdp,
    #[serde(rename = "TC")]
    Tc,
    #[serde(rename = "TCX")]
    Tcx,
    FEntry,
    FExit,
    KProbe,
    KRetProbe,
    UProbe,
    URetProbe,
    TracePoint,
}

/// uprobe defines the desired state of the application's UprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsUprobe {
    /// links is the list of attach points for the BPF program on the given node. Each entry
    /// in *AttachInfoState represents a specific, unique attach point that is
    /// derived from *AttachInfo by fully expanding any selectors.  Each entry
    /// also contains information about the attach point required by the
    /// reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsUprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsUprobeLinks {
    /// Optional container pid to attach the uprobe program in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPid")]
    pub container_pid: Option<i32>,
    /// function to attach the uprobe to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// offset added to the address of the function for uprobe.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    /// pid only execute uprobe for given process identification number (PID). If PID
    /// is not provided, uprobe executes for all PIDs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i32>,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// target is the library name or the absolute path to a binary or library.
    pub target: String,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

/// uretprobe defines the desired state of the application's UretprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsUretprobe {
    /// links is the list of attach points for the BPF program on the given node. Each entry
    /// in *AttachInfoState represents a specific, unique attach point that is
    /// derived from *AttachInfo by fully expanding any selectors.  Each entry
    /// also contains information about the attach point required by the
    /// reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsUretprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsUretprobeLinks {
    /// Optional container pid to attach the uprobe program in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPid")]
    pub container_pid: Option<i32>,
    /// function to attach the uprobe to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// offset added to the address of the function for uprobe.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    /// pid only execute uprobe for given process identification number (PID). If PID
    /// is not provided, uprobe executes for all PIDs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i32>,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// target is the library name or the absolute path to a binary or library.
    pub target: String,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

/// xdp defines the desired state of the application's XdpPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsXdp {
    /// links is the list of attach points for the BPF program on the given node. Each entry
    /// in *AttachInfoState represents a specific, unique attach point that is
    /// derived from *AttachInfo by fully expanding any selectors.  Each entry
    /// also contains information about the attach point required by the
    /// reconciler
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationStateStatusProgramsXdpLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStateStatusProgramsXdpLinks {
    /// interfaceName is the interface name to attach the xdp program to.
    #[serde(rename = "interfaceName")]
    pub interface_name: String,
    /// linkId is an identifier for the link assigned by bpfman. This field is
    /// empty until the program is successfully attached and bpfman returns the
    /// id.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "linkId")]
    pub link_id: Option<i32>,
    /// linkStatus reflects whether the attachment has been reconciled
    /// successfully, and if not, why.
    #[serde(rename = "linkStatus")]
    pub link_status: String,
    /// netnsPath is an optional path for a network namespace to attach the xdp
    /// program in.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "netnsPath")]
    pub netns_path: Option<String>,
    /// priority specifies the priority of the xdp program in relation to
    /// other programs of the same type with the same attach point. It is a value
    /// from 0 to 1000 where lower values have higher precedence.
    pub priority: i32,
    /// proceedOn allows the user to call other xdp programs in chain on this exit code.
    /// Multiple values are supported by repeating the parameter.
    #[serde(rename = "proceedOn")]
    pub proceed_on: Vec<String>,
    /// shouldAttach reflects whether the attachment should exist.
    #[serde(rename = "shouldAttach")]
    pub should_attach: bool,
    /// uuid is an Unique identifier for the attach point assigned by bpfman agent.
    pub uuid: String,
}

