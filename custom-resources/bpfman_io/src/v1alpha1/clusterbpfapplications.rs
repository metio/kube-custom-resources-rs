// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/bpfman/bpfman-operator/bpfman.io/v1alpha1/clusterbpfapplications.yaml
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ClBpfApplicationSpec defines the desired state of BpfApplication
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "bpfman.io", version = "v1alpha1", kind = "ClusterBpfApplication", plural = "clusterbpfapplications")]
#[kube(status = "ClusterBpfApplicationStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClusterBpfApplicationSpec {
    /// bytecode configures where the bpf program's bytecode should be loaded
    /// from.
    #[serde(rename = "byteCode")]
    pub byte_code: ClusterBpfApplicationByteCode,
    /// globalData allows the user to set global variables when the program is loaded
    /// with an array of raw bytes. This is a very low level primitive. The caller
    /// is responsible for formatting the byte string appropriately considering
    /// such things as size, endianness, alignment and packing of data structures.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalData")]
    pub global_data: Option<BTreeMap<String, String>>,
    /// TODO: need to work out how MapOwnerSelector will work after load-attach-split
    /// mapOwnerSelector is used to select the loaded eBPF program this eBPF program
    /// will share a map with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mapOwnerSelector")]
    pub map_owner_selector: Option<ClusterBpfApplicationMapOwnerSelector>,
    /// nodeSelector allows the user to specify which nodes to deploy the
    /// bpf program to. This field must be specified, to select all nodes
    /// use standard metav1.LabelSelector semantics and make it empty.
    #[serde(rename = "nodeSelector")]
    pub node_selector: ClusterBpfApplicationNodeSelector,
    /// programs is the list of bpf programs in the BpfApplication that should be
    /// loaded. The application can selectively choose which program(s) to run
    /// from this list based on the optional attach points provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub programs: Option<Vec<ClusterBpfApplicationPrograms>>,
}

/// bytecode configures where the bpf program's bytecode should be loaded
/// from.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationByteCode {
    /// image used to specify a bytecode container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<ClusterBpfApplicationByteCodeImage>,
    /// path is used to specify a bytecode object via filepath.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// image used to specify a bytecode container image.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationByteCodeImage {
    /// pullPolicy describes a policy for if/when to pull a bytecode image. Defaults to IfNotPresent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<ClusterBpfApplicationByteCodeImageImagePullPolicy>,
    /// imagePullSecret is the name of the secret bpfman should use to get remote image
    /// repository secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecret")]
    pub image_pull_secret: Option<ClusterBpfApplicationByteCodeImageImagePullSecret>,
    /// url is a valid container image URL used to reference a remote bytecode image.
    pub url: String,
}

/// image used to specify a bytecode container image.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterBpfApplicationByteCodeImageImagePullPolicy {
    Always,
    Never,
    IfNotPresent,
}

/// imagePullSecret is the name of the secret bpfman should use to get remote image
/// repository secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationByteCodeImageImagePullSecret {
    /// name of the secret which contains the credentials to access the image repository.
    pub name: String,
    /// namespace of the secret which contains the credentials to access the image repository.
    pub namespace: String,
}

/// TODO: need to work out how MapOwnerSelector will work after load-attach-split
/// mapOwnerSelector is used to select the loaded eBPF program this eBPF program
/// will share a map with.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationMapOwnerSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterBpfApplicationMapOwnerSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationMapOwnerSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// nodeSelector allows the user to specify which nodes to deploy the
/// bpf program to. This field must be specified, to select all nodes
/// use standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationNodeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterBpfApplicationNodeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationNodeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ClBpfApplicationProgram defines the desired state of BpfApplication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterBpfApplicationPrograms {
    /// fentry defines the desired state of the application's FentryPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fentry: Option<ClusterBpfApplicationProgramsFentry>,
    /// fexit defines the desired state of the application's FexitPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fexit: Option<ClusterBpfApplicationProgramsFexit>,
    /// kprobe defines the desired state of the application's KprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kprobe: Option<ClusterBpfApplicationProgramsKprobe>,
    /// kretprobe defines the desired state of the application's KretprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kretprobe: Option<ClusterBpfApplicationProgramsKretprobe>,
    /// name is the name of the function that is the entry point for the BPF
    /// program
    pub name: String,
    /// tc defines the desired state of the application's TcPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tc: Option<ClusterBpfApplicationProgramsTc>,
    /// tcx defines the desired state of the application's TcxPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcx: Option<ClusterBpfApplicationProgramsTcx>,
    /// tracepointInfo defines the desired state of the application's TracepointPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tracepoint: Option<ClusterBpfApplicationProgramsTracepoint>,
    /// type specifies the bpf program type
    #[serde(rename = "type")]
    pub r#type: ClusterBpfApplicationProgramsType,
    /// uprobe defines the desired state of the application's UprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uprobe: Option<ClusterBpfApplicationProgramsUprobe>,
    /// uretprobeInfo defines the desired state of the application's UretprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uretprobe: Option<ClusterBpfApplicationProgramsUretprobe>,
    /// xdp defines the desired state of the application's XdpPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub xdp: Option<ClusterBpfApplicationProgramsXdp>,
}

/// fentry defines the desired state of the application's FentryPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsFentry {
    /// function is the name of the function to attach the Fentry program to.
    pub function: String,
    /// Whether the program should be attached to the function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsFentryLinks>>,
}

/// ClFentryAttachInfo indicates that the Fentry program should be attached to
/// the function identified in ClFentryLoadInfo. The only valid value for Attach
/// is true.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterBpfApplicationProgramsFentryLinks {
    pub mode: ClusterBpfApplicationProgramsFentryLinksMode,
}

/// ClFentryAttachInfo indicates that the Fentry program should be attached to
/// the function identified in ClFentryLoadInfo. The only valid value for Attach
/// is true.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterBpfApplicationProgramsFentryLinksMode {
    Attach,
    Dettach,
}

/// fexit defines the desired state of the application's FexitPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsFexit {
    /// function is the name of the function to attach the Fexit program to.
    pub function: String,
    /// Whether the program should be attached to the function.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsFexitLinks>>,
}

/// ClFexitAttachInfo indicates that the Fentry program should be attached to
/// the function identified in ClFentryLoadInfo. The only valid value for Attach
/// is true.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterBpfApplicationProgramsFexitLinks {
    pub mode: ClusterBpfApplicationProgramsFexitLinksMode,
}

/// ClFexitAttachInfo indicates that the Fentry program should be attached to
/// the function identified in ClFentryLoadInfo. The only valid value for Attach
/// is true.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterBpfApplicationProgramsFexitLinksMode {
    Attach,
    Dettach,
}

/// kprobe defines the desired state of the application's KprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsKprobe {
    /// The list of points to which the program should be attached.  The list items
    /// are optional and may be udated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsKprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsKprobeLinks {
    /// function to attach the kprobe to.
    pub function: String,
    /// offset added to the address of the function for kprobe.
    /// The offset must be zero for kretprobes.
    /// TODO: Add a webhook to enforce kretprobe offset=0.
    /// See: https://github.com/bpfman/bpfman-operator/issues/403
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
}

/// kretprobe defines the desired state of the application's KretprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsKretprobe {
    /// The list of points to which the program should be attached.  The list items
    /// are optional and may be udated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsKretprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsKretprobeLinks {
    /// function to attach the kprobe to.
    pub function: String,
}

/// tc defines the desired state of the application's TcPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTc {
    /// The list of points to which the program should be attached.  The list items
    /// are optional and may be udated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsTcLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcLinks {
    /// direction specifies the direction of traffic the tc program should
    /// attach to for a given network device.
    pub direction: ClusterBpfApplicationProgramsTcLinksDirection,
    /// interfaceSelector to determine the network interface (or interfaces)
    #[serde(rename = "interfaceSelector")]
    pub interface_selector: ClusterBpfApplicationProgramsTcLinksInterfaceSelector,
    /// networkNamespaces identifies the set of network namespaces in which to
    /// attach the eBPF program. If networkNamespaces is not specified, the BPF
    /// program will be attached in the root network namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkNamespaces")]
    pub network_namespaces: Option<ClusterBpfApplicationProgramsTcLinksNetworkNamespaces>,
    /// priority specifies the priority of the tc program in relation to
    /// other programs of the same type with the same attach point. It is a value
    /// from 0 to 1000 where lower values have higher precedence.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    /// proceedOn allows the user to call other tc programs in chain on this exit code.
    /// Multiple values are supported by repeating the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proceedOn")]
    pub proceed_on: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterBpfApplicationProgramsTcLinksDirection {
    Ingress,
    Egress,
}

/// interfaceSelector to determine the network interface (or interfaces)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcLinksInterfaceSelector {
    /// interfaces refers to a list of network interfaces to attach the BPF
    /// program to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<String>>,
    /// discoveryConfig allow configuring interface discovery functionality,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacesDiscoveryConfig")]
    pub interfaces_discovery_config: Option<ClusterBpfApplicationProgramsTcLinksInterfaceSelectorInterfacesDiscoveryConfig>,
    /// primaryNodeInterface to attach BPF program to the primary interface on the node. Only 'true' accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryNodeInterface")]
    pub primary_node_interface: Option<bool>,
}

/// discoveryConfig allow configuring interface discovery functionality,
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcLinksInterfaceSelectorInterfacesDiscoveryConfig {
    /// allowedInterfaces contains the interface names. If empty, the agent
    /// fetches all the interfaces in the system, excepting the ones listed in `excludeInterfaces`.
    /// An entry enclosed by slashes, such as `/br-/`, is matched as a regular expression.
    /// Otherwise, it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInterfaces")]
    pub allowed_interfaces: Option<Vec<String>>,
    /// excludeInterfaces contains the interface names that are excluded from interface discovery
    /// it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInterfaces")]
    pub exclude_interfaces: Option<Vec<String>>,
    /// interfaceAutoDiscovery when enabled, the agent process monitors the creation and deletion of interfaces,
    /// automatically attaching eBPF hooks to newly discovered interfaces in both directions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceAutoDiscovery")]
    pub interface_auto_discovery: Option<bool>,
}

/// networkNamespaces identifies the set of network namespaces in which to
/// attach the eBPF program. If networkNamespaces is not specified, the BPF
/// program will be attached in the root network namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcLinksNetworkNamespaces {
    /// Target namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: ClusterBpfApplicationProgramsTcLinksNetworkNamespacesPods,
}

/// Target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcLinksNetworkNamespacesPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterBpfApplicationProgramsTcLinksNetworkNamespacesPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcLinksNetworkNamespacesPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// tcx defines the desired state of the application's TcxPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcx {
    /// links is the list of points to which the program should be attached. The list items
    /// are optional and may be updated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsTcxLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcxLinks {
    /// direction specifies the direction of traffic the tcx program should
    /// attach to for a given network device.
    pub direction: ClusterBpfApplicationProgramsTcxLinksDirection,
    /// interfaceSelector to determine the network interface (or interfaces)
    #[serde(rename = "interfaceSelector")]
    pub interface_selector: ClusterBpfApplicationProgramsTcxLinksInterfaceSelector,
    /// networkNamespaces identifies the set of network namespaces in which to
    /// attach the eBPF program. If networkNamespaces is not specified, the BPF
    /// program will be attached in the root network namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkNamespaces")]
    pub network_namespaces: Option<ClusterBpfApplicationProgramsTcxLinksNetworkNamespaces>,
    /// priority specifies the priority of the tcx program in relation to
    /// other programs of the same type with the same attach point. It is a value
    /// from 0 to 1000 where lower values have higher precedence.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterBpfApplicationProgramsTcxLinksDirection {
    Ingress,
    Egress,
}

/// interfaceSelector to determine the network interface (or interfaces)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcxLinksInterfaceSelector {
    /// interfaces refers to a list of network interfaces to attach the BPF
    /// program to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<String>>,
    /// discoveryConfig allow configuring interface discovery functionality,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacesDiscoveryConfig")]
    pub interfaces_discovery_config: Option<ClusterBpfApplicationProgramsTcxLinksInterfaceSelectorInterfacesDiscoveryConfig>,
    /// primaryNodeInterface to attach BPF program to the primary interface on the node. Only 'true' accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryNodeInterface")]
    pub primary_node_interface: Option<bool>,
}

/// discoveryConfig allow configuring interface discovery functionality,
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcxLinksInterfaceSelectorInterfacesDiscoveryConfig {
    /// allowedInterfaces contains the interface names. If empty, the agent
    /// fetches all the interfaces in the system, excepting the ones listed in `excludeInterfaces`.
    /// An entry enclosed by slashes, such as `/br-/`, is matched as a regular expression.
    /// Otherwise, it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInterfaces")]
    pub allowed_interfaces: Option<Vec<String>>,
    /// excludeInterfaces contains the interface names that are excluded from interface discovery
    /// it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInterfaces")]
    pub exclude_interfaces: Option<Vec<String>>,
    /// interfaceAutoDiscovery when enabled, the agent process monitors the creation and deletion of interfaces,
    /// automatically attaching eBPF hooks to newly discovered interfaces in both directions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceAutoDiscovery")]
    pub interface_auto_discovery: Option<bool>,
}

/// networkNamespaces identifies the set of network namespaces in which to
/// attach the eBPF program. If networkNamespaces is not specified, the BPF
/// program will be attached in the root network namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcxLinksNetworkNamespaces {
    /// Target namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: ClusterBpfApplicationProgramsTcxLinksNetworkNamespacesPods,
}

/// Target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcxLinksNetworkNamespacesPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterBpfApplicationProgramsTcxLinksNetworkNamespacesPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTcxLinksNetworkNamespacesPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// tracepointInfo defines the desired state of the application's TracepointPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTracepoint {
    /// links is the list of points to which the program should be attached.  The list items
    /// are optional and may be updated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsTracepointLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsTracepointLinks {
    /// name refers to the name of a kernel tracepoint to attach the
    /// bpf program to.
    pub name: String,
}

/// ClBpfApplicationProgram defines the desired state of BpfApplication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterBpfApplicationProgramsType {
    #[serde(rename = "XDP")]
    Xdp,
    #[serde(rename = "TC")]
    Tc,
    #[serde(rename = "TCX")]
    Tcx,
    FEntry,
    FExit,
    KProbe,
    KRetProbe,
    UProbe,
    URetProbe,
    TracePoint,
}

/// uprobe defines the desired state of the application's UprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUprobe {
    /// links in the list of points to which the program should be attached.  The list items
    /// are optional and may be udated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsUprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUprobeLinks {
    /// containers identify the set of containers in which to attach the
    /// uprobe. If Containers is not specified, the uprobe will be attached in
    /// the bpfman-agent container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub containers: Option<ClusterBpfApplicationProgramsUprobeLinksContainers>,
    /// function to attach the uprobe to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,
    /// offset added to the address of the function for uprobe.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    /// pid only execute uprobe for given process identification number (PID). If PID
    /// is not provided, uprobe executes for all PIDs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i32>,
    /// target is the Library name or the absolute path to a binary or library.
    pub target: String,
}

/// containers identify the set of containers in which to attach the
/// uprobe. If Containers is not specified, the uprobe will be attached in
/// the bpfman-agent container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUprobeLinksContainers {
    /// containerNames indicate the Name(s) of container(s).  If none are specified, all containers in the
    /// pod are selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerNames")]
    pub container_names: Option<Vec<String>>,
    /// namespaces indicate the target namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// pods indicate the target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: ClusterBpfApplicationProgramsUprobeLinksContainersPods,
}

/// pods indicate the target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUprobeLinksContainersPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterBpfApplicationProgramsUprobeLinksContainersPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUprobeLinksContainersPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// uretprobeInfo defines the desired state of the application's UretprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUretprobe {
    /// links in the list of points to which the program should be attached.  The list items
    /// are optional and may be udated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsUretprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUretprobeLinks {
    /// containers identify the set of containers in which to attach the
    /// uprobe. If Containers is not specified, the uprobe will be attached in
    /// the bpfman-agent container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub containers: Option<ClusterBpfApplicationProgramsUretprobeLinksContainers>,
    /// function to attach the uprobe to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,
    /// offset added to the address of the function for uprobe.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    /// pid only execute uprobe for given process identification number (PID). If PID
    /// is not provided, uprobe executes for all PIDs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i32>,
    /// target is the Library name or the absolute path to a binary or library.
    pub target: String,
}

/// containers identify the set of containers in which to attach the
/// uprobe. If Containers is not specified, the uprobe will be attached in
/// the bpfman-agent container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUretprobeLinksContainers {
    /// containerNames indicate the Name(s) of container(s).  If none are specified, all containers in the
    /// pod are selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerNames")]
    pub container_names: Option<Vec<String>>,
    /// namespaces indicate the target namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// pods indicate the target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: ClusterBpfApplicationProgramsUretprobeLinksContainersPods,
}

/// pods indicate the target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUretprobeLinksContainersPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterBpfApplicationProgramsUretprobeLinksContainersPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsUretprobeLinksContainersPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// xdp defines the desired state of the application's XdpPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsXdp {
    /// links is the list of points to which the program should be attached.  The list items
    /// are optional and may be updated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ClusterBpfApplicationProgramsXdpLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsXdpLinks {
    /// interfaceSelector to determine the network interface (or interfaces)
    #[serde(rename = "interfaceSelector")]
    pub interface_selector: ClusterBpfApplicationProgramsXdpLinksInterfaceSelector,
    /// networkNamespaces identifies the set of network namespaces in which to
    /// attach the eBPF program. If networkNamespaces is not specified, the BPF
    /// program will be attached in the root network namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkNamespaces")]
    pub network_namespaces: Option<ClusterBpfApplicationProgramsXdpLinksNetworkNamespaces>,
    /// priority specifies the priority of the bpf program in relation to
    /// other programs of the same type with the same attach point. It is a value
    /// from 0 to 1000 where lower values have higher precedence.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    /// proceedOn allows the user to call other xdp programs in chain on this exit code.
    /// Multiple values are supported by repeating the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proceedOn")]
    pub proceed_on: Option<Vec<String>>,
}

/// interfaceSelector to determine the network interface (or interfaces)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsXdpLinksInterfaceSelector {
    /// interfaces refers to a list of network interfaces to attach the BPF
    /// program to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<String>>,
    /// discoveryConfig allow configuring interface discovery functionality,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacesDiscoveryConfig")]
    pub interfaces_discovery_config: Option<ClusterBpfApplicationProgramsXdpLinksInterfaceSelectorInterfacesDiscoveryConfig>,
    /// primaryNodeInterface to attach BPF program to the primary interface on the node. Only 'true' accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryNodeInterface")]
    pub primary_node_interface: Option<bool>,
}

/// discoveryConfig allow configuring interface discovery functionality,
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsXdpLinksInterfaceSelectorInterfacesDiscoveryConfig {
    /// allowedInterfaces contains the interface names. If empty, the agent
    /// fetches all the interfaces in the system, excepting the ones listed in `excludeInterfaces`.
    /// An entry enclosed by slashes, such as `/br-/`, is matched as a regular expression.
    /// Otherwise, it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInterfaces")]
    pub allowed_interfaces: Option<Vec<String>>,
    /// excludeInterfaces contains the interface names that are excluded from interface discovery
    /// it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInterfaces")]
    pub exclude_interfaces: Option<Vec<String>>,
    /// interfaceAutoDiscovery when enabled, the agent process monitors the creation and deletion of interfaces,
    /// automatically attaching eBPF hooks to newly discovered interfaces in both directions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceAutoDiscovery")]
    pub interface_auto_discovery: Option<bool>,
}

/// networkNamespaces identifies the set of network namespaces in which to
/// attach the eBPF program. If networkNamespaces is not specified, the BPF
/// program will be attached in the root network namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsXdpLinksNetworkNamespaces {
    /// Target namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: ClusterBpfApplicationProgramsXdpLinksNetworkNamespacesPods,
}

/// Target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsXdpLinksNetworkNamespacesPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterBpfApplicationProgramsXdpLinksNetworkNamespacesPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationProgramsXdpLinksNetworkNamespacesPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// BpfAppStatus reflects the status of a BpfApplication or BpfApplicationState object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterBpfApplicationStatus {
    /// For a BpfApplication object, Conditions contains the global cluster state
    /// for the object. For a BpfApplicationState object, Conditions contains the
    /// state of the BpfApplication object on the given node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

