// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/bpfman/bpfman-operator/bpfman.io/v1alpha1/bpfapplications.yaml
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// BpfApplicationSpec defines the desired state of BpfApplication
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "bpfman.io", version = "v1alpha1", kind = "BpfApplication", plural = "bpfapplications")]
#[kube(namespaced)]
#[kube(status = "BpfApplicationStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct BpfApplicationSpec {
    /// bytecode configures where the bpf program's bytecode should be loaded
    /// from.
    #[serde(rename = "byteCode")]
    pub byte_code: BpfApplicationByteCode,
    /// globalData allows the user to set global variables when the program is loaded
    /// with an array of raw bytes. This is a very low level primitive. The caller
    /// is responsible for formatting the byte string appropriately considering
    /// such things as size, endianness, alignment and packing of data structures.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalData")]
    pub global_data: Option<BTreeMap<String, String>>,
    /// TODO: need to work out how MapOwnerSelector will work after load-attach-split
    /// mapOwnerSelector is used to select the loaded eBPF program this eBPF program
    /// will share a map with.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mapOwnerSelector")]
    pub map_owner_selector: Option<BpfApplicationMapOwnerSelector>,
    /// nodeSelector allows the user to specify which nodes to deploy the
    /// bpf program to. This field must be specified, to select all nodes
    /// use standard metav1.LabelSelector semantics and make it empty.
    #[serde(rename = "nodeSelector")]
    pub node_selector: BpfApplicationNodeSelector,
    /// programs is the list of bpf programs in the BpfApplication that should be
    /// loaded. The application can selectively choose which program(s) to run
    /// from this list based on the optional attach points provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub programs: Option<Vec<BpfApplicationPrograms>>,
}

/// bytecode configures where the bpf program's bytecode should be loaded
/// from.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationByteCode {
    /// image used to specify a bytecode container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<BpfApplicationByteCodeImage>,
    /// path is used to specify a bytecode object via filepath.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// image used to specify a bytecode container image.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationByteCodeImage {
    /// pullPolicy describes a policy for if/when to pull a bytecode image. Defaults to IfNotPresent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<BpfApplicationByteCodeImageImagePullPolicy>,
    /// imagePullSecret is the name of the secret bpfman should use to get remote image
    /// repository secrets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecret")]
    pub image_pull_secret: Option<BpfApplicationByteCodeImageImagePullSecret>,
    /// url is a valid container image URL used to reference a remote bytecode image.
    pub url: String,
}

/// image used to specify a bytecode container image.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum BpfApplicationByteCodeImageImagePullPolicy {
    Always,
    Never,
    IfNotPresent,
}

/// imagePullSecret is the name of the secret bpfman should use to get remote image
/// repository secrets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationByteCodeImageImagePullSecret {
    /// name of the secret which contains the credentials to access the image repository.
    pub name: String,
    /// namespace of the secret which contains the credentials to access the image repository.
    pub namespace: String,
}

/// TODO: need to work out how MapOwnerSelector will work after load-attach-split
/// mapOwnerSelector is used to select the loaded eBPF program this eBPF program
/// will share a map with.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationMapOwnerSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationMapOwnerSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationMapOwnerSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// nodeSelector allows the user to specify which nodes to deploy the
/// bpf program to. This field must be specified, to select all nodes
/// use standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationNodeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationNodeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationNodeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// BpfApplicationProgram defines the desired state of BpfApplication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BpfApplicationPrograms {
    /// name is the name of the function that is the entry point for the BPF
    /// program
    pub name: String,
    /// tc defines the desired state of the application's TcPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tc: Option<BpfApplicationProgramsTc>,
    /// tcx defines the desired state of the application's TcxPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcx: Option<BpfApplicationProgramsTcx>,
    /// type specifies the bpf program type
    #[serde(rename = "type")]
    pub r#type: BpfApplicationProgramsType,
    /// uprobe defines the desired state of the application's UprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uprobe: Option<BpfApplicationProgramsUprobe>,
    /// uretprobe defines the desired state of the application's UretprobePrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uretprobe: Option<BpfApplicationProgramsUretprobe>,
    /// xdp defines the desired state of the application's XdpPrograms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub xdp: Option<BpfApplicationProgramsXdp>,
}

/// tc defines the desired state of the application's TcPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTc {
    /// links is the list of points to which the program should be attached.  The list items
    /// are optional and may be updated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsTcLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BpfApplicationProgramsTcLinks {
    /// direction specifies the direction of traffic the tc program should
    /// attach to for a given network device.
    pub direction: BpfApplicationProgramsTcLinksDirection,
    /// interfaceSelector to determine the network interface (or interfaces)
    #[serde(rename = "interfaceSelector")]
    pub interface_selector: BpfApplicationProgramsTcLinksInterfaceSelector,
    /// networkNamespaces identifies the set of network namespaces in which to
    /// attach the eBPF program. If networkNamespaces is not specified, the BPF
    /// program will be attached in the root network namespace.
    #[serde(rename = "networkNamespaces")]
    pub network_namespaces: BpfApplicationProgramsTcLinksNetworkNamespaces,
    /// priority specifies the priority of the tc program in relation to
    /// other programs of the same type with the same attach point. It is a value
    /// from 0 to 1000 where lower values have higher precedence.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    /// proceedOn allows the user to call other tc programs in chain on this exit code.
    /// Multiple values are supported by repeating the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proceedOn")]
    pub proceed_on: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum BpfApplicationProgramsTcLinksDirection {
    Ingress,
    Egress,
}

/// interfaceSelector to determine the network interface (or interfaces)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksInterfaceSelector {
    /// interfaces refers to a list of network interfaces to attach the BPF
    /// program to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<String>>,
    /// discoveryConfig allow configuring interface discovery functionality,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacesDiscoveryConfig")]
    pub interfaces_discovery_config: Option<BpfApplicationProgramsTcLinksInterfaceSelectorInterfacesDiscoveryConfig>,
    /// primaryNodeInterface to attach BPF program to the primary interface on the node. Only 'true' accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryNodeInterface")]
    pub primary_node_interface: Option<bool>,
}

/// discoveryConfig allow configuring interface discovery functionality,
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksInterfaceSelectorInterfacesDiscoveryConfig {
    /// allowedInterfaces contains the interface names. If empty, the agent
    /// fetches all the interfaces in the system, excepting the ones listed in `excludeInterfaces`.
    /// An entry enclosed by slashes, such as `/br-/`, is matched as a regular expression.
    /// Otherwise, it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInterfaces")]
    pub allowed_interfaces: Option<Vec<String>>,
    /// excludeInterfaces contains the interface names that are excluded from interface discovery
    /// it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInterfaces")]
    pub exclude_interfaces: Option<Vec<String>>,
    /// interfaceAutoDiscovery when enabled, the agent process monitors the creation and deletion of interfaces,
    /// automatically attaching eBPF hooks to newly discovered interfaces in both directions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceAutoDiscovery")]
    pub interface_auto_discovery: Option<bool>,
}

/// networkNamespaces identifies the set of network namespaces in which to
/// attach the eBPF program. If networkNamespaces is not specified, the BPF
/// program will be attached in the root network namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksNetworkNamespaces {
    /// Target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsTcLinksNetworkNamespacesPods,
}

/// Target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksNetworkNamespacesPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsTcLinksNetworkNamespacesPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksNetworkNamespacesPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// tcx defines the desired state of the application's TcxPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcx {
    /// links is The list of points to which the program should be attached.  The list items
    /// are optional and may be updated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsTcxLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BpfApplicationProgramsTcxLinks {
    /// direction specifies the direction of traffic the tcx program should
    /// attach to for a given network device.
    pub direction: BpfApplicationProgramsTcxLinksDirection,
    /// interfaceSelector to determine the network interface (or interfaces)
    #[serde(rename = "interfaceSelector")]
    pub interface_selector: BpfApplicationProgramsTcxLinksInterfaceSelector,
    /// networkNamespaces identifies the set of network namespaces in which to
    /// attach the eBPF program.
    #[serde(rename = "networkNamespaces")]
    pub network_namespaces: BpfApplicationProgramsTcxLinksNetworkNamespaces,
    /// priority specifies the priority of the tcx program in relation to
    /// other programs of the same type with the same attach point. It is a value
    /// from 0 to 1000 where lower values have higher precedence.
    pub priority: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum BpfApplicationProgramsTcxLinksDirection {
    Ingress,
    Egress,
}

/// interfaceSelector to determine the network interface (or interfaces)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksInterfaceSelector {
    /// interfaces refers to a list of network interfaces to attach the BPF
    /// program to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<String>>,
    /// discoveryConfig allow configuring interface discovery functionality,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacesDiscoveryConfig")]
    pub interfaces_discovery_config: Option<BpfApplicationProgramsTcxLinksInterfaceSelectorInterfacesDiscoveryConfig>,
    /// primaryNodeInterface to attach BPF program to the primary interface on the node. Only 'true' accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryNodeInterface")]
    pub primary_node_interface: Option<bool>,
}

/// discoveryConfig allow configuring interface discovery functionality,
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksInterfaceSelectorInterfacesDiscoveryConfig {
    /// allowedInterfaces contains the interface names. If empty, the agent
    /// fetches all the interfaces in the system, excepting the ones listed in `excludeInterfaces`.
    /// An entry enclosed by slashes, such as `/br-/`, is matched as a regular expression.
    /// Otherwise, it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInterfaces")]
    pub allowed_interfaces: Option<Vec<String>>,
    /// excludeInterfaces contains the interface names that are excluded from interface discovery
    /// it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInterfaces")]
    pub exclude_interfaces: Option<Vec<String>>,
    /// interfaceAutoDiscovery when enabled, the agent process monitors the creation and deletion of interfaces,
    /// automatically attaching eBPF hooks to newly discovered interfaces in both directions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceAutoDiscovery")]
    pub interface_auto_discovery: Option<bool>,
}

/// networkNamespaces identifies the set of network namespaces in which to
/// attach the eBPF program.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksNetworkNamespaces {
    /// Target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsTcxLinksNetworkNamespacesPods,
}

/// Target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksNetworkNamespacesPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsTcxLinksNetworkNamespacesPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksNetworkNamespacesPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// BpfApplicationProgram defines the desired state of BpfApplication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum BpfApplicationProgramsType {
    #[serde(rename = "XDP")]
    Xdp,
    #[serde(rename = "TC")]
    Tc,
    #[serde(rename = "TCX")]
    Tcx,
    UProbe,
    URetProbe,
}

/// uprobe defines the desired state of the application's UprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobe {
    /// links is The list of points to which the program should be attached.  The list items
    /// are optional and may be updated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsUprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobeLinks {
    /// containers identify the set of containers in which to attach the
    /// uprobe.
    pub containers: BpfApplicationProgramsUprobeLinksContainers,
    /// function to attach the uprobe to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,
    /// offset added to the address of the function for uprobe.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    /// pid is only execute uprobe for given process identification number (PID). If PID
    /// is not provided, uprobe executes for all PIDs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i32>,
    /// target is the Library name or the absolute path to a binary or library.
    pub target: String,
}

/// containers identify the set of containers in which to attach the
/// uprobe.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobeLinksContainers {
    /// containerNames indicate the name(s) of container(s).  If none are specified, all containers in the
    /// pod are selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerNames")]
    pub container_names: Option<Vec<String>>,
    /// pods indicate the target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsUprobeLinksContainersPods,
}

/// pods indicate the target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobeLinksContainersPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsUprobeLinksContainersPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobeLinksContainersPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// uretprobe defines the desired state of the application's UretprobePrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobe {
    /// links is The list of points to which the program should be attached.  The list items
    /// are optional and may be updated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsUretprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobeLinks {
    /// containers identify the set of containers in which to attach the
    /// uprobe.
    pub containers: BpfApplicationProgramsUretprobeLinksContainers,
    /// function to attach the uprobe to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,
    /// offset added to the address of the function for uprobe.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    /// pid is only execute uprobe for given process identification number (PID). If PID
    /// is not provided, uprobe executes for all PIDs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i32>,
    /// target is the Library name or the absolute path to a binary or library.
    pub target: String,
}

/// containers identify the set of containers in which to attach the
/// uprobe.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobeLinksContainers {
    /// containerNames indicate the name(s) of container(s).  If none are specified, all containers in the
    /// pod are selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerNames")]
    pub container_names: Option<Vec<String>>,
    /// pods indicate the target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsUretprobeLinksContainersPods,
}

/// pods indicate the target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobeLinksContainersPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsUretprobeLinksContainersPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobeLinksContainersPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// xdp defines the desired state of the application's XdpPrograms.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdp {
    /// links is the list of points to which the program should be attached.  The list items
    /// are optional and may be udated after the bpf program has been loaded
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsXdpLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinks {
    /// interfaceSelector to determine the network interface (or interfaces)
    #[serde(rename = "interfaceSelector")]
    pub interface_selector: BpfApplicationProgramsXdpLinksInterfaceSelector,
    /// networkNamespaces identifies the set of network namespaces in which to
    /// attach the eBPF program.
    #[serde(rename = "networkNamespaces")]
    pub network_namespaces: BpfApplicationProgramsXdpLinksNetworkNamespaces,
    /// priority specifies the priority of the bpf program in relation to
    /// other programs of the same type with the same attach point. It is a value
    /// from 0 to 1000 where lower values have higher precedence.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    /// proceedOn allows the user to call other xdp programs in chain on this exit code.
    /// Multiple values are supported by repeating the parameter.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proceedOn")]
    pub proceed_on: Option<Vec<String>>,
}

/// interfaceSelector to determine the network interface (or interfaces)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksInterfaceSelector {
    /// interfaces refers to a list of network interfaces to attach the BPF
    /// program to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<String>>,
    /// discoveryConfig allow configuring interface discovery functionality,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacesDiscoveryConfig")]
    pub interfaces_discovery_config: Option<BpfApplicationProgramsXdpLinksInterfaceSelectorInterfacesDiscoveryConfig>,
    /// primaryNodeInterface to attach BPF program to the primary interface on the node. Only 'true' accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryNodeInterface")]
    pub primary_node_interface: Option<bool>,
}

/// discoveryConfig allow configuring interface discovery functionality,
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksInterfaceSelectorInterfacesDiscoveryConfig {
    /// allowedInterfaces contains the interface names. If empty, the agent
    /// fetches all the interfaces in the system, excepting the ones listed in `excludeInterfaces`.
    /// An entry enclosed by slashes, such as `/br-/`, is matched as a regular expression.
    /// Otherwise, it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInterfaces")]
    pub allowed_interfaces: Option<Vec<String>>,
    /// excludeInterfaces contains the interface names that are excluded from interface discovery
    /// it is matched as a case-sensitive string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInterfaces")]
    pub exclude_interfaces: Option<Vec<String>>,
    /// interfaceAutoDiscovery when enabled, the agent process monitors the creation and deletion of interfaces,
    /// automatically attaching eBPF hooks to newly discovered interfaces in both directions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceAutoDiscovery")]
    pub interface_auto_discovery: Option<bool>,
}

/// networkNamespaces identifies the set of network namespaces in which to
/// attach the eBPF program.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksNetworkNamespaces {
    /// Target pods. This field must be specified, to select all pods use
    /// standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsXdpLinksNetworkNamespacesPods,
}

/// Target pods. This field must be specified, to select all pods use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksNetworkNamespacesPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsXdpLinksNetworkNamespacesPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksNetworkNamespacesPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// BpfAppStatus reflects the status of a BpfApplication or BpfApplicationState object
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationStatus {
    /// For a BpfApplication object, Conditions contains the global cluster state
    /// for the object. For a BpfApplicationState object, Conditions contains the
    /// state of the BpfApplication object on the given node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

