// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/bpfman/bpfman-operator/bpfman.io/v1alpha1/bpfapplications.yaml
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// spec defines the desired state of the BpfApplication. The BpfApplication
/// describes the set of one or more namespace scoped eBPF programs that should
/// be loaded for a given application and attributes for how they should be
/// loaded. eBPF programs that are grouped together under the same
/// BpfApplication instance can share maps and global data between the eBPF
/// programs loaded on the same Kubernetes Node.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "bpfman.io", version = "v1alpha1", kind = "BpfApplication", plural = "bpfapplications")]
#[kube(namespaced)]
#[kube(status = "BpfApplicationStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct BpfApplicationSpec {
    /// bytecode is a required field and configures where the eBPF program's
    /// bytecode should be loaded from. The image must contain one or more
    /// eBPF programs.
    #[serde(rename = "byteCode")]
    pub byte_code: BpfApplicationByteCode,
    /// globalData is an optional field that allows the user to set global variables
    /// when the program is loaded. This allows the same compiled bytecode to be
    /// deployed by different BPF Applications to behave differently based on
    /// globalData configuration values.  It uses an array of raw bytes. This is a
    /// very low level primitive. The caller is responsible for formatting the byte
    /// string appropriately considering such things as size, endianness, alignment
    /// and packing of data structures.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "globalData")]
    pub global_data: Option<BTreeMap<String, String>>,
    /// mapOwnerSelector is an optional field used to share maps across
    /// applications. eBPF programs loaded with the same ClusterBpfApplication or
    /// BpfApplication instance do not need to use this field. This label selector
    /// allows maps from a different ClusterBpfApplication or BpfApplication
    /// instance to be used by this instance.
    /// TODO: mapOwnerSelector is currently not supported due to recent code rework.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mapOwnerSelector")]
    pub map_owner_selector: Option<BpfApplicationMapOwnerSelector>,
    /// nodeSelector is a required field and allows the user to specify which
    /// Kubernetes nodes to deploy the eBPF programs. To select all nodes use
    /// standard metav1.LabelSelector semantics and make it empty.
    #[serde(rename = "nodeSelector")]
    pub node_selector: BpfApplicationNodeSelector,
    /// programs is a required field and is the list of eBPF programs in a BPF
    /// Application CRD that should be loaded in kernel memory. At least one entry
    /// is required. eBPF programs in this list will be loaded on the system based
    /// the nodeSelector. Even if an eBPF program is loaded in kernel memory, it
    /// cannot be triggered until an attachment point is provided. The different
    /// program types have different ways of attaching. The attachment points can be
    /// added at creation time or modified (added or removed) at a later time to
    /// activate or deactivate the eBPF program as desired.
    /// CAUTION: When programs are added or removed from the list, that requires all
    /// programs in the list to be reloaded, which could be temporarily service
    /// effecting. For this reason, modifying the list is currently not allowed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub programs: Option<Vec<BpfApplicationPrograms>>,
}

/// bytecode is a required field and configures where the eBPF program's
/// bytecode should be loaded from. The image must contain one or more
/// eBPF programs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationByteCode {
    /// image is an optional field and used to specify details on how to retrieve an
    /// eBPF program packaged in a OCI container image from a given registry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<BpfApplicationByteCodeImage>,
    /// path is an optional field and used to specify a bytecode object file via
    /// filepath on a Kubernetes node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// image is an optional field and used to specify details on how to retrieve an
/// eBPF program packaged in a OCI container image from a given registry.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationByteCodeImage {
    /// pullPolicy is an optional field that describes a policy for if/when to pull
    /// a bytecode image. Defaults to IfNotPresent. Allowed values are:
    ///   Always, IfNotPresent and Never
    /// 
    /// 
    /// When set to Always, the given image will be pulled even if the image is
    /// already present on the node.
    /// 
    /// 
    /// When set to IfNotPresent, the given image will only be pulled if it is not
    /// present on the node.
    /// 
    /// 
    /// When set to Never, the given image will never be pulled and must be
    /// loaded on the node by some other means.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<BpfApplicationByteCodeImageImagePullPolicy>,
    /// imagePullSecret is an optional field and indicates the secret which contains
    /// the credentials to access the image repository.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecret")]
    pub image_pull_secret: Option<BpfApplicationByteCodeImageImagePullSecret>,
    /// url is a required field and is a valid container image URL used to reference
    /// a remote bytecode image. url must not be an empty string, must not exceed
    /// 525 characters in length and must be a valid URL.
    pub url: String,
}

/// image is an optional field and used to specify details on how to retrieve an
/// eBPF program packaged in a OCI container image from a given registry.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum BpfApplicationByteCodeImageImagePullPolicy {
    Always,
    Never,
    IfNotPresent,
}

/// imagePullSecret is an optional field and indicates the secret which contains
/// the credentials to access the image repository.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationByteCodeImageImagePullSecret {
    /// name is a required field and is the name of the secret which contains the
    /// credentials to access the image repository.
    pub name: String,
    /// namespace is a required field and is the namespace of the secret which
    /// contains the credentials to access the image repository.
    pub namespace: String,
}

/// mapOwnerSelector is an optional field used to share maps across
/// applications. eBPF programs loaded with the same ClusterBpfApplication or
/// BpfApplication instance do not need to use this field. This label selector
/// allows maps from a different ClusterBpfApplication or BpfApplication
/// instance to be used by this instance.
/// TODO: mapOwnerSelector is currently not supported due to recent code rework.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationMapOwnerSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationMapOwnerSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationMapOwnerSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// nodeSelector is a required field and allows the user to specify which
/// Kubernetes nodes to deploy the eBPF programs. To select all nodes use
/// standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationNodeSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationNodeSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationNodeSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// BpfApplicationProgram defines the desired state of BpfApplication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BpfApplicationPrograms {
    /// name is a required field and is the name of the function that is the entry
    /// point for the eBPF program. name must not be an empty string, must not
    /// exceed 64 characters in length, must start with alpha characters and must
    /// only contain alphanumeric characters.
    pub name: String,
    /// tc is an optional field, but required when the type field is set to TC. tc
    /// defines the desired state of the application's TC programs. TC programs are
    /// attached to network devices (interfaces). The program can be attached on
    /// either packet ingress or egress, so the program will be called on every
    /// incoming or outgoing packet seen by the network device. The TC attachment
    /// point is in Linux's Traffic Control (tc) subsystem, which is after the
    /// Linux kernel has allocated an sk_buff. TCX is newer implementation of TC
    /// with enhanced performance and better support for running multiple programs
    /// on a given network device. This makes TC useful for packet classification
    /// actions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tc: Option<BpfApplicationProgramsTc>,
    /// tcx is an optional field, but required when the type field is set to TCX.
    /// tcx defines the desired state of the application's TCX programs. TCX
    /// programs are attached to network devices (interfaces). The program can be
    /// attached on either packet ingress or egress, so the program will be called
    /// on every incoming or outgoing packet seen by the network device. The TCX
    /// attachment point is in Linux's Traffic Control (tc) subsystem, which is
    /// after the Linux kernel has allocated an sk_buff. This makes TCX useful for
    /// packet classification actions. TCX is a newer implementation of TC with
    /// enhanced performance and better support for running multiple programs on a
    /// given network device.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcx: Option<BpfApplicationProgramsTcx>,
    /// type is a required field used to specify the type of the eBPF program.
    /// 
    /// 
    /// Allowed values are:
    ///   TC, TCX, UProbe, URetProbe, XDP
    /// 
    /// 
    /// When set to TC, the eBPF program can attach to network devices (interfaces).
    /// The program can be attached on either packet ingress or egress, so the
    /// program will be called on every incoming or outgoing packet seen by the
    /// network device. When using the TC program type, the tc field is required.
    /// See tc for more details on TC programs.
    /// 
    /// 
    /// When set to TCX, the eBPF program can attach to network devices
    /// (interfaces). The program can be attached on either packet ingress or
    /// egress, so the program will be called on every incoming or outgoing packet
    /// seen by the network device. When using the TCX program type, the tcx field
    /// is required. See tcx for more details on TCX programs.
    /// 
    /// 
    /// When set to UProbe, the program can attach in user-space. The UProbe is
    /// attached to a binary, library or function name, and optionally an offset in
    /// the code. When using the UProbe program type, the uprobe field is required.
    /// See uprobe for more details on UProbe programs.
    /// 
    /// 
    /// When set to URetProbe, the program can attach in user-space.
    /// The URetProbe is attached to the return of a binary, library or function
    /// name, and optionally an offset in the code.  When using the URetProbe
    /// program type, the uretprobe field is required. See uretprobe for more
    /// details on URetProbe programs.
    /// 
    /// 
    /// When set to XDP, the eBPF program can attach to network devices (interfaces)
    /// and will be called on every incoming packet received by the network device.
    /// When using the XDP program type, the xdp field is required. See xdp for more
    /// details on XDP programs.
    #[serde(rename = "type")]
    pub r#type: BpfApplicationProgramsType,
    /// uprobe is an optional field, but required when the type field is set to
    /// UProbe. uprobe defines the desired state of the application's UProbe
    /// programs. UProbe programs are user-space probes. A target must be provided,
    /// which is the library name or absolute path to a binary or library where the
    /// probe is attached. Optionally, a function name can also be provided to
    /// provide finer granularity on where the probe is attached. They can be
    /// attached at any point in the binary, library or function using the optional
    /// offset field. However, caution must be taken when using the offset, ensuring
    /// the offset is still in the desired bytecode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uprobe: Option<BpfApplicationProgramsUprobe>,
    /// uretprobe is an optional field, but required when the type field is set to
    /// URetProbe. uretprobe defines the desired state of the application's
    /// URetProbe programs. URetProbe programs are user-space probes. A target must
    /// be provided, which is the library name or absolute path to a binary or
    /// library where the probe is attached. Optionally, a function name can also be
    /// provided to provide finer granularity on where the probe is attached. They
    /// are attached to the return point of the binary, library or function, but can
    /// be set anywhere using the optional offset field. However, caution must be
    /// taken when using the offset, ensuring the offset is still in the desired
    /// bytecode.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uretprobe: Option<BpfApplicationProgramsUretprobe>,
    /// xdp is an optional field, but required when the type field is set to XDP.
    /// xdp defines the desired state of the application's XDP programs. XDP program
    /// can be attached to network devices (interfaces) and will be called on every
    /// incoming packet received by the network device. The XDP attachment point is
    /// just after the packet has been received off the wire, but before the Linux
    /// kernel has allocated an sk_buff, which is used to pass the packet through
    /// the kernel networking stack.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub xdp: Option<BpfApplicationProgramsXdp>,
}

/// tc is an optional field, but required when the type field is set to TC. tc
/// defines the desired state of the application's TC programs. TC programs are
/// attached to network devices (interfaces). The program can be attached on
/// either packet ingress or egress, so the program will be called on every
/// incoming or outgoing packet seen by the network device. The TC attachment
/// point is in Linux's Traffic Control (tc) subsystem, which is after the
/// Linux kernel has allocated an sk_buff. TCX is newer implementation of TC
/// with enhanced performance and better support for running multiple programs
/// on a given network device. This makes TC useful for packet classification
/// actions.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTc {
    /// links is an optional field and is the list of attachment points to which the
    /// TC program should be attached. The TC program is loaded in kernel memory
    /// when the BPF Application CRD is created and the selected Kubernetes nodes
    /// are active. The TC program will not be triggered until the program has also
    /// been attached to an attachment point described in this list. Items may be
    /// added or removed from the list at any point, causing the TC program to be
    /// attached or detached.
    /// 
    /// 
    /// The attachment point for a TC program is a network interface (or device).
    /// The interface can be specified by name, by allowing bpfman to discover each
    /// interface, or by setting the primaryNodeInterface flag, which instructs
    /// bpfman to use the primary interface of a Kubernetes node. Optionally, the
    /// TC program can also be installed into a set of network namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsTcLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BpfApplicationProgramsTcLinks {
    /// direction is a required field and specifies the direction of traffic.
    /// Allowed values are:
    ///    Ingress, Egress
    /// 
    /// 
    /// When set to Ingress, the TC program is triggered when packets are received
    /// by the interface.
    /// 
    /// 
    /// When set to Egress, the TC program is triggered when packets are to be
    /// transmitted by the interface.
    pub direction: BpfApplicationProgramsTcLinksDirection,
    /// interfaceSelector is a required field and is used to determine the network
    /// interface (or interfaces) the TC program is attached. Interface list is set
    /// by providing a list of interface names, enabling auto discovery, or setting
    /// the primaryNodeInterface flag, but only one option is allowed.
    #[serde(rename = "interfaceSelector")]
    pub interface_selector: BpfApplicationProgramsTcLinksInterfaceSelector,
    /// networkNamespaces is a required field that identifies the set of network
    /// namespaces in which to attach the eBPF program.
    #[serde(rename = "networkNamespaces")]
    pub network_namespaces: BpfApplicationProgramsTcLinksNetworkNamespaces,
    /// priority is an optional field and determines the execution order of the TC
    /// program relative to other TC programs attached to the same attachment point.
    /// It must be a value between 0 and 1000, where lower values indicate higher
    /// precedence. For TC programs on the same attachment point with the same
    /// direction and priority, the most recently attached program has a lower
    /// precedence. If not provided, priority will default to 1000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    /// proceedOn is an optional field and allows the user to call other TC programs
    /// in a chain, or not call the next program in a chain based on the exit code
    /// of a TC program. Allowed values, which are the possible exit codes from a TC
    /// eBPF program, are:
    ///   UnSpec, OK, ReClassify, Shot, Pipe, Stolen, Queued, Repeat, ReDirect,
    ///   Trap, DispatcherReturn
    /// 
    /// 
    /// Multiple values are supported. Default is OK, Pipe and DispatcherReturn. So
    /// using the default values, if a TC program returns Pipe, the next TC
    /// program in the chain will be called. If a TC program returns Stolen, the
    /// next TC program in the chain will NOT be called.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proceedOn")]
    pub proceed_on: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum BpfApplicationProgramsTcLinksDirection {
    Ingress,
    Egress,
}

/// interfaceSelector is a required field and is used to determine the network
/// interface (or interfaces) the TC program is attached. Interface list is set
/// by providing a list of interface names, enabling auto discovery, or setting
/// the primaryNodeInterface flag, but only one option is allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksInterfaceSelector {
    /// interfaces is an optional field and is a list of network interface names to
    /// attach the eBPF program. The interface names in the list are case-sensitive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<String>>,
    /// interfacesDiscoveryConfig is an optional field that is used to control if
    /// and how to automatically discover interfaces. If the agent should
    /// automatically discover and attach eBPF programs to interfaces, use the
    /// fields under interfacesDiscoveryConfig to control what is allow and excluded
    /// from discovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacesDiscoveryConfig")]
    pub interfaces_discovery_config: Option<BpfApplicationProgramsTcLinksInterfaceSelectorInterfacesDiscoveryConfig>,
    /// primaryNodeInterface is and optional field and indicates to attach the eBPF
    /// program to the primary interface on the Kubernetes node. Only 'true' is
    /// accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryNodeInterface")]
    pub primary_node_interface: Option<bool>,
}

/// interfacesDiscoveryConfig is an optional field that is used to control if
/// and how to automatically discover interfaces. If the agent should
/// automatically discover and attach eBPF programs to interfaces, use the
/// fields under interfacesDiscoveryConfig to control what is allow and excluded
/// from discovery.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksInterfaceSelectorInterfacesDiscoveryConfig {
    /// allowedInterfaces is an optional field that contains a list of interface
    /// names that are allowed to be discovered. If empty, the agent will fetch all
    /// the interfaces in the system, excepting the ones listed in
    /// excludeInterfaces. if non-empty, only entries in the list will be considered
    /// for discovery. If an entry enclosed by slashes, such as `/br-/` or
    /// `/veth*/`, then the entry is considered as a regular expression for
    /// matching. Otherwise, the interface names in the list are case-sensitive.
    /// This field is only taken into consideration if interfaceAutoDiscovery is set
    /// to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInterfaces")]
    pub allowed_interfaces: Option<Vec<String>>,
    /// excludeInterfaces is an optional field that contains a list of interface
    /// names that are excluded from interface discovery. The interface names in
    /// the list are case-sensitive. By default, the list contains the loopback
    /// interface, "lo". This field is only taken into consideration if
    /// interfaceAutoDiscovery is set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInterfaces")]
    pub exclude_interfaces: Option<Vec<String>>,
    /// interfaceAutoDiscovery is an optional field. When enabled, the agent
    /// monitors the creation and deletion of interfaces and automatically
    /// attached eBPF programs to the newly discovered interfaces.
    /// CAUTION: This has the potential to attach a given eBPF program to a large
    /// number of interfaces. Use with caution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceAutoDiscovery")]
    pub interface_auto_discovery: Option<bool>,
}

/// networkNamespaces is a required field that identifies the set of network
/// namespaces in which to attach the eBPF program.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksNetworkNamespaces {
    /// pods is a required field and indicates the target pods. To select all pods
    /// use the standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsTcLinksNetworkNamespacesPods,
}

/// pods is a required field and indicates the target pods. To select all pods
/// use the standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksNetworkNamespacesPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsTcLinksNetworkNamespacesPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcLinksNetworkNamespacesPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// tcx is an optional field, but required when the type field is set to TCX.
/// tcx defines the desired state of the application's TCX programs. TCX
/// programs are attached to network devices (interfaces). The program can be
/// attached on either packet ingress or egress, so the program will be called
/// on every incoming or outgoing packet seen by the network device. The TCX
/// attachment point is in Linux's Traffic Control (tc) subsystem, which is
/// after the Linux kernel has allocated an sk_buff. This makes TCX useful for
/// packet classification actions. TCX is a newer implementation of TC with
/// enhanced performance and better support for running multiple programs on a
/// given network device.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcx {
    /// links is an optional field and is the list of attachment points to which the
    /// TCX program should be attached. The TCX program is loaded in kernel memory
    /// when the BPF Application CRD is created and the selected Kubernetes nodes
    /// are active. The TCX program will not be triggered until the program has also
    /// been attached to an attachment point described in this list. Items may be
    /// added or removed from the list at any point, causing the TCX program to be
    /// attached or detached.
    /// 
    /// 
    /// The attachment point for a TCX program is a network interface (or device).
    /// The interface can be specified by name, by allowing bpfman to discover each
    /// interface, or by setting the primaryNodeInterface flag, which instructs
    /// bpfman to use the primary interface of a Kubernetes node. Optionally, the
    /// TCX program can also be installed into a set of network namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsTcxLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BpfApplicationProgramsTcxLinks {
    /// direction is a required field and specifies the direction of traffic.
    /// Allowed values are:
    ///    Ingress, Egress
    /// 
    /// 
    /// When set to Ingress, the TC program is triggered when packets are received
    /// by the interface.
    /// 
    /// 
    /// When set to Egress, the TC program is triggered when packets are to be
    /// transmitted by the interface.
    pub direction: BpfApplicationProgramsTcxLinksDirection,
    /// interfaceSelector is a required field and is used to determine the network
    /// interface (or interfaces) the TCX program is attached. Interface list is set
    /// by providing a list of interface names, enabling auto discovery, or setting
    /// the primaryNodeInterface flag, but only one option is allowed.
    #[serde(rename = "interfaceSelector")]
    pub interface_selector: BpfApplicationProgramsTcxLinksInterfaceSelector,
    /// networkNamespaces is a required field that identifies the set of network
    /// namespaces in which to attach the eBPF program.
    #[serde(rename = "networkNamespaces")]
    pub network_namespaces: BpfApplicationProgramsTcxLinksNetworkNamespaces,
    /// priority is an optional field and determines the execution order of the TCX
    /// program relative to other TCX programs attached to the same attachment
    /// point. It must be a value between 0 and 1000, where lower values indicate
    /// higher precedence. For TCX programs on the same attachment point with the
    /// same direction and priority, the most recently attached program has a lower
    /// precedence. If not provided, priority will default to 1000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum BpfApplicationProgramsTcxLinksDirection {
    Ingress,
    Egress,
}

/// interfaceSelector is a required field and is used to determine the network
/// interface (or interfaces) the TCX program is attached. Interface list is set
/// by providing a list of interface names, enabling auto discovery, or setting
/// the primaryNodeInterface flag, but only one option is allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksInterfaceSelector {
    /// interfaces is an optional field and is a list of network interface names to
    /// attach the eBPF program. The interface names in the list are case-sensitive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<String>>,
    /// interfacesDiscoveryConfig is an optional field that is used to control if
    /// and how to automatically discover interfaces. If the agent should
    /// automatically discover and attach eBPF programs to interfaces, use the
    /// fields under interfacesDiscoveryConfig to control what is allow and excluded
    /// from discovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacesDiscoveryConfig")]
    pub interfaces_discovery_config: Option<BpfApplicationProgramsTcxLinksInterfaceSelectorInterfacesDiscoveryConfig>,
    /// primaryNodeInterface is and optional field and indicates to attach the eBPF
    /// program to the primary interface on the Kubernetes node. Only 'true' is
    /// accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryNodeInterface")]
    pub primary_node_interface: Option<bool>,
}

/// interfacesDiscoveryConfig is an optional field that is used to control if
/// and how to automatically discover interfaces. If the agent should
/// automatically discover and attach eBPF programs to interfaces, use the
/// fields under interfacesDiscoveryConfig to control what is allow and excluded
/// from discovery.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksInterfaceSelectorInterfacesDiscoveryConfig {
    /// allowedInterfaces is an optional field that contains a list of interface
    /// names that are allowed to be discovered. If empty, the agent will fetch all
    /// the interfaces in the system, excepting the ones listed in
    /// excludeInterfaces. if non-empty, only entries in the list will be considered
    /// for discovery. If an entry enclosed by slashes, such as `/br-/` or
    /// `/veth*/`, then the entry is considered as a regular expression for
    /// matching. Otherwise, the interface names in the list are case-sensitive.
    /// This field is only taken into consideration if interfaceAutoDiscovery is set
    /// to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInterfaces")]
    pub allowed_interfaces: Option<Vec<String>>,
    /// excludeInterfaces is an optional field that contains a list of interface
    /// names that are excluded from interface discovery. The interface names in
    /// the list are case-sensitive. By default, the list contains the loopback
    /// interface, "lo". This field is only taken into consideration if
    /// interfaceAutoDiscovery is set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInterfaces")]
    pub exclude_interfaces: Option<Vec<String>>,
    /// interfaceAutoDiscovery is an optional field. When enabled, the agent
    /// monitors the creation and deletion of interfaces and automatically
    /// attached eBPF programs to the newly discovered interfaces.
    /// CAUTION: This has the potential to attach a given eBPF program to a large
    /// number of interfaces. Use with caution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceAutoDiscovery")]
    pub interface_auto_discovery: Option<bool>,
}

/// networkNamespaces is a required field that identifies the set of network
/// namespaces in which to attach the eBPF program.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksNetworkNamespaces {
    /// pods is a required field and indicates the target pods. To select all pods
    /// use the standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsTcxLinksNetworkNamespacesPods,
}

/// pods is a required field and indicates the target pods. To select all pods
/// use the standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksNetworkNamespacesPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsTcxLinksNetworkNamespacesPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsTcxLinksNetworkNamespacesPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// BpfApplicationProgram defines the desired state of BpfApplication
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum BpfApplicationProgramsType {
    #[serde(rename = "XDP")]
    Xdp,
    #[serde(rename = "TC")]
    Tc,
    #[serde(rename = "TCX")]
    Tcx,
    UProbe,
    URetProbe,
}

/// uprobe is an optional field, but required when the type field is set to
/// UProbe. uprobe defines the desired state of the application's UProbe
/// programs. UProbe programs are user-space probes. A target must be provided,
/// which is the library name or absolute path to a binary or library where the
/// probe is attached. Optionally, a function name can also be provided to
/// provide finer granularity on where the probe is attached. They can be
/// attached at any point in the binary, library or function using the optional
/// offset field. However, caution must be taken when using the offset, ensuring
/// the offset is still in the desired bytecode.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobe {
    /// links is an optional field and is the list of attachment points to which the
    /// UProbe or URetProbe program should be attached. The eBPF program is loaded
    /// in kernel memory when the BPF Application CRD is created and the selected
    /// Kubernetes nodes are active. The eBPF program will not be triggered until
    /// the program has also been attached to an attachment point described in this
    /// list. Items may be added or removed from the list at any point, causing the
    /// eBPF program to be attached or detached.
    /// 
    /// 
    /// The attachment point for a UProbe and URetProbe program is a user-space
    /// binary or function. By default, the eBPF program is triggered at the entry
    /// of the attachment point, but the attachment point can be adjusted using an
    /// optional function name and/or offset. Optionally, the eBPF program can be
    /// installed in a set of containers or limited to a specified PID.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsUprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobeLinks {
    /// containers is an optional field that identifies the set of containers in
    /// which to attach the UProbe or URetProbe program. If containers is not
    /// specified, the eBPF program will be attached in the bpfman container.
    /// uprobe.
    pub containers: BpfApplicationProgramsUprobeLinksContainers,
    /// function is an optional field and specifies the name of a user-space function
    /// to attach the UProbe or URetProbe program. If not provided, the eBPF program
    /// will be triggered on the entry of the target. function must not be an empty
    /// string, must not exceed 64 characters in length, must start with alpha
    /// characters and must only contain alphanumeric characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,
    /// offset is an optional field and the value is added to the address of the
    /// attachment point function. If not provided, offset defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    /// pid is an optional field and if provided, limits the execution of the UProbe
    /// or URetProbe to the provided process identification number (PID). If pid is
    /// not provided, the UProbe or URetProbe executes for all PIDs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i32>,
    /// target is a required field and is the user-space library name or the
    /// absolute path to a binary or library.
    pub target: String,
}

/// containers is an optional field that identifies the set of containers in
/// which to attach the UProbe or URetProbe program. If containers is not
/// specified, the eBPF program will be attached in the bpfman container.
/// uprobe.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobeLinksContainers {
    /// containerNames is an optional field and is a list of container names in a
    /// pod to attach the eBPF program. If no names are  specified, all containers
    /// in the pod are selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerNames")]
    pub container_names: Option<Vec<String>>,
    /// pods is a required field and indicates the target pods. To select all pods
    /// use the standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsUprobeLinksContainersPods,
}

/// pods is a required field and indicates the target pods. To select all pods
/// use the standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobeLinksContainersPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsUprobeLinksContainersPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUprobeLinksContainersPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// uretprobe is an optional field, but required when the type field is set to
/// URetProbe. uretprobe defines the desired state of the application's
/// URetProbe programs. URetProbe programs are user-space probes. A target must
/// be provided, which is the library name or absolute path to a binary or
/// library where the probe is attached. Optionally, a function name can also be
/// provided to provide finer granularity on where the probe is attached. They
/// are attached to the return point of the binary, library or function, but can
/// be set anywhere using the optional offset field. However, caution must be
/// taken when using the offset, ensuring the offset is still in the desired
/// bytecode.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobe {
    /// links is an optional field and is the list of attachment points to which the
    /// UProbe or URetProbe program should be attached. The eBPF program is loaded
    /// in kernel memory when the BPF Application CRD is created and the selected
    /// Kubernetes nodes are active. The eBPF program will not be triggered until
    /// the program has also been attached to an attachment point described in this
    /// list. Items may be added or removed from the list at any point, causing the
    /// eBPF program to be attached or detached.
    /// 
    /// 
    /// The attachment point for a UProbe and URetProbe program is a user-space
    /// binary or function. By default, the eBPF program is triggered at the entry
    /// of the attachment point, but the attachment point can be adjusted using an
    /// optional function name and/or offset. Optionally, the eBPF program can be
    /// installed in a set of containers or limited to a specified PID.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsUretprobeLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobeLinks {
    /// containers is an optional field that identifies the set of containers in
    /// which to attach the UProbe or URetProbe program. If containers is not
    /// specified, the eBPF program will be attached in the bpfman container.
    /// uprobe.
    pub containers: BpfApplicationProgramsUretprobeLinksContainers,
    /// function is an optional field and specifies the name of a user-space function
    /// to attach the UProbe or URetProbe program. If not provided, the eBPF program
    /// will be triggered on the entry of the target. function must not be an empty
    /// string, must not exceed 64 characters in length, must start with alpha
    /// characters and must only contain alphanumeric characters.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub function: Option<String>,
    /// offset is an optional field and the value is added to the address of the
    /// attachment point function. If not provided, offset defaults to 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<i64>,
    /// pid is an optional field and if provided, limits the execution of the UProbe
    /// or URetProbe to the provided process identification number (PID). If pid is
    /// not provided, the UProbe or URetProbe executes for all PIDs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<i32>,
    /// target is a required field and is the user-space library name or the
    /// absolute path to a binary or library.
    pub target: String,
}

/// containers is an optional field that identifies the set of containers in
/// which to attach the UProbe or URetProbe program. If containers is not
/// specified, the eBPF program will be attached in the bpfman container.
/// uprobe.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobeLinksContainers {
    /// containerNames is an optional field and is a list of container names in a
    /// pod to attach the eBPF program. If no names are  specified, all containers
    /// in the pod are selected.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerNames")]
    pub container_names: Option<Vec<String>>,
    /// pods is a required field and indicates the target pods. To select all pods
    /// use the standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsUretprobeLinksContainersPods,
}

/// pods is a required field and indicates the target pods. To select all pods
/// use the standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobeLinksContainersPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsUretprobeLinksContainersPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsUretprobeLinksContainersPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// xdp is an optional field, but required when the type field is set to XDP.
/// xdp defines the desired state of the application's XDP programs. XDP program
/// can be attached to network devices (interfaces) and will be called on every
/// incoming packet received by the network device. The XDP attachment point is
/// just after the packet has been received off the wire, but before the Linux
/// kernel has allocated an sk_buff, which is used to pass the packet through
/// the kernel networking stack.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdp {
    /// links is an optional field and is the list of attachment points to which the
    /// XDP program should be attached. The XDP program is loaded in kernel memory
    /// when the BPF Application CRD is created and the selected Kubernetes nodes
    /// are active. The XDP program will not be triggered until the program has also
    /// been attached to an attachment point described in this list. Items may be
    /// added or removed from the list at any point, causing the XDP program to be
    /// attached or detached.
    /// 
    /// 
    /// The attachment point for a XDP program is a network interface (or device).
    /// The interface can be specified by name, by allowing bpfman to discover each
    /// interface, or by setting the primaryNodeInterface flag, which instructs
    /// bpfman to use the primary interface of a Kubernetes node.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<BpfApplicationProgramsXdpLinks>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinks {
    /// interfaceSelector is a required field and is used to determine the network
    /// interface (or interfaces) the XDP program is attached. Interface list is set
    /// by providing a list of interface names, enabling auto discovery, or setting
    /// the primaryNodeInterface flag, but only one option is allowed.
    #[serde(rename = "interfaceSelector")]
    pub interface_selector: BpfApplicationProgramsXdpLinksInterfaceSelector,
    /// networkNamespaces is a required field that identifies the set of network
    /// namespaces in which to attach the eBPF program.
    #[serde(rename = "networkNamespaces")]
    pub network_namespaces: BpfApplicationProgramsXdpLinksNetworkNamespaces,
    /// priority is an optional field and determines the execution order of the XDP
    /// program relative to other XDP programs attached to the same attachment
    /// point. It must be a value between 0 and 1000, where lower values indicate
    /// higher precedence. For XDP programs on the same attachment point with the
    /// same priority, the most recently attached program has a lower precedence.
    /// If not provided, priority will default to 1000.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    /// proceedOn is an optional field and allows the user to call other XDP
    /// programs in a chain, or not call the next program in a chain based on the
    /// exit code of an XDP program. Allowed values, which are the possible exit
    /// codes from an XDP eBPF program, are:
    ///   Aborted, Drop, Pass, TX, ReDirect,DispatcherReturn
    /// 
    /// 
    /// Multiple values are supported. Default is Pass and DispatcherReturn. So
    /// using the default values, if an XDP program returns Pass, the next XDP
    /// program in the chain will be called. If an XDP program returns Drop, the
    /// next XDP program in the chain will NOT be called.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proceedOn")]
    pub proceed_on: Option<Vec<String>>,
}

/// interfaceSelector is a required field and is used to determine the network
/// interface (or interfaces) the XDP program is attached. Interface list is set
/// by providing a list of interface names, enabling auto discovery, or setting
/// the primaryNodeInterface flag, but only one option is allowed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksInterfaceSelector {
    /// interfaces is an optional field and is a list of network interface names to
    /// attach the eBPF program. The interface names in the list are case-sensitive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<String>>,
    /// interfacesDiscoveryConfig is an optional field that is used to control if
    /// and how to automatically discover interfaces. If the agent should
    /// automatically discover and attach eBPF programs to interfaces, use the
    /// fields under interfacesDiscoveryConfig to control what is allow and excluded
    /// from discovery.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfacesDiscoveryConfig")]
    pub interfaces_discovery_config: Option<BpfApplicationProgramsXdpLinksInterfaceSelectorInterfacesDiscoveryConfig>,
    /// primaryNodeInterface is and optional field and indicates to attach the eBPF
    /// program to the primary interface on the Kubernetes node. Only 'true' is
    /// accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryNodeInterface")]
    pub primary_node_interface: Option<bool>,
}

/// interfacesDiscoveryConfig is an optional field that is used to control if
/// and how to automatically discover interfaces. If the agent should
/// automatically discover and attach eBPF programs to interfaces, use the
/// fields under interfacesDiscoveryConfig to control what is allow and excluded
/// from discovery.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksInterfaceSelectorInterfacesDiscoveryConfig {
    /// allowedInterfaces is an optional field that contains a list of interface
    /// names that are allowed to be discovered. If empty, the agent will fetch all
    /// the interfaces in the system, excepting the ones listed in
    /// excludeInterfaces. if non-empty, only entries in the list will be considered
    /// for discovery. If an entry enclosed by slashes, such as `/br-/` or
    /// `/veth*/`, then the entry is considered as a regular expression for
    /// matching. Otherwise, the interface names in the list are case-sensitive.
    /// This field is only taken into consideration if interfaceAutoDiscovery is set
    /// to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedInterfaces")]
    pub allowed_interfaces: Option<Vec<String>>,
    /// excludeInterfaces is an optional field that contains a list of interface
    /// names that are excluded from interface discovery. The interface names in
    /// the list are case-sensitive. By default, the list contains the loopback
    /// interface, "lo". This field is only taken into consideration if
    /// interfaceAutoDiscovery is set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeInterfaces")]
    pub exclude_interfaces: Option<Vec<String>>,
    /// interfaceAutoDiscovery is an optional field. When enabled, the agent
    /// monitors the creation and deletion of interfaces and automatically
    /// attached eBPF programs to the newly discovered interfaces.
    /// CAUTION: This has the potential to attach a given eBPF program to a large
    /// number of interfaces. Use with caution.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interfaceAutoDiscovery")]
    pub interface_auto_discovery: Option<bool>,
}

/// networkNamespaces is a required field that identifies the set of network
/// namespaces in which to attach the eBPF program.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksNetworkNamespaces {
    /// pods is a required field and indicates the target pods. To select all pods
    /// use the standard metav1.LabelSelector semantics and make it empty.
    pub pods: BpfApplicationProgramsXdpLinksNetworkNamespacesPods,
}

/// pods is a required field and indicates the target pods. To select all pods
/// use the standard metav1.LabelSelector semantics and make it empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksNetworkNamespacesPods {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<BpfApplicationProgramsXdpLinksNetworkNamespacesPodsMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationProgramsXdpLinksNetworkNamespacesPodsMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// status reflects the status of a BPF Application and indicates if all the
/// eBPF programs for a given instance loaded successfully or not.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct BpfApplicationStatus {
    /// conditions contains the summary state for all eBPF programs defined in the
    /// BPF Application instance for all the Kubernetes nodes in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

