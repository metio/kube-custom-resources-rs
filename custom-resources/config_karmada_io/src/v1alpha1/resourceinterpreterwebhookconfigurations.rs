// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/karmada-io/karmada/config.karmada.io/v1alpha1/resourceinterpreterwebhookconfigurations.yaml
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
}
use self::prelude::*;

/// ResourceInterpreterWebhook describes the webhook as well as the resources and operations it applies to.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ResourceInterpreterWebhookConfigurationWebhooks {
    /// ClientConfig defines how to communicate with the hook.
    /// It supports two mutually exclusive configuration modes:
    /// 
    /// 1. URL - Directly specify the webhook URL with format `scheme://host:port/path`.
    ///    Example: https://webhook.example.com:8443/my-interpreter
    /// 
    /// 2. Service - Reference a Kubernetes Service that exposes the webhook.
    ///    When using Service reference, Karmada resolves the endpoint through following steps:
    ///    a) First attempts to locate the Service in karmada-apiserver
    ///    b) If found, constructs URL based on Service type:
    ///       - ClusterIP/LoadBalancer/NodePort: Uses ClusterIP with port from Service spec
    ///         (Note: Services with ClusterIP "None" are rejected), Example:
    ///         `https://<cluster ip>:<port>`
    ///       - ExternalName: Uses external DNS name format: `https://<external name>:<port>`
    ///    c) If NOT found in karmada-apiserver, falls back to standard Kubernetes
    ///       service DNS name format: `https://<service>.<namespace>.svc:<port>`
    /// 
    /// Note: When both URL and Service are specified, the Service reference takes precedence
    ///       and the URL configuration will be ignored.
    #[serde(rename = "clientConfig")]
    pub client_config: ResourceInterpreterWebhookConfigurationWebhooksClientConfig,
    /// InterpreterContextVersions is an ordered list of preferred `ResourceInterpreterContext`
    /// versions the Webhook expects. Karmada will try to use first version in
    /// the list which it supports. If none of the versions specified in this list
    /// supported by Karmada, validation will fail for this object.
    /// If a persisted webhook configuration specifies allowed versions and does not
    /// include any versions known to the Karmada, calls to the webhook will fail
    /// and be subject to the failure policy.
    #[serde(rename = "interpreterContextVersions")]
    pub interpreter_context_versions: Vec<String>,
    /// Name is the full-qualified name of the webhook.
    pub name: String,
    /// Rules describes what operations on what resources the webhook cares about.
    /// The webhook cares about an operation if it matches any Rule.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<ResourceInterpreterWebhookConfigurationWebhooksRules>>,
    /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
    /// the webhook call will be ignored or the API call will fail based on the
    /// failure policy.
    /// The timeout value must be between 1 and 30 seconds.
    /// Default to 10 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// ClientConfig defines how to communicate with the hook.
/// It supports two mutually exclusive configuration modes:
/// 
/// 1. URL - Directly specify the webhook URL with format `scheme://host:port/path`.
///    Example: https://webhook.example.com:8443/my-interpreter
/// 
/// 2. Service - Reference a Kubernetes Service that exposes the webhook.
///    When using Service reference, Karmada resolves the endpoint through following steps:
///    a) First attempts to locate the Service in karmada-apiserver
///    b) If found, constructs URL based on Service type:
///       - ClusterIP/LoadBalancer/NodePort: Uses ClusterIP with port from Service spec
///         (Note: Services with ClusterIP "None" are rejected), Example:
///         `https://<cluster ip>:<port>`
///       - ExternalName: Uses external DNS name format: `https://<external name>:<port>`
///    c) If NOT found in karmada-apiserver, falls back to standard Kubernetes
///       service DNS name format: `https://<service>.<namespace>.svc:<port>`
/// 
/// Note: When both URL and Service are specified, the Service reference takes precedence
///       and the URL configuration will be ignored.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ResourceInterpreterWebhookConfigurationWebhooksClientConfig {
    /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
    /// If unspecified, system trust roots on the apiserver are used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caBundle")]
    pub ca_bundle: Option<String>,
    /// `service` is a reference to the service for this webhook. Either
    /// `service` or `url` must be specified.
    /// 
    /// If the webhook is running within the cluster, then you should use `service`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<ResourceInterpreterWebhookConfigurationWebhooksClientConfigService>,
    /// `url` gives the location of the webhook, in standard URL form
    /// (`scheme://host:port/path`). Exactly one of `url` or `service`
    /// must be specified.
    /// 
    /// The `host` should not refer to a service running in the cluster; use
    /// the `service` field instead. The host might be resolved via external
    /// DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
    /// in-cluster DNS as that would be a layering violation). `host` may
    /// also be an IP address.
    /// 
    /// Please note that using `localhost` or `127.0.0.1` as a `host` is
    /// risky unless you take great care to run this webhook on all hosts
    /// which run an apiserver which might need to make calls to this
    /// webhook. Such installs are likely to be non-portable, i.e., not easy
    /// to turn up in a new cluster.
    /// 
    /// The scheme must be "https"; the URL must begin with "https://".
    /// 
    /// A path is optional, and if present may be any string permissible in
    /// a URL. You may use the path to pass an arbitrary string to the
    /// webhook, for example, a cluster identifier.
    /// 
    /// Attempting to use a user or basic auth e.g. "user:password@" is not
    /// allowed. Fragments ("#...") and query parameters ("?...") are not
    /// allowed, either.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// `service` is a reference to the service for this webhook. Either
/// `service` or `url` must be specified.
/// 
/// If the webhook is running within the cluster, then you should use `service`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ResourceInterpreterWebhookConfigurationWebhooksClientConfigService {
    /// `name` is the name of the service.
    /// Required
    pub name: String,
    /// `namespace` is the namespace of the service.
    /// Required
    pub namespace: String,
    /// `path` is an optional URL path which will be sent in any request to
    /// this service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// If specified, the port on the service that hosting webhook.
    /// Default to 443 for backward compatibility.
    /// `port` should be a valid port number (1-65535, inclusive).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

/// RuleWithOperations is a tuple of Operations and Resources. It is recommended to make
/// sure that all the tuple expansions are valid.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ResourceInterpreterWebhookConfigurationWebhooksRules {
    /// APIGroups is the API groups the resources belong to. '*' is all groups.
    /// If '*' is present, the length of the slice must be one.
    /// For example:
    ///  ["apps", "batch", "example.io"] means matches 3 groups.
    ///  ["*"] means matches all group
    /// 
    /// Note: The group could be empty, e.g the 'core' group of kubernetes, in that case use [""].
    #[serde(rename = "apiGroups")]
    pub api_groups: Vec<String>,
    /// APIVersions is the API versions the resources belong to. '*' is all versions.
    /// If '*' is present, the length of the slice must be one.
    /// For example:
    ///  ["v1alpha1", "v1beta1"] means matches 2 versions.
    ///  ["*"] means matches all versions.
    #[serde(rename = "apiVersions")]
    pub api_versions: Vec<String>,
    /// Kinds is a list of resources this rule applies to.
    /// If '*' is present, the length of the slice must be one.
    /// For example:
    ///  ["Deployment", "Pod"] means matches Deployment and Pod.
    ///  ["*"] means apply to all resources.
    pub kinds: Vec<String>,
    /// Operations is the operations the hook cares about.
    /// If '*' is present, the length of the slice must be one.
    pub operations: Vec<String>,
}

