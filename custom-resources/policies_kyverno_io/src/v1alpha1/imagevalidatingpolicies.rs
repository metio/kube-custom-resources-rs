// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/kyverno/kyverno/policies.kyverno.io/v1alpha1/imagevalidatingpolicies.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ImageValidatingPolicySpec is the specification of the desired behavior of the ImageValidatingPolicy.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "policies.kyverno.io", version = "v1alpha1", kind = "ImageValidatingPolicy", plural = "imagevalidatingpolicies")]
#[kube(status = "ImageValidatingPolicyStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ImageValidatingPolicySpec {
    /// Attestations provides a list of image metadata to verify
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attestations: Option<Vec<ImageValidatingPolicyAttestations>>,
    /// Attestors provides a list of trusted authorities.
    pub attestors: Vec<ImageValidatingPolicyAttestors>,
    /// auditAnnotations contains CEL expressions which are used to produce audit
    /// annotations for the audit event of the API request.
    /// validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
    /// required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditAnnotations")]
    pub audit_annotations: Option<Vec<ImageValidatingPolicyAuditAnnotations>>,
    /// AutogenConfiguration defines the configuration for the generation controller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autogen: Option<ImageValidatingPolicyAutogen>,
    /// Credentials provides credentials that will be used for authentication with registry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ImageValidatingPolicyCredentials>,
    /// EvaluationConfiguration defines the configuration for the policy evaluation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub evaluation: Option<ImageValidatingPolicyEvaluation>,
    /// FailurePolicy defines how to handle failures for the admission policy. Failures can
    /// occur from CEL expression parse errors, type check errors, runtime errors and invalid
    /// or mis-configured policy definitions or bindings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failurePolicy")]
    pub failure_policy: Option<ImageValidatingPolicyFailurePolicy>,
    /// ImageExtractors is a list of CEL expression to extract images from the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub images: Option<Vec<ImageValidatingPolicyImages>>,
    /// MatchConditions is a list of conditions that must be met for a request to be validated.
    /// Match conditions filter requests that have already been matched by the rules,
    /// namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
    /// There are a maximum of 64 match conditions allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchConditions")]
    pub match_conditions: Option<Vec<ImageValidatingPolicyMatchConditions>>,
    /// MatchConstraints specifies what resources this policy is designed to validate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchConstraints")]
    pub match_constraints: Option<ImageValidatingPolicyMatchConstraints>,
    /// MatchImageReferences is a list of Glob and CELExpressions to match images.
    /// Any image that matches one of the rules is considered for validation
    /// Any image that does not match a rule is skipped, even when they are passed as arguments to
    /// image verification functions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchImageReferences")]
    pub match_image_references: Option<Vec<ImageValidatingPolicyMatchImageReferences>>,
    /// ValidationAction specifies the action to be taken when the matched resource violates the policy.
    /// If a validation evaluates to false it is always enforced according to these actions.
    /// 
    /// Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
    /// to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
    /// ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
    /// 
    /// validationActions is declared as a set of action values. Order does
    /// not matter. validationActions may not contain duplicates of the same action.
    /// 
    /// The supported actions values are:
    /// 
    /// "Deny" specifies that a validation failure results in a denied request.
    /// 
    /// "Warn" specifies that a validation failure is reported to the request client
    /// in HTTP Warning headers, with a warning code of 299. Warnings can be sent
    /// both for allowed or denied admission responses.
    /// 
    /// "Audit" specifies that a validation failure is recorded in the created reports.
    /// 
    /// Clients should expect to handle additional values by ignoring
    /// any values not recognized.
    /// 
    /// "Deny" and "Warn" may not be used together since this combination
    /// needlessly duplicates the validation failure both in the
    /// API response body and the HTTP warning headers.
    /// 
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validationActions")]
    pub validation_actions: Option<Vec<String>>,
    /// ValidationConfigurations defines settings for mutating and verifying image digests, and enforcing image verification through signatures.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validationConfigurations")]
    pub validation_configurations: Option<ImageValidatingPolicyValidationConfigurations>,
    /// Validations contain CEL expressions which is used to apply the image validation checks.
    pub validations: Vec<ImageValidatingPolicyValidations>,
    /// Variables contain definitions of variables that can be used in composition of other expressions.
    /// Each variable is defined as a named CEL expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<ImageValidatingPolicyVariables>>,
    /// WebhookConfiguration defines the configuration for the webhook.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookConfiguration")]
    pub webhook_configuration: Option<ImageValidatingPolicyWebhookConfiguration>,
}

/// Attestation defines the identification details of the  metadata that has to be verified
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestations {
    /// InToto defines the details of attestation attached using intoto format
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub intoto: Option<ImageValidatingPolicyAttestationsIntoto>,
    /// Name is the name for this attestation. It is used to refer to the attestation in verification
    pub name: String,
    /// Referrer defines the details of attestation attached using OCI 1.1 format
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub referrer: Option<ImageValidatingPolicyAttestationsReferrer>,
}

/// InToto defines the details of attestation attached using intoto format
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestationsIntoto {
    /// Type defines the type of attestation contained within the statement.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Referrer defines the details of attestation attached using OCI 1.1 format
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestationsReferrer {
    /// Type defines the type of attestation attached to the image.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Attestor is an identity that confirms or verifies the authenticity of an image or an attestation
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestors {
    /// Cosign defines attestor configuration for Cosign based signatures
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cosign: Option<ImageValidatingPolicyAttestorsCosign>,
    /// Name is the name for this attestor. It is used to refer to the attestor in verification
    pub name: String,
    /// Notary defines attestor configuration for Notary based signatures
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notary: Option<ImageValidatingPolicyAttestorsNotary>,
}

/// Cosign defines attestor configuration for Cosign based signatures
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosign {
    /// Annotations are used for image verification.
    /// Every specified key-value pair must exist and match in the verified payload.
    /// The payload may contain other key-value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Certificate defines the configuration for local signature verification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<ImageValidatingPolicyAttestorsCosignCertificate>,
    /// CTLog sets the configuration to verify the authority against a Rekor instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ctlog: Option<ImageValidatingPolicyAttestorsCosignCtlog>,
    /// Key defines the type of key to validate the image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<ImageValidatingPolicyAttestorsCosignKey>,
    /// Keyless sets the configuration to verify the authority against a Fulcio instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyless: Option<ImageValidatingPolicyAttestorsCosignKeyless>,
    /// Sources sets the configuration to specify the sources from where to consume the signature and attestations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<ImageValidatingPolicyAttestorsCosignSource>,
    /// TUF defines the configuration to fetch sigstore root
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tuf: Option<ImageValidatingPolicyAttestorsCosignTuf>,
}

/// Certificate defines the configuration for local signature verification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignCertificate {
    /// Certificate is the to the public certificate for local signature verification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ImageValidatingPolicyAttestorsCosignCertificateCert>,
    /// CertificateChain is the list of CA certificates in PEM format which will be needed
    /// when building the certificate chain for the signing certificate. Must start with the
    /// parent intermediate CA certificate of the signing certificate and end with the root certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certChain")]
    pub cert_chain: Option<ImageValidatingPolicyAttestorsCosignCertificateCertChain>,
}

/// Certificate is the to the public certificate for local signature verification.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignCertificateCert {
    /// Expression defines the a CEL expression input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Value defines the raw string input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// CertificateChain is the list of CA certificates in PEM format which will be needed
/// when building the certificate chain for the signing certificate. Must start with the
/// parent intermediate CA certificate of the signing certificate and end with the root certificate
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignCertificateCertChain {
    /// Expression defines the a CEL expression input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Value defines the raw string input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// CTLog sets the configuration to verify the authority against a Rekor instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignCtlog {
    /// CTLogPubKey, if set, is used to validate SCTs against a custom source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ctLogPubKey")]
    pub ct_log_pub_key: Option<String>,
    /// IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
    /// timestamp. Default is false. Set to true if this was opted out during signing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureIgnoreSCT")]
    pub insecure_ignore_sct: Option<bool>,
    /// InsecureIgnoreTlog skips transparency log verification.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureIgnoreTlog")]
    pub insecure_ignore_tlog: Option<bool>,
    /// RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
    /// If set, this will be used to validate transparency log signatures from a custom Rekor.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rekorPubKey")]
    pub rekor_pub_key: Option<String>,
    /// TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
    /// contain the root CA certificate. Optionally may contain intermediate CA certificates, and
    /// may contain the leaf TSA certificate if not present in the timestamurce.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tsaCertChain")]
    pub tsa_cert_chain: Option<String>,
    /// URL sets the url to the rekor instance (by default the public rekor.sigstore.dev)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Key defines the type of key to validate the image.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignKey {
    /// Data contains the inline public key
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// Expression is a Expression expression that returns the public key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// HashAlgorithm specifues signature algorithm for public keys. Supported values are
    /// sha224, sha256, sha384 and sha512. Defaults to sha256.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashAlgorithm")]
    pub hash_algorithm: Option<String>,
    /// KMS contains the KMS url of the public key
    /// Supported formats differ based on the KMS system used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kms: Option<String>,
}

/// Keyless sets the configuration to verify the authority against a Fulcio instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignKeyless {
    /// Identities sets a list of identities.
    pub identities: Vec<ImageValidatingPolicyAttestorsCosignKeylessIdentities>,
    /// Roots is an optional set of PEM encoded trusted root certificates.
    /// If not provided, the system roots are used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roots: Option<String>,
}

/// Identity may contain the issuer and/or the subject found in the transparency
/// log.
/// Issuer/Subject uses a strict match, while IssuerRegExp and SubjectRegExp
/// apply a regexp for matching.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignKeylessIdentities {
    /// Issuer defines the issuer for this identity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issuer: Option<String>,
    /// IssuerRegExp specifies a regular expression to match the issuer for this identity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerRegExp")]
    pub issuer_reg_exp: Option<String>,
    /// Subject defines the subject for this identity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<String>,
    /// SubjectRegExp specifies a regular expression to match the subject for this identity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectRegExp")]
    pub subject_reg_exp: Option<String>,
}

/// Sources sets the configuration to specify the sources from where to consume the signature and attestations.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignSource {
    /// SignaturePullSecrets is an optional list of references to secrets in the
    /// same namespace as the deploying resource for pulling any of the signatures
    /// used by this Source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "PullSecrets")]
    pub pull_secrets: Option<Vec<ImageValidatingPolicyAttestorsCosignSourcePullSecrets>>,
    /// Repository defines the location from where to pull the signature / attestations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    /// TagPrefix is an optional prefix that signature and attestations have.
    /// This is the 'tag based discovery' and in the future once references are
    /// fully supported that should likely be the preferred way to handle these.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagPrefix")]
    pub tag_prefix: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignSourcePullSecrets {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// TUF defines the configuration to fetch sigstore root
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignTuf {
    /// Mirror is the base URL of Sigstore TUF repository
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<String>,
    /// Root defines the path or data of the trusted root
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub root: Option<ImageValidatingPolicyAttestorsCosignTufRoot>,
}

/// Root defines the path or data of the trusted root
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsCosignTufRoot {
    /// Data is the base64 encoded TUF root
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// Path is the URL or File location of the TUF root
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// Notary defines attestor configuration for Notary based signatures
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsNotary {
    /// Certs define the cert chain for Notary signature verification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certs: Option<ImageValidatingPolicyAttestorsNotaryCerts>,
    /// TSACerts define the cert chain for verifying timestamps of notary signature
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tsaCerts")]
    pub tsa_certs: Option<ImageValidatingPolicyAttestorsNotaryTsaCerts>,
}

/// Certs define the cert chain for Notary signature verification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsNotaryCerts {
    /// Expression defines the a CEL expression input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Value defines the raw string input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// TSACerts define the cert chain for verifying timestamps of notary signature
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAttestorsNotaryTsaCerts {
    /// Expression defines the a CEL expression input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Value defines the raw string input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// AuditAnnotation describes how to produce an audit annotation for an API request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAuditAnnotations {
    /// key specifies the audit annotation key. The audit annotation keys of
    /// a ValidatingAdmissionPolicy must be unique. The key must be a qualified
    /// name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
    /// 
    /// The key is combined with the resource name of the
    /// ValidatingAdmissionPolicy to construct an audit annotation key:
    /// "{ValidatingAdmissionPolicy name}/{key}".
    /// 
    /// If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
    /// and the same audit annotation key, the annotation key will be identical.
    /// In this case, the first annotation written with the key will be included
    /// in the audit event and all subsequent annotations with the same key
    /// will be discarded.
    /// 
    /// Required.
    pub key: String,
    /// valueExpression represents the expression which is evaluated by CEL to
    /// produce an audit annotation value. The expression must evaluate to either
    /// a string or null value. If the expression evaluates to a string, the
    /// audit annotation is included with the string value. If the expression
    /// evaluates to null or empty string the audit annotation will be omitted.
    /// The valueExpression may be no longer than 5kb in length.
    /// If the result of the valueExpression is more than 10kb in length, it
    /// will be truncated to 10kb.
    /// 
    /// If multiple ValidatingAdmissionPolicyBinding resources match an
    /// API request, then the valueExpression will be evaluated for
    /// each binding. All unique values produced by the valueExpressions
    /// will be joined together in a comma-separated list.
    /// 
    /// Required.
    #[serde(rename = "valueExpression")]
    pub value_expression: String,
}

/// AutogenConfiguration defines the configuration for the generation controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAutogen {
    /// PodControllers specifies whether to generate a pod controllers rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podControllers")]
    pub pod_controllers: Option<ImageValidatingPolicyAutogenPodControllers>,
}

/// PodControllers specifies whether to generate a pod controllers rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyAutogenPodControllers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub controllers: Option<Vec<String>>,
}

/// Credentials provides credentials that will be used for authentication with registry.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyCredentials {
    /// AllowInsecureRegistry allows insecure access to a registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowInsecureRegistry")]
    pub allow_insecure_registry: Option<bool>,
    /// Providers specifies a list of OCI Registry names, whose authentication providers are provided.
    /// It can be of one of these values: default,google,azure,amazon,github.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub providers: Option<Vec<String>>,
    /// Secrets specifies a list of secrets that are provided for credentials.
    /// Secrets must live in the Kyverno namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
}

/// EvaluationConfiguration defines the configuration for the policy evaluation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyEvaluation {
    /// Admission controls policy evaluation during admission.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admission: Option<ImageValidatingPolicyEvaluationAdmission>,
    /// Background  controls policy evaluation during background scan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub background: Option<ImageValidatingPolicyEvaluationBackground>,
    /// Mode is the mode of policy evaluation.
    /// Allowed values are "Kubernetes" or "JSON".
    /// Optional. Default value is "Kubernetes".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Admission controls policy evaluation during admission.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyEvaluationAdmission {
    /// Enabled controls if rules are applied during admission.
    /// Optional. Default value is "true".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Background  controls policy evaluation during background scan.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyEvaluationBackground {
    /// Enabled controls if rules are applied to existing resources during a background scan.
    /// Optional. Default value is "true". The value must be set to "false" if the policy rule
    /// uses variables that are only available in the admission review request (e.g. user name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// ImageValidatingPolicySpec is the specification of the desired behavior of the ImageValidatingPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ImageValidatingPolicyFailurePolicy {
    Ignore,
    Fail,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyImages {
    /// Expression defines CEL expression to extract images from the resource.
    pub expression: String,
    /// Name is the name for this imageList. It is used to refer to the images in verification block as images.<name>
    pub name: String,
}

/// MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyMatchConditions {
    /// Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
    /// CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
    /// 
    /// 'object' - The object from the incoming request. The value is null for DELETE requests.
    /// 'oldObject' - The existing object. The value is null for CREATE requests.
    /// 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
    /// 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
    ///   See <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz>
    /// 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
    ///   request resource.
    /// Documentation on CEL: <https://kubernetes.io/docs/reference/using-api/cel/>
    /// 
    /// Required.
    pub expression: String,
    /// Name is an identifier for this match condition, used for strategic merging of MatchConditions,
    /// as well as providing an identifier for logging purposes. A good name should be descriptive of
    /// the associated expression.
    /// Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
    /// must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
    /// '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
    /// optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
    /// 
    /// Required.
    pub name: String,
}

/// MatchConstraints specifies what resources this policy is designed to validate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyMatchConstraints {
    /// ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
    /// The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeResourceRules")]
    pub exclude_resource_rules: Option<Vec<ImageValidatingPolicyMatchConstraintsExcludeResourceRules>>,
    /// matchPolicy defines how the "MatchResources" list is used to match incoming requests.
    /// Allowed values are "Exact" or "Equivalent".
    /// 
    /// - Exact: match a request only if it exactly matches a specified rule.
    /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    /// but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    /// a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
    /// 
    /// - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
    /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    /// and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    /// a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
    /// 
    /// Defaults to "Equivalent"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPolicy")]
    pub match_policy: Option<String>,
    /// NamespaceSelector decides whether to run the admission control policy on an object based
    /// on whether the namespace for that object matches the selector. If the
    /// object itself is a namespace, the matching is performed on
    /// object.metadata.labels. If the object is another cluster scoped resource,
    /// it never skips the policy.
    /// 
    /// For example, to run the webhook on any objects whose namespace is not
    /// associated with "runlevel" of "0" or "1";  you will set the selector as
    /// follows:
    /// "namespaceSelector": {
    ///   "matchExpressions": [
    ///     {
    ///       "key": "runlevel",
    ///       "operator": "NotIn",
    ///       "values": [
    ///         "0",
    ///         "1"
    ///       ]
    ///     }
    ///   ]
    /// }
    /// 
    /// If instead you want to only run the policy on any objects whose
    /// namespace is associated with the "environment" of "prod" or "staging";
    /// you will set the selector as follows:
    /// "namespaceSelector": {
    ///   "matchExpressions": [
    ///     {
    ///       "key": "environment",
    ///       "operator": "In",
    ///       "values": [
    ///         "prod",
    ///         "staging"
    ///       ]
    ///     }
    ///   ]
    /// }
    /// 
    /// See
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
    /// for more examples of label selectors.
    /// 
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ImageValidatingPolicyMatchConstraintsNamespaceSelector>,
    /// ObjectSelector decides whether to run the validation based on if the
    /// object has matching labels. objectSelector is evaluated against both
    /// the oldObject and newObject that would be sent to the cel validation, and
    /// is considered to match if either object matches the selector. A null
    /// object (oldObject in the case of create, or newObject in the case of
    /// delete) or an object that cannot have labels (like a
    /// DeploymentRollback or a PodProxyOptions object) is not considered to
    /// match.
    /// Use the object selector only if the webhook is opt-in, because end
    /// users may skip the admission webhook by setting the labels.
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectSelector")]
    pub object_selector: Option<ImageValidatingPolicyMatchConstraintsObjectSelector>,
    /// ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
    /// The policy cares about an operation if it matches _any_ Rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceRules")]
    pub resource_rules: Option<Vec<ImageValidatingPolicyMatchConstraintsResourceRules>>,
}

/// NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyMatchConstraintsExcludeResourceRules {
    /// APIGroups is the API groups the resources belong to. '*' is all groups.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroups")]
    pub api_groups: Option<Vec<String>>,
    /// APIVersions is the API versions the resources belong to. '*' is all versions.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersions")]
    pub api_versions: Option<Vec<String>>,
    /// Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
    /// for all of those operations and any future admission operations that are added.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceNames")]
    pub resource_names: Option<Vec<String>>,
    /// Resources is a list of resources this rule applies to.
    /// 
    /// For example:
    /// 'pods' means pods.
    /// 'pods/log' means the log subresource of pods.
    /// '*' means all resources, but not subresources.
    /// 'pods/*' means all subresources of pods.
    /// '*/scale' means all scale subresources.
    /// '*/*' means all resources and their subresources.
    /// 
    /// If wildcard is present, the validation rule will ensure resources do not
    /// overlap with each other.
    /// 
    /// Depending on the enclosing object, subresources might not be allowed.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// scope specifies the scope of this rule.
    /// Valid values are "Cluster", "Namespaced", and "*"
    /// "Cluster" means that only cluster-scoped resources will match this rule.
    /// Namespace API objects are cluster-scoped.
    /// "Namespaced" means that only namespaced resources will match this rule.
    /// "*" means that there are no scope restrictions.
    /// Subresources match the scope of their parent resource.
    /// Default is "*".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// NamespaceSelector decides whether to run the admission control policy on an object based
/// on whether the namespace for that object matches the selector. If the
/// object itself is a namespace, the matching is performed on
/// object.metadata.labels. If the object is another cluster scoped resource,
/// it never skips the policy.
/// 
/// For example, to run the webhook on any objects whose namespace is not
/// associated with "runlevel" of "0" or "1";  you will set the selector as
/// follows:
/// "namespaceSelector": {
///   "matchExpressions": [
///     {
///       "key": "runlevel",
///       "operator": "NotIn",
///       "values": [
///         "0",
///         "1"
///       ]
///     }
///   ]
/// }
/// 
/// If instead you want to only run the policy on any objects whose
/// namespace is associated with the "environment" of "prod" or "staging";
/// you will set the selector as follows:
/// "namespaceSelector": {
///   "matchExpressions": [
///     {
///       "key": "environment",
///       "operator": "In",
///       "values": [
///         "prod",
///         "staging"
///       ]
///     }
///   ]
/// }
/// 
/// See
/// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
/// for more examples of label selectors.
/// 
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyMatchConstraintsNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ImageValidatingPolicyMatchConstraintsNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyMatchConstraintsNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ObjectSelector decides whether to run the validation based on if the
/// object has matching labels. objectSelector is evaluated against both
/// the oldObject and newObject that would be sent to the cel validation, and
/// is considered to match if either object matches the selector. A null
/// object (oldObject in the case of create, or newObject in the case of
/// delete) or an object that cannot have labels (like a
/// DeploymentRollback or a PodProxyOptions object) is not considered to
/// match.
/// Use the object selector only if the webhook is opt-in, because end
/// users may skip the admission webhook by setting the labels.
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyMatchConstraintsObjectSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ImageValidatingPolicyMatchConstraintsObjectSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyMatchConstraintsObjectSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyMatchConstraintsResourceRules {
    /// APIGroups is the API groups the resources belong to. '*' is all groups.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroups")]
    pub api_groups: Option<Vec<String>>,
    /// APIVersions is the API versions the resources belong to. '*' is all versions.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersions")]
    pub api_versions: Option<Vec<String>>,
    /// Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
    /// for all of those operations and any future admission operations that are added.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceNames")]
    pub resource_names: Option<Vec<String>>,
    /// Resources is a list of resources this rule applies to.
    /// 
    /// For example:
    /// 'pods' means pods.
    /// 'pods/log' means the log subresource of pods.
    /// '*' means all resources, but not subresources.
    /// 'pods/*' means all subresources of pods.
    /// '*/scale' means all scale subresources.
    /// '*/*' means all resources and their subresources.
    /// 
    /// If wildcard is present, the validation rule will ensure resources do not
    /// overlap with each other.
    /// 
    /// Depending on the enclosing object, subresources might not be allowed.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// scope specifies the scope of this rule.
    /// Valid values are "Cluster", "Namespaced", and "*"
    /// "Cluster" means that only cluster-scoped resources will match this rule.
    /// Namespace API objects are cluster-scoped.
    /// "Namespaced" means that only namespaced resources will match this rule.
    /// "*" means that there are no scope restrictions.
    /// Subresources match the scope of their parent resource.
    /// Default is "*".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// MatchImageReference defines a Glob or a CEL expression for matching images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyMatchImageReferences {
    /// Expression defines CEL Expressions for matching images
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Glob defines a globbing pattern for matching images
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glob: Option<String>,
}

/// ValidationConfigurations defines settings for mutating and verifying image digests, and enforcing image verification through signatures.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyValidationConfigurations {
    /// MutateDigest enables replacement of image tags with digests.
    /// Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mutateDigest")]
    pub mutate_digest: Option<bool>,
    /// Required validates that images are verified, i.e., have passed a signature or attestation check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    /// VerifyDigest validates that images have a digest.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verifyDigest")]
    pub verify_digest: Option<bool>,
}

/// Validation specifies the CEL expression which is used to apply the validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyValidations {
    /// Expression represents the expression which will be evaluated by CEL.
    /// ref: <https://github.com/google/cel-spec>
    /// CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
    /// 
    /// - 'object' - The object from the incoming request. The value is null for DELETE requests.
    /// - 'oldObject' - The existing object. The value is null for CREATE requests.
    /// - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
    /// - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
    /// - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
    /// - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
    ///   For example, a variable named 'foo' can be accessed as 'variables.foo'.
    /// - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
    ///   See <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz>
    /// - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
    ///   request resource.
    /// 
    /// The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
    /// object. No other metadata properties are accessible.
    /// 
    /// Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
    /// Accessible property names are escaped according to the following rules when accessed in the expression:
    /// - '__' escapes to '__underscores__'
    /// - '.' escapes to '__dot__'
    /// - '-' escapes to '__dash__'
    /// - '/' escapes to '__slash__'
    /// - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
    /// 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
    /// 	  "import", "let", "loop", "package", "namespace", "return".
    /// Examples:
    ///   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
    ///   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
    ///   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}
    /// 
    /// Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
    /// Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
    ///   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
    ///     non-intersecting elements in `Y` are appended, retaining their partial order.
    ///   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
    ///     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
    ///     non-intersecting keys are appended, retaining their partial order.
    /// Required.
    pub expression: String,
    /// Message represents the message displayed when validation fails. The message is required if the Expression contains
    /// line breaks. The message must not contain line breaks.
    /// If unset, the message is "failed rule: {Rule}".
    /// e.g. "must be a URL with the host matching spec.host"
    /// If the Expression contains line breaks. Message is required.
    /// The message must not contain line breaks.
    /// If unset, the message is "failed Expression: {Expression}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
    /// Since messageExpression is used as a failure message, it must evaluate to a string.
    /// If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
    /// If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
    /// as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
    /// that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
    /// the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
    /// messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
    /// Example:
    /// "object.x must be less than max ("+string(params.max)+")"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageExpression")]
    pub message_expression: Option<String>,
    /// Reason represents a machine-readable description of why this validation failed.
    /// If this is the first validation in the list to fail, this reason, as well as the
    /// corresponding HTTP response code, are used in the
    /// HTTP response to the client.
    /// The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
    /// If not set, StatusReasonInvalid is used in the response to the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyVariables {
    /// Expression is the expression that will be evaluated as the value of the variable.
    /// The CEL expression has access to the same identifiers as the CEL expressions in Validation.
    pub expression: String,
    /// Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
    /// The variable can be accessed in other expressions through `variables`
    /// For example, if name is "foo", the variable will be available as `variables.foo`
    pub name: String,
}

/// WebhookConfiguration defines the configuration for the webhook.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyWebhookConfiguration {
    /// TimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
    /// After the configured time expires, the admission request may fail, or may simply ignore the policy results,
    /// based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Status contains policy runtime data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autogen: Option<ImageValidatingPolicyStatusAutogen>,
    /// ConditionStatus is the shared status across all policy types
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionStatus")]
    pub condition_status: Option<ImageValidatingPolicyStatusConditionStatus>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogen {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configs: Option<BTreeMap<String, ImageValidatingPolicyStatusAutogenConfigs>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigs {
    /// ImageValidatingPolicySpec is the specification of the desired behavior of the ImageValidatingPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ImageValidatingPolicyStatusAutogenConfigsSpec>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsTargets>>,
}

/// ImageValidatingPolicySpec is the specification of the desired behavior of the ImageValidatingPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpec {
    /// Attestations provides a list of image metadata to verify
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attestations: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecAttestations>>,
    /// Attestors provides a list of trusted authorities.
    pub attestors: Vec<ImageValidatingPolicyStatusAutogenConfigsSpecAttestors>,
    /// auditAnnotations contains CEL expressions which are used to produce audit
    /// annotations for the audit event of the API request.
    /// validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
    /// required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditAnnotations")]
    pub audit_annotations: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecAuditAnnotations>>,
    /// AutogenConfiguration defines the configuration for the generation controller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autogen: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAutogen>,
    /// Credentials provides credentials that will be used for authentication with registry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ImageValidatingPolicyStatusAutogenConfigsSpecCredentials>,
    /// EvaluationConfiguration defines the configuration for the policy evaluation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub evaluation: Option<ImageValidatingPolicyStatusAutogenConfigsSpecEvaluation>,
    /// FailurePolicy defines how to handle failures for the admission policy. Failures can
    /// occur from CEL expression parse errors, type check errors, runtime errors and invalid
    /// or mis-configured policy definitions or bindings.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failurePolicy")]
    pub failure_policy: Option<ImageValidatingPolicyStatusAutogenConfigsSpecFailurePolicy>,
    /// ImageExtractors is a list of CEL expression to extract images from the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub images: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecImages>>,
    /// MatchConditions is a list of conditions that must be met for a request to be validated.
    /// Match conditions filter requests that have already been matched by the rules,
    /// namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
    /// There are a maximum of 64 match conditions allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchConditions")]
    pub match_conditions: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecMatchConditions>>,
    /// MatchConstraints specifies what resources this policy is designed to validate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchConstraints")]
    pub match_constraints: Option<ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraints>,
    /// MatchImageReferences is a list of Glob and CELExpressions to match images.
    /// Any image that matches one of the rules is considered for validation
    /// Any image that does not match a rule is skipped, even when they are passed as arguments to
    /// image verification functions
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchImageReferences")]
    pub match_image_references: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecMatchImageReferences>>,
    /// ValidationAction specifies the action to be taken when the matched resource violates the policy.
    /// If a validation evaluates to false it is always enforced according to these actions.
    /// 
    /// Failures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according
    /// to these actions only if the FailurePolicy is set to Fail, otherwise the failures are
    /// ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.
    /// 
    /// validationActions is declared as a set of action values. Order does
    /// not matter. validationActions may not contain duplicates of the same action.
    /// 
    /// The supported actions values are:
    /// 
    /// "Deny" specifies that a validation failure results in a denied request.
    /// 
    /// "Warn" specifies that a validation failure is reported to the request client
    /// in HTTP Warning headers, with a warning code of 299. Warnings can be sent
    /// both for allowed or denied admission responses.
    /// 
    /// "Audit" specifies that a validation failure is recorded in the created reports.
    /// 
    /// Clients should expect to handle additional values by ignoring
    /// any values not recognized.
    /// 
    /// "Deny" and "Warn" may not be used together since this combination
    /// needlessly duplicates the validation failure both in the
    /// API response body and the HTTP warning headers.
    /// 
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validationActions")]
    pub validation_actions: Option<Vec<String>>,
    /// ValidationConfigurations defines settings for mutating and verifying image digests, and enforcing image verification through signatures.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validationConfigurations")]
    pub validation_configurations: Option<ImageValidatingPolicyStatusAutogenConfigsSpecValidationConfigurations>,
    /// Validations contain CEL expressions which is used to apply the image validation checks.
    pub validations: Vec<ImageValidatingPolicyStatusAutogenConfigsSpecValidations>,
    /// Variables contain definitions of variables that can be used in composition of other expressions.
    /// Each variable is defined as a named CEL expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecVariables>>,
    /// WebhookConfiguration defines the configuration for the webhook.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookConfiguration")]
    pub webhook_configuration: Option<ImageValidatingPolicyStatusAutogenConfigsSpecWebhookConfiguration>,
}

/// Attestation defines the identification details of the  metadata that has to be verified
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestations {
    /// InToto defines the details of attestation attached using intoto format
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub intoto: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestationsIntoto>,
    /// Name is the name for this attestation. It is used to refer to the attestation in verification
    pub name: String,
    /// Referrer defines the details of attestation attached using OCI 1.1 format
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub referrer: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestationsReferrer>,
}

/// InToto defines the details of attestation attached using intoto format
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestationsIntoto {
    /// Type defines the type of attestation contained within the statement.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Referrer defines the details of attestation attached using OCI 1.1 format
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestationsReferrer {
    /// Type defines the type of attestation attached to the image.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Attestor is an identity that confirms or verifies the authenticity of an image or an attestation
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestors {
    /// Cosign defines attestor configuration for Cosign based signatures
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cosign: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosign>,
    /// Name is the name for this attestor. It is used to refer to the attestor in verification
    pub name: String,
    /// Notary defines attestor configuration for Notary based signatures
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notary: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsNotary>,
}

/// Cosign defines attestor configuration for Cosign based signatures
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosign {
    /// Annotations are used for image verification.
    /// Every specified key-value pair must exist and match in the verified payload.
    /// The payload may contain other key-value pairs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Certificate defines the configuration for local signature verification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignCertificate>,
    /// CTLog sets the configuration to verify the authority against a Rekor instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ctlog: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignCtlog>,
    /// Key defines the type of key to validate the image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignKey>,
    /// Keyless sets the configuration to verify the authority against a Fulcio instance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyless: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignKeyless>,
    /// Sources sets the configuration to specify the sources from where to consume the signature and attestations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignSource>,
    /// TUF defines the configuration to fetch sigstore root
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tuf: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignTuf>,
}

/// Certificate defines the configuration for local signature verification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignCertificate {
    /// Certificate is the to the public certificate for local signature verification.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignCertificateCert>,
    /// CertificateChain is the list of CA certificates in PEM format which will be needed
    /// when building the certificate chain for the signing certificate. Must start with the
    /// parent intermediate CA certificate of the signing certificate and end with the root certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certChain")]
    pub cert_chain: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignCertificateCertChain>,
}

/// Certificate is the to the public certificate for local signature verification.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignCertificateCert {
    /// Expression defines the a CEL expression input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Value defines the raw string input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// CertificateChain is the list of CA certificates in PEM format which will be needed
/// when building the certificate chain for the signing certificate. Must start with the
/// parent intermediate CA certificate of the signing certificate and end with the root certificate
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignCertificateCertChain {
    /// Expression defines the a CEL expression input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Value defines the raw string input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// CTLog sets the configuration to verify the authority against a Rekor instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignCtlog {
    /// CTLogPubKey, if set, is used to validate SCTs against a custom source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ctLogPubKey")]
    pub ct_log_pub_key: Option<String>,
    /// IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
    /// timestamp. Default is false. Set to true if this was opted out during signing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureIgnoreSCT")]
    pub insecure_ignore_sct: Option<bool>,
    /// InsecureIgnoreTlog skips transparency log verification.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureIgnoreTlog")]
    pub insecure_ignore_tlog: Option<bool>,
    /// RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
    /// If set, this will be used to validate transparency log signatures from a custom Rekor.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rekorPubKey")]
    pub rekor_pub_key: Option<String>,
    /// TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
    /// contain the root CA certificate. Optionally may contain intermediate CA certificates, and
    /// may contain the leaf TSA certificate if not present in the timestamurce.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tsaCertChain")]
    pub tsa_cert_chain: Option<String>,
    /// URL sets the url to the rekor instance (by default the public rekor.sigstore.dev)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Key defines the type of key to validate the image.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignKey {
    /// Data contains the inline public key
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// Expression is a Expression expression that returns the public key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// HashAlgorithm specifues signature algorithm for public keys. Supported values are
    /// sha224, sha256, sha384 and sha512. Defaults to sha256.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hashAlgorithm")]
    pub hash_algorithm: Option<String>,
    /// KMS contains the KMS url of the public key
    /// Supported formats differ based on the KMS system used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kms: Option<String>,
}

/// Keyless sets the configuration to verify the authority against a Fulcio instance.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignKeyless {
    /// Identities sets a list of identities.
    pub identities: Vec<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignKeylessIdentities>,
    /// Roots is an optional set of PEM encoded trusted root certificates.
    /// If not provided, the system roots are used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roots: Option<String>,
}

/// Identity may contain the issuer and/or the subject found in the transparency
/// log.
/// Issuer/Subject uses a strict match, while IssuerRegExp and SubjectRegExp
/// apply a regexp for matching.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignKeylessIdentities {
    /// Issuer defines the issuer for this identity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issuer: Option<String>,
    /// IssuerRegExp specifies a regular expression to match the issuer for this identity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "issuerRegExp")]
    pub issuer_reg_exp: Option<String>,
    /// Subject defines the subject for this identity.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subject: Option<String>,
    /// SubjectRegExp specifies a regular expression to match the subject for this identity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subjectRegExp")]
    pub subject_reg_exp: Option<String>,
}

/// Sources sets the configuration to specify the sources from where to consume the signature and attestations.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignSource {
    /// SignaturePullSecrets is an optional list of references to secrets in the
    /// same namespace as the deploying resource for pulling any of the signatures
    /// used by this Source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "PullSecrets")]
    pub pull_secrets: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignSourcePullSecrets>>,
    /// Repository defines the location from where to pull the signature / attestations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
    /// TagPrefix is an optional prefix that signature and attestations have.
    /// This is the 'tag based discovery' and in the future once references are
    /// fully supported that should likely be the preferred way to handle these.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tagPrefix")]
    pub tag_prefix: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignSourcePullSecrets {
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// TUF defines the configuration to fetch sigstore root
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignTuf {
    /// Mirror is the base URL of Sigstore TUF repository
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mirror: Option<String>,
    /// Root defines the path or data of the trusted root
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub root: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignTufRoot>,
}

/// Root defines the path or data of the trusted root
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsCosignTufRoot {
    /// Data is the base64 encoded TUF root
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// Path is the URL or File location of the TUF root
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// Notary defines attestor configuration for Notary based signatures
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsNotary {
    /// Certs define the cert chain for Notary signature verification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certs: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsNotaryCerts>,
    /// TSACerts define the cert chain for verifying timestamps of notary signature
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tsaCerts")]
    pub tsa_certs: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsNotaryTsaCerts>,
}

/// Certs define the cert chain for Notary signature verification
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsNotaryCerts {
    /// Expression defines the a CEL expression input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Value defines the raw string input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// TSACerts define the cert chain for verifying timestamps of notary signature
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAttestorsNotaryTsaCerts {
    /// Expression defines the a CEL expression input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Value defines the raw string input.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// AuditAnnotation describes how to produce an audit annotation for an API request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAuditAnnotations {
    /// key specifies the audit annotation key. The audit annotation keys of
    /// a ValidatingAdmissionPolicy must be unique. The key must be a qualified
    /// name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
    /// 
    /// The key is combined with the resource name of the
    /// ValidatingAdmissionPolicy to construct an audit annotation key:
    /// "{ValidatingAdmissionPolicy name}/{key}".
    /// 
    /// If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
    /// and the same audit annotation key, the annotation key will be identical.
    /// In this case, the first annotation written with the key will be included
    /// in the audit event and all subsequent annotations with the same key
    /// will be discarded.
    /// 
    /// Required.
    pub key: String,
    /// valueExpression represents the expression which is evaluated by CEL to
    /// produce an audit annotation value. The expression must evaluate to either
    /// a string or null value. If the expression evaluates to a string, the
    /// audit annotation is included with the string value. If the expression
    /// evaluates to null or empty string the audit annotation will be omitted.
    /// The valueExpression may be no longer than 5kb in length.
    /// If the result of the valueExpression is more than 10kb in length, it
    /// will be truncated to 10kb.
    /// 
    /// If multiple ValidatingAdmissionPolicyBinding resources match an
    /// API request, then the valueExpression will be evaluated for
    /// each binding. All unique values produced by the valueExpressions
    /// will be joined together in a comma-separated list.
    /// 
    /// Required.
    #[serde(rename = "valueExpression")]
    pub value_expression: String,
}

/// AutogenConfiguration defines the configuration for the generation controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAutogen {
    /// PodControllers specifies whether to generate a pod controllers rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podControllers")]
    pub pod_controllers: Option<ImageValidatingPolicyStatusAutogenConfigsSpecAutogenPodControllers>,
}

/// PodControllers specifies whether to generate a pod controllers rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecAutogenPodControllers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub controllers: Option<Vec<String>>,
}

/// Credentials provides credentials that will be used for authentication with registry.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecCredentials {
    /// AllowInsecureRegistry allows insecure access to a registry.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowInsecureRegistry")]
    pub allow_insecure_registry: Option<bool>,
    /// Providers specifies a list of OCI Registry names, whose authentication providers are provided.
    /// It can be of one of these values: default,google,azure,amazon,github.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub providers: Option<Vec<String>>,
    /// Secrets specifies a list of secrets that are provided for credentials.
    /// Secrets must live in the Kyverno namespace.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<String>>,
}

/// EvaluationConfiguration defines the configuration for the policy evaluation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecEvaluation {
    /// Admission controls policy evaluation during admission.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admission: Option<ImageValidatingPolicyStatusAutogenConfigsSpecEvaluationAdmission>,
    /// Background  controls policy evaluation during background scan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub background: Option<ImageValidatingPolicyStatusAutogenConfigsSpecEvaluationBackground>,
    /// Mode is the mode of policy evaluation.
    /// Allowed values are "Kubernetes" or "JSON".
    /// Optional. Default value is "Kubernetes".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Admission controls policy evaluation during admission.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecEvaluationAdmission {
    /// Enabled controls if rules are applied during admission.
    /// Optional. Default value is "true".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Background  controls policy evaluation during background scan.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecEvaluationBackground {
    /// Enabled controls if rules are applied to existing resources during a background scan.
    /// Optional. Default value is "true". The value must be set to "false" if the policy rule
    /// uses variables that are only available in the admission review request (e.g. user name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// ImageValidatingPolicySpec is the specification of the desired behavior of the ImageValidatingPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ImageValidatingPolicyStatusAutogenConfigsSpecFailurePolicy {
    Ignore,
    Fail,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecImages {
    /// Expression defines CEL expression to extract images from the resource.
    pub expression: String,
    /// Name is the name for this imageList. It is used to refer to the images in verification block as images.<name>
    pub name: String,
}

/// MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecMatchConditions {
    /// Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
    /// CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
    /// 
    /// 'object' - The object from the incoming request. The value is null for DELETE requests.
    /// 'oldObject' - The existing object. The value is null for CREATE requests.
    /// 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
    /// 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
    ///   See <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz>
    /// 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
    ///   request resource.
    /// Documentation on CEL: <https://kubernetes.io/docs/reference/using-api/cel/>
    /// 
    /// Required.
    pub expression: String,
    /// Name is an identifier for this match condition, used for strategic merging of MatchConditions,
    /// as well as providing an identifier for logging purposes. A good name should be descriptive of
    /// the associated expression.
    /// Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
    /// must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
    /// '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
    /// optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
    /// 
    /// Required.
    pub name: String,
}

/// MatchConstraints specifies what resources this policy is designed to validate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraints {
    /// ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
    /// The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeResourceRules")]
    pub exclude_resource_rules: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsExcludeResourceRules>>,
    /// matchPolicy defines how the "MatchResources" list is used to match incoming requests.
    /// Allowed values are "Exact" or "Equivalent".
    /// 
    /// - Exact: match a request only if it exactly matches a specified rule.
    /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    /// but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    /// a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
    /// 
    /// - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
    /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    /// and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    /// a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
    /// 
    /// Defaults to "Equivalent"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPolicy")]
    pub match_policy: Option<String>,
    /// NamespaceSelector decides whether to run the admission control policy on an object based
    /// on whether the namespace for that object matches the selector. If the
    /// object itself is a namespace, the matching is performed on
    /// object.metadata.labels. If the object is another cluster scoped resource,
    /// it never skips the policy.
    /// 
    /// For example, to run the webhook on any objects whose namespace is not
    /// associated with "runlevel" of "0" or "1";  you will set the selector as
    /// follows:
    /// "namespaceSelector": {
    ///   "matchExpressions": [
    ///     {
    ///       "key": "runlevel",
    ///       "operator": "NotIn",
    ///       "values": [
    ///         "0",
    ///         "1"
    ///       ]
    ///     }
    ///   ]
    /// }
    /// 
    /// If instead you want to only run the policy on any objects whose
    /// namespace is associated with the "environment" of "prod" or "staging";
    /// you will set the selector as follows:
    /// "namespaceSelector": {
    ///   "matchExpressions": [
    ///     {
    ///       "key": "environment",
    ///       "operator": "In",
    ///       "values": [
    ///         "prod",
    ///         "staging"
    ///       ]
    ///     }
    ///   ]
    /// }
    /// 
    /// See
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
    /// for more examples of label selectors.
    /// 
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsNamespaceSelector>,
    /// ObjectSelector decides whether to run the validation based on if the
    /// object has matching labels. objectSelector is evaluated against both
    /// the oldObject and newObject that would be sent to the cel validation, and
    /// is considered to match if either object matches the selector. A null
    /// object (oldObject in the case of create, or newObject in the case of
    /// delete) or an object that cannot have labels (like a
    /// DeploymentRollback or a PodProxyOptions object) is not considered to
    /// match.
    /// Use the object selector only if the webhook is opt-in, because end
    /// users may skip the admission webhook by setting the labels.
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectSelector")]
    pub object_selector: Option<ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsObjectSelector>,
    /// ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
    /// The policy cares about an operation if it matches _any_ Rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceRules")]
    pub resource_rules: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsResourceRules>>,
}

/// NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsExcludeResourceRules {
    /// APIGroups is the API groups the resources belong to. '*' is all groups.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroups")]
    pub api_groups: Option<Vec<String>>,
    /// APIVersions is the API versions the resources belong to. '*' is all versions.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersions")]
    pub api_versions: Option<Vec<String>>,
    /// Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
    /// for all of those operations and any future admission operations that are added.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceNames")]
    pub resource_names: Option<Vec<String>>,
    /// Resources is a list of resources this rule applies to.
    /// 
    /// For example:
    /// 'pods' means pods.
    /// 'pods/log' means the log subresource of pods.
    /// '*' means all resources, but not subresources.
    /// 'pods/*' means all subresources of pods.
    /// '*/scale' means all scale subresources.
    /// '*/*' means all resources and their subresources.
    /// 
    /// If wildcard is present, the validation rule will ensure resources do not
    /// overlap with each other.
    /// 
    /// Depending on the enclosing object, subresources might not be allowed.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// scope specifies the scope of this rule.
    /// Valid values are "Cluster", "Namespaced", and "*"
    /// "Cluster" means that only cluster-scoped resources will match this rule.
    /// Namespace API objects are cluster-scoped.
    /// "Namespaced" means that only namespaced resources will match this rule.
    /// "*" means that there are no scope restrictions.
    /// Subresources match the scope of their parent resource.
    /// Default is "*".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// NamespaceSelector decides whether to run the admission control policy on an object based
/// on whether the namespace for that object matches the selector. If the
/// object itself is a namespace, the matching is performed on
/// object.metadata.labels. If the object is another cluster scoped resource,
/// it never skips the policy.
/// 
/// For example, to run the webhook on any objects whose namespace is not
/// associated with "runlevel" of "0" or "1";  you will set the selector as
/// follows:
/// "namespaceSelector": {
///   "matchExpressions": [
///     {
///       "key": "runlevel",
///       "operator": "NotIn",
///       "values": [
///         "0",
///         "1"
///       ]
///     }
///   ]
/// }
/// 
/// If instead you want to only run the policy on any objects whose
/// namespace is associated with the "environment" of "prod" or "staging";
/// you will set the selector as follows:
/// "namespaceSelector": {
///   "matchExpressions": [
///     {
///       "key": "environment",
///       "operator": "In",
///       "values": [
///         "prod",
///         "staging"
///       ]
///     }
///   ]
/// }
/// 
/// See
/// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
/// for more examples of label selectors.
/// 
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ObjectSelector decides whether to run the validation based on if the
/// object has matching labels. objectSelector is evaluated against both
/// the oldObject and newObject that would be sent to the cel validation, and
/// is considered to match if either object matches the selector. A null
/// object (oldObject in the case of create, or newObject in the case of
/// delete) or an object that cannot have labels (like a
/// DeploymentRollback or a PodProxyOptions object) is not considered to
/// match.
/// Use the object selector only if the webhook is opt-in, because end
/// users may skip the admission webhook by setting the labels.
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsObjectSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsObjectSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsObjectSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsResourceRules {
    /// APIGroups is the API groups the resources belong to. '*' is all groups.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroups")]
    pub api_groups: Option<Vec<String>>,
    /// APIVersions is the API versions the resources belong to. '*' is all versions.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersions")]
    pub api_versions: Option<Vec<String>>,
    /// Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
    /// for all of those operations and any future admission operations that are added.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceNames")]
    pub resource_names: Option<Vec<String>>,
    /// Resources is a list of resources this rule applies to.
    /// 
    /// For example:
    /// 'pods' means pods.
    /// 'pods/log' means the log subresource of pods.
    /// '*' means all resources, but not subresources.
    /// 'pods/*' means all subresources of pods.
    /// '*/scale' means all scale subresources.
    /// '*/*' means all resources and their subresources.
    /// 
    /// If wildcard is present, the validation rule will ensure resources do not
    /// overlap with each other.
    /// 
    /// Depending on the enclosing object, subresources might not be allowed.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// scope specifies the scope of this rule.
    /// Valid values are "Cluster", "Namespaced", and "*"
    /// "Cluster" means that only cluster-scoped resources will match this rule.
    /// Namespace API objects are cluster-scoped.
    /// "Namespaced" means that only namespaced resources will match this rule.
    /// "*" means that there are no scope restrictions.
    /// Subresources match the scope of their parent resource.
    /// Default is "*".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// MatchImageReference defines a Glob or a CEL expression for matching images
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecMatchImageReferences {
    /// Expression defines CEL Expressions for matching images
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Glob defines a globbing pattern for matching images
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glob: Option<String>,
}

/// ValidationConfigurations defines settings for mutating and verifying image digests, and enforcing image verification through signatures.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecValidationConfigurations {
    /// MutateDigest enables replacement of image tags with digests.
    /// Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mutateDigest")]
    pub mutate_digest: Option<bool>,
    /// Required validates that images are verified, i.e., have passed a signature or attestation check.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    /// VerifyDigest validates that images have a digest.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "verifyDigest")]
    pub verify_digest: Option<bool>,
}

/// Validation specifies the CEL expression which is used to apply the validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecValidations {
    /// Expression represents the expression which will be evaluated by CEL.
    /// ref: <https://github.com/google/cel-spec>
    /// CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
    /// 
    /// - 'object' - The object from the incoming request. The value is null for DELETE requests.
    /// - 'oldObject' - The existing object. The value is null for CREATE requests.
    /// - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
    /// - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
    /// - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
    /// - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
    ///   For example, a variable named 'foo' can be accessed as 'variables.foo'.
    /// - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
    ///   See <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz>
    /// - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
    ///   request resource.
    /// 
    /// The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
    /// object. No other metadata properties are accessible.
    /// 
    /// Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
    /// Accessible property names are escaped according to the following rules when accessed in the expression:
    /// - '__' escapes to '__underscores__'
    /// - '.' escapes to '__dot__'
    /// - '-' escapes to '__dash__'
    /// - '/' escapes to '__slash__'
    /// - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
    /// 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
    /// 	  "import", "let", "loop", "package", "namespace", "return".
    /// Examples:
    ///   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
    ///   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
    ///   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}
    /// 
    /// Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
    /// Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
    ///   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
    ///     non-intersecting elements in `Y` are appended, retaining their partial order.
    ///   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
    ///     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
    ///     non-intersecting keys are appended, retaining their partial order.
    /// Required.
    pub expression: String,
    /// Message represents the message displayed when validation fails. The message is required if the Expression contains
    /// line breaks. The message must not contain line breaks.
    /// If unset, the message is "failed rule: {Rule}".
    /// e.g. "must be a URL with the host matching spec.host"
    /// If the Expression contains line breaks. Message is required.
    /// The message must not contain line breaks.
    /// If unset, the message is "failed Expression: {Expression}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
    /// Since messageExpression is used as a failure message, it must evaluate to a string.
    /// If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
    /// If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
    /// as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
    /// that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
    /// the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
    /// messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
    /// Example:
    /// "object.x must be less than max ("+string(params.max)+")"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageExpression")]
    pub message_expression: Option<String>,
    /// Reason represents a machine-readable description of why this validation failed.
    /// If this is the first validation in the list to fail, this reason, as well as the
    /// corresponding HTTP response code, are used in the
    /// HTTP response to the client.
    /// The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
    /// If not set, StatusReasonInvalid is used in the response to the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecVariables {
    /// Expression is the expression that will be evaluated as the value of the variable.
    /// The CEL expression has access to the same identifiers as the CEL expressions in Validation.
    pub expression: String,
    /// Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
    /// The variable can be accessed in other expressions through `variables`
    /// For example, if name is "foo", the variable will be available as `variables.foo`
    pub name: String,
}

/// WebhookConfiguration defines the configuration for the webhook.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsSpecWebhookConfiguration {
    /// TimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
    /// After the configured time expires, the admission request may fail, or may simply ignore the policy results,
    /// based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusAutogenConfigsTargets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    pub kind: String,
    pub resource: String,
    pub version: String,
}

/// ConditionStatus is the shared status across all policy types
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ImageValidatingPolicyStatusConditionStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// Message is a human readable message indicating details about the generation of ValidatingAdmissionPolicy/MutatingAdmissionPolicy
    /// It is an empty string when ValidatingAdmissionPolicy/MutatingAdmissionPolicy is successfully generated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// The ready of a policy is a high-level summary of where the policy is in its lifecycle.
    /// The conditions array, the reason and message fields contain more detail about the policy's status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ready: Option<bool>,
}

