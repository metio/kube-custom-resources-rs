// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/kyverno/kyverno/policies.kyverno.io/v1alpha1/validatingpolicies.yaml
// kopium version: 0.22.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ValidatingPolicySpec is the specification of the desired behavior of the ValidatingPolicy.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "policies.kyverno.io", version = "v1alpha1", kind = "ValidatingPolicy", plural = "validatingpolicies")]
#[kube(status = "ValidatingPolicyStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ValidatingPolicySpec {
    /// auditAnnotations contains CEL expressions which are used to produce audit
    /// annotations for the audit event of the API request.
    /// validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
    /// required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditAnnotations")]
    pub audit_annotations: Option<Vec<ValidatingPolicyAuditAnnotations>>,
    /// AutogenConfiguration defines the configuration for the generation controller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autogen: Option<ValidatingPolicyAutogen>,
    /// EvaluationConfiguration defines the configuration for the policy evaluation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub evaluation: Option<ValidatingPolicyEvaluation>,
    /// failurePolicy defines how to handle failures for the admission policy. Failures can
    /// occur from CEL expression parse errors, type check errors, runtime errors and invalid
    /// or mis-configured policy definitions or bindings.
    /// 
    /// failurePolicy does not define how validations that evaluate to false are handled.
    /// 
    /// When failurePolicy is set to Fail, the validationActions field define how failures are enforced.
    /// 
    /// Allowed values are Ignore or Fail. Defaults to Fail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failurePolicy")]
    pub failure_policy: Option<ValidatingPolicyFailurePolicy>,
    /// MatchConditions is a list of conditions that must be met for a request to be validated.
    /// Match conditions filter requests that have already been matched by the rules,
    /// namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
    /// There are a maximum of 64 match conditions allowed.
    /// 
    /// If a parameter object is provided, it can be accessed via the `params` handle in the same
    /// manner as validation expressions.
    /// 
    /// The exact matching logic is (in order):
    ///   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
    ///   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
    ///   3. If any matchCondition evaluates to an error (but none are FALSE):
    ///      - If failurePolicy=Fail, reject the request
    ///      - If failurePolicy=Ignore, the policy is skipped
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchConditions")]
    pub match_conditions: Option<Vec<ValidatingPolicyMatchConditions>>,
    /// MatchConstraints specifies what resources this policy is designed to validate.
    /// The AdmissionPolicy cares about a request if it matches _all_ Constraints.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchConstraints")]
    pub match_constraints: Option<ValidatingPolicyMatchConstraints>,
    /// ValidationAction specifies the action to be taken when the matched resource violates the policy.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validationActions")]
    pub validation_actions: Option<Vec<String>>,
    /// Validations contain CEL expressions which is used to apply the validation.
    /// Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
    /// required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validations: Option<Vec<ValidatingPolicyValidations>>,
    /// Variables contain definitions of variables that can be used in composition of other expressions.
    /// Each variable is defined as a named CEL expression.
    /// The variables defined here will be available under `variables` in other expressions of the policy
    /// except MatchConditions because MatchConditions are evaluated before the rest of the policy.
    /// 
    /// The expression of a variable can refer to other variables defined earlier in the list but not those after.
    /// Thus, Variables must be sorted by the order of first appearance and acyclic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<ValidatingPolicyVariables>>,
    /// WebhookConfiguration defines the configuration for the webhook.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookConfiguration")]
    pub webhook_configuration: Option<ValidatingPolicyWebhookConfiguration>,
}

/// AuditAnnotation describes how to produce an audit annotation for an API request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyAuditAnnotations {
    /// key specifies the audit annotation key. The audit annotation keys of
    /// a ValidatingAdmissionPolicy must be unique. The key must be a qualified
    /// name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
    /// 
    /// The key is combined with the resource name of the
    /// ValidatingAdmissionPolicy to construct an audit annotation key:
    /// "{ValidatingAdmissionPolicy name}/{key}".
    /// 
    /// If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
    /// and the same audit annotation key, the annotation key will be identical.
    /// In this case, the first annotation written with the key will be included
    /// in the audit event and all subsequent annotations with the same key
    /// will be discarded.
    /// 
    /// Required.
    pub key: String,
    /// valueExpression represents the expression which is evaluated by CEL to
    /// produce an audit annotation value. The expression must evaluate to either
    /// a string or null value. If the expression evaluates to a string, the
    /// audit annotation is included with the string value. If the expression
    /// evaluates to null or empty string the audit annotation will be omitted.
    /// The valueExpression may be no longer than 5kb in length.
    /// If the result of the valueExpression is more than 10kb in length, it
    /// will be truncated to 10kb.
    /// 
    /// If multiple ValidatingAdmissionPolicyBinding resources match an
    /// API request, then the valueExpression will be evaluated for
    /// each binding. All unique values produced by the valueExpressions
    /// will be joined together in a comma-separated list.
    /// 
    /// Required.
    #[serde(rename = "valueExpression")]
    pub value_expression: String,
}

/// AutogenConfiguration defines the configuration for the generation controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyAutogen {
    /// PodControllers specifies whether to generate a pod controllers rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podControllers")]
    pub pod_controllers: Option<ValidatingPolicyAutogenPodControllers>,
    /// ValidatingAdmissionPolicy specifies whether to generate a Kubernetes ValidatingAdmissionPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validatingAdmissionPolicy")]
    pub validating_admission_policy: Option<ValidatingPolicyAutogenValidatingAdmissionPolicy>,
}

/// PodControllers specifies whether to generate a pod controllers rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyAutogenPodControllers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub controllers: Option<Vec<String>>,
}

/// ValidatingAdmissionPolicy specifies whether to generate a Kubernetes ValidatingAdmissionPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyAutogenValidatingAdmissionPolicy {
    /// Enabled specifies whether to generate a Kubernetes ValidatingAdmissionPolicy.
    /// Optional. Defaults to "false" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// EvaluationConfiguration defines the configuration for the policy evaluation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyEvaluation {
    /// Admission controls policy evaluation during admission.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admission: Option<ValidatingPolicyEvaluationAdmission>,
    /// Background  controls policy evaluation during background scan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub background: Option<ValidatingPolicyEvaluationBackground>,
    /// Mode is the mode of policy evaluation.
    /// Allowed values are "Kubernetes" or "JSON".
    /// Optional. Default value is "Kubernetes".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Admission controls policy evaluation during admission.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyEvaluationAdmission {
    /// Enabled controls if rules are applied during admission.
    /// Optional. Default value is "true".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Background  controls policy evaluation during background scan.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyEvaluationBackground {
    /// Enabled controls if rules are applied to existing resources during a background scan.
    /// Optional. Default value is "true". The value must be set to "false" if the policy rule
    /// uses variables that are only available in the admission review request (e.g. user name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// ValidatingPolicySpec is the specification of the desired behavior of the ValidatingPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ValidatingPolicyFailurePolicy {
    Ignore,
    Fail,
}

/// MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyMatchConditions {
    /// Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
    /// CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
    /// 
    /// 'object' - The object from the incoming request. The value is null for DELETE requests.
    /// 'oldObject' - The existing object. The value is null for CREATE requests.
    /// 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
    /// 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
    ///   See <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz>
    /// 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
    ///   request resource.
    /// Documentation on CEL: <https://kubernetes.io/docs/reference/using-api/cel/>
    /// 
    /// Required.
    pub expression: String,
    /// Name is an identifier for this match condition, used for strategic merging of MatchConditions,
    /// as well as providing an identifier for logging purposes. A good name should be descriptive of
    /// the associated expression.
    /// Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
    /// must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
    /// '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
    /// optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
    /// 
    /// Required.
    pub name: String,
}

/// MatchConstraints specifies what resources this policy is designed to validate.
/// The AdmissionPolicy cares about a request if it matches _all_ Constraints.
/// Required.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyMatchConstraints {
    /// ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
    /// The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeResourceRules")]
    pub exclude_resource_rules: Option<Vec<ValidatingPolicyMatchConstraintsExcludeResourceRules>>,
    /// matchPolicy defines how the "MatchResources" list is used to match incoming requests.
    /// Allowed values are "Exact" or "Equivalent".
    /// 
    /// - Exact: match a request only if it exactly matches a specified rule.
    /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    /// but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    /// a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
    /// 
    /// - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
    /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    /// and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    /// a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
    /// 
    /// Defaults to "Equivalent"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPolicy")]
    pub match_policy: Option<String>,
    /// NamespaceSelector decides whether to run the admission control policy on an object based
    /// on whether the namespace for that object matches the selector. If the
    /// object itself is a namespace, the matching is performed on
    /// object.metadata.labels. If the object is another cluster scoped resource,
    /// it never skips the policy.
    /// 
    /// For example, to run the webhook on any objects whose namespace is not
    /// associated with "runlevel" of "0" or "1";  you will set the selector as
    /// follows:
    /// "namespaceSelector": {
    ///   "matchExpressions": [
    ///     {
    ///       "key": "runlevel",
    ///       "operator": "NotIn",
    ///       "values": [
    ///         "0",
    ///         "1"
    ///       ]
    ///     }
    ///   ]
    /// }
    /// 
    /// If instead you want to only run the policy on any objects whose
    /// namespace is associated with the "environment" of "prod" or "staging";
    /// you will set the selector as follows:
    /// "namespaceSelector": {
    ///   "matchExpressions": [
    ///     {
    ///       "key": "environment",
    ///       "operator": "In",
    ///       "values": [
    ///         "prod",
    ///         "staging"
    ///       ]
    ///     }
    ///   ]
    /// }
    /// 
    /// See
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
    /// for more examples of label selectors.
    /// 
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ValidatingPolicyMatchConstraintsNamespaceSelector>,
    /// ObjectSelector decides whether to run the validation based on if the
    /// object has matching labels. objectSelector is evaluated against both
    /// the oldObject and newObject that would be sent to the cel validation, and
    /// is considered to match if either object matches the selector. A null
    /// object (oldObject in the case of create, or newObject in the case of
    /// delete) or an object that cannot have labels (like a
    /// DeploymentRollback or a PodProxyOptions object) is not considered to
    /// match.
    /// Use the object selector only if the webhook is opt-in, because end
    /// users may skip the admission webhook by setting the labels.
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectSelector")]
    pub object_selector: Option<ValidatingPolicyMatchConstraintsObjectSelector>,
    /// ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
    /// The policy cares about an operation if it matches _any_ Rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceRules")]
    pub resource_rules: Option<Vec<ValidatingPolicyMatchConstraintsResourceRules>>,
}

/// NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyMatchConstraintsExcludeResourceRules {
    /// APIGroups is the API groups the resources belong to. '*' is all groups.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroups")]
    pub api_groups: Option<Vec<String>>,
    /// APIVersions is the API versions the resources belong to. '*' is all versions.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersions")]
    pub api_versions: Option<Vec<String>>,
    /// Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
    /// for all of those operations and any future admission operations that are added.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceNames")]
    pub resource_names: Option<Vec<String>>,
    /// Resources is a list of resources this rule applies to.
    /// 
    /// For example:
    /// 'pods' means pods.
    /// 'pods/log' means the log subresource of pods.
    /// '*' means all resources, but not subresources.
    /// 'pods/*' means all subresources of pods.
    /// '*/scale' means all scale subresources.
    /// '*/*' means all resources and their subresources.
    /// 
    /// If wildcard is present, the validation rule will ensure resources do not
    /// overlap with each other.
    /// 
    /// Depending on the enclosing object, subresources might not be allowed.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// scope specifies the scope of this rule.
    /// Valid values are "Cluster", "Namespaced", and "*"
    /// "Cluster" means that only cluster-scoped resources will match this rule.
    /// Namespace API objects are cluster-scoped.
    /// "Namespaced" means that only namespaced resources will match this rule.
    /// "*" means that there are no scope restrictions.
    /// Subresources match the scope of their parent resource.
    /// Default is "*".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// NamespaceSelector decides whether to run the admission control policy on an object based
/// on whether the namespace for that object matches the selector. If the
/// object itself is a namespace, the matching is performed on
/// object.metadata.labels. If the object is another cluster scoped resource,
/// it never skips the policy.
/// 
/// For example, to run the webhook on any objects whose namespace is not
/// associated with "runlevel" of "0" or "1";  you will set the selector as
/// follows:
/// "namespaceSelector": {
///   "matchExpressions": [
///     {
///       "key": "runlevel",
///       "operator": "NotIn",
///       "values": [
///         "0",
///         "1"
///       ]
///     }
///   ]
/// }
/// 
/// If instead you want to only run the policy on any objects whose
/// namespace is associated with the "environment" of "prod" or "staging";
/// you will set the selector as follows:
/// "namespaceSelector": {
///   "matchExpressions": [
///     {
///       "key": "environment",
///       "operator": "In",
///       "values": [
///         "prod",
///         "staging"
///       ]
///     }
///   ]
/// }
/// 
/// See
/// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
/// for more examples of label selectors.
/// 
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyMatchConstraintsNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ValidatingPolicyMatchConstraintsNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyMatchConstraintsNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ObjectSelector decides whether to run the validation based on if the
/// object has matching labels. objectSelector is evaluated against both
/// the oldObject and newObject that would be sent to the cel validation, and
/// is considered to match if either object matches the selector. A null
/// object (oldObject in the case of create, or newObject in the case of
/// delete) or an object that cannot have labels (like a
/// DeploymentRollback or a PodProxyOptions object) is not considered to
/// match.
/// Use the object selector only if the webhook is opt-in, because end
/// users may skip the admission webhook by setting the labels.
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyMatchConstraintsObjectSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ValidatingPolicyMatchConstraintsObjectSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyMatchConstraintsObjectSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyMatchConstraintsResourceRules {
    /// APIGroups is the API groups the resources belong to. '*' is all groups.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroups")]
    pub api_groups: Option<Vec<String>>,
    /// APIVersions is the API versions the resources belong to. '*' is all versions.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersions")]
    pub api_versions: Option<Vec<String>>,
    /// Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
    /// for all of those operations and any future admission operations that are added.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceNames")]
    pub resource_names: Option<Vec<String>>,
    /// Resources is a list of resources this rule applies to.
    /// 
    /// For example:
    /// 'pods' means pods.
    /// 'pods/log' means the log subresource of pods.
    /// '*' means all resources, but not subresources.
    /// 'pods/*' means all subresources of pods.
    /// '*/scale' means all scale subresources.
    /// '*/*' means all resources and their subresources.
    /// 
    /// If wildcard is present, the validation rule will ensure resources do not
    /// overlap with each other.
    /// 
    /// Depending on the enclosing object, subresources might not be allowed.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// scope specifies the scope of this rule.
    /// Valid values are "Cluster", "Namespaced", and "*"
    /// "Cluster" means that only cluster-scoped resources will match this rule.
    /// Namespace API objects are cluster-scoped.
    /// "Namespaced" means that only namespaced resources will match this rule.
    /// "*" means that there are no scope restrictions.
    /// Subresources match the scope of their parent resource.
    /// Default is "*".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// Validation specifies the CEL expression which is used to apply the validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyValidations {
    /// Expression represents the expression which will be evaluated by CEL.
    /// ref: <https://github.com/google/cel-spec>
    /// CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
    /// 
    /// - 'object' - The object from the incoming request. The value is null for DELETE requests.
    /// - 'oldObject' - The existing object. The value is null for CREATE requests.
    /// - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
    /// - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
    /// - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
    /// - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
    ///   For example, a variable named 'foo' can be accessed as 'variables.foo'.
    /// - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
    ///   See <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz>
    /// - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
    ///   request resource.
    /// 
    /// The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
    /// object. No other metadata properties are accessible.
    /// 
    /// Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
    /// Accessible property names are escaped according to the following rules when accessed in the expression:
    /// - '__' escapes to '__underscores__'
    /// - '.' escapes to '__dot__'
    /// - '-' escapes to '__dash__'
    /// - '/' escapes to '__slash__'
    /// - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
    /// 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
    /// 	  "import", "let", "loop", "package", "namespace", "return".
    /// Examples:
    ///   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
    ///   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
    ///   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}
    /// 
    /// Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
    /// Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
    ///   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
    ///     non-intersecting elements in `Y` are appended, retaining their partial order.
    ///   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
    ///     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
    ///     non-intersecting keys are appended, retaining their partial order.
    /// Required.
    pub expression: String,
    /// Message represents the message displayed when validation fails. The message is required if the Expression contains
    /// line breaks. The message must not contain line breaks.
    /// If unset, the message is "failed rule: {Rule}".
    /// e.g. "must be a URL with the host matching spec.host"
    /// If the Expression contains line breaks. Message is required.
    /// The message must not contain line breaks.
    /// If unset, the message is "failed Expression: {Expression}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
    /// Since messageExpression is used as a failure message, it must evaluate to a string.
    /// If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
    /// If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
    /// as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
    /// that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
    /// the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
    /// messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
    /// Example:
    /// "object.x must be less than max ("+string(params.max)+")"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageExpression")]
    pub message_expression: Option<String>,
    /// Reason represents a machine-readable description of why this validation failed.
    /// If this is the first validation in the list to fail, this reason, as well as the
    /// corresponding HTTP response code, are used in the
    /// HTTP response to the client.
    /// The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
    /// If not set, StatusReasonInvalid is used in the response to the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyVariables {
    /// Expression is the expression that will be evaluated as the value of the variable.
    /// The CEL expression has access to the same identifiers as the CEL expressions in Validation.
    pub expression: String,
    /// Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
    /// The variable can be accessed in other expressions through `variables`
    /// For example, if name is "foo", the variable will be available as `variables.foo`
    pub name: String,
}

/// WebhookConfiguration defines the configuration for the webhook.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyWebhookConfiguration {
    /// TimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
    /// After the configured time expires, the admission request may fail, or may simply ignore the policy results,
    /// based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Status contains policy runtime data.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autogen: Option<ValidatingPolicyStatusAutogen>,
    /// ConditionStatus is the shared status across all policy types
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "conditionStatus")]
    pub condition_status: Option<ValidatingPolicyStatusConditionStatus>,
    /// Generated indicates whether a ValidatingAdmissionPolicy/MutatingAdmissionPolicy is generated from the policy or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generated: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogen {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configs: Option<BTreeMap<String, ValidatingPolicyStatusAutogenConfigs>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigs {
    /// ValidatingPolicySpec is the specification of the desired behavior of the ValidatingPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ValidatingPolicyStatusAutogenConfigsSpec>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<ValidatingPolicyStatusAutogenConfigsTargets>>,
}

/// ValidatingPolicySpec is the specification of the desired behavior of the ValidatingPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpec {
    /// auditAnnotations contains CEL expressions which are used to produce audit
    /// annotations for the audit event of the API request.
    /// validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is
    /// required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "auditAnnotations")]
    pub audit_annotations: Option<Vec<ValidatingPolicyStatusAutogenConfigsSpecAuditAnnotations>>,
    /// AutogenConfiguration defines the configuration for the generation controller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autogen: Option<ValidatingPolicyStatusAutogenConfigsSpecAutogen>,
    /// EvaluationConfiguration defines the configuration for the policy evaluation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub evaluation: Option<ValidatingPolicyStatusAutogenConfigsSpecEvaluation>,
    /// failurePolicy defines how to handle failures for the admission policy. Failures can
    /// occur from CEL expression parse errors, type check errors, runtime errors and invalid
    /// or mis-configured policy definitions or bindings.
    /// 
    /// failurePolicy does not define how validations that evaluate to false are handled.
    /// 
    /// When failurePolicy is set to Fail, the validationActions field define how failures are enforced.
    /// 
    /// Allowed values are Ignore or Fail. Defaults to Fail.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failurePolicy")]
    pub failure_policy: Option<ValidatingPolicyStatusAutogenConfigsSpecFailurePolicy>,
    /// MatchConditions is a list of conditions that must be met for a request to be validated.
    /// Match conditions filter requests that have already been matched by the rules,
    /// namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
    /// There are a maximum of 64 match conditions allowed.
    /// 
    /// If a parameter object is provided, it can be accessed via the `params` handle in the same
    /// manner as validation expressions.
    /// 
    /// The exact matching logic is (in order):
    ///   1. If ANY matchCondition evaluates to FALSE, the policy is skipped.
    ///   2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.
    ///   3. If any matchCondition evaluates to an error (but none are FALSE):
    ///      - If failurePolicy=Fail, reject the request
    ///      - If failurePolicy=Ignore, the policy is skipped
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchConditions")]
    pub match_conditions: Option<Vec<ValidatingPolicyStatusAutogenConfigsSpecMatchConditions>>,
    /// MatchConstraints specifies what resources this policy is designed to validate.
    /// The AdmissionPolicy cares about a request if it matches _all_ Constraints.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchConstraints")]
    pub match_constraints: Option<ValidatingPolicyStatusAutogenConfigsSpecMatchConstraints>,
    /// ValidationAction specifies the action to be taken when the matched resource violates the policy.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validationActions")]
    pub validation_actions: Option<Vec<String>>,
    /// Validations contain CEL expressions which is used to apply the validation.
    /// Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is
    /// required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub validations: Option<Vec<ValidatingPolicyStatusAutogenConfigsSpecValidations>>,
    /// Variables contain definitions of variables that can be used in composition of other expressions.
    /// Each variable is defined as a named CEL expression.
    /// The variables defined here will be available under `variables` in other expressions of the policy
    /// except MatchConditions because MatchConditions are evaluated before the rest of the policy.
    /// 
    /// The expression of a variable can refer to other variables defined earlier in the list but not those after.
    /// Thus, Variables must be sorted by the order of first appearance and acyclic.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<ValidatingPolicyStatusAutogenConfigsSpecVariables>>,
    /// WebhookConfiguration defines the configuration for the webhook.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "webhookConfiguration")]
    pub webhook_configuration: Option<ValidatingPolicyStatusAutogenConfigsSpecWebhookConfiguration>,
}

/// AuditAnnotation describes how to produce an audit annotation for an API request.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecAuditAnnotations {
    /// key specifies the audit annotation key. The audit annotation keys of
    /// a ValidatingAdmissionPolicy must be unique. The key must be a qualified
    /// name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
    /// 
    /// The key is combined with the resource name of the
    /// ValidatingAdmissionPolicy to construct an audit annotation key:
    /// "{ValidatingAdmissionPolicy name}/{key}".
    /// 
    /// If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
    /// and the same audit annotation key, the annotation key will be identical.
    /// In this case, the first annotation written with the key will be included
    /// in the audit event and all subsequent annotations with the same key
    /// will be discarded.
    /// 
    /// Required.
    pub key: String,
    /// valueExpression represents the expression which is evaluated by CEL to
    /// produce an audit annotation value. The expression must evaluate to either
    /// a string or null value. If the expression evaluates to a string, the
    /// audit annotation is included with the string value. If the expression
    /// evaluates to null or empty string the audit annotation will be omitted.
    /// The valueExpression may be no longer than 5kb in length.
    /// If the result of the valueExpression is more than 10kb in length, it
    /// will be truncated to 10kb.
    /// 
    /// If multiple ValidatingAdmissionPolicyBinding resources match an
    /// API request, then the valueExpression will be evaluated for
    /// each binding. All unique values produced by the valueExpressions
    /// will be joined together in a comma-separated list.
    /// 
    /// Required.
    #[serde(rename = "valueExpression")]
    pub value_expression: String,
}

/// AutogenConfiguration defines the configuration for the generation controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecAutogen {
    /// PodControllers specifies whether to generate a pod controllers rules.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podControllers")]
    pub pod_controllers: Option<ValidatingPolicyStatusAutogenConfigsSpecAutogenPodControllers>,
    /// ValidatingAdmissionPolicy specifies whether to generate a Kubernetes ValidatingAdmissionPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validatingAdmissionPolicy")]
    pub validating_admission_policy: Option<ValidatingPolicyStatusAutogenConfigsSpecAutogenValidatingAdmissionPolicy>,
}

/// PodControllers specifies whether to generate a pod controllers rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecAutogenPodControllers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub controllers: Option<Vec<String>>,
}

/// ValidatingAdmissionPolicy specifies whether to generate a Kubernetes ValidatingAdmissionPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecAutogenValidatingAdmissionPolicy {
    /// Enabled specifies whether to generate a Kubernetes ValidatingAdmissionPolicy.
    /// Optional. Defaults to "false" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// EvaluationConfiguration defines the configuration for the policy evaluation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecEvaluation {
    /// Admission controls policy evaluation during admission.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub admission: Option<ValidatingPolicyStatusAutogenConfigsSpecEvaluationAdmission>,
    /// Background  controls policy evaluation during background scan.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub background: Option<ValidatingPolicyStatusAutogenConfigsSpecEvaluationBackground>,
    /// Mode is the mode of policy evaluation.
    /// Allowed values are "Kubernetes" or "JSON".
    /// Optional. Default value is "Kubernetes".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<String>,
}

/// Admission controls policy evaluation during admission.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecEvaluationAdmission {
    /// Enabled controls if rules are applied during admission.
    /// Optional. Default value is "true".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// Background  controls policy evaluation during background scan.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecEvaluationBackground {
    /// Enabled controls if rules are applied to existing resources during a background scan.
    /// Optional. Default value is "true". The value must be set to "false" if the policy rule
    /// uses variables that are only available in the admission review request (e.g. user name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// ValidatingPolicySpec is the specification of the desired behavior of the ValidatingPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ValidatingPolicyStatusAutogenConfigsSpecFailurePolicy {
    Ignore,
    Fail,
}

/// MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecMatchConditions {
    /// Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
    /// CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
    /// 
    /// 'object' - The object from the incoming request. The value is null for DELETE requests.
    /// 'oldObject' - The existing object. The value is null for CREATE requests.
    /// 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
    /// 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
    ///   See <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz>
    /// 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
    ///   request resource.
    /// Documentation on CEL: <https://kubernetes.io/docs/reference/using-api/cel/>
    /// 
    /// Required.
    pub expression: String,
    /// Name is an identifier for this match condition, used for strategic merging of MatchConditions,
    /// as well as providing an identifier for logging purposes. A good name should be descriptive of
    /// the associated expression.
    /// Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
    /// must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
    /// '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
    /// optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
    /// 
    /// Required.
    pub name: String,
}

/// MatchConstraints specifies what resources this policy is designed to validate.
/// The AdmissionPolicy cares about a request if it matches _all_ Constraints.
/// Required.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecMatchConstraints {
    /// ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about.
    /// The exclude rules take precedence over include rules (if a resource matches both, it is excluded)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "excludeResourceRules")]
    pub exclude_resource_rules: Option<Vec<ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsExcludeResourceRules>>,
    /// matchPolicy defines how the "MatchResources" list is used to match incoming requests.
    /// Allowed values are "Exact" or "Equivalent".
    /// 
    /// - Exact: match a request only if it exactly matches a specified rule.
    /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    /// but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    /// a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.
    /// 
    /// - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
    /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    /// and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    /// a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.
    /// 
    /// Defaults to "Equivalent"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPolicy")]
    pub match_policy: Option<String>,
    /// NamespaceSelector decides whether to run the admission control policy on an object based
    /// on whether the namespace for that object matches the selector. If the
    /// object itself is a namespace, the matching is performed on
    /// object.metadata.labels. If the object is another cluster scoped resource,
    /// it never skips the policy.
    /// 
    /// For example, to run the webhook on any objects whose namespace is not
    /// associated with "runlevel" of "0" or "1";  you will set the selector as
    /// follows:
    /// "namespaceSelector": {
    ///   "matchExpressions": [
    ///     {
    ///       "key": "runlevel",
    ///       "operator": "NotIn",
    ///       "values": [
    ///         "0",
    ///         "1"
    ///       ]
    ///     }
    ///   ]
    /// }
    /// 
    /// If instead you want to only run the policy on any objects whose
    /// namespace is associated with the "environment" of "prod" or "staging";
    /// you will set the selector as follows:
    /// "namespaceSelector": {
    ///   "matchExpressions": [
    ///     {
    ///       "key": "environment",
    ///       "operator": "In",
    ///       "values": [
    ///         "prod",
    ///         "staging"
    ///       ]
    ///     }
    ///   ]
    /// }
    /// 
    /// See
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
    /// for more examples of label selectors.
    /// 
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsNamespaceSelector>,
    /// ObjectSelector decides whether to run the validation based on if the
    /// object has matching labels. objectSelector is evaluated against both
    /// the oldObject and newObject that would be sent to the cel validation, and
    /// is considered to match if either object matches the selector. A null
    /// object (oldObject in the case of create, or newObject in the case of
    /// delete) or an object that cannot have labels (like a
    /// DeploymentRollback or a PodProxyOptions object) is not considered to
    /// match.
    /// Use the object selector only if the webhook is opt-in, because end
    /// users may skip the admission webhook by setting the labels.
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "objectSelector")]
    pub object_selector: Option<ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsObjectSelector>,
    /// ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches.
    /// The policy cares about an operation if it matches _any_ Rule.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceRules")]
    pub resource_rules: Option<Vec<ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsResourceRules>>,
}

/// NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsExcludeResourceRules {
    /// APIGroups is the API groups the resources belong to. '*' is all groups.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroups")]
    pub api_groups: Option<Vec<String>>,
    /// APIVersions is the API versions the resources belong to. '*' is all versions.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersions")]
    pub api_versions: Option<Vec<String>>,
    /// Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
    /// for all of those operations and any future admission operations that are added.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceNames")]
    pub resource_names: Option<Vec<String>>,
    /// Resources is a list of resources this rule applies to.
    /// 
    /// For example:
    /// 'pods' means pods.
    /// 'pods/log' means the log subresource of pods.
    /// '*' means all resources, but not subresources.
    /// 'pods/*' means all subresources of pods.
    /// '*/scale' means all scale subresources.
    /// '*/*' means all resources and their subresources.
    /// 
    /// If wildcard is present, the validation rule will ensure resources do not
    /// overlap with each other.
    /// 
    /// Depending on the enclosing object, subresources might not be allowed.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// scope specifies the scope of this rule.
    /// Valid values are "Cluster", "Namespaced", and "*"
    /// "Cluster" means that only cluster-scoped resources will match this rule.
    /// Namespace API objects are cluster-scoped.
    /// "Namespaced" means that only namespaced resources will match this rule.
    /// "*" means that there are no scope restrictions.
    /// Subresources match the scope of their parent resource.
    /// Default is "*".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// NamespaceSelector decides whether to run the admission control policy on an object based
/// on whether the namespace for that object matches the selector. If the
/// object itself is a namespace, the matching is performed on
/// object.metadata.labels. If the object is another cluster scoped resource,
/// it never skips the policy.
/// 
/// For example, to run the webhook on any objects whose namespace is not
/// associated with "runlevel" of "0" or "1";  you will set the selector as
/// follows:
/// "namespaceSelector": {
///   "matchExpressions": [
///     {
///       "key": "runlevel",
///       "operator": "NotIn",
///       "values": [
///         "0",
///         "1"
///       ]
///     }
///   ]
/// }
/// 
/// If instead you want to only run the policy on any objects whose
/// namespace is associated with the "environment" of "prod" or "staging";
/// you will set the selector as follows:
/// "namespaceSelector": {
///   "matchExpressions": [
///     {
///       "key": "environment",
///       "operator": "In",
///       "values": [
///         "prod",
///         "staging"
///       ]
///     }
///   ]
/// }
/// 
/// See
/// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
/// for more examples of label selectors.
/// 
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ObjectSelector decides whether to run the validation based on if the
/// object has matching labels. objectSelector is evaluated against both
/// the oldObject and newObject that would be sent to the cel validation, and
/// is considered to match if either object matches the selector. A null
/// object (oldObject in the case of create, or newObject in the case of
/// delete) or an object that cannot have labels (like a
/// DeploymentRollback or a PodProxyOptions object) is not considered to
/// match.
/// Use the object selector only if the webhook is opt-in, because end
/// users may skip the admission webhook by setting the labels.
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsObjectSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsObjectSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsObjectSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecMatchConstraintsResourceRules {
    /// APIGroups is the API groups the resources belong to. '*' is all groups.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroups")]
    pub api_groups: Option<Vec<String>>,
    /// APIVersions is the API versions the resources belong to. '*' is all versions.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersions")]
    pub api_versions: Option<Vec<String>>,
    /// Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
    /// for all of those operations and any future admission operations that are added.
    /// If '*' is present, the length of the slice must be one.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operations: Option<Vec<String>>,
    /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceNames")]
    pub resource_names: Option<Vec<String>>,
    /// Resources is a list of resources this rule applies to.
    /// 
    /// For example:
    /// 'pods' means pods.
    /// 'pods/log' means the log subresource of pods.
    /// '*' means all resources, but not subresources.
    /// 'pods/*' means all subresources of pods.
    /// '*/scale' means all scale subresources.
    /// '*/*' means all resources and their subresources.
    /// 
    /// If wildcard is present, the validation rule will ensure resources do not
    /// overlap with each other.
    /// 
    /// Depending on the enclosing object, subresources might not be allowed.
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// scope specifies the scope of this rule.
    /// Valid values are "Cluster", "Namespaced", and "*"
    /// "Cluster" means that only cluster-scoped resources will match this rule.
    /// Namespace API objects are cluster-scoped.
    /// "Namespaced" means that only namespaced resources will match this rule.
    /// "*" means that there are no scope restrictions.
    /// Subresources match the scope of their parent resource.
    /// Default is "*".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}

/// Validation specifies the CEL expression which is used to apply the validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecValidations {
    /// Expression represents the expression which will be evaluated by CEL.
    /// ref: <https://github.com/google/cel-spec>
    /// CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
    /// 
    /// - 'object' - The object from the incoming request. The value is null for DELETE requests.
    /// - 'oldObject' - The existing object. The value is null for CREATE requests.
    /// - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
    /// - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
    /// - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
    /// - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
    ///   For example, a variable named 'foo' can be accessed as 'variables.foo'.
    /// - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
    ///   See <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz>
    /// - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
    ///   request resource.
    /// 
    /// The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
    /// object. No other metadata properties are accessible.
    /// 
    /// Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
    /// Accessible property names are escaped according to the following rules when accessed in the expression:
    /// - '__' escapes to '__underscores__'
    /// - '.' escapes to '__dot__'
    /// - '-' escapes to '__dash__'
    /// - '/' escapes to '__slash__'
    /// - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
    /// 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
    /// 	  "import", "let", "loop", "package", "namespace", "return".
    /// Examples:
    ///   - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
    ///   - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
    ///   - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}
    /// 
    /// Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
    /// Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
    ///   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
    ///     non-intersecting elements in `Y` are appended, retaining their partial order.
    ///   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
    ///     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
    ///     non-intersecting keys are appended, retaining their partial order.
    /// Required.
    pub expression: String,
    /// Message represents the message displayed when validation fails. The message is required if the Expression contains
    /// line breaks. The message must not contain line breaks.
    /// If unset, the message is "failed rule: {Rule}".
    /// e.g. "must be a URL with the host matching spec.host"
    /// If the Expression contains line breaks. Message is required.
    /// The message must not contain line breaks.
    /// If unset, the message is "failed Expression: {Expression}".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
    /// Since messageExpression is used as a failure message, it must evaluate to a string.
    /// If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
    /// If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
    /// as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
    /// that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
    /// the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
    /// messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
    /// Example:
    /// "object.x must be less than max ("+string(params.max)+")"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageExpression")]
    pub message_expression: Option<String>,
    /// Reason represents a machine-readable description of why this validation failed.
    /// If this is the first validation in the list to fail, this reason, as well as the
    /// corresponding HTTP response code, are used in the
    /// HTTP response to the client.
    /// The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
    /// If not set, StatusReasonInvalid is used in the response to the client.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

/// Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecVariables {
    /// Expression is the expression that will be evaluated as the value of the variable.
    /// The CEL expression has access to the same identifiers as the CEL expressions in Validation.
    pub expression: String,
    /// Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
    /// The variable can be accessed in other expressions through `variables`
    /// For example, if name is "foo", the variable will be available as `variables.foo`
    pub name: String,
}

/// WebhookConfiguration defines the configuration for the webhook.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsSpecWebhookConfiguration {
    /// TimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
    /// After the configured time expires, the admission request may fail, or may simply ignore the policy results,
    /// based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusAutogenConfigsTargets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    pub kind: String,
    pub resource: String,
    pub version: String,
}

/// ConditionStatus is the shared status across all policy types
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ValidatingPolicyStatusConditionStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// Message is a human readable message indicating details about the generation of ValidatingAdmissionPolicy/MutatingAdmissionPolicy
    /// It is an empty string when ValidatingAdmissionPolicy/MutatingAdmissionPolicy is successfully generated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// The ready of a policy is a high-level summary of where the policy is in its lifecycle.
    /// The conditions array, the reason and message fields contain more detail about the policy's status.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ready: Option<bool>,
}

