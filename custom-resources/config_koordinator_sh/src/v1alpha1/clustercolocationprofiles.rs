// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/koordinator-sh/koordinator/config.koordinator.sh/v1alpha1/clustercolocationprofiles.yaml
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// ClusterColocationProfileSpec is a description of a ClusterColocationProfile.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "config.koordinator.sh", version = "v1alpha1", kind = "ClusterColocationProfile", plural = "clustercolocationprofiles")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClusterColocationProfileSpec {
    /// AnnotationKeysMapping describes the annotations that needs to inject into Pod.Annotations with the same values.
    /// It sets the Pod.Annotations[AnnotationKeysMapping[k]] = Pod.Annotations[k] for each key k.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "annotationKeysMapping")]
    pub annotation_keys_mapping: Option<BTreeMap<String, String>>,
    /// Annotations describes the k/v pair that needs to inject into Pod.Annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// KoordinatorPriority defines the Pod sub-priority in Koordinator.
    /// The priority value will be injected into Pod as label koordinator.sh/priority.
    /// Various Koordinator components determine the priority of the Pod
    /// in the Koordinator through KoordinatorPriority and the priority value in PriorityClassName.
    /// The higher the value, the higher the priority.
    /// TODO: remove this field, use Labels instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "koordinatorPriority")]
    pub koordinator_priority: Option<i32>,
    /// LabelKeysMapping describes the labels that needs to inject into Pod.Labels with the same values.
    /// It sets the Pod.Labels[LabelKeysMapping[k]] = Pod.Labels[k] for each key k.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelKeysMapping")]
    pub label_keys_mapping: Option<BTreeMap<String, String>>,
    /// LabelSuffixes describes the labels that needs to inject into Pod.Labels with the same values.
    /// It appends the suffix to the Pod.Labels[k] as Pod.Labels[k]+LabelSuffixes[k].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSuffixes")]
    pub label_suffixes: Option<BTreeMap<String, String>>,
    /// Labels describes the k/v pair that needs to inject into Pod.Labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// NamespaceSelector decides whether to mutate/validate Pods if the
    /// namespace matches the selector.
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ClusterColocationProfileNamespaceSelector>,
    /// Patch indicates patching podTemplate that will be injected to the Pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch: Option<serde_json::Value>,
    /// If specified, the priorityClassName and the priority value defined in PriorityClass
    /// will be injected into the Pod.
    /// The PriorityClassName, priority value in PriorityClassName and
    /// KoordinatorPriority will affect the scheduling, preemption and
    /// other behaviors of Koordinator system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// Probability indicates profile will make effect with a probability.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probability: Option<IntOrString>,
    /// QoSClass describes the type of Koordinator QoS that the Pod is running.
    /// The value will be injected into Pod as label koordinator.sh/qosClass.
    /// Options are LSE/LSR/LS/BE/SYSTEM.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "qosClass")]
    pub qos_class: Option<ClusterColocationProfileQosClass>,
    /// If specified, the pod will be dispatched by specified scheduler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    /// Selector decides whether to mutate/validate Pods if the
    /// Pod matches the selector.
    /// Default to the empty LabelSelector, which matches everything.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ClusterColocationProfileSelector>,
}

/// NamespaceSelector decides whether to mutate/validate Pods if the
/// namespace matches the selector.
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterColocationProfileNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterColocationProfileNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterColocationProfileNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ClusterColocationProfileSpec is a description of a ClusterColocationProfile.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterColocationProfileQosClass {
    #[serde(rename = "LSE")]
    Lse,
    #[serde(rename = "LSR")]
    Lsr,
    #[serde(rename = "LS")]
    Ls,
    #[serde(rename = "BE")]
    Be,
    #[serde(rename = "SYSTEM")]
    System,
}

/// Selector decides whether to mutate/validate Pods if the
/// Pod matches the selector.
/// Default to the empty LabelSelector, which matches everything.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterColocationProfileSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ClusterColocationProfileSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterColocationProfileSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ClusterColocationProfileStatus represents information about the status of a ClusterColocationProfile.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterColocationProfileStatus {
}

