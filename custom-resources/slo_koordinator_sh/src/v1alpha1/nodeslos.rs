// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/koordinator-sh/koordinator/slo.koordinator.sh/v1alpha1/nodeslos.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// NodeSLOSpec defines the desired state of NodeSLO
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "slo.koordinator.sh", version = "v1alpha1", kind = "NodeSLO", plural = "nodeslos")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct NodeSloSpec {
    /// CPU Burst Strategy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuBurstStrategy")]
    pub cpu_burst_strategy: Option<NodeSloCpuBurstStrategy>,
    /// Third party extensions for NodeSLO
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extensions: Option<BTreeMap<String, serde_json::Value>>,
    /// QoS management for out-of-band applications
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostApplications")]
    pub host_applications: Option<Vec<NodeSloHostApplications>>,
    /// QoS config strategy for pods of different qos-class
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceQOSStrategy")]
    pub resource_qos_strategy: Option<NodeSloResourceQosStrategy>,
    /// BE pods will be limited if node resource usage overload
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceUsedThresholdWithBE")]
    pub resource_used_threshold_with_be: Option<NodeSloResourceUsedThresholdWithBe>,
    /// node global system config
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "systemStrategy")]
    pub system_strategy: Option<NodeSloSystemStrategy>,
}

/// CPU Burst Strategy
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloCpuBurstStrategy {
    /// pod cfs quota scale up ceil percentage, default = 300 (300%)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cfsQuotaBurstPercent")]
    pub cfs_quota_burst_percent: Option<i64>,
    /// specifies a period of time for pod can use at burst, default = -1 (unlimited)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cfsQuotaBurstPeriodSeconds")]
    pub cfs_quota_burst_period_seconds: Option<i64>,
    /// cpu burst percentage for setting cpu.cfs_burst_us in Cgroupv1 or setting cpu.max.burst in Cgroupv2, legal range: [0, 10000], default as 1000 (1000%)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuBurstPercent")]
    pub cpu_burst_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<String>,
    /// scale down cfs quota if node cpu overload, default = 50
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sharePoolThresholdPercent")]
    pub share_pool_threshold_percent: Option<i64>,
}

/// HostApplicationSpec describes the QoS management for out-out-band applications on node
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloHostApplications {
    /// Optional, defines the host cgroup configuration, use default if not specified according to priority and qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupPath")]
    pub cgroup_path: Option<NodeSloHostApplicationsCgroupPath>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Priority class of the application
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<String>,
    /// QoS class of the application
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub qos: Option<String>,
    /// QoS Strategy of host application
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<NodeSloHostApplicationsStrategy>,
}

/// Optional, defines the host cgroup configuration, use default if not specified according to priority and qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloHostApplicationsCgroupPath {
    /// cgroup base dir, the format is various across cgroup drivers
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub base: Option<String>,
    /// cgroup parent path under base dir
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "parentDir")]
    pub parent_dir: Option<String>,
    /// cgroup relative path under parent dir
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "relativePath")]
    pub relative_path: Option<String>,
}

/// QoS Strategy of host application
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloHostApplicationsStrategy {
}

/// QoS config strategy for pods of different qos-class
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategy {
    /// ResourceQOS for BE pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "beClass")]
    pub be_class: Option<NodeSloResourceQosStrategyBeClass>,
    /// ResourceQOS for root cgroup.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cgroupRoot")]
    pub cgroup_root: Option<NodeSloResourceQosStrategyCgroupRoot>,
    /// ResourceQOS for LS pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lsClass")]
    pub ls_class: Option<NodeSloResourceQosStrategyLsClass>,
    /// ResourceQOS for LSR pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lsrClass")]
    pub lsr_class: Option<NodeSloResourceQosStrategyLsrClass>,
    /// Policies of pod QoS.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policies: Option<NodeSloResourceQosStrategyPolicies>,
    /// ResourceQOS for system pods
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "systemClass")]
    pub system_class: Option<NodeSloResourceQosStrategySystemClass>,
}

/// ResourceQOS for BE pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyBeClass {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blkioQOS")]
    pub blkio_qos: Option<NodeSloResourceQosStrategyBeClassBlkioQos>,
    /// CPUQOSCfg stores node-level config of cpu qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuQOS")]
    pub cpu_qos: Option<NodeSloResourceQosStrategyBeClassCpuQos>,
    /// MemoryQOSCfg stores node-level config of memory qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryQOS")]
    pub memory_qos: Option<NodeSloResourceQosStrategyBeClassMemoryQos>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkQOS")]
    pub network_qos: Option<NodeSloResourceQosStrategyBeClassNetworkQos>,
    /// ResctrlQOSCfg stores node-level config of resctrl qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resctrlQOS")]
    pub resctrl_qos: Option<NodeSloResourceQosStrategyBeClassResctrlQos>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyBeClassBlkioQos {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blocks: Option<Vec<NodeSloResourceQosStrategyBeClassBlkioQosBlocks>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyBeClassBlkioQosBlocks {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioCfg")]
    pub io_cfg: Option<NodeSloResourceQosStrategyBeClassBlkioQosBlocksIoCfg>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyBeClassBlkioQosBlocksIoCfg {
    /// configure the cost model of blkio-cost manually
    /// whether the user model is enabled. Default value: false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableUserModel")]
    pub enable_user_model: Option<bool>,
    /// This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioWeightPercent")]
    pub io_weight_percent: Option<i64>,
    /// the read BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadBPS")]
    pub model_read_bps: Option<i64>,
    /// the random read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadRandIOPS")]
    pub model_read_rand_iops: Option<i64>,
    /// the sequential read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadSeqIOPS")]
    pub model_read_seq_iops: Option<i64>,
    /// the write BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteBPS")]
    pub model_write_bps: Option<i64>,
    /// the random write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteRandIOPS")]
    pub model_write_rand_iops: Option<i64>,
    /// the sequential write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteSeqIOPS")]
    pub model_write_seq_iops: Option<i64>,
    /// Throttling of throughput
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readBPS")]
    pub read_bps: Option<i64>,
    /// Throttling of IOPS
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readIOPS")]
    pub read_iops: Option<i64>,
    /// Configure the weight-based throttling feature of blk-iocost
    /// Only used for RootClass
    /// After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk.
    /// the read latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatency")]
    pub read_latency: Option<i64>,
    /// the read latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatencyPercent")]
    pub read_latency_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeBPS")]
    pub write_bps: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeIOPS")]
    pub write_iops: Option<i64>,
    /// the write latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatency")]
    pub write_latency: Option<i64>,
    /// the write latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatencyPercent")]
    pub write_latency_percent: Option<i64>,
}

/// CPUQOSCfg stores node-level config of cpu qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyBeClassCpuQos {
    /// whether pods of the QoS class can expel the cgroup idle pods at the SMT-level. default = false
    /// If set to true, pods of this QoS will use a dedicated core sched group for noise clean with the SchedIdle pods.
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreExpeller")]
    pub core_expeller: Option<bool>,
    /// Enable indicates whether the cpu qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// group identity value for pods, default = 0
    /// NOTE: It takes effect if cpuPolicy = "groupIdentity".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIdentity")]
    pub group_identity: Option<i64>,
    /// cpu.idle value for pods, default = 0.
    /// `1` means using SCHED_IDLE.
    /// CGroup Idle (introduced since mainline Linux 5.15): <https://lore.kernel.org/lkml/162971078674.25758.15464079371945307825.tip-bot2@tip-bot2/#r>
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedIdle")]
    pub sched_idle: Option<i64>,
}

/// MemoryQOSCfg stores node-level config of memory qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyBeClassMemoryQos {
    /// Enable indicates whether the memory qos is enabled (default: false).
    /// This field is used for node-level control, while pod-level configuration is done with MemoryQOS and `Policy`
    /// instead of an `Enable` option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST
    /// protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected
    /// memcg can be reclaimed.
    /// NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory,
    /// pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowLimitPercent")]
    pub low_limit_percent: Option<i64>,
    /// memcg qos
    /// If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec.
    /// 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set)
    /// 4. `memory.high` := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize
    /// MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory
    /// from global reclamation when memory usage does not exceed the min limit.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLimitPercent")]
    pub min_limit_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oomKillGroup")]
    pub oom_kill_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// TODO: enhance the usages of oom priority and oom kill group
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityEnable")]
    pub priority_enable: Option<i64>,
    /// ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod
    /// memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds.
    /// Lower the factor brings more heavier reclaim pressure.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throttlingPercent")]
    pub throttling_percent: Option<i64>,
    /// wmark_min_adj (Anolis OS required)
    /// WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory
    /// reclamation. Lower the factor brings later reclamation.
    /// The adjustment uses different formula for different value range.
    /// [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj
    /// (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj
    /// Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkMinAdj")]
    pub wmark_min_adj: Option<i64>,
    /// wmark_ratio (Anolis OS required)
    /// Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation
    /// stops when usage is below `memory.wmark_low`. Basically,
    /// `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio
    /// `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor)
    /// WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async
    /// memory reclamation when memory usage exceeds.
    /// Close: 0. Recommended: 95.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkRatio")]
    pub wmark_ratio: Option<i64>,
    /// WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which
    /// stops async memory reclamation when memory usage belows.
    /// Close: 50. Recommended: 20.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkScalePermill")]
    pub wmark_scale_permill: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyBeClassNetworkQos {
    /// EgressLimit describes the maximum network bandwidth can be used in the egress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressLimit")]
    pub egress_limit: Option<IntOrString>,
    /// EgressRequest describes the minimum network bandwidth guaranteed in the egress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressRequest")]
    pub egress_request: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// IngressLimit describes the maximum network bandwidth can be used in the ingress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressLimit")]
    pub ingress_limit: Option<IntOrString>,
    /// IngressRequest describes the minimum network bandwidth guaranteed in the ingress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressRequest")]
    pub ingress_request: Option<IntOrString>,
}

/// ResctrlQOSCfg stores node-level config of resctrl qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyBeClassResctrlQos {
    /// LLC available range end for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeEndPercent")]
    pub cat_range_end_percent: Option<i64>,
    /// LLC available range start for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeStartPercent")]
    pub cat_range_start_percent: Option<i64>,
    /// Enable indicates whether the resctrl qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// MBA percent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mbaPercent")]
    pub mba_percent: Option<i64>,
}

/// ResourceQOS for root cgroup.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyCgroupRoot {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blkioQOS")]
    pub blkio_qos: Option<NodeSloResourceQosStrategyCgroupRootBlkioQos>,
    /// CPUQOSCfg stores node-level config of cpu qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuQOS")]
    pub cpu_qos: Option<NodeSloResourceQosStrategyCgroupRootCpuQos>,
    /// MemoryQOSCfg stores node-level config of memory qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryQOS")]
    pub memory_qos: Option<NodeSloResourceQosStrategyCgroupRootMemoryQos>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkQOS")]
    pub network_qos: Option<NodeSloResourceQosStrategyCgroupRootNetworkQos>,
    /// ResctrlQOSCfg stores node-level config of resctrl qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resctrlQOS")]
    pub resctrl_qos: Option<NodeSloResourceQosStrategyCgroupRootResctrlQos>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyCgroupRootBlkioQos {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blocks: Option<Vec<NodeSloResourceQosStrategyCgroupRootBlkioQosBlocks>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyCgroupRootBlkioQosBlocks {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioCfg")]
    pub io_cfg: Option<NodeSloResourceQosStrategyCgroupRootBlkioQosBlocksIoCfg>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyCgroupRootBlkioQosBlocksIoCfg {
    /// configure the cost model of blkio-cost manually
    /// whether the user model is enabled. Default value: false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableUserModel")]
    pub enable_user_model: Option<bool>,
    /// This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioWeightPercent")]
    pub io_weight_percent: Option<i64>,
    /// the read BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadBPS")]
    pub model_read_bps: Option<i64>,
    /// the random read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadRandIOPS")]
    pub model_read_rand_iops: Option<i64>,
    /// the sequential read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadSeqIOPS")]
    pub model_read_seq_iops: Option<i64>,
    /// the write BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteBPS")]
    pub model_write_bps: Option<i64>,
    /// the random write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteRandIOPS")]
    pub model_write_rand_iops: Option<i64>,
    /// the sequential write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteSeqIOPS")]
    pub model_write_seq_iops: Option<i64>,
    /// Throttling of throughput
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readBPS")]
    pub read_bps: Option<i64>,
    /// Throttling of IOPS
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readIOPS")]
    pub read_iops: Option<i64>,
    /// Configure the weight-based throttling feature of blk-iocost
    /// Only used for RootClass
    /// After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk.
    /// the read latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatency")]
    pub read_latency: Option<i64>,
    /// the read latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatencyPercent")]
    pub read_latency_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeBPS")]
    pub write_bps: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeIOPS")]
    pub write_iops: Option<i64>,
    /// the write latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatency")]
    pub write_latency: Option<i64>,
    /// the write latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatencyPercent")]
    pub write_latency_percent: Option<i64>,
}

/// CPUQOSCfg stores node-level config of cpu qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyCgroupRootCpuQos {
    /// whether pods of the QoS class can expel the cgroup idle pods at the SMT-level. default = false
    /// If set to true, pods of this QoS will use a dedicated core sched group for noise clean with the SchedIdle pods.
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreExpeller")]
    pub core_expeller: Option<bool>,
    /// Enable indicates whether the cpu qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// group identity value for pods, default = 0
    /// NOTE: It takes effect if cpuPolicy = "groupIdentity".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIdentity")]
    pub group_identity: Option<i64>,
    /// cpu.idle value for pods, default = 0.
    /// `1` means using SCHED_IDLE.
    /// CGroup Idle (introduced since mainline Linux 5.15): <https://lore.kernel.org/lkml/162971078674.25758.15464079371945307825.tip-bot2@tip-bot2/#r>
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedIdle")]
    pub sched_idle: Option<i64>,
}

/// MemoryQOSCfg stores node-level config of memory qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyCgroupRootMemoryQos {
    /// Enable indicates whether the memory qos is enabled (default: false).
    /// This field is used for node-level control, while pod-level configuration is done with MemoryQOS and `Policy`
    /// instead of an `Enable` option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST
    /// protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected
    /// memcg can be reclaimed.
    /// NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory,
    /// pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowLimitPercent")]
    pub low_limit_percent: Option<i64>,
    /// memcg qos
    /// If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec.
    /// 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set)
    /// 4. `memory.high` := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize
    /// MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory
    /// from global reclamation when memory usage does not exceed the min limit.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLimitPercent")]
    pub min_limit_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oomKillGroup")]
    pub oom_kill_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// TODO: enhance the usages of oom priority and oom kill group
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityEnable")]
    pub priority_enable: Option<i64>,
    /// ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod
    /// memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds.
    /// Lower the factor brings more heavier reclaim pressure.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throttlingPercent")]
    pub throttling_percent: Option<i64>,
    /// wmark_min_adj (Anolis OS required)
    /// WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory
    /// reclamation. Lower the factor brings later reclamation.
    /// The adjustment uses different formula for different value range.
    /// [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj
    /// (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj
    /// Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkMinAdj")]
    pub wmark_min_adj: Option<i64>,
    /// wmark_ratio (Anolis OS required)
    /// Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation
    /// stops when usage is below `memory.wmark_low`. Basically,
    /// `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio
    /// `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor)
    /// WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async
    /// memory reclamation when memory usage exceeds.
    /// Close: 0. Recommended: 95.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkRatio")]
    pub wmark_ratio: Option<i64>,
    /// WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which
    /// stops async memory reclamation when memory usage belows.
    /// Close: 50. Recommended: 20.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkScalePermill")]
    pub wmark_scale_permill: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyCgroupRootNetworkQos {
    /// EgressLimit describes the maximum network bandwidth can be used in the egress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressLimit")]
    pub egress_limit: Option<IntOrString>,
    /// EgressRequest describes the minimum network bandwidth guaranteed in the egress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressRequest")]
    pub egress_request: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// IngressLimit describes the maximum network bandwidth can be used in the ingress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressLimit")]
    pub ingress_limit: Option<IntOrString>,
    /// IngressRequest describes the minimum network bandwidth guaranteed in the ingress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressRequest")]
    pub ingress_request: Option<IntOrString>,
}

/// ResctrlQOSCfg stores node-level config of resctrl qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyCgroupRootResctrlQos {
    /// LLC available range end for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeEndPercent")]
    pub cat_range_end_percent: Option<i64>,
    /// LLC available range start for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeStartPercent")]
    pub cat_range_start_percent: Option<i64>,
    /// Enable indicates whether the resctrl qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// MBA percent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mbaPercent")]
    pub mba_percent: Option<i64>,
}

/// ResourceQOS for LS pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsClass {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blkioQOS")]
    pub blkio_qos: Option<NodeSloResourceQosStrategyLsClassBlkioQos>,
    /// CPUQOSCfg stores node-level config of cpu qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuQOS")]
    pub cpu_qos: Option<NodeSloResourceQosStrategyLsClassCpuQos>,
    /// MemoryQOSCfg stores node-level config of memory qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryQOS")]
    pub memory_qos: Option<NodeSloResourceQosStrategyLsClassMemoryQos>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkQOS")]
    pub network_qos: Option<NodeSloResourceQosStrategyLsClassNetworkQos>,
    /// ResctrlQOSCfg stores node-level config of resctrl qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resctrlQOS")]
    pub resctrl_qos: Option<NodeSloResourceQosStrategyLsClassResctrlQos>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsClassBlkioQos {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blocks: Option<Vec<NodeSloResourceQosStrategyLsClassBlkioQosBlocks>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsClassBlkioQosBlocks {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioCfg")]
    pub io_cfg: Option<NodeSloResourceQosStrategyLsClassBlkioQosBlocksIoCfg>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsClassBlkioQosBlocksIoCfg {
    /// configure the cost model of blkio-cost manually
    /// whether the user model is enabled. Default value: false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableUserModel")]
    pub enable_user_model: Option<bool>,
    /// This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioWeightPercent")]
    pub io_weight_percent: Option<i64>,
    /// the read BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadBPS")]
    pub model_read_bps: Option<i64>,
    /// the random read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadRandIOPS")]
    pub model_read_rand_iops: Option<i64>,
    /// the sequential read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadSeqIOPS")]
    pub model_read_seq_iops: Option<i64>,
    /// the write BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteBPS")]
    pub model_write_bps: Option<i64>,
    /// the random write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteRandIOPS")]
    pub model_write_rand_iops: Option<i64>,
    /// the sequential write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteSeqIOPS")]
    pub model_write_seq_iops: Option<i64>,
    /// Throttling of throughput
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readBPS")]
    pub read_bps: Option<i64>,
    /// Throttling of IOPS
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readIOPS")]
    pub read_iops: Option<i64>,
    /// Configure the weight-based throttling feature of blk-iocost
    /// Only used for RootClass
    /// After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk.
    /// the read latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatency")]
    pub read_latency: Option<i64>,
    /// the read latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatencyPercent")]
    pub read_latency_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeBPS")]
    pub write_bps: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeIOPS")]
    pub write_iops: Option<i64>,
    /// the write latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatency")]
    pub write_latency: Option<i64>,
    /// the write latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatencyPercent")]
    pub write_latency_percent: Option<i64>,
}

/// CPUQOSCfg stores node-level config of cpu qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsClassCpuQos {
    /// whether pods of the QoS class can expel the cgroup idle pods at the SMT-level. default = false
    /// If set to true, pods of this QoS will use a dedicated core sched group for noise clean with the SchedIdle pods.
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreExpeller")]
    pub core_expeller: Option<bool>,
    /// Enable indicates whether the cpu qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// group identity value for pods, default = 0
    /// NOTE: It takes effect if cpuPolicy = "groupIdentity".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIdentity")]
    pub group_identity: Option<i64>,
    /// cpu.idle value for pods, default = 0.
    /// `1` means using SCHED_IDLE.
    /// CGroup Idle (introduced since mainline Linux 5.15): <https://lore.kernel.org/lkml/162971078674.25758.15464079371945307825.tip-bot2@tip-bot2/#r>
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedIdle")]
    pub sched_idle: Option<i64>,
}

/// MemoryQOSCfg stores node-level config of memory qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsClassMemoryQos {
    /// Enable indicates whether the memory qos is enabled (default: false).
    /// This field is used for node-level control, while pod-level configuration is done with MemoryQOS and `Policy`
    /// instead of an `Enable` option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST
    /// protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected
    /// memcg can be reclaimed.
    /// NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory,
    /// pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowLimitPercent")]
    pub low_limit_percent: Option<i64>,
    /// memcg qos
    /// If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec.
    /// 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set)
    /// 4. `memory.high` := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize
    /// MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory
    /// from global reclamation when memory usage does not exceed the min limit.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLimitPercent")]
    pub min_limit_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oomKillGroup")]
    pub oom_kill_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// TODO: enhance the usages of oom priority and oom kill group
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityEnable")]
    pub priority_enable: Option<i64>,
    /// ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod
    /// memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds.
    /// Lower the factor brings more heavier reclaim pressure.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throttlingPercent")]
    pub throttling_percent: Option<i64>,
    /// wmark_min_adj (Anolis OS required)
    /// WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory
    /// reclamation. Lower the factor brings later reclamation.
    /// The adjustment uses different formula for different value range.
    /// [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj
    /// (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj
    /// Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkMinAdj")]
    pub wmark_min_adj: Option<i64>,
    /// wmark_ratio (Anolis OS required)
    /// Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation
    /// stops when usage is below `memory.wmark_low`. Basically,
    /// `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio
    /// `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor)
    /// WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async
    /// memory reclamation when memory usage exceeds.
    /// Close: 0. Recommended: 95.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkRatio")]
    pub wmark_ratio: Option<i64>,
    /// WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which
    /// stops async memory reclamation when memory usage belows.
    /// Close: 50. Recommended: 20.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkScalePermill")]
    pub wmark_scale_permill: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsClassNetworkQos {
    /// EgressLimit describes the maximum network bandwidth can be used in the egress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressLimit")]
    pub egress_limit: Option<IntOrString>,
    /// EgressRequest describes the minimum network bandwidth guaranteed in the egress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressRequest")]
    pub egress_request: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// IngressLimit describes the maximum network bandwidth can be used in the ingress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressLimit")]
    pub ingress_limit: Option<IntOrString>,
    /// IngressRequest describes the minimum network bandwidth guaranteed in the ingress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressRequest")]
    pub ingress_request: Option<IntOrString>,
}

/// ResctrlQOSCfg stores node-level config of resctrl qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsClassResctrlQos {
    /// LLC available range end for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeEndPercent")]
    pub cat_range_end_percent: Option<i64>,
    /// LLC available range start for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeStartPercent")]
    pub cat_range_start_percent: Option<i64>,
    /// Enable indicates whether the resctrl qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// MBA percent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mbaPercent")]
    pub mba_percent: Option<i64>,
}

/// ResourceQOS for LSR pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsrClass {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blkioQOS")]
    pub blkio_qos: Option<NodeSloResourceQosStrategyLsrClassBlkioQos>,
    /// CPUQOSCfg stores node-level config of cpu qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuQOS")]
    pub cpu_qos: Option<NodeSloResourceQosStrategyLsrClassCpuQos>,
    /// MemoryQOSCfg stores node-level config of memory qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryQOS")]
    pub memory_qos: Option<NodeSloResourceQosStrategyLsrClassMemoryQos>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkQOS")]
    pub network_qos: Option<NodeSloResourceQosStrategyLsrClassNetworkQos>,
    /// ResctrlQOSCfg stores node-level config of resctrl qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resctrlQOS")]
    pub resctrl_qos: Option<NodeSloResourceQosStrategyLsrClassResctrlQos>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsrClassBlkioQos {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blocks: Option<Vec<NodeSloResourceQosStrategyLsrClassBlkioQosBlocks>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsrClassBlkioQosBlocks {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioCfg")]
    pub io_cfg: Option<NodeSloResourceQosStrategyLsrClassBlkioQosBlocksIoCfg>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsrClassBlkioQosBlocksIoCfg {
    /// configure the cost model of blkio-cost manually
    /// whether the user model is enabled. Default value: false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableUserModel")]
    pub enable_user_model: Option<bool>,
    /// This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioWeightPercent")]
    pub io_weight_percent: Option<i64>,
    /// the read BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadBPS")]
    pub model_read_bps: Option<i64>,
    /// the random read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadRandIOPS")]
    pub model_read_rand_iops: Option<i64>,
    /// the sequential read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadSeqIOPS")]
    pub model_read_seq_iops: Option<i64>,
    /// the write BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteBPS")]
    pub model_write_bps: Option<i64>,
    /// the random write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteRandIOPS")]
    pub model_write_rand_iops: Option<i64>,
    /// the sequential write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteSeqIOPS")]
    pub model_write_seq_iops: Option<i64>,
    /// Throttling of throughput
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readBPS")]
    pub read_bps: Option<i64>,
    /// Throttling of IOPS
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readIOPS")]
    pub read_iops: Option<i64>,
    /// Configure the weight-based throttling feature of blk-iocost
    /// Only used for RootClass
    /// After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk.
    /// the read latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatency")]
    pub read_latency: Option<i64>,
    /// the read latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatencyPercent")]
    pub read_latency_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeBPS")]
    pub write_bps: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeIOPS")]
    pub write_iops: Option<i64>,
    /// the write latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatency")]
    pub write_latency: Option<i64>,
    /// the write latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatencyPercent")]
    pub write_latency_percent: Option<i64>,
}

/// CPUQOSCfg stores node-level config of cpu qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsrClassCpuQos {
    /// whether pods of the QoS class can expel the cgroup idle pods at the SMT-level. default = false
    /// If set to true, pods of this QoS will use a dedicated core sched group for noise clean with the SchedIdle pods.
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreExpeller")]
    pub core_expeller: Option<bool>,
    /// Enable indicates whether the cpu qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// group identity value for pods, default = 0
    /// NOTE: It takes effect if cpuPolicy = "groupIdentity".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIdentity")]
    pub group_identity: Option<i64>,
    /// cpu.idle value for pods, default = 0.
    /// `1` means using SCHED_IDLE.
    /// CGroup Idle (introduced since mainline Linux 5.15): <https://lore.kernel.org/lkml/162971078674.25758.15464079371945307825.tip-bot2@tip-bot2/#r>
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedIdle")]
    pub sched_idle: Option<i64>,
}

/// MemoryQOSCfg stores node-level config of memory qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsrClassMemoryQos {
    /// Enable indicates whether the memory qos is enabled (default: false).
    /// This field is used for node-level control, while pod-level configuration is done with MemoryQOS and `Policy`
    /// instead of an `Enable` option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST
    /// protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected
    /// memcg can be reclaimed.
    /// NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory,
    /// pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowLimitPercent")]
    pub low_limit_percent: Option<i64>,
    /// memcg qos
    /// If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec.
    /// 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set)
    /// 4. `memory.high` := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize
    /// MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory
    /// from global reclamation when memory usage does not exceed the min limit.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLimitPercent")]
    pub min_limit_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oomKillGroup")]
    pub oom_kill_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// TODO: enhance the usages of oom priority and oom kill group
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityEnable")]
    pub priority_enable: Option<i64>,
    /// ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod
    /// memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds.
    /// Lower the factor brings more heavier reclaim pressure.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throttlingPercent")]
    pub throttling_percent: Option<i64>,
    /// wmark_min_adj (Anolis OS required)
    /// WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory
    /// reclamation. Lower the factor brings later reclamation.
    /// The adjustment uses different formula for different value range.
    /// [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj
    /// (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj
    /// Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkMinAdj")]
    pub wmark_min_adj: Option<i64>,
    /// wmark_ratio (Anolis OS required)
    /// Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation
    /// stops when usage is below `memory.wmark_low`. Basically,
    /// `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio
    /// `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor)
    /// WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async
    /// memory reclamation when memory usage exceeds.
    /// Close: 0. Recommended: 95.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkRatio")]
    pub wmark_ratio: Option<i64>,
    /// WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which
    /// stops async memory reclamation when memory usage belows.
    /// Close: 50. Recommended: 20.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkScalePermill")]
    pub wmark_scale_permill: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsrClassNetworkQos {
    /// EgressLimit describes the maximum network bandwidth can be used in the egress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressLimit")]
    pub egress_limit: Option<IntOrString>,
    /// EgressRequest describes the minimum network bandwidth guaranteed in the egress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressRequest")]
    pub egress_request: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// IngressLimit describes the maximum network bandwidth can be used in the ingress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressLimit")]
    pub ingress_limit: Option<IntOrString>,
    /// IngressRequest describes the minimum network bandwidth guaranteed in the ingress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressRequest")]
    pub ingress_request: Option<IntOrString>,
}

/// ResctrlQOSCfg stores node-level config of resctrl qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyLsrClassResctrlQos {
    /// LLC available range end for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeEndPercent")]
    pub cat_range_end_percent: Option<i64>,
    /// LLC available range start for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeStartPercent")]
    pub cat_range_start_percent: Option<i64>,
    /// Enable indicates whether the resctrl qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// MBA percent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mbaPercent")]
    pub mba_percent: Option<i64>,
}

/// Policies of pod QoS.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategyPolicies {
    /// applied policy for the CPU QoS, default = "groupIdentity"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuPolicy")]
    pub cpu_policy: Option<String>,
    /// applied policy for the Net QoS, default = "tc"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "netQOSPolicy")]
    pub net_qos_policy: Option<String>,
}

/// ResourceQOS for system pods
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategySystemClass {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "blkioQOS")]
    pub blkio_qos: Option<NodeSloResourceQosStrategySystemClassBlkioQos>,
    /// CPUQOSCfg stores node-level config of cpu qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuQOS")]
    pub cpu_qos: Option<NodeSloResourceQosStrategySystemClassCpuQos>,
    /// MemoryQOSCfg stores node-level config of memory qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryQOS")]
    pub memory_qos: Option<NodeSloResourceQosStrategySystemClassMemoryQos>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "networkQOS")]
    pub network_qos: Option<NodeSloResourceQosStrategySystemClassNetworkQos>,
    /// ResctrlQOSCfg stores node-level config of resctrl qos
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resctrlQOS")]
    pub resctrl_qos: Option<NodeSloResourceQosStrategySystemClassResctrlQos>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategySystemClassBlkioQos {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blocks: Option<Vec<NodeSloResourceQosStrategySystemClassBlkioQosBlocks>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategySystemClassBlkioQosBlocks {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioCfg")]
    pub io_cfg: Option<NodeSloResourceQosStrategySystemClassBlkioQosBlocksIoCfg>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategySystemClassBlkioQosBlocksIoCfg {
    /// configure the cost model of blkio-cost manually
    /// whether the user model is enabled. Default value: false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableUserModel")]
    pub enable_user_model: Option<bool>,
    /// This field is used to set the weight of a sub-group. Default value: 100. Valid values: 1 to 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ioWeightPercent")]
    pub io_weight_percent: Option<i64>,
    /// the read BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadBPS")]
    pub model_read_bps: Option<i64>,
    /// the random read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadRandIOPS")]
    pub model_read_rand_iops: Option<i64>,
    /// the sequential read iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelReadSeqIOPS")]
    pub model_read_seq_iops: Option<i64>,
    /// the write BPS of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteBPS")]
    pub model_write_bps: Option<i64>,
    /// the random write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteRandIOPS")]
    pub model_write_rand_iops: Option<i64>,
    /// the sequential write iops of user model
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "modelWriteSeqIOPS")]
    pub model_write_seq_iops: Option<i64>,
    /// Throttling of throughput
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readBPS")]
    pub read_bps: Option<i64>,
    /// Throttling of IOPS
    /// The value is set to 0, which indicates that the feature is disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readIOPS")]
    pub read_iops: Option<i64>,
    /// Configure the weight-based throttling feature of blk-iocost
    /// Only used for RootClass
    /// After blk-iocost is enabled, the kernel calculates the proportion of requests that exceed the read or write latency threshold out of all requests. When the proportion is greater than the read or write latency percentile (95%), the kernel considers the disk to be saturated and reduces the rate at which requests are sent to the disk.
    /// the read latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatency")]
    pub read_latency: Option<i64>,
    /// the read latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readLatencyPercent")]
    pub read_latency_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeBPS")]
    pub write_bps: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeIOPS")]
    pub write_iops: Option<i64>,
    /// the write latency threshold. Unit: microseconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatency")]
    pub write_latency: Option<i64>,
    /// the write latency percentile
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeLatencyPercent")]
    pub write_latency_percent: Option<i64>,
}

/// CPUQOSCfg stores node-level config of cpu qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategySystemClassCpuQos {
    /// whether pods of the QoS class can expel the cgroup idle pods at the SMT-level. default = false
    /// If set to true, pods of this QoS will use a dedicated core sched group for noise clean with the SchedIdle pods.
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "coreExpeller")]
    pub core_expeller: Option<bool>,
    /// Enable indicates whether the cpu qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// group identity value for pods, default = 0
    /// NOTE: It takes effect if cpuPolicy = "groupIdentity".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "groupIdentity")]
    pub group_identity: Option<i64>,
    /// cpu.idle value for pods, default = 0.
    /// `1` means using SCHED_IDLE.
    /// CGroup Idle (introduced since mainline Linux 5.15): <https://lore.kernel.org/lkml/162971078674.25758.15464079371945307825.tip-bot2@tip-bot2/#r>
    /// NOTE: It takes effect if cpuPolicy = "coreSched".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedIdle")]
    pub sched_idle: Option<i64>,
}

/// MemoryQOSCfg stores node-level config of memory qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategySystemClassMemoryQos {
    /// Enable indicates whether the memory qos is enabled (default: false).
    /// This field is used for node-level control, while pod-level configuration is done with MemoryQOS and `Policy`
    /// instead of an `Enable` option. Please view the differences between MemoryQOSCfg and PodMemoryQOSConfig structs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST
    /// protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected
    /// memcg can be reclaimed.
    /// NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory,
    /// pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lowLimitPercent")]
    pub low_limit_percent: Option<i64>,
    /// memcg qos
    /// If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec.
    /// 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set)
    /// 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set)
    /// 4. `memory.high` := floor[(spec.requests.memory + throttlingFactor / 100 * (memory.limit_in_bytes or node allocatable memory - spec.requests.memory))/pageSize] * pageSize
    /// MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory
    /// from global reclamation when memory usage does not exceed the min limit.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLimitPercent")]
    pub min_limit_percent: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oomKillGroup")]
    pub oom_kill_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    /// TODO: enhance the usages of oom priority and oom kill group
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityEnable")]
    pub priority_enable: Option<i64>,
    /// ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod
    /// memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds.
    /// Lower the factor brings more heavier reclaim pressure.
    /// Close: 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "throttlingPercent")]
    pub throttling_percent: Option<i64>,
    /// wmark_min_adj (Anolis OS required)
    /// WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory
    /// reclamation. Lower the factor brings later reclamation.
    /// The adjustment uses different formula for different value range.
    /// [-25, 0)：global_wmark_min' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj
    /// (0, 50]：global_wmark_min' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj
    /// Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkMinAdj")]
    pub wmark_min_adj: Option<i64>,
    /// wmark_ratio (Anolis OS required)
    /// Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation
    /// stops when usage is below `memory.wmark_low`. Basically,
    /// `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.memory.wmark_ratio
    /// `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor)
    /// WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async
    /// memory reclamation when memory usage exceeds.
    /// Close: 0. Recommended: 95.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkRatio")]
    pub wmark_ratio: Option<i64>,
    /// WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which
    /// stops async memory reclamation when memory usage belows.
    /// Close: 50. Recommended: 20.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "wmarkScalePermill")]
    pub wmark_scale_permill: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategySystemClassNetworkQos {
    /// EgressLimit describes the maximum network bandwidth can be used in the egress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressLimit")]
    pub egress_limit: Option<IntOrString>,
    /// EgressRequest describes the minimum network bandwidth guaranteed in the egress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressRequest")]
    pub egress_request: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// IngressLimit describes the maximum network bandwidth can be used in the ingress direction,
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressLimit")]
    pub ingress_limit: Option<IntOrString>,
    /// IngressRequest describes the minimum network bandwidth guaranteed in the ingress direction.
    /// unit: bps(bytes per second), two expressions are supported，int and string,
    /// int: percentage based on total bandwidth，valid in 0-100
    /// string: a specific network bandwidth value, eg: 50M.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressRequest")]
    pub ingress_request: Option<IntOrString>,
}

/// ResctrlQOSCfg stores node-level config of resctrl qos
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceQosStrategySystemClassResctrlQos {
    /// LLC available range end for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeEndPercent")]
    pub cat_range_end_percent: Option<i64>,
    /// LLC available range start for pods by percentage
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "catRangeStartPercent")]
    pub cat_range_start_percent: Option<i64>,
    /// Enable indicates whether the resctrl qos is enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// MBA percent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mbaPercent")]
    pub mba_percent: Option<i64>,
}

/// BE pods will be limited if node resource usage overload
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloResourceUsedThresholdWithBe {
    /// be.satisfactionRate = be.CPURealLimit/be.CPURequest; be.cpuUsage = be.CPUUsed/be.CPURealLimit
    /// if be.satisfactionRate < CPUEvictBESatisfactionLowerPercent/100 && be.usage >= CPUEvictBEUsageThresholdPercent/100,
    /// then start to evict pod, and will evict to ${CPUEvictBESatisfactionUpperPercent}
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuEvictBESatisfactionLowerPercent")]
    pub cpu_evict_be_satisfaction_lower_percent: Option<i64>,
    /// be.satisfactionRate = be.CPURealLimit/be.CPURequest
    /// if be.satisfactionRate > CPUEvictBESatisfactionUpperPercent/100, then stop to evict.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuEvictBESatisfactionUpperPercent")]
    pub cpu_evict_be_satisfaction_upper_percent: Option<i64>,
    /// if be.cpuUsage >= CPUEvictBEUsageThresholdPercent/100, then start to calculate the resources need to be released.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuEvictBEUsageThresholdPercent")]
    pub cpu_evict_be_usage_threshold_percent: Option<i64>,
    /// CPUEvictPolicy defines the policy for the BECPUEvict feature.
    /// Default: `evictByRealLimit`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuEvictPolicy")]
    pub cpu_evict_policy: Option<String>,
    /// when avg(cpuusage) > CPUEvictThresholdPercent, will start to evict pod by cpu,
    /// and avg(cpuusage) is calculated based on the most recent CPUEvictTimeWindowSeconds data
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuEvictTimeWindowSeconds")]
    pub cpu_evict_time_window_seconds: Option<i64>,
    /// cpu suppress min percentage (0,100)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuSuppressMinPercent")]
    pub cpu_suppress_min_percent: Option<i64>,
    /// CPUSuppressPolicy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuSuppressPolicy")]
    pub cpu_suppress_policy: Option<String>,
    /// cpu suppress threshold percentage (0,100), default = 65
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuSuppressThresholdPercent")]
    pub cpu_suppress_threshold_percent: Option<i64>,
    /// whether the strategy is enabled, default = false
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// lower: memory release util usage under MemoryEvictLowerPercent, default = MemoryEvictThresholdPercent - 2
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryEvictLowerPercent")]
    pub memory_evict_lower_percent: Option<i64>,
    /// upper: memory evict threshold percentage (0,100), default = 70
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryEvictThresholdPercent")]
    pub memory_evict_threshold_percent: Option<i64>,
}

/// node global system config
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloSystemStrategy {
    /// /sys/kernel/mm/memcg_reaper/reap_background
    /// Unset by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memcgReapBackGround")]
    pub memcg_reap_back_ground: Option<i64>,
    /// for /proc/sys/vm/min_free_kbytes, min_free_kbytes = minFreeKbytesFactor * nodeTotalMemory /10000
    /// Unset by default. 1 means 1/10000. Recommended = 100.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minFreeKbytesFactor")]
    pub min_free_kbytes_factor: Option<i64>,
    /// /sys/kernel/sched_features
    /// Extra scheduling features supported by the kernel.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedFeatures")]
    pub sched_features: Option<BTreeMap<String, bool>>,
    /// /sys/kernel/sched_group_identity_enabled
    /// <https://github.com/koordinator-sh/koordinator/pull/1172>
    /// 0 to disable, 1 to enable.
    /// Disable (0) when CPUQoS (Group Identity) is manually disabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedGroupIdentityEnabled")]
    pub sched_group_identity_enabled: Option<i64>,
    /// /proc/sys/kernel/sched_idle_saver_wmark
    /// <https://www.alibabacloud.com/help/en/alinux/user-guide/group-identity-feature>
    /// 1 means 1ns.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedIdleSaverWmark")]
    pub sched_idle_saver_wmark: Option<i64>,
    /// TotalNetworkBandwidth indicates the overall network bandwidth, cluster manager can set this field, and default value taken from /sys/class/net/${NIC_NAME}/speed, unit: Mbps
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "totalNetworkBandwidth")]
    pub total_network_bandwidth: Option<IntOrString>,
    /// /proc/sys/vm/watermark_scale_factor
    /// Unset by default. 1 means 1/10000. Recommended = 150.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "watermarkScaleFactor")]
    pub watermark_scale_factor: Option<i64>,
}

/// NodeSLOStatus defines the observed state of NodeSLO
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct NodeSloStatus {
}

