// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/kubernetes-sigs/cluster-api/cluster.x-k8s.io/v1beta2/clusters.yaml
// kopium version: 0.22.4

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// spec is the desired state of Cluster.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "cluster.x-k8s.io", version = "v1beta2", kind = "Cluster", plural = "clusters")]
#[kube(namespaced)]
#[kube(status = "ClusterStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClusterSpec {
    /// availabilityGates specifies additional conditions to include when evaluating Cluster Available condition.
    /// 
    /// If this field is not defined and the Cluster implements a managed topology, availabilityGates
    /// from the corresponding ClusterClass will be used, if any.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityGates")]
    pub availability_gates: Option<Vec<ClusterAvailabilityGates>>,
    /// clusterNetwork represents the cluster network configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterNetwork")]
    pub cluster_network: Option<ClusterClusterNetwork>,
    /// controlPlaneEndpoint represents the endpoint used to communicate with the control plane.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlaneEndpoint")]
    pub control_plane_endpoint: Option<ClusterControlPlaneEndpoint>,
    /// controlPlaneRef is an optional reference to a provider-specific resource that holds
    /// the details for provisioning the Control Plane for a Cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlaneRef")]
    pub control_plane_ref: Option<ClusterControlPlaneRef>,
    /// infrastructureRef is a reference to a provider-specific resource that holds the details
    /// for provisioning infrastructure for a cluster in said provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infrastructureRef")]
    pub infrastructure_ref: Option<ClusterInfrastructureRef>,
    /// paused can be used to prevent controllers from processing the Cluster and all its associated objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    /// topology encapsulates the topology for the cluster.
    /// NOTE: It is required to enable the ClusterTopology
    /// feature gate flag to activate managed topologies support;
    /// this feature is highly experimental, and parts of it might still be not implemented.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topology: Option<ClusterTopology>,
}

/// ClusterAvailabilityGate contains the type of a Cluster condition to be used as availability gate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterAvailabilityGates {
    /// conditionType refers to a condition with matching type in the Cluster's condition list.
    /// If the conditions doesn't exist, it will be treated as unknown.
    /// Note: Both Cluster API conditions or conditions added by 3rd party controllers can be used as availability gates.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
    /// polarity of the conditionType specified in this availabilityGate.
    /// Valid values are Positive, Negative and omitted.
    /// When omitted, the default behaviour will be Positive.
    /// A positive polarity means that the condition should report a true status under normal conditions.
    /// A negative polarity means that the condition should report a false status under normal conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub polarity: Option<ClusterAvailabilityGatesPolarity>,
}

/// ClusterAvailabilityGate contains the type of a Cluster condition to be used as availability gate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterAvailabilityGatesPolarity {
    Positive,
    Negative,
}

/// clusterNetwork represents the cluster network configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClusterNetwork {
    /// apiServerPort specifies the port the API Server should bind to.
    /// Defaults to 6443.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServerPort")]
    pub api_server_port: Option<i32>,
    /// pods is the network ranges from which Pod networks are allocated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pods: Option<ClusterClusterNetworkPods>,
    /// serviceDomain is the domain name for services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDomain")]
    pub service_domain: Option<String>,
    /// services is the network ranges from which service VIPs are allocated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<ClusterClusterNetworkServices>,
}

/// pods is the network ranges from which Pod networks are allocated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClusterNetworkPods {
    /// cidrBlocks is a list of CIDR blocks.
    #[serde(rename = "cidrBlocks")]
    pub cidr_blocks: Vec<String>,
}

/// services is the network ranges from which service VIPs are allocated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClusterNetworkServices {
    /// cidrBlocks is a list of CIDR blocks.
    #[serde(rename = "cidrBlocks")]
    pub cidr_blocks: Vec<String>,
}

/// controlPlaneEndpoint represents the endpoint used to communicate with the control plane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterControlPlaneEndpoint {
    /// host is the hostname on which the API server is serving.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// port is the port on which the API server is serving.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
}

/// controlPlaneRef is an optional reference to a provider-specific resource that holds
/// the details for provisioning the Control Plane for a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterControlPlaneRef {
    /// apiGroup is the group of the resource being referenced.
    /// apiGroup must be fully qualified domain name.
    /// The corresponding version for this reference will be looked up from the contract
    /// labels of the corresponding CRD of the resource being referenced.
    #[serde(rename = "apiGroup")]
    pub api_group: String,
    /// kind of the resource being referenced.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the resource being referenced.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// infrastructureRef is a reference to a provider-specific resource that holds the details
/// for provisioning infrastructure for a cluster in said provider.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterInfrastructureRef {
    /// apiGroup is the group of the resource being referenced.
    /// apiGroup must be fully qualified domain name.
    /// The corresponding version for this reference will be looked up from the contract
    /// labels of the corresponding CRD of the resource being referenced.
    #[serde(rename = "apiGroup")]
    pub api_group: String,
    /// kind of the resource being referenced.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the resource being referenced.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// topology encapsulates the topology for the cluster.
/// NOTE: It is required to enable the ClusterTopology
/// feature gate flag to activate managed topologies support;
/// this feature is highly experimental, and parts of it might still be not implemented.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopology {
    /// classRef is the ref to the ClusterClass that should be used for the topology.
    #[serde(rename = "classRef")]
    pub class_ref: ClusterTopologyClassRef,
    /// controlPlane describes the cluster control plane.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlane")]
    pub control_plane: Option<ClusterTopologyControlPlane>,
    /// variables can be used to customize the Cluster through
    /// patches. They must comply to the corresponding
    /// VariableClasses defined in the ClusterClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<ClusterTopologyVariables>>,
    /// version is the Kubernetes version of the cluster.
    pub version: String,
    /// workers encapsulates the different constructs that form the worker nodes
    /// for the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<ClusterTopologyWorkers>,
}

/// classRef is the ref to the ClusterClass that should be used for the topology.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyClassRef {
    /// name is the name of the ClusterClass that should be used for the topology.
    /// name must be a valid ClusterClass name and because of that be at most 253 characters in length
    /// and it must consist only of lower case alphanumeric characters, hyphens (-) and periods (.), and must start
    /// and end with an alphanumeric character.
    pub name: String,
    /// namespace is the namespace of the ClusterClass that should be used for the topology.
    /// If namespace is empty or not set, it is defaulted to the namespace of the Cluster object.
    /// namespace must be a valid namespace name and because of that be at most 63 characters in length
    /// and it must consist only of lower case alphanumeric characters or hyphens (-), and must start
    /// and end with an alphanumeric character.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// controlPlane describes the cluster control plane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlane {
    /// deletion contains configuration options for Machine deletion.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deletion: Option<ClusterTopologyControlPlaneDeletion>,
    /// healthCheck allows to enable, disable and override control plane health check
    /// configuration from the ClusterClass for this control plane.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<ClusterTopologyControlPlaneHealthCheck>,
    /// metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane
    /// if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it
    /// is applied only to the ControlPlane.
    /// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterTopologyControlPlaneMetadata>,
    /// readinessGates specifies additional conditions to include when evaluating Machine Ready condition.
    /// 
    /// This field can be used e.g. to instruct the machine controller to include in the computation for Machine's ready
    /// computation a condition, managed by an external controllers, reporting the status of special software/hardware installed on the Machine.
    /// 
    /// If this field is not defined, readinessGates from the corresponding ControlPlaneClass will be used, if any.
    /// 
    /// NOTE: Specific control plane provider implementations might automatically extend the list of readinessGates;
    /// e.g. the kubeadm control provider adds ReadinessGates for the APIServerPodHealthy, SchedulerPodHealthy conditions, etc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<ClusterTopologyControlPlaneReadinessGates>>,
    /// replicas is the number of control plane nodes.
    /// If the value is not set, the ControlPlane object is created without the number of Replicas
    /// and it's assumed that the control plane controller does not implement support for this field.
    /// When specified against a control plane provider that lacks support for this field, this value will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// variables can be used to customize the ControlPlane through patches.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<ClusterTopologyControlPlaneVariables>,
}

/// deletion contains configuration options for Machine deletion.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneDeletion {
    /// nodeDeletionTimeoutSeconds defines how long the controller will attempt to delete the Node that the Machine
    /// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// Defaults to 10 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeoutSeconds")]
    pub node_deletion_timeout_seconds: Option<i32>,
    /// nodeDrainTimeoutSeconds is the total amount of time that the controller will spend on draining a node.
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain --timeout`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeoutSeconds")]
    pub node_drain_timeout_seconds: Option<i32>,
    /// nodeVolumeDetachTimeoutSeconds is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeoutSeconds")]
    pub node_volume_detach_timeout_seconds: Option<i32>,
}

/// healthCheck allows to enable, disable and override control plane health check
/// configuration from the ClusterClass for this control plane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneHealthCheck {
    /// checks are the checks that are used to evaluate if a Machine is healthy.
    /// 
    /// If one of checks and remediation fields are set, the system assumes that an healthCheck override is defined,
    /// and as a consequence the checks and remediation fields from Cluster will be used instead of the
    /// corresponding fields in ClusterClass.
    /// 
    /// Independent of this configuration the MachineHealthCheck controller will always
    /// flag Machines with `cluster.x-k8s.io/remediate-machine` annotation and
    /// Machines with deleted Nodes as unhealthy.
    /// 
    /// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
    /// is defaulted to 10 minutes and evaluated accordingly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<ClusterTopologyControlPlaneHealthCheckChecks>,
    /// enabled controls if a MachineHealthCheck should be created for the target machines.
    /// 
    /// If false: No MachineHealthCheck will be created.
    /// 
    /// If not set(default): A MachineHealthCheck will be created if it is defined here or
    ///  in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created.
    /// 
    /// If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will
    /// block if `enable` is true and no MachineHealthCheck definition is available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// remediation configures if and how remediations are triggered if a Machine is unhealthy.
    /// 
    /// If one of checks and remediation fields are set, the system assumes that an healthCheck override is defined,
    /// and as a consequence the checks and remediation fields from cluster will be used instead of the
    /// corresponding fields in ClusterClass.
    /// 
    /// If an health check override is defined and remediation or remediation.triggerIf is not set,
    /// remediation will always be triggered for unhealthy Machines.
    /// 
    /// If an health check override is defined and remediation or remediation.templateRef is not set,
    /// the OwnerRemediated condition will be set on unhealthy Machines to trigger remediation via
    /// the owner of the Machines, for example a MachineSet or a KubeadmControlPlane.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remediation: Option<ClusterTopologyControlPlaneHealthCheckRemediation>,
}

/// checks are the checks that are used to evaluate if a Machine is healthy.
/// 
/// If one of checks and remediation fields are set, the system assumes that an healthCheck override is defined,
/// and as a consequence the checks and remediation fields from Cluster will be used instead of the
/// corresponding fields in ClusterClass.
/// 
/// Independent of this configuration the MachineHealthCheck controller will always
/// flag Machines with `cluster.x-k8s.io/remediate-machine` annotation and
/// Machines with deleted Nodes as unhealthy.
/// 
/// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
/// is defaulted to 10 minutes and evaluated accordingly.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneHealthCheckChecks {
    /// nodeStartupTimeoutSeconds allows to set the maximum time for MachineHealthCheck
    /// to consider a Machine unhealthy if a corresponding Node isn't associated
    /// through a `Spec.ProviderID` field.
    /// 
    /// The duration set in this field is compared to the greatest of:
    /// - Cluster's infrastructure ready condition timestamp (if and when available)
    /// - Control Plane's initialized condition timestamp (if and when available)
    /// - Machine's infrastructure ready condition timestamp (if and when available)
    /// - Machine's metadata creation timestamp
    /// 
    /// Defaults to 10 minutes.
    /// If you wish to disable this feature, set the value explicitly to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeStartupTimeoutSeconds")]
    pub node_startup_timeout_seconds: Option<i32>,
    /// unhealthyNodeConditions contains a list of conditions that determine
    /// whether a node is considered unhealthy. The conditions are combined in a
    /// logical OR, i.e. if any of the conditions is met, the node is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyNodeConditions")]
    pub unhealthy_node_conditions: Option<Vec<ClusterTopologyControlPlaneHealthCheckChecksUnhealthyNodeConditions>>,
}

/// UnhealthyNodeCondition represents a Node condition type and value with a timeout
/// specified as a duration.  When the named condition has been in the given
/// status for at least the timeout value, a node is considered unhealthy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneHealthCheckChecksUnhealthyNodeConditions {
    /// status of the condition, one of True, False, Unknown.
    pub status: String,
    /// timeoutSeconds is the duration that a node must be in a given status for,
    /// after which the node is considered unhealthy.
    /// For example, with a value of "1h", the node must match the status
    /// for at least 1 hour before being considered unhealthy.
    #[serde(rename = "timeoutSeconds")]
    pub timeout_seconds: i32,
    /// type of Node condition
    #[serde(rename = "type")]
    pub r#type: String,
}

/// remediation configures if and how remediations are triggered if a Machine is unhealthy.
/// 
/// If one of checks and remediation fields are set, the system assumes that an healthCheck override is defined,
/// and as a consequence the checks and remediation fields from cluster will be used instead of the
/// corresponding fields in ClusterClass.
/// 
/// If an health check override is defined and remediation or remediation.triggerIf is not set,
/// remediation will always be triggered for unhealthy Machines.
/// 
/// If an health check override is defined and remediation or remediation.templateRef is not set,
/// the OwnerRemediated condition will be set on unhealthy Machines to trigger remediation via
/// the owner of the Machines, for example a MachineSet or a KubeadmControlPlane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneHealthCheckRemediation {
    /// templateRef is a reference to a remediation template
    /// provided by an infrastructure provider.
    /// 
    /// This field is completely optional, when filled, the MachineHealthCheck controller
    /// creates a new object from the template referenced and hands off remediation of the machine to
    /// a controller that lives outside of Cluster API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateRef")]
    pub template_ref: Option<ClusterTopologyControlPlaneHealthCheckRemediationTemplateRef>,
    /// triggerIf configures if remediations are triggered.
    /// If this field is not set, remediations are always triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerIf")]
    pub trigger_if: Option<ClusterTopologyControlPlaneHealthCheckRemediationTriggerIf>,
}

/// templateRef is a reference to a remediation template
/// provided by an infrastructure provider.
/// 
/// This field is completely optional, when filled, the MachineHealthCheck controller
/// creates a new object from the template referenced and hands off remediation of the machine to
/// a controller that lives outside of Cluster API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneHealthCheckRemediationTemplateRef {
    /// apiVersion of the remediation template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    /// NOTE: This field must be kept in sync with the APIVersion of the remediation template.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the remediation template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the remediation template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// triggerIf configures if remediations are triggered.
/// If this field is not set, remediations are always triggered.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneHealthCheckRemediationTriggerIf {
    /// unhealthyInRange specifies that remediations are only triggered if the number of
    /// unhealthy Machines is in the configured range.
    /// Takes precedence over unhealthyLessThanOrEqualTo.
    /// Eg. "[3-5]" - This means that remediation will be allowed only when:
    /// (a) there are at least 3 unhealthy Machines (and)
    /// (b) there are at most 5 unhealthy Machines
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyInRange")]
    pub unhealthy_in_range: Option<String>,
    /// unhealthyLessThanOrEqualTo specifies that remediations are only triggered if the number of
    /// unhealthy Machines is less than or equal to the configured value.
    /// unhealthyInRange takes precedence if set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyLessThanOrEqualTo")]
    pub unhealthy_less_than_or_equal_to: Option<IntOrString>,
}

/// metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane
/// if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it
/// is applied only to the ControlPlane.
/// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneMetadata {
    /// annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <http://kubernetes.io/docs/user-guide/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <http://kubernetes.io/docs/user-guide/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneReadinessGates {
    /// conditionType refers to a condition with matching type in the Machine's condition list.
    /// If the conditions doesn't exist, it will be treated as unknown.
    /// Note: Both Cluster API conditions or conditions added by 3rd party controllers can be used as readiness gates.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
    /// polarity of the conditionType specified in this readinessGate.
    /// Valid values are Positive, Negative and omitted.
    /// When omitted, the default behaviour will be Positive.
    /// A positive polarity means that the condition should report a true status under normal conditions.
    /// A negative polarity means that the condition should report a false status under normal conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub polarity: Option<ClusterTopologyControlPlaneReadinessGatesPolarity>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterTopologyControlPlaneReadinessGatesPolarity {
    Positive,
    Negative,
}

/// variables can be used to customize the ControlPlane through patches.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneVariables {
    /// overrides can be used to override Cluster level variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<Vec<ClusterTopologyControlPlaneVariablesOverrides>>,
}

/// ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a
/// Variable definition in the ClusterClass `status` variables.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyControlPlaneVariablesOverrides {
    /// name of the variable.
    pub name: String,
    /// value of the variable.
    /// Note: the value will be validated against the schema of the corresponding ClusterClassVariable
    /// from the ClusterClass.
    /// Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a
    /// hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools,
    /// i.e. it is not possible to have no type field.
    /// Ref: <https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111>
    pub value: serde_json::Value,
}

/// ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a
/// Variable definition in the ClusterClass `status` variables.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyVariables {
    /// name of the variable.
    pub name: String,
    /// value of the variable.
    /// Note: the value will be validated against the schema of the corresponding ClusterClassVariable
    /// from the ClusterClass.
    /// Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a
    /// hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools,
    /// i.e. it is not possible to have no type field.
    /// Ref: <https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111>
    pub value: serde_json::Value,
}

/// workers encapsulates the different constructs that form the worker nodes
/// for the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkers {
    /// machineDeployments is a list of machine deployments in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineDeployments")]
    pub machine_deployments: Option<Vec<ClusterTopologyWorkersMachineDeployments>>,
    /// machinePools is a list of machine pools in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machinePools")]
    pub machine_pools: Option<Vec<ClusterTopologyWorkersMachinePools>>,
}

/// MachineDeploymentTopology specifies the different parameters for a set of worker nodes in the topology.
/// This set of nodes is managed by a MachineDeployment object whose lifecycle is managed by the Cluster controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeployments {
    /// class is the name of the MachineDeploymentClass used to create the set of worker nodes.
    /// This should match one of the deployment classes defined in the ClusterClass object
    /// mentioned in the `Cluster.Spec.Class` field.
    pub class: String,
    /// deletion contains configuration options for Machine deletion.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deletion: Option<ClusterTopologyWorkersMachineDeploymentsDeletion>,
    /// failureDomain is the failure domain the machines will be created in.
    /// Must match a key in the FailureDomains map stored on the cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomain")]
    pub failure_domain: Option<String>,
    /// healthCheck allows to enable, disable and override MachineDeployment health check
    /// configuration from the ClusterClass for this MachineDeployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<ClusterTopologyWorkersMachineDeploymentsHealthCheck>,
    /// metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment.
    /// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterTopologyWorkersMachineDeploymentsMetadata>,
    /// minReadySeconds is the minimum number of seconds for which a newly created machine should
    /// be ready.
    /// Defaults to 0 (machine will be considered available as soon as it
    /// is ready)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// name is the unique identifier for this MachineDeploymentTopology.
    /// The value is used with other unique identifiers to create a MachineDeployment's Name
    /// (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length,
    /// the values are hashed together.
    pub name: String,
    /// readinessGates specifies additional conditions to include when evaluating Machine Ready condition.
    /// 
    /// This field can be used e.g. to instruct the machine controller to include in the computation for Machine's ready
    /// computation a condition, managed by an external controllers, reporting the status of special software/hardware installed on the Machine.
    /// 
    /// If this field is not defined, readinessGates from the corresponding MachineDeploymentClass will be used, if any.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<ClusterTopologyWorkersMachineDeploymentsReadinessGates>>,
    /// replicas is the number of worker nodes belonging to this set.
    /// If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to 1)
    /// and it's assumed that an external entity (like cluster autoscaler) is responsible for the management
    /// of this value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// rollout allows you to configure the behaviour of rolling updates to the MachineDeployment Machines.
    /// It allows you to define the strategy used during rolling replacements.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollout: Option<ClusterTopologyWorkersMachineDeploymentsRollout>,
    /// variables can be used to customize the MachineDeployment through patches.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<ClusterTopologyWorkersMachineDeploymentsVariables>,
}

/// deletion contains configuration options for Machine deletion.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsDeletion {
    /// nodeDeletionTimeoutSeconds defines how long the controller will attempt to delete the Node that the Machine
    /// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// Defaults to 10 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeoutSeconds")]
    pub node_deletion_timeout_seconds: Option<i32>,
    /// nodeDrainTimeoutSeconds is the total amount of time that the controller will spend on draining a node.
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain --timeout`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeoutSeconds")]
    pub node_drain_timeout_seconds: Option<i32>,
    /// nodeVolumeDetachTimeoutSeconds is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeoutSeconds")]
    pub node_volume_detach_timeout_seconds: Option<i32>,
    /// order defines the order in which Machines are deleted when downscaling.
    /// Defaults to "Random".  Valid values are "Random, "Newest", "Oldest"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub order: Option<ClusterTopologyWorkersMachineDeploymentsDeletionOrder>,
}

/// deletion contains configuration options for Machine deletion.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterTopologyWorkersMachineDeploymentsDeletionOrder {
    Random,
    Newest,
    Oldest,
}

/// healthCheck allows to enable, disable and override MachineDeployment health check
/// configuration from the ClusterClass for this MachineDeployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsHealthCheck {
    /// checks are the checks that are used to evaluate if a Machine is healthy.
    /// 
    /// If one of checks and remediation fields are set, the system assumes that an healthCheck override is defined,
    /// and as a consequence the checks and remediation fields from Cluster will be used instead of the
    /// corresponding fields in ClusterClass.
    /// 
    /// Independent of this configuration the MachineHealthCheck controller will always
    /// flag Machines with `cluster.x-k8s.io/remediate-machine` annotation and
    /// Machines with deleted Nodes as unhealthy.
    /// 
    /// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
    /// is defaulted to 10 minutes and evaluated accordingly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<ClusterTopologyWorkersMachineDeploymentsHealthCheckChecks>,
    /// enabled controls if a MachineHealthCheck should be created for the target machines.
    /// 
    /// If false: No MachineHealthCheck will be created.
    /// 
    /// If not set(default): A MachineHealthCheck will be created if it is defined here or
    ///  in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created.
    /// 
    /// If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will
    /// block if `enable` is true and no MachineHealthCheck definition is available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// remediation configures if and how remediations are triggered if a Machine is unhealthy.
    /// 
    /// If one of checks and remediation fields are set, the system assumes that an healthCheck override is defined,
    /// and as a consequence the checks and remediation fields from cluster will be used instead of the
    /// corresponding fields in ClusterClass.
    /// 
    /// If an health check override is defined and remediation or remediation.triggerIf is not set,
    /// remediation will always be triggered for unhealthy Machines.
    /// 
    /// If an health check override is defined and remediation or remediation.templateRef is not set,
    /// the OwnerRemediated condition will be set on unhealthy Machines to trigger remediation via
    /// the owner of the Machines, for example a MachineSet or a KubeadmControlPlane.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remediation: Option<ClusterTopologyWorkersMachineDeploymentsHealthCheckRemediation>,
}

/// checks are the checks that are used to evaluate if a Machine is healthy.
/// 
/// If one of checks and remediation fields are set, the system assumes that an healthCheck override is defined,
/// and as a consequence the checks and remediation fields from Cluster will be used instead of the
/// corresponding fields in ClusterClass.
/// 
/// Independent of this configuration the MachineHealthCheck controller will always
/// flag Machines with `cluster.x-k8s.io/remediate-machine` annotation and
/// Machines with deleted Nodes as unhealthy.
/// 
/// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
/// is defaulted to 10 minutes and evaluated accordingly.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsHealthCheckChecks {
    /// nodeStartupTimeoutSeconds allows to set the maximum time for MachineHealthCheck
    /// to consider a Machine unhealthy if a corresponding Node isn't associated
    /// through a `Spec.ProviderID` field.
    /// 
    /// The duration set in this field is compared to the greatest of:
    /// - Cluster's infrastructure ready condition timestamp (if and when available)
    /// - Control Plane's initialized condition timestamp (if and when available)
    /// - Machine's infrastructure ready condition timestamp (if and when available)
    /// - Machine's metadata creation timestamp
    /// 
    /// Defaults to 10 minutes.
    /// If you wish to disable this feature, set the value explicitly to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeStartupTimeoutSeconds")]
    pub node_startup_timeout_seconds: Option<i32>,
    /// unhealthyNodeConditions contains a list of conditions that determine
    /// whether a node is considered unhealthy. The conditions are combined in a
    /// logical OR, i.e. if any of the conditions is met, the node is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyNodeConditions")]
    pub unhealthy_node_conditions: Option<Vec<ClusterTopologyWorkersMachineDeploymentsHealthCheckChecksUnhealthyNodeConditions>>,
}

/// UnhealthyNodeCondition represents a Node condition type and value with a timeout
/// specified as a duration.  When the named condition has been in the given
/// status for at least the timeout value, a node is considered unhealthy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsHealthCheckChecksUnhealthyNodeConditions {
    /// status of the condition, one of True, False, Unknown.
    pub status: String,
    /// timeoutSeconds is the duration that a node must be in a given status for,
    /// after which the node is considered unhealthy.
    /// For example, with a value of "1h", the node must match the status
    /// for at least 1 hour before being considered unhealthy.
    #[serde(rename = "timeoutSeconds")]
    pub timeout_seconds: i32,
    /// type of Node condition
    #[serde(rename = "type")]
    pub r#type: String,
}

/// remediation configures if and how remediations are triggered if a Machine is unhealthy.
/// 
/// If one of checks and remediation fields are set, the system assumes that an healthCheck override is defined,
/// and as a consequence the checks and remediation fields from cluster will be used instead of the
/// corresponding fields in ClusterClass.
/// 
/// If an health check override is defined and remediation or remediation.triggerIf is not set,
/// remediation will always be triggered for unhealthy Machines.
/// 
/// If an health check override is defined and remediation or remediation.templateRef is not set,
/// the OwnerRemediated condition will be set on unhealthy Machines to trigger remediation via
/// the owner of the Machines, for example a MachineSet or a KubeadmControlPlane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsHealthCheckRemediation {
    /// maxInFlight determines how many in flight remediations should happen at the same time.
    /// 
    /// Remediation only happens on the MachineSet with the most current revision, while
    /// older MachineSets (usually present during rollout operations) aren't allowed to remediate.
    /// 
    /// Note: In general (independent of remediations), unhealthy machines are always
    /// prioritized during scale down operations over healthy ones.
    /// 
    /// MaxInFlight can be set to a fixed number or a percentage.
    /// Example: when this is set to 20%, the MachineSet controller deletes at most 20% of
    /// the desired replicas.
    /// 
    /// If not set, remediation is limited to all machines (bounded by replicas)
    /// under the active MachineSet's management.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInFlight")]
    pub max_in_flight: Option<IntOrString>,
    /// templateRef is a reference to a remediation template
    /// provided by an infrastructure provider.
    /// 
    /// This field is completely optional, when filled, the MachineHealthCheck controller
    /// creates a new object from the template referenced and hands off remediation of the machine to
    /// a controller that lives outside of Cluster API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateRef")]
    pub template_ref: Option<ClusterTopologyWorkersMachineDeploymentsHealthCheckRemediationTemplateRef>,
    /// triggerIf configures if remediations are triggered.
    /// If this field is not set, remediations are always triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerIf")]
    pub trigger_if: Option<ClusterTopologyWorkersMachineDeploymentsHealthCheckRemediationTriggerIf>,
}

/// templateRef is a reference to a remediation template
/// provided by an infrastructure provider.
/// 
/// This field is completely optional, when filled, the MachineHealthCheck controller
/// creates a new object from the template referenced and hands off remediation of the machine to
/// a controller that lives outside of Cluster API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsHealthCheckRemediationTemplateRef {
    /// apiVersion of the remediation template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    /// NOTE: This field must be kept in sync with the APIVersion of the remediation template.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the remediation template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the remediation template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// triggerIf configures if remediations are triggered.
/// If this field is not set, remediations are always triggered.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsHealthCheckRemediationTriggerIf {
    /// unhealthyInRange specifies that remediations are only triggered if the number of
    /// unhealthy Machines is in the configured range.
    /// Takes precedence over unhealthyLessThanOrEqualTo.
    /// Eg. "[3-5]" - This means that remediation will be allowed only when:
    /// (a) there are at least 3 unhealthy Machines (and)
    /// (b) there are at most 5 unhealthy Machines
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyInRange")]
    pub unhealthy_in_range: Option<String>,
    /// unhealthyLessThanOrEqualTo specifies that remediations are only triggered if the number of
    /// unhealthy Machines is less than or equal to the configured value.
    /// unhealthyInRange takes precedence if set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyLessThanOrEqualTo")]
    pub unhealthy_less_than_or_equal_to: Option<IntOrString>,
}

/// metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment.
/// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsMetadata {
    /// annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <http://kubernetes.io/docs/user-guide/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <http://kubernetes.io/docs/user-guide/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsReadinessGates {
    /// conditionType refers to a condition with matching type in the Machine's condition list.
    /// If the conditions doesn't exist, it will be treated as unknown.
    /// Note: Both Cluster API conditions or conditions added by 3rd party controllers can be used as readiness gates.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
    /// polarity of the conditionType specified in this readinessGate.
    /// Valid values are Positive, Negative and omitted.
    /// When omitted, the default behaviour will be Positive.
    /// A positive polarity means that the condition should report a true status under normal conditions.
    /// A negative polarity means that the condition should report a false status under normal conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub polarity: Option<ClusterTopologyWorkersMachineDeploymentsReadinessGatesPolarity>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterTopologyWorkersMachineDeploymentsReadinessGatesPolarity {
    Positive,
    Negative,
}

/// rollout allows you to configure the behaviour of rolling updates to the MachineDeployment Machines.
/// It allows you to define the strategy used during rolling replacements.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsRollout {
    /// strategy specifies how to roll out control plane Machines.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<ClusterTopologyWorkersMachineDeploymentsRolloutStrategy>,
}

/// strategy specifies how to roll out control plane Machines.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsRolloutStrategy {
    /// rollingUpdate is the rolling update config params. Present only if
    /// type = RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<ClusterTopologyWorkersMachineDeploymentsRolloutStrategyRollingUpdate>,
    /// type of rollout. Allowed values are RollingUpdate and OnDelete.
    /// Default is RollingUpdate.
    #[serde(rename = "type")]
    pub r#type: ClusterTopologyWorkersMachineDeploymentsRolloutStrategyType,
}

/// rollingUpdate is the rolling update config params. Present only if
/// type = RollingUpdate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsRolloutStrategyRollingUpdate {
    /// maxSurge is the maximum number of machines that can be scheduled above the
    /// desired number of machines.
    /// Value can be an absolute number (ex: 5) or a percentage of
    /// desired machines (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up.
    /// Defaults to 1.
    /// Example: when this is set to 30%, the new MachineSet can be scaled
    /// up immediately when the rolling update starts, such that the total
    /// number of old and new machines do not exceed 130% of desired
    /// machines. Once old machines have been killed, new MachineSet can
    /// be scaled up further, ensuring that total number of machines running
    /// at any time during the update is at most 130% of desired machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// maxUnavailable is the maximum number of machines that can be unavailable during the update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired
    /// machines (ex: 10%).
    /// Absolute number is calculated from percentage by rounding down.
    /// This can not be 0 if MaxSurge is 0.
    /// Defaults to 0.
    /// Example: when this is set to 30%, the old MachineSet can be scaled
    /// down to 70% of desired machines immediately when the rolling update
    /// starts. Once new machines are ready, old MachineSet can be scaled
    /// down further, followed by scaling up the new MachineSet, ensuring
    /// that the total number of machines available at all times
    /// during the update is at least 70% of desired machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// strategy specifies how to roll out control plane Machines.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterTopologyWorkersMachineDeploymentsRolloutStrategyType {
    RollingUpdate,
    OnDelete,
}

/// variables can be used to customize the MachineDeployment through patches.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsVariables {
    /// overrides can be used to override Cluster level variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<Vec<ClusterTopologyWorkersMachineDeploymentsVariablesOverrides>>,
}

/// ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a
/// Variable definition in the ClusterClass `status` variables.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachineDeploymentsVariablesOverrides {
    /// name of the variable.
    pub name: String,
    /// value of the variable.
    /// Note: the value will be validated against the schema of the corresponding ClusterClassVariable
    /// from the ClusterClass.
    /// Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a
    /// hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools,
    /// i.e. it is not possible to have no type field.
    /// Ref: <https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111>
    pub value: serde_json::Value,
}

/// MachinePoolTopology specifies the different parameters for a pool of worker nodes in the topology.
/// This pool of nodes is managed by a MachinePool object whose lifecycle is managed by the Cluster controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachinePools {
    /// class is the name of the MachinePoolClass used to create the pool of worker nodes.
    /// This should match one of the deployment classes defined in the ClusterClass object
    /// mentioned in the `Cluster.Spec.Class` field.
    pub class: String,
    /// deletion contains configuration options for Machine deletion.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deletion: Option<ClusterTopologyWorkersMachinePoolsDeletion>,
    /// failureDomains is the list of failure domains the machine pool will be created in.
    /// Must match a key in the FailureDomains map stored on the cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomains")]
    pub failure_domains: Option<Vec<String>>,
    /// metadata is the metadata applied to the MachinePool.
    /// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterTopologyWorkersMachinePoolsMetadata>,
    /// minReadySeconds is the minimum number of seconds for which a newly created machine pool should
    /// be ready.
    /// Defaults to 0 (machine will be considered available as soon as it
    /// is ready)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// name is the unique identifier for this MachinePoolTopology.
    /// The value is used with other unique identifiers to create a MachinePool's Name
    /// (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length,
    /// the values are hashed together.
    pub name: String,
    /// replicas is the number of nodes belonging to this pool.
    /// If the value is nil, the MachinePool is created without the number of Replicas (defaulting to 1)
    /// and it's assumed that an external entity (like cluster autoscaler) is responsible for the management
    /// of this value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// variables can be used to customize the MachinePool through patches.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<ClusterTopologyWorkersMachinePoolsVariables>,
}

/// deletion contains configuration options for Machine deletion.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachinePoolsDeletion {
    /// nodeDeletionTimeoutSeconds defines how long the controller will attempt to delete the Node that the MachinePool
    /// hosts after the MachinePool is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// Defaults to 10 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeoutSeconds")]
    pub node_deletion_timeout_seconds: Option<i32>,
    /// nodeDrainTimeoutSeconds is the total amount of time that the controller will spend on draining a node.
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain --timeout`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeoutSeconds")]
    pub node_drain_timeout_seconds: Option<i32>,
    /// nodeVolumeDetachTimeoutSeconds is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeoutSeconds")]
    pub node_volume_detach_timeout_seconds: Option<i32>,
}

/// metadata is the metadata applied to the MachinePool.
/// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachinePoolsMetadata {
    /// annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <http://kubernetes.io/docs/user-guide/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <http://kubernetes.io/docs/user-guide/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// variables can be used to customize the MachinePool through patches.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachinePoolsVariables {
    /// overrides can be used to override Cluster level variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<Vec<ClusterTopologyWorkersMachinePoolsVariablesOverrides>>,
}

/// ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a
/// Variable definition in the ClusterClass `status` variables.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterTopologyWorkersMachinePoolsVariablesOverrides {
    /// name of the variable.
    pub name: String,
    /// value of the variable.
    /// Note: the value will be validated against the schema of the corresponding ClusterClassVariable
    /// from the ClusterClass.
    /// Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a
    /// hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools,
    /// i.e. it is not possible to have no type field.
    /// Ref: <https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111>
    pub value: serde_json::Value,
}

/// status is the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterStatus {
    /// conditions represents the observations of a Cluster's current state.
    /// Known condition types are Available, InfrastructureReady, ControlPlaneInitialized, ControlPlaneAvailable, WorkersAvailable, MachinesReady
    /// MachinesUpToDate, RemoteConnectionProbe, ScalingUp, ScalingDown, Remediating, Deleting, Paused.
    /// Additionally, a TopologyReconciled condition will be added in case the Cluster is referencing a ClusterClass / defining a managed Topology.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// controlPlane groups all the observations about Cluster's ControlPlane current state.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlane")]
    pub control_plane: Option<ClusterStatusControlPlane>,
    /// deprecated groups all the status fields that are deprecated and will be removed when all the nested field are removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<ClusterStatusDeprecated>,
    /// failureDomains is a slice of failure domain objects synced from the infrastructure provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomains")]
    pub failure_domains: Option<Vec<ClusterStatusFailureDomains>>,
    /// initialization provides observations of the Cluster initialization process.
    /// NOTE: Fields in this struct are part of the Cluster API contract and are used to orchestrate initial Cluster provisioning.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initialization: Option<ClusterStatusInitialization>,
    /// observedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// phase represents the current phase of cluster actuation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<ClusterStatusPhase>,
    /// workers groups all the observations about Cluster's Workers current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<ClusterStatusWorkers>,
}

/// controlPlane groups all the observations about Cluster's ControlPlane current state.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterStatusControlPlane {
    /// availableReplicas is the total number of available control plane machines in this cluster. A machine is considered available when Machine's Available condition is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableReplicas")]
    pub available_replicas: Option<i32>,
    /// desiredReplicas is the total number of desired control plane machines in this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredReplicas")]
    pub desired_replicas: Option<i32>,
    /// readyReplicas is the total number of ready control plane machines in this cluster. A machine is considered ready when Machine's Ready condition is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readyReplicas")]
    pub ready_replicas: Option<i32>,
    /// replicas is the total number of control plane machines in this cluster.
    /// NOTE: replicas also includes machines still being provisioned or being deleted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// upToDateReplicas is the number of up-to-date control plane machines in this cluster. A machine is considered up-to-date when Machine's UpToDate condition is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upToDateReplicas")]
    pub up_to_date_replicas: Option<i32>,
}

/// deprecated groups all the status fields that are deprecated and will be removed when all the nested field are removed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterStatusDeprecated {
    /// v1beta1 groups all the status fields that are deprecated and will be removed when support for v1beta1 will be dropped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub v1beta1: Option<ClusterStatusDeprecatedV1beta1>,
}

/// v1beta1 groups all the status fields that are deprecated and will be removed when support for v1beta1 will be dropped.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterStatusDeprecatedV1beta1 {
    /// conditions defines current service state of the cluster.
    /// 
    /// Deprecated: This field is deprecated and is going to be removed when support for v1beta1 will be dropped. Please see <https://github.com/kubernetes-sigs/cluster-api/blob/main/docs/proposals/20240916-improve-status-in-CAPI-resources.md> for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// failureMessage indicates that there is a fatal problem reconciling the
    /// state, and will be set to a descriptive error message.
    /// 
    /// Deprecated: This field is deprecated and is going to be removed when support for v1beta1 will be dropped. Please see <https://github.com/kubernetes-sigs/cluster-api/blob/main/docs/proposals/20240916-improve-status-in-CAPI-resources.md> for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureMessage")]
    pub failure_message: Option<String>,
    /// failureReason indicates that there is a fatal problem reconciling the
    /// state, and will be set to a token value suitable for
    /// programmatic interpretation.
    /// 
    /// Deprecated: This field is deprecated and is going to be removed when support for v1beta1 will be dropped. Please see <https://github.com/kubernetes-sigs/cluster-api/blob/main/docs/proposals/20240916-improve-status-in-CAPI-resources.md> for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureReason")]
    pub failure_reason: Option<String>,
}

/// FailureDomain is the Schema for Cluster API failure domains.
/// It allows controllers to understand how many failure domains a cluster can optionally span across.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterStatusFailureDomains {
    /// attributes is a free form map of attributes an infrastructure provider might use or require.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attributes: Option<BTreeMap<String, String>>,
    /// controlPlane determines if this failure domain is suitable for use by control plane machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlane")]
    pub control_plane: Option<bool>,
    /// name is the name of the failure domain.
    pub name: String,
}

/// initialization provides observations of the Cluster initialization process.
/// NOTE: Fields in this struct are part of the Cluster API contract and are used to orchestrate initial Cluster provisioning.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterStatusInitialization {
    /// controlPlaneInitialized denotes when the control plane is functional enough to accept requests.
    /// This information is usually used as a signal for starting all the provisioning operations that depends on
    /// a functional API server, but do not require a full HA control plane to exists, like e.g. join worker Machines,
    /// install core addons like CNI, CPI, CSI etc.
    /// NOTE: this field is part of the Cluster API contract, and it is used to orchestrate provisioning.
    /// The value of this field is never updated after initialization is completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlaneInitialized")]
    pub control_plane_initialized: Option<bool>,
    /// infrastructureProvisioned is true when the infrastructure provider reports that Cluster's infrastructure is fully provisioned.
    /// NOTE: this field is part of the Cluster API contract, and it is used to orchestrate provisioning.
    /// The value of this field is never updated after provisioning is completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infrastructureProvisioned")]
    pub infrastructure_provisioned: Option<bool>,
}

/// status is the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterStatusPhase {
    Pending,
    Provisioning,
    Provisioned,
    Deleting,
    Failed,
    Unknown,
}

/// workers groups all the observations about Cluster's Workers current state.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterStatusWorkers {
    /// availableReplicas is the total number of available worker machines in this cluster. A machine is considered available when Machine's Available condition is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableReplicas")]
    pub available_replicas: Option<i32>,
    /// desiredReplicas is the total number of desired worker machines in this cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "desiredReplicas")]
    pub desired_replicas: Option<i32>,
    /// readyReplicas is the total number of ready worker machines in this cluster. A machine is considered ready when Machine's Ready condition is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readyReplicas")]
    pub ready_replicas: Option<i32>,
    /// replicas is the total number of worker machines in this cluster.
    /// NOTE: replicas also includes machines still being provisioned or being deleted.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// upToDateReplicas is the number of up-to-date worker machines in this cluster. A machine is considered up-to-date when Machine's UpToDate condition is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upToDateReplicas")]
    pub up_to_date_replicas: Option<i32>,
}

