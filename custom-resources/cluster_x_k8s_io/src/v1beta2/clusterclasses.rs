// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/kubernetes-sigs/cluster-api/cluster.x-k8s.io/v1beta2/clusterclasses.yaml
// kopium version: 0.22.4

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// spec is the desired state of ClusterClass.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "cluster.x-k8s.io", version = "v1beta2", kind = "ClusterClass", plural = "clusterclasses")]
#[kube(namespaced)]
#[kube(status = "ClusterClassStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClusterClassSpec {
    /// availabilityGates specifies additional conditions to include when evaluating Cluster Available condition.
    /// 
    /// NOTE: If a Cluster is using this ClusterClass, and this Cluster defines a custom list of availabilityGates,
    /// such list overrides availabilityGates defined in this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityGates")]
    pub availability_gates: Option<Vec<ClusterClassAvailabilityGates>>,
    /// controlPlane is a reference to a local struct that holds the details
    /// for provisioning the Control Plane for the Cluster.
    #[serde(rename = "controlPlane")]
    pub control_plane: ClusterClassControlPlane,
    /// infrastructure is a reference to a local struct that holds the details
    /// for provisioning the infrastructure cluster for the Cluster.
    pub infrastructure: ClusterClassInfrastructure,
    /// kubernetesVersions is the list of Kubernetes versions that can be
    /// used for clusters using this ClusterClass.
    /// The list of version must be ordered from the older to the newer version, and there should be
    /// at least one version for every minor in between the first and the last version.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesVersions")]
    pub kubernetes_versions: Option<Vec<String>>,
    /// patches defines the patches which are applied to customize
    /// referenced templates of a ClusterClass.
    /// Note: Patches will be applied in the order of the array.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patches: Option<Vec<ClusterClassPatches>>,
    /// variables defines the variables which can be configured
    /// in the Cluster topology and are then used in patches.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<ClusterClassVariables>>,
    /// workers describes the worker nodes for the cluster.
    /// It is a collection of node types which can be used to create
    /// the worker nodes of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<ClusterClassWorkers>,
}

/// ClusterAvailabilityGate contains the type of a Cluster condition to be used as availability gate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassAvailabilityGates {
    /// conditionType refers to a condition with matching type in the Cluster's condition list.
    /// If the conditions doesn't exist, it will be treated as unknown.
    /// Note: Both Cluster API conditions or conditions added by 3rd party controllers can be used as availability gates.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
    /// polarity of the conditionType specified in this availabilityGate.
    /// Valid values are Positive, Negative and omitted.
    /// When omitted, the default behaviour will be Positive.
    /// A positive polarity means that the condition should report a true status under normal conditions.
    /// A negative polarity means that the condition should report a false status under normal conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub polarity: Option<ClusterClassAvailabilityGatesPolarity>,
}

/// ClusterAvailabilityGate contains the type of a Cluster condition to be used as availability gate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassAvailabilityGatesPolarity {
    Positive,
    Negative,
}

/// controlPlane is a reference to a local struct that holds the details
/// for provisioning the Control Plane for the Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlane {
    /// deletion contains configuration options for Machine deletion.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deletion: Option<ClusterClassControlPlaneDeletion>,
    /// healthCheck defines a MachineHealthCheck for this ControlPlaneClass.
    /// This field is supported if and only if the ControlPlane provider template
    /// referenced above is Machine based and supports setting replicas.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<ClusterClassControlPlaneHealthCheck>,
    /// machineInfrastructure defines the metadata and infrastructure information
    /// for control plane machines.
    /// 
    /// This field is supported if and only if the control plane provider template
    /// referenced above is Machine based and supports setting replicas.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineInfrastructure")]
    pub machine_infrastructure: Option<ClusterClassControlPlaneMachineInfrastructure>,
    /// metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane
    /// if the ControlPlaneTemplate referenced is machine based. If not, it is applied only to the
    /// ControlPlane.
    /// At runtime this metadata is merged with the corresponding metadata from the topology.
    /// 
    /// This field is supported if and only if the control plane provider template
    /// referenced is Machine based.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterClassControlPlaneMetadata>,
    /// naming allows changing the naming pattern used when creating the control plane provider object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub naming: Option<ClusterClassControlPlaneNaming>,
    /// readinessGates specifies additional conditions to include when evaluating Machine Ready condition.
    /// 
    /// This field can be used e.g. to instruct the machine controller to include in the computation for Machine's ready
    /// computation a condition, managed by an external controllers, reporting the status of special software/hardware installed on the Machine.
    /// 
    /// NOTE: If a Cluster defines a custom list of readinessGates for the control plane,
    /// such list overrides readinessGates defined in this field.
    /// NOTE: Specific control plane provider implementations might automatically extend the list of readinessGates;
    /// e.g. the kubeadm control provider adds ReadinessGates for the APIServerPodHealthy, SchedulerPodHealthy conditions, etc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<ClusterClassControlPlaneReadinessGates>>,
    /// templateRef contains the reference to a provider-specific control plane template.
    #[serde(rename = "templateRef")]
    pub template_ref: ClusterClassControlPlaneTemplateRef,
}

/// deletion contains configuration options for Machine deletion.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneDeletion {
    /// nodeDeletionTimeoutSeconds defines how long the controller will attempt to delete the Node that the Machine
    /// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// Defaults to 10 seconds.
    /// NOTE: This value can be overridden while defining a Cluster.Topology.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeoutSeconds")]
    pub node_deletion_timeout_seconds: Option<i32>,
    /// nodeDrainTimeoutSeconds is the total amount of time that the controller will spend on draining a node.
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain --timeout`
    /// NOTE: This value can be overridden while defining a Cluster.Topology.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeoutSeconds")]
    pub node_drain_timeout_seconds: Option<i32>,
    /// nodeVolumeDetachTimeoutSeconds is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    /// NOTE: This value can be overridden while defining a Cluster.Topology.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeoutSeconds")]
    pub node_volume_detach_timeout_seconds: Option<i32>,
}

/// healthCheck defines a MachineHealthCheck for this ControlPlaneClass.
/// This field is supported if and only if the ControlPlane provider template
/// referenced above is Machine based and supports setting replicas.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneHealthCheck {
    /// checks are the checks that are used to evaluate if a Machine is healthy.
    /// 
    /// Independent of this configuration the MachineHealthCheck controller will always
    /// flag Machines with `cluster.x-k8s.io/remediate-machine` annotation and
    /// Machines with deleted Nodes as unhealthy.
    /// 
    /// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
    /// is defaulted to 10 minutes and evaluated accordingly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<ClusterClassControlPlaneHealthCheckChecks>,
    /// remediation configures if and how remediations are triggered if a Machine is unhealthy.
    /// 
    /// If remediation or remediation.triggerIf is not set,
    /// remediation will always be triggered for unhealthy Machines.
    /// 
    /// If remediation or remediation.templateRef is not set,
    /// the OwnerRemediated condition will be set on unhealthy Machines to trigger remediation via
    /// the owner of the Machines, for example a MachineSet or a KubeadmControlPlane.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remediation: Option<ClusterClassControlPlaneHealthCheckRemediation>,
}

/// checks are the checks that are used to evaluate if a Machine is healthy.
/// 
/// Independent of this configuration the MachineHealthCheck controller will always
/// flag Machines with `cluster.x-k8s.io/remediate-machine` annotation and
/// Machines with deleted Nodes as unhealthy.
/// 
/// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
/// is defaulted to 10 minutes and evaluated accordingly.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneHealthCheckChecks {
    /// nodeStartupTimeoutSeconds allows to set the maximum time for MachineHealthCheck
    /// to consider a Machine unhealthy if a corresponding Node isn't associated
    /// through a `Spec.ProviderID` field.
    /// 
    /// The duration set in this field is compared to the greatest of:
    /// - Cluster's infrastructure ready condition timestamp (if and when available)
    /// - Control Plane's initialized condition timestamp (if and when available)
    /// - Machine's infrastructure ready condition timestamp (if and when available)
    /// - Machine's metadata creation timestamp
    /// 
    /// Defaults to 10 minutes.
    /// If you wish to disable this feature, set the value explicitly to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeStartupTimeoutSeconds")]
    pub node_startup_timeout_seconds: Option<i32>,
    /// unhealthyNodeConditions contains a list of conditions that determine
    /// whether a node is considered unhealthy. The conditions are combined in a
    /// logical OR, i.e. if any of the conditions is met, the node is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyNodeConditions")]
    pub unhealthy_node_conditions: Option<Vec<ClusterClassControlPlaneHealthCheckChecksUnhealthyNodeConditions>>,
}

/// UnhealthyNodeCondition represents a Node condition type and value with a timeout
/// specified as a duration.  When the named condition has been in the given
/// status for at least the timeout value, a node is considered unhealthy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneHealthCheckChecksUnhealthyNodeConditions {
    /// status of the condition, one of True, False, Unknown.
    pub status: String,
    /// timeoutSeconds is the duration that a node must be in a given status for,
    /// after which the node is considered unhealthy.
    /// For example, with a value of "1h", the node must match the status
    /// for at least 1 hour before being considered unhealthy.
    #[serde(rename = "timeoutSeconds")]
    pub timeout_seconds: i32,
    /// type of Node condition
    #[serde(rename = "type")]
    pub r#type: String,
}

/// remediation configures if and how remediations are triggered if a Machine is unhealthy.
/// 
/// If remediation or remediation.triggerIf is not set,
/// remediation will always be triggered for unhealthy Machines.
/// 
/// If remediation or remediation.templateRef is not set,
/// the OwnerRemediated condition will be set on unhealthy Machines to trigger remediation via
/// the owner of the Machines, for example a MachineSet or a KubeadmControlPlane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneHealthCheckRemediation {
    /// templateRef is a reference to a remediation template
    /// provided by an infrastructure provider.
    /// 
    /// This field is completely optional, when filled, the MachineHealthCheck controller
    /// creates a new object from the template referenced and hands off remediation of the machine to
    /// a controller that lives outside of Cluster API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateRef")]
    pub template_ref: Option<ClusterClassControlPlaneHealthCheckRemediationTemplateRef>,
    /// triggerIf configures if remediations are triggered.
    /// If this field is not set, remediations are always triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerIf")]
    pub trigger_if: Option<ClusterClassControlPlaneHealthCheckRemediationTriggerIf>,
}

/// templateRef is a reference to a remediation template
/// provided by an infrastructure provider.
/// 
/// This field is completely optional, when filled, the MachineHealthCheck controller
/// creates a new object from the template referenced and hands off remediation of the machine to
/// a controller that lives outside of Cluster API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneHealthCheckRemediationTemplateRef {
    /// apiVersion of the remediation template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    /// NOTE: This field must be kept in sync with the APIVersion of the remediation template.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the remediation template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the remediation template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// triggerIf configures if remediations are triggered.
/// If this field is not set, remediations are always triggered.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneHealthCheckRemediationTriggerIf {
    /// unhealthyInRange specifies that remediations are only triggered if the number of
    /// unhealthy Machines is in the configured range.
    /// Takes precedence over unhealthyLessThanOrEqualTo.
    /// Eg. "[3-5]" - This means that remediation will be allowed only when:
    /// (a) there are at least 3 unhealthy Machines (and)
    /// (b) there are at most 5 unhealthy Machines
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyInRange")]
    pub unhealthy_in_range: Option<String>,
    /// unhealthyLessThanOrEqualTo specifies that remediations are only triggered if the number of
    /// unhealthy Machines is less than or equal to the configured value.
    /// unhealthyInRange takes precedence if set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyLessThanOrEqualTo")]
    pub unhealthy_less_than_or_equal_to: Option<IntOrString>,
}

/// machineInfrastructure defines the metadata and infrastructure information
/// for control plane machines.
/// 
/// This field is supported if and only if the control plane provider template
/// referenced above is Machine based and supports setting replicas.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneMachineInfrastructure {
    /// templateRef is a required reference to the template for a MachineInfrastructure of a ControlPlane.
    #[serde(rename = "templateRef")]
    pub template_ref: ClusterClassControlPlaneMachineInfrastructureTemplateRef,
}

/// templateRef is a required reference to the template for a MachineInfrastructure of a ControlPlane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneMachineInfrastructureTemplateRef {
    /// apiVersion of the template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane
/// if the ControlPlaneTemplate referenced is machine based. If not, it is applied only to the
/// ControlPlane.
/// At runtime this metadata is merged with the corresponding metadata from the topology.
/// 
/// This field is supported if and only if the control plane provider template
/// referenced is Machine based.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneMetadata {
    /// annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <http://kubernetes.io/docs/user-guide/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <http://kubernetes.io/docs/user-guide/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// naming allows changing the naming pattern used when creating the control plane provider object.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneNaming {
    /// template defines the template to use for generating the name of the ControlPlane object.
    /// If not defined, it will fallback to `{{ .cluster.name }}-{{ .random }}`.
    /// If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will
    /// get concatenated with a random suffix of length 5.
    /// The templating mechanism provides the following arguments:
    /// * `.cluster.name`: The name of the cluster object.
    /// * `.random`: A random alphanumeric string, without vowels, of length 5.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneReadinessGates {
    /// conditionType refers to a condition with matching type in the Machine's condition list.
    /// If the conditions doesn't exist, it will be treated as unknown.
    /// Note: Both Cluster API conditions or conditions added by 3rd party controllers can be used as readiness gates.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
    /// polarity of the conditionType specified in this readinessGate.
    /// Valid values are Positive, Negative and omitted.
    /// When omitted, the default behaviour will be Positive.
    /// A positive polarity means that the condition should report a true status under normal conditions.
    /// A negative polarity means that the condition should report a false status under normal conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub polarity: Option<ClusterClassControlPlaneReadinessGatesPolarity>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassControlPlaneReadinessGatesPolarity {
    Positive,
    Negative,
}

/// templateRef contains the reference to a provider-specific control plane template.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassControlPlaneTemplateRef {
    /// apiVersion of the template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// infrastructure is a reference to a local struct that holds the details
/// for provisioning the infrastructure cluster for the Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassInfrastructure {
    /// naming allows changing the naming pattern used when creating the infrastructure cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub naming: Option<ClusterClassInfrastructureNaming>,
    /// templateRef contains the reference to a provider-specific infrastructure cluster template.
    #[serde(rename = "templateRef")]
    pub template_ref: ClusterClassInfrastructureTemplateRef,
}

/// naming allows changing the naming pattern used when creating the infrastructure cluster object.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassInfrastructureNaming {
    /// template defines the template to use for generating the name of the Infrastructure object.
    /// If not defined, it will fallback to `{{ .cluster.name }}-{{ .random }}`.
    /// If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will
    /// get concatenated with a random suffix of length 5.
    /// The templating mechanism provides the following arguments:
    /// * `.cluster.name`: The name of the cluster object.
    /// * `.random`: A random alphanumeric string, without vowels, of length 5.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
}

/// templateRef contains the reference to a provider-specific infrastructure cluster template.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassInfrastructureTemplateRef {
    /// apiVersion of the template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// ClusterClassPatch defines a patch which is applied to customize the referenced templates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassPatches {
    /// definitions define inline patches.
    /// Note: Patches will be applied in the order of the array.
    /// Note: Exactly one of Definitions or External must be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub definitions: Option<Vec<ClusterClassPatchesDefinitions>>,
    /// description is a human-readable description of this patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// enabledIf is a Go template to be used to calculate if a patch should be enabled.
    /// It can reference variables defined in .spec.variables and builtin variables.
    /// The patch will be enabled if the template evaluates to `true`, otherwise it will
    /// be disabled.
    /// If EnabledIf is not set, the patch will be enabled per default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enabledIf")]
    pub enabled_if: Option<String>,
    /// external defines an external patch.
    /// Note: Exactly one of Definitions or External must be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub external: Option<ClusterClassPatchesExternal>,
    /// name of the patch.
    pub name: String,
}

/// PatchDefinition defines a patch which is applied to customize the referenced templates.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassPatchesDefinitions {
    /// jsonPatches defines the patches which should be applied on the templates
    /// matching the selector.
    /// Note: Patches will be applied in the order of the array.
    #[serde(rename = "jsonPatches")]
    pub json_patches: Vec<ClusterClassPatchesDefinitionsJsonPatches>,
    /// selector defines on which templates the patch should be applied.
    pub selector: ClusterClassPatchesDefinitionsSelector,
}

/// JSONPatch defines a JSON patch.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterClassPatchesDefinitionsJsonPatches {
    /// op defines the operation of the patch.
    /// Note: Only `add`, `replace` and `remove` are supported.
    pub op: ClusterClassPatchesDefinitionsJsonPatchesOp,
    /// path defines the path of the patch.
    /// Note: Only the spec of a template can be patched, thus the path has to start with /spec/.
    /// Note: For now the only allowed array modifications are `append` and `prepend`, i.e.:
    /// * for op: `add`: only index 0 (prepend) and - (append) are allowed
    /// * for op: `replace` or `remove`: no indexes are allowed
    pub path: String,
    /// value defines the value of the patch.
    /// Note: Either Value or ValueFrom is required for add and replace
    /// operations. Only one of them is allowed to be set at the same time.
    /// Note: We have to use apiextensionsv1.JSON instead of our JSON type,
    /// because controller-tools has a hard-coded schema for apiextensionsv1.JSON
    /// which cannot be produced by another type (unset type field).
    /// Ref: <https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
    /// valueFrom defines the value of the patch.
    /// Note: Either Value or ValueFrom is required for add and replace
    /// operations. Only one of them is allowed to be set at the same time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClusterClassPatchesDefinitionsJsonPatchesValueFrom>,
}

/// JSONPatch defines a JSON patch.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassPatchesDefinitionsJsonPatchesOp {
    #[serde(rename = "add")]
    Add,
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "remove")]
    Remove,
}

/// valueFrom defines the value of the patch.
/// Note: Either Value or ValueFrom is required for add and replace
/// operations. Only one of them is allowed to be set at the same time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassPatchesDefinitionsJsonPatchesValueFrom {
    /// template is the Go template to be used to calculate the value.
    /// A template can reference variables defined in .spec.variables and builtin variables.
    /// Note: The template must evaluate to a valid YAML or JSON value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
    /// variable is the variable to be used as value.
    /// Variable can be one of the variables defined in .spec.variables or a builtin variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variable: Option<String>,
}

/// selector defines on which templates the patch should be applied.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassPatchesDefinitionsSelector {
    /// apiVersion filters templates by apiVersion.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind filters templates by kind.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// matchResources selects templates based on where they are referenced.
    #[serde(rename = "matchResources")]
    pub match_resources: ClusterClassPatchesDefinitionsSelectorMatchResources,
}

/// matchResources selects templates based on where they are referenced.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassPatchesDefinitionsSelectorMatchResources {
    /// controlPlane selects templates referenced in .spec.ControlPlane.
    /// Note: this will match the controlPlane and also the controlPlane
    /// machineInfrastructure (depending on the kind and apiVersion).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlane")]
    pub control_plane: Option<bool>,
    /// infrastructureCluster selects templates referenced in .spec.infrastructure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infrastructureCluster")]
    pub infrastructure_cluster: Option<bool>,
    /// machineDeploymentClass selects templates referenced in specific MachineDeploymentClasses in
    /// .spec.workers.machineDeployments.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineDeploymentClass")]
    pub machine_deployment_class: Option<ClusterClassPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClass>,
    /// machinePoolClass selects templates referenced in specific MachinePoolClasses in
    /// .spec.workers.machinePools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machinePoolClass")]
    pub machine_pool_class: Option<ClusterClassPatchesDefinitionsSelectorMatchResourcesMachinePoolClass>,
}

/// machineDeploymentClass selects templates referenced in specific MachineDeploymentClasses in
/// .spec.workers.machineDeployments.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClass {
    /// names selects templates by class names.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
}

/// machinePoolClass selects templates referenced in specific MachinePoolClasses in
/// .spec.workers.machinePools.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassPatchesDefinitionsSelectorMatchResourcesMachinePoolClass {
    /// names selects templates by class names.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub names: Option<Vec<String>>,
}

/// external defines an external patch.
/// Note: Exactly one of Definitions or External must be set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassPatchesExternal {
    /// discoverVariablesExtension references an extension which is called to discover variables.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "discoverVariablesExtension")]
    pub discover_variables_extension: Option<String>,
    /// generatePatchesExtension references an extension which is called to generate patches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generatePatchesExtension")]
    pub generate_patches_extension: Option<String>,
    /// settings defines key value pairs to be passed to the extensions.
    /// Values defined here take precedence over the values defined in the
    /// corresponding ExtensionConfig.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, String>>,
    /// validateTopologyExtension references an extension which is called to validate the topology.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "validateTopologyExtension")]
    pub validate_topology_extension: Option<String>,
}

/// ClusterClassVariable defines a variable which can
/// be configured in the Cluster topology and used in patches.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassVariables {
    /// deprecatedV1Beta1Metadata is the metadata of a variable.
    /// It can be used to add additional data for higher level tools to
    /// a ClusterClassVariable.
    /// 
    /// Deprecated: This field is deprecated and will be removed when support for v1beta1 will be dropped. Please use XMetadata in JSONSchemaProps instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deprecatedV1Beta1Metadata")]
    pub deprecated_v1_beta1_metadata: Option<ClusterClassVariablesDeprecatedV1Beta1Metadata>,
    /// name of the variable.
    pub name: String,
    /// required specifies if the variable is required.
    /// Note: this applies to the variable as a whole and thus the
    /// top-level object defined in the schema. If nested fields are
    /// required, this will be specified inside the schema.
    pub required: bool,
    /// schema defines the schema of the variable.
    pub schema: ClusterClassVariablesSchema,
}

/// deprecatedV1Beta1Metadata is the metadata of a variable.
/// It can be used to add additional data for higher level tools to
/// a ClusterClassVariable.
/// 
/// Deprecated: This field is deprecated and will be removed when support for v1beta1 will be dropped. Please use XMetadata in JSONSchemaProps instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassVariablesDeprecatedV1Beta1Metadata {
    /// annotations is an unstructured key value map that can be used to store and
    /// retrieve arbitrary metadata.
    /// They are not queryable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// schema defines the schema of the variable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassVariablesSchema {
    /// openAPIV3Schema defines the schema of a variable via OpenAPI v3
    /// schema. The schema is a subset of the schema used in
    /// Kubernetes CRDs.
    #[serde(rename = "openAPIV3Schema")]
    pub open_apiv3_schema: ClusterClassVariablesSchemaOpenApiv3Schema,
}

/// openAPIV3Schema defines the schema of a variable via OpenAPI v3
/// schema. The schema is a subset of the schema used in
/// Kubernetes CRDs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassVariablesSchemaOpenApiv3Schema {
    /// additionalProperties specifies the schema of values in a map (keys are always strings).
    /// NOTE: Can only be set if type is object.
    /// NOTE: AdditionalProperties is mutually exclusive with Properties.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalProperties")]
    pub additional_properties: Option<serde_json::Value>,
    /// allOf specifies that the variable must validate against all of the subschemas in the array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allOf")]
    pub all_of: Option<serde_json::Value>,
    /// anyOf specifies that the variable must validate against one or more of the subschemas in the array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "anyOf")]
    pub any_of: Option<serde_json::Value>,
    /// default is the default value of the variable.
    /// NOTE: Can be set for all types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    /// description is a human-readable description of this variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// enum is the list of valid values of the variable.
    /// NOTE: Can be set for all types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enum")]
    pub r#enum: Option<Vec<serde_json::Value>>,
    /// example is an example for this variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub example: Option<serde_json::Value>,
    /// exclusiveMaximum specifies if the Maximum is exclusive.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusiveMaximum")]
    pub exclusive_maximum: Option<bool>,
    /// exclusiveMinimum specifies if the Minimum is exclusive.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusiveMinimum")]
    pub exclusive_minimum: Option<bool>,
    /// format is an OpenAPI v3 format string. Unknown formats are ignored.
    /// For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using)
    /// <https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go>
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
    /// items specifies fields of an array.
    /// NOTE: Can only be set if type is array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<serde_json::Value>,
    /// maxItems is the max length of an array variable.
    /// NOTE: Can only be set if type is array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxItems")]
    pub max_items: Option<i64>,
    /// maxLength is the max length of a string variable.
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLength")]
    pub max_length: Option<i64>,
    /// maxProperties is the maximum amount of entries in a map or properties in an object.
    /// NOTE: Can only be set if type is object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxProperties")]
    pub max_properties: Option<i64>,
    /// maximum is the maximum of an integer or number variable.
    /// If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum.
    /// If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum: Option<i64>,
    /// minItems is the min length of an array variable.
    /// NOTE: Can only be set if type is array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minItems")]
    pub min_items: Option<i64>,
    /// minLength is the min length of a string variable.
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLength")]
    pub min_length: Option<i64>,
    /// minProperties is the minimum amount of entries in a map or properties in an object.
    /// NOTE: Can only be set if type is object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minProperties")]
    pub min_properties: Option<i64>,
    /// minimum is the minimum of an integer or number variable.
    /// If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum.
    /// If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minimum: Option<i64>,
    /// not specifies that the variable must not validate against the subschema.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<serde_json::Value>,
    /// oneOf specifies that the variable must validate against exactly one of the subschemas in the array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oneOf")]
    pub one_of: Option<serde_json::Value>,
    /// pattern is the regex which a string variable must match.
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    /// properties specifies fields of an object.
    /// NOTE: Can only be set if type is object.
    /// NOTE: Properties is mutually exclusive with AdditionalProperties.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<serde_json::Value>,
    /// required specifies which fields of an object are required.
    /// NOTE: Can only be set if type is object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required: Option<Vec<String>>,
    /// type is the type of the variable.
    /// Valid values are: object, array, string, integer, number or boolean.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ClusterClassVariablesSchemaOpenApiv3SchemaType>,
    /// uniqueItems specifies if items in an array must be unique.
    /// NOTE: Can only be set if type is array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "uniqueItems")]
    pub unique_items: Option<bool>,
    /// x-kubernetes-int-or-string specifies that this value is
    /// either an integer or a string. If this is true, an empty
    /// type is allowed and type as child of anyOf is permitted
    /// if following one of the following patterns:
    /// 
    /// 1) anyOf:
    ///    - type: integer
    ///    - type: string
    /// 2) allOf:
    ///    - anyOf:
    ///      - type: integer
    ///      - type: string
    ///    - ... zero or more
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-kubernetes-int-or-string")]
    pub x_kubernetes_int_or_string: Option<bool>,
    /// x-kubernetes-preserve-unknown-fields allows setting fields in a variable object
    /// which are not defined in the variable schema. This affects fields recursively,
    /// except if nested properties or additionalProperties are specified in the schema.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-kubernetes-preserve-unknown-fields")]
    pub x_kubernetes_preserve_unknown_fields: Option<bool>,
    /// x-kubernetes-validations describes a list of validation rules written in the CEL expression language.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-kubernetes-validations")]
    pub x_kubernetes_validations: Option<Vec<ClusterClassVariablesSchemaOpenApiv3SchemaXKubernetesValidations>>,
    /// x-metadata is the metadata of a variable or a nested field within a variable.
    /// It can be used to add additional data for higher level tools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-metadata")]
    pub x_metadata: Option<ClusterClassVariablesSchemaOpenApiv3SchemaXMetadata>,
}

/// openAPIV3Schema defines the schema of a variable via OpenAPI v3
/// schema. The schema is a subset of the schema used in
/// Kubernetes CRDs.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassVariablesSchemaOpenApiv3SchemaType {
    #[serde(rename = "object")]
    Object,
    #[serde(rename = "array")]
    Array,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "integer")]
    Integer,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "boolean")]
    Boolean,
}

/// ValidationRule describes a validation rule written in the CEL expression language.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassVariablesSchemaOpenApiv3SchemaXKubernetesValidations {
    /// fieldPath represents the field path returned when the validation fails.
    /// It must be a relative JSON path (i.e. with array notation) scoped to the location of this x-kubernetes-validations extension in the schema and refer to an existing field.
    /// e.g. when validation checks if a specific attribute `foo` under a map `testMap`, the fieldPath could be set to `.testMap.foo`
    /// If the validation checks two lists must have unique attributes, the fieldPath could be set to either of the list: e.g. `.testList`
    /// It does not support list numeric index.
    /// It supports child operation to refer to an existing field currently. Refer to [JSONPath support in Kubernetes](<https://kubernetes.io/docs/reference/kubectl/jsonpath/)> for more info.
    /// Numeric index of array is not supported.
    /// For field name which contains special characters, use `['specialName']` to refer the field name.
    /// e.g. for attribute `foo.34$` appears in a list `testList`, the fieldPath could be set to `.testList['foo.34$']`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// message represents the message displayed when validation fails. The message is required if the Rule contains
    /// line breaks. The message must not contain line breaks.
    /// If unset, the message is "failed rule: {Rule}".
    /// e.g. "must be a URL with the host matching spec.host"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
    /// Since messageExpression is used as a failure message, it must evaluate to a string.
    /// If both message and messageExpression are present on a rule, then messageExpression will be used if validation
    /// fails. If messageExpression results in a runtime error, the validation failure message is produced
    /// as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
    /// that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset.
    /// messageExpression has access to all the same variables as the rule; the only difference is the return type.
    /// Example:
    /// "x must be less than max ("+string(self.max)+")"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageExpression")]
    pub message_expression: Option<String>,
    /// reason provides a machine-readable validation failure reason that is returned to the caller when a request fails this validation rule.
    /// The currently supported reasons are: "FieldValueInvalid", "FieldValueForbidden", "FieldValueRequired", "FieldValueDuplicate".
    /// If not set, default to use "FieldValueInvalid".
    /// All future added reasons must be accepted by clients when reading this value and unknown reasons should be treated as FieldValueInvalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<ClusterClassVariablesSchemaOpenApiv3SchemaXKubernetesValidationsReason>,
    /// rule represents the expression which will be evaluated by CEL.
    /// ref: <https://github.com/google/cel-spec>
    /// The Rule is scoped to the location of the x-kubernetes-validations extension in the schema.
    /// The `self` variable in the CEL expression is bound to the scoped value.
    /// If the Rule is scoped to an object with properties, the accessible properties of the object are field selectable
    /// via `self.field` and field presence can be checked via `has(self.field)`.
    /// If the Rule is scoped to an object with additionalProperties (i.e. a map) the value of the map
    /// are accessible via `self[mapKey]`, map containment can be checked via `mapKey in self` and all entries of the map
    /// are accessible via CEL macros and functions such as `self.all(...)`.
    /// If the Rule is scoped to an array, the elements of the array are accessible via `self[i]` and also by macros and
    /// functions.
    /// If the Rule is scoped to a scalar, `self` is bound to the scalar value.
    /// Examples:
    /// - Rule scoped to a map of objects: {"rule": "self.components['Widget'].priority < 10"}
    /// - Rule scoped to a list of integers: {"rule": "self.values.all(value, value >= 0 && value < 100)"}
    /// - Rule scoped to a string value: {"rule": "self.startsWith('kube')"}
    /// 
    /// Unknown data preserved in custom resources via x-kubernetes-preserve-unknown-fields is not accessible in CEL
    /// expressions. This includes:
    /// - Unknown field values that are preserved by object schemas with x-kubernetes-preserve-unknown-fields.
    /// - Object properties where the property schema is of an "unknown type". An "unknown type" is recursively defined as:
    ///   - A schema with no type and x-kubernetes-preserve-unknown-fields set to true
    ///   - An array where the items schema is of an "unknown type"
    ///   - An object where the additionalProperties schema is of an "unknown type"
    /// 
    /// Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
    /// Accessible property names are escaped according to the following rules when accessed in the expression:
    /// - '__' escapes to '__underscores__'
    /// - '.' escapes to '__dot__'
    /// - '-' escapes to '__dash__'
    /// - '/' escapes to '__slash__'
    /// - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
    /// 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
    /// 	  "import", "let", "loop", "package", "namespace", "return".
    /// Examples:
    ///   - Rule accessing a property named "namespace": {"rule": "self.__namespace__ > 0"}
    ///   - Rule accessing a property named "x-prop": {"rule": "self.x__dash__prop > 0"}
    ///   - Rule accessing a property named "redact__d": {"rule": "self.redact__underscores__d > 0"}
    /// 
    /// If `rule` makes use of the `oldSelf` variable it is implicitly a
    /// `transition rule`.
    /// 
    /// By default, the `oldSelf` variable is the same type as `self`.
    /// 
    /// Transition rules by default are applied only on UPDATE requests and are
    /// skipped if an old value could not be found.
    pub rule: String,
}

/// ValidationRule describes a validation rule written in the CEL expression language.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassVariablesSchemaOpenApiv3SchemaXKubernetesValidationsReason {
    FieldValueInvalid,
    FieldValueForbidden,
    FieldValueRequired,
    FieldValueDuplicate,
}

/// x-metadata is the metadata of a variable or a nested field within a variable.
/// It can be used to add additional data for higher level tools.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassVariablesSchemaOpenApiv3SchemaXMetadata {
    /// annotations is an unstructured key value map that can be used to store and
    /// retrieve arbitrary metadata.
    /// They are not queryable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// workers describes the worker nodes for the cluster.
/// It is a collection of node types which can be used to create
/// the worker nodes of the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkers {
    /// machineDeployments is a list of machine deployment classes that can be used to create
    /// a set of worker nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineDeployments")]
    pub machine_deployments: Option<Vec<ClusterClassWorkersMachineDeployments>>,
    /// machinePools is a list of machine pool classes that can be used to create
    /// a set of worker nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machinePools")]
    pub machine_pools: Option<Vec<ClusterClassWorkersMachinePools>>,
}

/// MachineDeploymentClass serves as a template to define a set of worker nodes of the cluster
/// provisioned using the `ClusterClass`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeployments {
    /// bootstrap contains the bootstrap template reference to be used
    /// for the creation of worker Machines.
    pub bootstrap: ClusterClassWorkersMachineDeploymentsBootstrap,
    /// class denotes a type of worker node present in the cluster,
    /// this name MUST be unique within a ClusterClass and can be referenced
    /// in the Cluster to create a managed MachineDeployment.
    pub class: String,
    /// deletion contains configuration options for Machine deletion.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deletion: Option<ClusterClassWorkersMachineDeploymentsDeletion>,
    /// failureDomain is the failure domain the machines will be created in.
    /// Must match the name of a FailureDomain from the Cluster status.
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomain")]
    pub failure_domain: Option<String>,
    /// healthCheck defines a MachineHealthCheck for this MachineDeploymentClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheck")]
    pub health_check: Option<ClusterClassWorkersMachineDeploymentsHealthCheck>,
    /// infrastructure contains the infrastructure template reference to be used
    /// for the creation of worker Machines.
    pub infrastructure: ClusterClassWorkersMachineDeploymentsInfrastructure,
    /// metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment.
    /// At runtime this metadata is merged with the corresponding metadata from the topology.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterClassWorkersMachineDeploymentsMetadata>,
    /// minReadySeconds is the minimum number of seconds for which a newly created machine should
    /// be ready.
    /// Defaults to 0 (machine will be considered available as soon as it
    /// is ready)
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// naming allows changing the naming pattern used when creating the MachineDeployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub naming: Option<ClusterClassWorkersMachineDeploymentsNaming>,
    /// readinessGates specifies additional conditions to include when evaluating Machine Ready condition.
    /// 
    /// This field can be used e.g. to instruct the machine controller to include in the computation for Machine's ready
    /// computation a condition, managed by an external controllers, reporting the status of special software/hardware installed on the Machine.
    /// 
    /// NOTE: If a Cluster defines a custom list of readinessGates for a MachineDeployment using this MachineDeploymentClass,
    /// such list overrides readinessGates defined in this field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<ClusterClassWorkersMachineDeploymentsReadinessGates>>,
    /// rollout allows you to configure the behaviour of rolling updates to the MachineDeployment Machines.
    /// It allows you to define the strategy used during rolling replacements.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rollout: Option<ClusterClassWorkersMachineDeploymentsRollout>,
}

/// bootstrap contains the bootstrap template reference to be used
/// for the creation of worker Machines.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsBootstrap {
    /// templateRef is a required reference to the BootstrapTemplate for a MachineDeployment.
    #[serde(rename = "templateRef")]
    pub template_ref: ClusterClassWorkersMachineDeploymentsBootstrapTemplateRef,
}

/// templateRef is a required reference to the BootstrapTemplate for a MachineDeployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsBootstrapTemplateRef {
    /// apiVersion of the template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// deletion contains configuration options for Machine deletion.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsDeletion {
    /// nodeDeletionTimeoutSeconds defines how long the controller will attempt to delete the Node that the Machine
    /// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// Defaults to 10 seconds.
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeoutSeconds")]
    pub node_deletion_timeout_seconds: Option<i32>,
    /// nodeDrainTimeoutSeconds is the total amount of time that the controller will spend on draining a node.
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain --timeout`
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeoutSeconds")]
    pub node_drain_timeout_seconds: Option<i32>,
    /// nodeVolumeDetachTimeoutSeconds is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeoutSeconds")]
    pub node_volume_detach_timeout_seconds: Option<i32>,
    /// order defines the order in which Machines are deleted when downscaling.
    /// Defaults to "Random".  Valid values are "Random, "Newest", "Oldest"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub order: Option<ClusterClassWorkersMachineDeploymentsDeletionOrder>,
}

/// deletion contains configuration options for Machine deletion.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassWorkersMachineDeploymentsDeletionOrder {
    Random,
    Newest,
    Oldest,
}

/// healthCheck defines a MachineHealthCheck for this MachineDeploymentClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsHealthCheck {
    /// checks are the checks that are used to evaluate if a Machine is healthy.
    /// 
    /// Independent of this configuration the MachineHealthCheck controller will always
    /// flag Machines with `cluster.x-k8s.io/remediate-machine` annotation and
    /// Machines with deleted Nodes as unhealthy.
    /// 
    /// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
    /// is defaulted to 10 minutes and evaluated accordingly.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checks: Option<ClusterClassWorkersMachineDeploymentsHealthCheckChecks>,
    /// remediation configures if and how remediations are triggered if a Machine is unhealthy.
    /// 
    /// If remediation or remediation.triggerIf is not set,
    /// remediation will always be triggered for unhealthy Machines.
    /// 
    /// If remediation or remediation.templateRef is not set,
    /// the OwnerRemediated condition will be set on unhealthy Machines to trigger remediation via
    /// the owner of the Machines, for example a MachineSet or a KubeadmControlPlane.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remediation: Option<ClusterClassWorkersMachineDeploymentsHealthCheckRemediation>,
}

/// checks are the checks that are used to evaluate if a Machine is healthy.
/// 
/// Independent of this configuration the MachineHealthCheck controller will always
/// flag Machines with `cluster.x-k8s.io/remediate-machine` annotation and
/// Machines with deleted Nodes as unhealthy.
/// 
/// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
/// is defaulted to 10 minutes and evaluated accordingly.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsHealthCheckChecks {
    /// nodeStartupTimeoutSeconds allows to set the maximum time for MachineHealthCheck
    /// to consider a Machine unhealthy if a corresponding Node isn't associated
    /// through a `Spec.ProviderID` field.
    /// 
    /// The duration set in this field is compared to the greatest of:
    /// - Cluster's infrastructure ready condition timestamp (if and when available)
    /// - Control Plane's initialized condition timestamp (if and when available)
    /// - Machine's infrastructure ready condition timestamp (if and when available)
    /// - Machine's metadata creation timestamp
    /// 
    /// Defaults to 10 minutes.
    /// If you wish to disable this feature, set the value explicitly to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeStartupTimeoutSeconds")]
    pub node_startup_timeout_seconds: Option<i32>,
    /// unhealthyNodeConditions contains a list of conditions that determine
    /// whether a node is considered unhealthy. The conditions are combined in a
    /// logical OR, i.e. if any of the conditions is met, the node is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyNodeConditions")]
    pub unhealthy_node_conditions: Option<Vec<ClusterClassWorkersMachineDeploymentsHealthCheckChecksUnhealthyNodeConditions>>,
}

/// UnhealthyNodeCondition represents a Node condition type and value with a timeout
/// specified as a duration.  When the named condition has been in the given
/// status for at least the timeout value, a node is considered unhealthy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsHealthCheckChecksUnhealthyNodeConditions {
    /// status of the condition, one of True, False, Unknown.
    pub status: String,
    /// timeoutSeconds is the duration that a node must be in a given status for,
    /// after which the node is considered unhealthy.
    /// For example, with a value of "1h", the node must match the status
    /// for at least 1 hour before being considered unhealthy.
    #[serde(rename = "timeoutSeconds")]
    pub timeout_seconds: i32,
    /// type of Node condition
    #[serde(rename = "type")]
    pub r#type: String,
}

/// remediation configures if and how remediations are triggered if a Machine is unhealthy.
/// 
/// If remediation or remediation.triggerIf is not set,
/// remediation will always be triggered for unhealthy Machines.
/// 
/// If remediation or remediation.templateRef is not set,
/// the OwnerRemediated condition will be set on unhealthy Machines to trigger remediation via
/// the owner of the Machines, for example a MachineSet or a KubeadmControlPlane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsHealthCheckRemediation {
    /// maxInFlight determines how many in flight remediations should happen at the same time.
    /// 
    /// Remediation only happens on the MachineSet with the most current revision, while
    /// older MachineSets (usually present during rollout operations) aren't allowed to remediate.
    /// 
    /// Note: In general (independent of remediations), unhealthy machines are always
    /// prioritized during scale down operations over healthy ones.
    /// 
    /// MaxInFlight can be set to a fixed number or a percentage.
    /// Example: when this is set to 20%, the MachineSet controller deletes at most 20% of
    /// the desired replicas.
    /// 
    /// If not set, remediation is limited to all machines (bounded by replicas)
    /// under the active MachineSet's management.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInFlight")]
    pub max_in_flight: Option<IntOrString>,
    /// templateRef is a reference to a remediation template
    /// provided by an infrastructure provider.
    /// 
    /// This field is completely optional, when filled, the MachineHealthCheck controller
    /// creates a new object from the template referenced and hands off remediation of the machine to
    /// a controller that lives outside of Cluster API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "templateRef")]
    pub template_ref: Option<ClusterClassWorkersMachineDeploymentsHealthCheckRemediationTemplateRef>,
    /// triggerIf configures if remediations are triggered.
    /// If this field is not set, remediations are always triggered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "triggerIf")]
    pub trigger_if: Option<ClusterClassWorkersMachineDeploymentsHealthCheckRemediationTriggerIf>,
}

/// templateRef is a reference to a remediation template
/// provided by an infrastructure provider.
/// 
/// This field is completely optional, when filled, the MachineHealthCheck controller
/// creates a new object from the template referenced and hands off remediation of the machine to
/// a controller that lives outside of Cluster API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsHealthCheckRemediationTemplateRef {
    /// apiVersion of the remediation template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    /// NOTE: This field must be kept in sync with the APIVersion of the remediation template.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the remediation template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the remediation template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// triggerIf configures if remediations are triggered.
/// If this field is not set, remediations are always triggered.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsHealthCheckRemediationTriggerIf {
    /// unhealthyInRange specifies that remediations are only triggered if the number of
    /// unhealthy Machines is in the configured range.
    /// Takes precedence over unhealthyLessThanOrEqualTo.
    /// Eg. "[3-5]" - This means that remediation will be allowed only when:
    /// (a) there are at least 3 unhealthy Machines (and)
    /// (b) there are at most 5 unhealthy Machines
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyInRange")]
    pub unhealthy_in_range: Option<String>,
    /// unhealthyLessThanOrEqualTo specifies that remediations are only triggered if the number of
    /// unhealthy Machines is less than or equal to the configured value.
    /// unhealthyInRange takes precedence if set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyLessThanOrEqualTo")]
    pub unhealthy_less_than_or_equal_to: Option<IntOrString>,
}

/// infrastructure contains the infrastructure template reference to be used
/// for the creation of worker Machines.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsInfrastructure {
    /// templateRef is a required reference to the InfrastructureTemplate for a MachineDeployment.
    #[serde(rename = "templateRef")]
    pub template_ref: ClusterClassWorkersMachineDeploymentsInfrastructureTemplateRef,
}

/// templateRef is a required reference to the InfrastructureTemplate for a MachineDeployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsInfrastructureTemplateRef {
    /// apiVersion of the template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment.
/// At runtime this metadata is merged with the corresponding metadata from the topology.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsMetadata {
    /// annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <http://kubernetes.io/docs/user-guide/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <http://kubernetes.io/docs/user-guide/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// naming allows changing the naming pattern used when creating the MachineDeployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsNaming {
    /// template defines the template to use for generating the name of the MachineDeployment object.
    /// If not defined, it will fallback to `{{ .cluster.name }}-{{ .machineDeployment.topologyName }}-{{ .random }}`.
    /// If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will
    /// get concatenated with a random suffix of length 5.
    /// The templating mechanism provides the following arguments:
    /// * `.cluster.name`: The name of the cluster object.
    /// * `.random`: A random alphanumeric string, without vowels, of length 5.
    /// * `.machineDeployment.topologyName`: The name of the MachineDeployment topology (Cluster.spec.topology.workers.machineDeployments[].name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsReadinessGates {
    /// conditionType refers to a condition with matching type in the Machine's condition list.
    /// If the conditions doesn't exist, it will be treated as unknown.
    /// Note: Both Cluster API conditions or conditions added by 3rd party controllers can be used as readiness gates.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
    /// polarity of the conditionType specified in this readinessGate.
    /// Valid values are Positive, Negative and omitted.
    /// When omitted, the default behaviour will be Positive.
    /// A positive polarity means that the condition should report a true status under normal conditions.
    /// A negative polarity means that the condition should report a false status under normal conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub polarity: Option<ClusterClassWorkersMachineDeploymentsReadinessGatesPolarity>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassWorkersMachineDeploymentsReadinessGatesPolarity {
    Positive,
    Negative,
}

/// rollout allows you to configure the behaviour of rolling updates to the MachineDeployment Machines.
/// It allows you to define the strategy used during rolling replacements.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsRollout {
    /// strategy specifies how to roll out control plane Machines.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<ClusterClassWorkersMachineDeploymentsRolloutStrategy>,
}

/// strategy specifies how to roll out control plane Machines.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsRolloutStrategy {
    /// rollingUpdate is the rolling update config params. Present only if
    /// type = RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<ClusterClassWorkersMachineDeploymentsRolloutStrategyRollingUpdate>,
    /// type of rollout. Allowed values are RollingUpdate and OnDelete.
    /// Default is RollingUpdate.
    #[serde(rename = "type")]
    pub r#type: ClusterClassWorkersMachineDeploymentsRolloutStrategyType,
}

/// rollingUpdate is the rolling update config params. Present only if
/// type = RollingUpdate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachineDeploymentsRolloutStrategyRollingUpdate {
    /// maxSurge is the maximum number of machines that can be scheduled above the
    /// desired number of machines.
    /// Value can be an absolute number (ex: 5) or a percentage of
    /// desired machines (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up.
    /// Defaults to 1.
    /// Example: when this is set to 30%, the new MachineSet can be scaled
    /// up immediately when the rolling update starts, such that the total
    /// number of old and new machines do not exceed 130% of desired
    /// machines. Once old machines have been killed, new MachineSet can
    /// be scaled up further, ensuring that total number of machines running
    /// at any time during the update is at most 130% of desired machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// maxUnavailable is the maximum number of machines that can be unavailable during the update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired
    /// machines (ex: 10%).
    /// Absolute number is calculated from percentage by rounding down.
    /// This can not be 0 if MaxSurge is 0.
    /// Defaults to 0.
    /// Example: when this is set to 30%, the old MachineSet can be scaled
    /// down to 70% of desired machines immediately when the rolling update
    /// starts. Once new machines are ready, old MachineSet can be scaled
    /// down further, followed by scaling up the new MachineSet, ensuring
    /// that the total number of machines available at all times
    /// during the update is at least 70% of desired machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// strategy specifies how to roll out control plane Machines.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassWorkersMachineDeploymentsRolloutStrategyType {
    RollingUpdate,
    OnDelete,
}

/// MachinePoolClass serves as a template to define a pool of worker nodes of the cluster
/// provisioned using `ClusterClass`.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachinePools {
    /// bootstrap contains the bootstrap template reference to be used
    /// for the creation of the Machines in the MachinePool.
    pub bootstrap: ClusterClassWorkersMachinePoolsBootstrap,
    /// class denotes a type of machine pool present in the cluster,
    /// this name MUST be unique within a ClusterClass and can be referenced
    /// in the Cluster to create a managed MachinePool.
    pub class: String,
    /// deletion contains configuration options for Machine deletion.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deletion: Option<ClusterClassWorkersMachinePoolsDeletion>,
    /// failureDomains is the list of failure domains the MachinePool should be attached to.
    /// Must match a key in the FailureDomains map stored on the cluster object.
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachinePoolClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomains")]
    pub failure_domains: Option<Vec<String>>,
    /// infrastructure contains the infrastructure template reference to be used
    /// for the creation of the MachinePool.
    pub infrastructure: ClusterClassWorkersMachinePoolsInfrastructure,
    /// metadata is the metadata applied to the MachinePool.
    /// At runtime this metadata is merged with the corresponding metadata from the topology.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterClassWorkersMachinePoolsMetadata>,
    /// minReadySeconds is the minimum number of seconds for which a newly created machine pool should
    /// be ready.
    /// Defaults to 0 (machine will be considered available as soon as it
    /// is ready)
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachinePoolClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// naming allows changing the naming pattern used when creating the MachinePool.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub naming: Option<ClusterClassWorkersMachinePoolsNaming>,
}

/// bootstrap contains the bootstrap template reference to be used
/// for the creation of the Machines in the MachinePool.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachinePoolsBootstrap {
    /// templateRef is a required reference to the BootstrapTemplate for a MachinePool.
    #[serde(rename = "templateRef")]
    pub template_ref: ClusterClassWorkersMachinePoolsBootstrapTemplateRef,
}

/// templateRef is a required reference to the BootstrapTemplate for a MachinePool.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachinePoolsBootstrapTemplateRef {
    /// apiVersion of the template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// deletion contains configuration options for Machine deletion.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachinePoolsDeletion {
    /// nodeDeletionTimeoutSeconds defines how long the controller will attempt to delete the Node that the Machine
    /// hosts after the Machine Pool is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// Defaults to 10 seconds.
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachinePoolClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeoutSeconds")]
    pub node_deletion_timeout_seconds: Option<i32>,
    /// nodeDrainTimeoutSeconds is the total amount of time that the controller will spend on draining a node.
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain --timeout`
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachinePoolClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeoutSeconds")]
    pub node_drain_timeout_seconds: Option<i32>,
    /// nodeVolumeDetachTimeoutSeconds is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    /// NOTE: This value can be overridden while defining a Cluster.Topology using this MachinePoolClass.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeoutSeconds")]
    pub node_volume_detach_timeout_seconds: Option<i32>,
}

/// infrastructure contains the infrastructure template reference to be used
/// for the creation of the MachinePool.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachinePoolsInfrastructure {
    /// templateRef is a required reference to the InfrastructureTemplate for a MachinePool.
    #[serde(rename = "templateRef")]
    pub template_ref: ClusterClassWorkersMachinePoolsInfrastructureTemplateRef,
}

/// templateRef is a required reference to the InfrastructureTemplate for a MachinePool.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachinePoolsInfrastructureTemplateRef {
    /// apiVersion of the template.
    /// apiVersion must be fully qualified domain name followed by / and a version.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// kind of the template.
    /// kind must consist of alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
    pub kind: String,
    /// name of the template.
    /// name must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.
    pub name: String,
}

/// metadata is the metadata applied to the MachinePool.
/// At runtime this metadata is merged with the corresponding metadata from the topology.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachinePoolsMetadata {
    /// annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: <http://kubernetes.io/docs/user-guide/annotations>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: <http://kubernetes.io/docs/user-guide/labels>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// naming allows changing the naming pattern used when creating the MachinePool.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassWorkersMachinePoolsNaming {
    /// template defines the template to use for generating the name of the MachinePool object.
    /// If not defined, it will fallback to `{{ .cluster.name }}-{{ .machinePool.topologyName }}-{{ .random }}`.
    /// If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will
    /// get concatenated with a random suffix of length 5.
    /// The templating mechanism provides the following arguments:
    /// * `.cluster.name`: The name of the cluster object.
    /// * `.random`: A random alphanumeric string, without vowels, of length 5.
    /// * `.machinePool.topologyName`: The name of the MachinePool topology (Cluster.spec.topology.workers.machinePools[].name).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
}

/// status is the observed state of ClusterClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatus {
    /// conditions represents the observations of a ClusterClass's current state.
    /// Known condition types are VariablesReady, RefVersionsUpToDate, Paused.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// deprecated groups all the status fields that are deprecated and will be removed when all the nested field are removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<ClusterClassStatusDeprecated>,
    /// observedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// variables is a list of ClusterClassStatusVariable that are defined for the ClusterClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<ClusterClassStatusVariables>>,
}

/// deprecated groups all the status fields that are deprecated and will be removed when all the nested field are removed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatusDeprecated {
    /// v1beta1 groups all the status fields that are deprecated and will be removed when support for v1beta1 will be dropped.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub v1beta1: Option<ClusterClassStatusDeprecatedV1beta1>,
}

/// v1beta1 groups all the status fields that are deprecated and will be removed when support for v1beta1 will be dropped.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatusDeprecatedV1beta1 {
    /// conditions defines current observed state of the ClusterClass.
    /// 
    /// Deprecated: This field is deprecated and is going to be removed when support for v1beta1 will be dropped. Please see <https://github.com/kubernetes-sigs/cluster-api/blob/main/docs/proposals/20240916-improve-status-in-CAPI-resources.md> for more details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

/// ClusterClassStatusVariable defines a variable which appears in the status of a ClusterClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatusVariables {
    /// definitions is a list of definitions for a variable.
    pub definitions: Vec<ClusterClassStatusVariablesDefinitions>,
    /// definitionsConflict specifies whether or not there are conflicting definitions for a single variable name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "definitionsConflict")]
    pub definitions_conflict: Option<bool>,
    /// name is the name of the variable.
    pub name: String,
}

/// ClusterClassStatusVariableDefinition defines a variable which appears in the status of a ClusterClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatusVariablesDefinitions {
    /// deprecatedV1Beta1Metadata is the metadata of a variable.
    /// It can be used to add additional data for higher level tools to
    /// a ClusterClassVariable.
    /// 
    /// Deprecated: This field is deprecated and will be removed when support for v1beta1 will be dropped. Please use XMetadata in JSONSchemaProps instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deprecatedV1Beta1Metadata")]
    pub deprecated_v1_beta1_metadata: Option<ClusterClassStatusVariablesDefinitionsDeprecatedV1Beta1Metadata>,
    /// from specifies the origin of the variable definition.
    /// This will be `inline` for variables defined in the ClusterClass or the name of a patch defined in the ClusterClass
    /// for variables discovered from a DiscoverVariables runtime extensions.
    pub from: String,
    /// required specifies if the variable is required.
    /// Note: this applies to the variable as a whole and thus the
    /// top-level object defined in the schema. If nested fields are
    /// required, this will be specified inside the schema.
    pub required: bool,
    /// schema defines the schema of the variable.
    pub schema: ClusterClassStatusVariablesDefinitionsSchema,
}

/// deprecatedV1Beta1Metadata is the metadata of a variable.
/// It can be used to add additional data for higher level tools to
/// a ClusterClassVariable.
/// 
/// Deprecated: This field is deprecated and will be removed when support for v1beta1 will be dropped. Please use XMetadata in JSONSchemaProps instead.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatusVariablesDefinitionsDeprecatedV1Beta1Metadata {
    /// annotations is an unstructured key value map that can be used to store and
    /// retrieve arbitrary metadata.
    /// They are not queryable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// schema defines the schema of the variable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatusVariablesDefinitionsSchema {
    /// openAPIV3Schema defines the schema of a variable via OpenAPI v3
    /// schema. The schema is a subset of the schema used in
    /// Kubernetes CRDs.
    #[serde(rename = "openAPIV3Schema")]
    pub open_apiv3_schema: ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3Schema,
}

/// openAPIV3Schema defines the schema of a variable via OpenAPI v3
/// schema. The schema is a subset of the schema used in
/// Kubernetes CRDs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3Schema {
    /// additionalProperties specifies the schema of values in a map (keys are always strings).
    /// NOTE: Can only be set if type is object.
    /// NOTE: AdditionalProperties is mutually exclusive with Properties.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalProperties")]
    pub additional_properties: Option<serde_json::Value>,
    /// allOf specifies that the variable must validate against all of the subschemas in the array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allOf")]
    pub all_of: Option<serde_json::Value>,
    /// anyOf specifies that the variable must validate against one or more of the subschemas in the array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "anyOf")]
    pub any_of: Option<serde_json::Value>,
    /// default is the default value of the variable.
    /// NOTE: Can be set for all types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    /// description is a human-readable description of this variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// enum is the list of valid values of the variable.
    /// NOTE: Can be set for all types.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enum")]
    pub r#enum: Option<Vec<serde_json::Value>>,
    /// example is an example for this variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub example: Option<serde_json::Value>,
    /// exclusiveMaximum specifies if the Maximum is exclusive.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusiveMaximum")]
    pub exclusive_maximum: Option<bool>,
    /// exclusiveMinimum specifies if the Minimum is exclusive.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exclusiveMinimum")]
    pub exclusive_minimum: Option<bool>,
    /// format is an OpenAPI v3 format string. Unknown formats are ignored.
    /// For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using)
    /// <https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go>
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
    /// items specifies fields of an array.
    /// NOTE: Can only be set if type is array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<serde_json::Value>,
    /// maxItems is the max length of an array variable.
    /// NOTE: Can only be set if type is array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxItems")]
    pub max_items: Option<i64>,
    /// maxLength is the max length of a string variable.
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxLength")]
    pub max_length: Option<i64>,
    /// maxProperties is the maximum amount of entries in a map or properties in an object.
    /// NOTE: Can only be set if type is object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxProperties")]
    pub max_properties: Option<i64>,
    /// maximum is the maximum of an integer or number variable.
    /// If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum.
    /// If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum: Option<i64>,
    /// minItems is the min length of an array variable.
    /// NOTE: Can only be set if type is array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minItems")]
    pub min_items: Option<i64>,
    /// minLength is the min length of a string variable.
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minLength")]
    pub min_length: Option<i64>,
    /// minProperties is the minimum amount of entries in a map or properties in an object.
    /// NOTE: Can only be set if type is object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minProperties")]
    pub min_properties: Option<i64>,
    /// minimum is the minimum of an integer or number variable.
    /// If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum.
    /// If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum.
    /// NOTE: Can only be set if type is integer or number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minimum: Option<i64>,
    /// not specifies that the variable must not validate against the subschema.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<serde_json::Value>,
    /// oneOf specifies that the variable must validate against exactly one of the subschemas in the array.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "oneOf")]
    pub one_of: Option<serde_json::Value>,
    /// pattern is the regex which a string variable must match.
    /// NOTE: Can only be set if type is string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    /// properties specifies fields of an object.
    /// NOTE: Can only be set if type is object.
    /// NOTE: Properties is mutually exclusive with AdditionalProperties.
    /// NOTE: This field uses PreserveUnknownFields and Schemaless,
    /// because recursive validation is not possible.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<serde_json::Value>,
    /// required specifies which fields of an object are required.
    /// NOTE: Can only be set if type is object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub required: Option<Vec<String>>,
    /// type is the type of the variable.
    /// Valid values are: object, array, string, integer, number or boolean.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaType>,
    /// uniqueItems specifies if items in an array must be unique.
    /// NOTE: Can only be set if type is array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "uniqueItems")]
    pub unique_items: Option<bool>,
    /// x-kubernetes-int-or-string specifies that this value is
    /// either an integer or a string. If this is true, an empty
    /// type is allowed and type as child of anyOf is permitted
    /// if following one of the following patterns:
    /// 
    /// 1) anyOf:
    ///    - type: integer
    ///    - type: string
    /// 2) allOf:
    ///    - anyOf:
    ///      - type: integer
    ///      - type: string
    ///    - ... zero or more
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-kubernetes-int-or-string")]
    pub x_kubernetes_int_or_string: Option<bool>,
    /// x-kubernetes-preserve-unknown-fields allows setting fields in a variable object
    /// which are not defined in the variable schema. This affects fields recursively,
    /// except if nested properties or additionalProperties are specified in the schema.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-kubernetes-preserve-unknown-fields")]
    pub x_kubernetes_preserve_unknown_fields: Option<bool>,
    /// x-kubernetes-validations describes a list of validation rules written in the CEL expression language.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-kubernetes-validations")]
    pub x_kubernetes_validations: Option<Vec<ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaXKubernetesValidations>>,
    /// x-metadata is the metadata of a variable or a nested field within a variable.
    /// It can be used to add additional data for higher level tools.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "x-metadata")]
    pub x_metadata: Option<ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaXMetadata>,
}

/// openAPIV3Schema defines the schema of a variable via OpenAPI v3
/// schema. The schema is a subset of the schema used in
/// Kubernetes CRDs.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaType {
    #[serde(rename = "object")]
    Object,
    #[serde(rename = "array")]
    Array,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "integer")]
    Integer,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "boolean")]
    Boolean,
}

/// ValidationRule describes a validation rule written in the CEL expression language.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaXKubernetesValidations {
    /// fieldPath represents the field path returned when the validation fails.
    /// It must be a relative JSON path (i.e. with array notation) scoped to the location of this x-kubernetes-validations extension in the schema and refer to an existing field.
    /// e.g. when validation checks if a specific attribute `foo` under a map `testMap`, the fieldPath could be set to `.testMap.foo`
    /// If the validation checks two lists must have unique attributes, the fieldPath could be set to either of the list: e.g. `.testList`
    /// It does not support list numeric index.
    /// It supports child operation to refer to an existing field currently. Refer to [JSONPath support in Kubernetes](<https://kubernetes.io/docs/reference/kubectl/jsonpath/)> for more info.
    /// Numeric index of array is not supported.
    /// For field name which contains special characters, use `['specialName']` to refer the field name.
    /// e.g. for attribute `foo.34$` appears in a list `testList`, the fieldPath could be set to `.testList['foo.34$']`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// message represents the message displayed when validation fails. The message is required if the Rule contains
    /// line breaks. The message must not contain line breaks.
    /// If unset, the message is "failed rule: {Rule}".
    /// e.g. "must be a URL with the host matching spec.host"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
    /// Since messageExpression is used as a failure message, it must evaluate to a string.
    /// If both message and messageExpression are present on a rule, then messageExpression will be used if validation
    /// fails. If messageExpression results in a runtime error, the validation failure message is produced
    /// as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
    /// that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset.
    /// messageExpression has access to all the same variables as the rule; the only difference is the return type.
    /// Example:
    /// "x must be less than max ("+string(self.max)+")"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "messageExpression")]
    pub message_expression: Option<String>,
    /// reason provides a machine-readable validation failure reason that is returned to the caller when a request fails this validation rule.
    /// The currently supported reasons are: "FieldValueInvalid", "FieldValueForbidden", "FieldValueRequired", "FieldValueDuplicate".
    /// If not set, default to use "FieldValueInvalid".
    /// All future added reasons must be accepted by clients when reading this value and unknown reasons should be treated as FieldValueInvalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaXKubernetesValidationsReason>,
    /// rule represents the expression which will be evaluated by CEL.
    /// ref: <https://github.com/google/cel-spec>
    /// The Rule is scoped to the location of the x-kubernetes-validations extension in the schema.
    /// The `self` variable in the CEL expression is bound to the scoped value.
    /// If the Rule is scoped to an object with properties, the accessible properties of the object are field selectable
    /// via `self.field` and field presence can be checked via `has(self.field)`.
    /// If the Rule is scoped to an object with additionalProperties (i.e. a map) the value of the map
    /// are accessible via `self[mapKey]`, map containment can be checked via `mapKey in self` and all entries of the map
    /// are accessible via CEL macros and functions such as `self.all(...)`.
    /// If the Rule is scoped to an array, the elements of the array are accessible via `self[i]` and also by macros and
    /// functions.
    /// If the Rule is scoped to a scalar, `self` is bound to the scalar value.
    /// Examples:
    /// - Rule scoped to a map of objects: {"rule": "self.components['Widget'].priority < 10"}
    /// - Rule scoped to a list of integers: {"rule": "self.values.all(value, value >= 0 && value < 100)"}
    /// - Rule scoped to a string value: {"rule": "self.startsWith('kube')"}
    /// 
    /// Unknown data preserved in custom resources via x-kubernetes-preserve-unknown-fields is not accessible in CEL
    /// expressions. This includes:
    /// - Unknown field values that are preserved by object schemas with x-kubernetes-preserve-unknown-fields.
    /// - Object properties where the property schema is of an "unknown type". An "unknown type" is recursively defined as:
    ///   - A schema with no type and x-kubernetes-preserve-unknown-fields set to true
    ///   - An array where the items schema is of an "unknown type"
    ///   - An object where the additionalProperties schema is of an "unknown type"
    /// 
    /// Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
    /// Accessible property names are escaped according to the following rules when accessed in the expression:
    /// - '__' escapes to '__underscores__'
    /// - '.' escapes to '__dot__'
    /// - '-' escapes to '__dash__'
    /// - '/' escapes to '__slash__'
    /// - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
    /// 	  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
    /// 	  "import", "let", "loop", "package", "namespace", "return".
    /// Examples:
    ///   - Rule accessing a property named "namespace": {"rule": "self.__namespace__ > 0"}
    ///   - Rule accessing a property named "x-prop": {"rule": "self.x__dash__prop > 0"}
    ///   - Rule accessing a property named "redact__d": {"rule": "self.redact__underscores__d > 0"}
    /// 
    /// If `rule` makes use of the `oldSelf` variable it is implicitly a
    /// `transition rule`.
    /// 
    /// By default, the `oldSelf` variable is the same type as `self`.
    /// 
    /// Transition rules by default are applied only on UPDATE requests and are
    /// skipped if an old value could not be found.
    pub rule: String,
}

/// ValidationRule describes a validation rule written in the CEL expression language.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaXKubernetesValidationsReason {
    FieldValueInvalid,
    FieldValueForbidden,
    FieldValueRequired,
    FieldValueDuplicate,
}

/// x-metadata is the metadata of a variable or a nested field within a variable.
/// It can be used to add additional data for higher level tools.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaXMetadata {
    /// annotations is an unstructured key value map that can be used to store and
    /// retrieve arbitrary metadata.
    /// They are not queryable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

