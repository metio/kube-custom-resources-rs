// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/crossplane/crossplane/apiextensions.crossplane.io/v1beta1/compositionrevisions.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// CompositionRevisionSpec specifies the desired state of the composition
/// revision.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "apiextensions.crossplane.io", version = "v1beta1", kind = "CompositionRevision", plural = "compositionrevisions")]
#[kube(status = "CompositionRevisionStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct CompositionRevisionSpec {
    /// CompositeTypeRef specifies the type of composite resource that this
    /// composition is compatible with.
    #[serde(rename = "compositeTypeRef")]
    pub composite_type_ref: CompositionRevisionCompositeTypeRef,
    /// Mode controls what type or "mode" of Composition will be used.
    /// 
    /// "Pipeline" indicates that a Composition specifies a pipeline of
    /// Composition Functions, each of which is responsible for producing
    /// composed resources that Crossplane should create or update.
    /// 
    /// "Resources" indicates that a Composition uses what is commonly referred
    /// to as "Patch & Transform" or P&T composition. This mode of Composition
    /// uses an array of resources, each a template for a composed resource.
    /// 
    /// All Compositions should use Pipeline mode. Resources mode is deprecated.
    /// Resources mode won't be removed in Crossplane 1.x, and will remain the
    /// default to avoid breaking legacy Compositions. However, it's no longer
    /// accepting new features, and only accepting security related bug fixes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<CompositionRevisionMode>,
    /// PatchSets define a named set of patches that may be included by any
    /// resource in this Composition. PatchSets cannot themselves refer to other
    /// PatchSets.
    /// 
    /// PatchSets are only used by the "Resources" mode of Composition. They
    /// are ignored by other modes.
    /// 
    /// Deprecated: Use Composition Functions instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchSets")]
    pub patch_sets: Option<Vec<CompositionRevisionPatchSets>>,
    /// Pipeline is a list of composition function steps that will be used when a
    /// composite resource referring to this composition is created. One of
    /// resources and pipeline must be specified - you cannot specify both.
    /// 
    /// The Pipeline is only used by the "Pipeline" mode of Composition. It is
    /// ignored by other modes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pipeline: Option<Vec<CompositionRevisionPipeline>>,
    /// PublishConnectionDetailsWithStoreConfig specifies the secret store config
    /// with which the connection details of composite resources dynamically
    /// provisioned using this composition will be published.
    /// 
    /// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
    /// unless the relevant Crossplane feature flag is enabled, and may be
    /// changed or removed without notice.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishConnectionDetailsWithStoreConfigRef")]
    pub publish_connection_details_with_store_config_ref: Option<CompositionRevisionPublishConnectionDetailsWithStoreConfigRef>,
    /// Resources is a list of resource templates that will be used when a
    /// composite resource referring to this composition is created.
    /// 
    /// Resources are only used by the "Resources" mode of Composition. They are
    /// ignored by other modes.
    /// 
    /// Deprecated: Use Composition Functions instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<CompositionRevisionResources>>,
    /// Revision number. Newer revisions have larger numbers.
    /// 
    /// This number can change. When a Composition transitions from state A
    /// -> B -> A there will be only two CompositionRevisions. Crossplane will
    /// edit the original CompositionRevision to change its revision number from
    /// 0 to 2.
    pub revision: i64,
    /// WriteConnectionSecretsToNamespace specifies the namespace in which the
    /// connection secrets of composite resource dynamically provisioned using
    /// this composition will be created.
    /// This field is planned to be replaced in a future release in favor of
    /// PublishConnectionDetailsWithStoreConfigRef. Currently, both could be
    /// set independently and connection details would be published to both
    /// without affecting each other as long as related fields at MR level
    /// specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "writeConnectionSecretsToNamespace")]
    pub write_connection_secrets_to_namespace: Option<String>,
}

/// CompositeTypeRef specifies the type of composite resource that this
/// composition is compatible with.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionCompositeTypeRef {
    /// APIVersion of the type.
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    /// Kind of the type.
    pub kind: String,
}

/// CompositionRevisionSpec specifies the desired state of the composition
/// revision.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionMode {
    Resources,
    Pipeline,
}

/// A PatchSet is a set of patches that can be reused from all resources within
/// a Composition.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSets {
    /// Name of this PatchSet.
    pub name: String,
    /// Patches will be applied as an overlay to the base resource.
    pub patches: Vec<CompositionRevisionPatchSetsPatches>,
}

/// Patch objects are applied between composite and composed resources. Their
/// behaviour depends on the Type selected. The default Type,
/// FromCompositeFieldPath, copies a value from the composite resource to
/// the composed resource, applying any defined transformers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatches {
    /// Combine is the patch configuration for a CombineFromComposite or
    /// CombineToComposite patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub combine: Option<CompositionRevisionPatchSetsPatchesCombine>,
    /// FromFieldPath is the path of the field on the resource whose value is
    /// to be used as input. Required when type is FromCompositeFieldPath or
    /// ToCompositeFieldPath.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromFieldPath")]
    pub from_field_path: Option<String>,
    /// PatchSetName to include patches from. Required when type is PatchSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchSetName")]
    pub patch_set_name: Option<String>,
    /// Policy configures the specifics of patching behaviour.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<CompositionRevisionPatchSetsPatchesPolicy>,
    /// ToFieldPath is the path of the field on the resource whose value will
    /// be changed with the result of transforms. Leave empty if you'd like to
    /// propagate to the same path as fromFieldPath.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toFieldPath")]
    pub to_field_path: Option<String>,
    /// Transforms are the list of functions that are used as a FIFO pipe for the
    /// input to be transformed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transforms: Option<Vec<CompositionRevisionPatchSetsPatchesTransforms>>,
    /// Type sets the patching behaviour to be used. Each patch type may require
    /// its own fields to be set on the Patch object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<CompositionRevisionPatchSetsPatchesType>,
}

/// Combine is the patch configuration for a CombineFromComposite or
/// CombineToComposite patch.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesCombine {
    /// Strategy defines the strategy to use to combine the input variable values.
    /// Currently only string is supported.
    pub strategy: CompositionRevisionPatchSetsPatchesCombineStrategy,
    /// String declares that input variables should be combined into a single
    /// string, using the relevant settings for formatting purposes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub string: Option<CompositionRevisionPatchSetsPatchesCombineString>,
    /// Variables are the list of variables whose values will be retrieved and
    /// combined.
    pub variables: Vec<CompositionRevisionPatchSetsPatchesCombineVariables>,
}

/// Combine is the patch configuration for a CombineFromComposite or
/// CombineToComposite patch.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesCombineStrategy {
    #[serde(rename = "string")]
    String,
}

/// String declares that input variables should be combined into a single
/// string, using the relevant settings for formatting purposes.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesCombineString {
    /// Format the input using a Go format string. See
    /// <https://golang.org/pkg/fmt/> for details.
    pub fmt: String,
}

/// A CombineVariable defines the source of a value that is combined with
/// others to form and patch an output value. Currently, this only supports
/// retrieving values from a field path.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesCombineVariables {
    /// FromFieldPath is the path of the field on the source whose value is
    /// to be used as input.
    #[serde(rename = "fromFieldPath")]
    pub from_field_path: String,
}

/// Policy configures the specifics of patching behaviour.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesPolicy {
    /// FromFieldPath specifies how to patch from a field path. The default is
    /// 'Optional', which means the patch will be a no-op if the specified
    /// fromFieldPath does not exist. Use 'Required' if the patch should fail if
    /// the specified path does not exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromFieldPath")]
    pub from_field_path: Option<CompositionRevisionPatchSetsPatchesPolicyFromFieldPath>,
    /// MergeOptions Specifies merge options on a field path.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mergeOptions")]
    pub merge_options: Option<CompositionRevisionPatchSetsPatchesPolicyMergeOptions>,
}

/// Policy configures the specifics of patching behaviour.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesPolicyFromFieldPath {
    Optional,
    Required,
}

/// MergeOptions Specifies merge options on a field path.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesPolicyMergeOptions {
    /// Specifies that already existing elements in a merged slice should be preserved
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appendSlice")]
    pub append_slice: Option<bool>,
    /// Specifies that already existing values in a merged map should be preserved
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepMapValues")]
    pub keep_map_values: Option<bool>,
}

/// Transform is a unit of process whose input is transformed into an output with
/// the supplied configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesTransforms {
    /// Convert is used to cast the input into the given output type.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub convert: Option<CompositionRevisionPatchSetsPatchesTransformsConvert>,
    /// Map uses the input as a key in the given map and returns the value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub map: Option<BTreeMap<String, serde_json::Value>>,
    /// Match is a more complex version of Map that matches a list of patterns.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<CompositionRevisionPatchSetsPatchesTransformsMatch>,
    /// Math is used to transform the input via mathematical operations such as
    /// multiplication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub math: Option<CompositionRevisionPatchSetsPatchesTransformsMath>,
    /// String is used to transform the input into a string or a different kind
    /// of string. Note that the input does not necessarily need to be a string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub string: Option<CompositionRevisionPatchSetsPatchesTransformsString>,
    /// Type of the transform to be run.
    #[serde(rename = "type")]
    pub r#type: CompositionRevisionPatchSetsPatchesTransformsType,
}

/// Convert is used to cast the input into the given output type.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesTransformsConvert {
    /// The expected input format.
    /// 
    /// * `quantity` - parses the input as a K8s [`resource.Quantity`](<https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).>
    /// Only used during `string -> float64` conversions.
    /// * `json` - parses the input as a JSON string.
    /// Only used during `string -> object` or `string -> list` conversions.
    /// 
    /// If this property is null, the default conversion is applied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<CompositionRevisionPatchSetsPatchesTransformsConvertFormat>,
    /// ToType is the type of the output of this transform.
    #[serde(rename = "toType")]
    pub to_type: CompositionRevisionPatchSetsPatchesTransformsConvertToType,
}

/// Convert is used to cast the input into the given output type.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesTransformsConvertFormat {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "quantity")]
    Quantity,
    #[serde(rename = "json")]
    Json,
}

/// Convert is used to cast the input into the given output type.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesTransformsConvertToType {
    #[serde(rename = "string")]
    String,
    #[serde(rename = "int")]
    Int,
    #[serde(rename = "int64")]
    Int64,
    #[serde(rename = "bool")]
    Bool,
    #[serde(rename = "float64")]
    Float64,
    #[serde(rename = "object")]
    Object,
    #[serde(rename = "array")]
    Array,
}

/// Match is a more complex version of Map that matches a list of patterns.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesTransformsMatch {
    /// Determines to what value the transform should fallback if no pattern matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fallbackTo")]
    pub fallback_to: Option<CompositionRevisionPatchSetsPatchesTransformsMatchFallbackTo>,
    /// The fallback value that should be returned by the transform if now pattern
    /// matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fallbackValue")]
    pub fallback_value: Option<serde_json::Value>,
    /// The patterns that should be tested against the input string.
    /// Patterns are tested in order. The value of the first match is used as
    /// result of this transform.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patterns: Option<Vec<CompositionRevisionPatchSetsPatchesTransformsMatchPatterns>>,
}

/// Match is a more complex version of Map that matches a list of patterns.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesTransformsMatchFallbackTo {
    Value,
    Input,
}

/// MatchTransformPattern is a transform that returns the value that matches a
/// pattern.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesTransformsMatchPatterns {
    /// Literal exactly matches the input string (case sensitive).
    /// Is required if `type` is `literal`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub literal: Option<String>,
    /// Regexp to match against the input string.
    /// Is required if `type` is `regexp`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regexp: Option<String>,
    /// The value that is used as result of the transform if the pattern matches.
    pub result: serde_json::Value,
    /// Type specifies how the pattern matches the input.
    /// 
    /// * `literal` - the pattern value has to exactly match (case sensitive) the
    /// input string. This is the default.
    /// 
    /// * `regexp` - the pattern treated as a regular expression against
    /// which the input string is tested. Crossplane will throw an error if the
    /// key is not a valid regexp.
    #[serde(rename = "type")]
    pub r#type: CompositionRevisionPatchSetsPatchesTransformsMatchPatternsType,
}

/// MatchTransformPattern is a transform that returns the value that matches a
/// pattern.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesTransformsMatchPatternsType {
    #[serde(rename = "literal")]
    Literal,
    #[serde(rename = "regexp")]
    Regexp,
}

/// Math is used to transform the input via mathematical operations such as
/// multiplication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesTransformsMath {
    /// ClampMax makes sure that the value is not bigger than the given value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clampMax")]
    pub clamp_max: Option<i64>,
    /// ClampMin makes sure that the value is not smaller than the given value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clampMin")]
    pub clamp_min: Option<i64>,
    /// Multiply the value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub multiply: Option<i64>,
    /// Type of the math transform to be run.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<CompositionRevisionPatchSetsPatchesTransformsMathType>,
}

/// Math is used to transform the input via mathematical operations such as
/// multiplication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesTransformsMathType {
    Multiply,
    ClampMin,
    ClampMax,
}

/// String is used to transform the input into a string or a different kind
/// of string. Note that the input does not necessarily need to be a string.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesTransformsString {
    /// Optional conversion method to be specified.
    /// `ToUpper` and `ToLower` change the letter case of the input string.
    /// `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
    /// `ToJson` converts any input value into its raw JSON representation.
    /// `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
    /// converted to JSON.
    /// `ToAdler32` generate a addler32 hash based on the input string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub convert: Option<CompositionRevisionPatchSetsPatchesTransformsStringConvert>,
    /// Format the input using a Go format string. See
    /// <https://golang.org/pkg/fmt/> for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fmt: Option<String>,
    /// Join defines parameters to join a slice of values to a string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub join: Option<CompositionRevisionPatchSetsPatchesTransformsStringJoin>,
    /// Extract a match from the input using a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regexp: Option<CompositionRevisionPatchSetsPatchesTransformsStringRegexp>,
    /// Trim the prefix or suffix from the input
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trim: Option<String>,
    /// Type of the string transform to be run.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<CompositionRevisionPatchSetsPatchesTransformsStringType>,
}

/// String is used to transform the input into a string or a different kind
/// of string. Note that the input does not necessarily need to be a string.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesTransformsStringConvert {
    ToUpper,
    ToLower,
    ToBase64,
    FromBase64,
    ToJson,
    ToSha1,
    ToSha256,
    ToSha512,
    ToAdler32,
}

/// Join defines parameters to join a slice of values to a string.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesTransformsStringJoin {
    /// Separator defines the character that should separate the values from each
    /// other in the joined string.
    pub separator: String,
}

/// Extract a match from the input using a regular expression.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPatchSetsPatchesTransformsStringRegexp {
    /// Group number to match. 0 (the default) matches the entire expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<i64>,
    /// Match string. May optionally include submatches, aka capture groups.
    /// See <https://pkg.go.dev/regexp/> for details.
    #[serde(rename = "match")]
    pub r#match: String,
}

/// String is used to transform the input into a string or a different kind
/// of string. Note that the input does not necessarily need to be a string.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesTransformsStringType {
    Format,
    Convert,
    TrimPrefix,
    TrimSuffix,
    Regexp,
    Join,
}

/// Transform is a unit of process whose input is transformed into an output with
/// the supplied configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesTransformsType {
    #[serde(rename = "map")]
    Map,
    #[serde(rename = "match")]
    Match,
    #[serde(rename = "math")]
    Math,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "convert")]
    Convert,
}

/// Patch objects are applied between composite and composed resources. Their
/// behaviour depends on the Type selected. The default Type,
/// FromCompositeFieldPath, copies a value from the composite resource to
/// the composed resource, applying any defined transformers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPatchSetsPatchesType {
    FromCompositeFieldPath,
    PatchSet,
    ToCompositeFieldPath,
    CombineFromComposite,
    CombineToComposite,
}

/// A PipelineStep in a Composition Function pipeline.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPipeline {
    /// Credentials are optional credentials that the Composition Function needs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<Vec<CompositionRevisionPipelineCredentials>>,
    /// FunctionRef is a reference to the Composition Function this step should
    /// execute.
    #[serde(rename = "functionRef")]
    pub function_ref: CompositionRevisionPipelineFunctionRef,
    /// Input is an optional, arbitrary Kubernetes resource (i.e. a resource
    /// with an apiVersion and kind) that will be passed to the Composition
    /// Function as the 'input' of its RunFunctionRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub input: Option<BTreeMap<String, serde_json::Value>>,
    /// Step name. Must be unique within its Pipeline.
    pub step: String,
}

/// FunctionCredentials are optional credentials that a Composition Function
/// needs to run.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionPipelineCredentials {
    /// Name of this set of credentials.
    pub name: String,
    /// A SecretRef is a reference to a secret containing credentials that should
    /// be supplied to the function.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<CompositionRevisionPipelineCredentialsSecretRef>,
    /// Source of the function credentials.
    pub source: CompositionRevisionPipelineCredentialsSource,
}

/// A SecretRef is a reference to a secret containing credentials that should
/// be supplied to the function.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPipelineCredentialsSecretRef {
    /// Name of the secret.
    pub name: String,
    /// Namespace of the secret.
    pub namespace: String,
}

/// FunctionCredentials are optional credentials that a Composition Function
/// needs to run.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionPipelineCredentialsSource {
    None,
    Secret,
}

/// FunctionRef is a reference to the Composition Function this step should
/// execute.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPipelineFunctionRef {
    /// Name of the referenced Function.
    pub name: String,
}

/// PublishConnectionDetailsWithStoreConfig specifies the secret store config
/// with which the connection details of composite resources dynamically
/// provisioned using this composition will be published.
/// 
/// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
/// unless the relevant Crossplane feature flag is enabled, and may be
/// changed or removed without notice.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionPublishConnectionDetailsWithStoreConfigRef {
    /// Name of the referenced StoreConfig.
    pub name: String,
}

/// ComposedTemplate is used to provide information about how the composed resource
/// should be processed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResources {
    /// Base is the target resource that the patches will be applied on.
    pub base: BTreeMap<String, serde_json::Value>,
    /// ConnectionDetails lists the propagation secret keys from this target
    /// resource to the composition instance connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionDetails")]
    pub connection_details: Option<Vec<CompositionRevisionResourcesConnectionDetails>>,
    /// A Name uniquely identifies this entry within its Composition's resources
    /// array. Names are optional but *strongly* recommended. When all entries in
    /// the resources array are named entries may added, deleted, and reordered
    /// as long as their names do not change. When entries are not named the
    /// length and order of the resources array should be treated as immutable.
    /// Either all or no entries must be named.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Patches will be applied as overlay to the base resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patches: Option<Vec<CompositionRevisionResourcesPatches>>,
    /// ReadinessChecks allows users to define custom readiness checks. All checks
    /// have to return true in order for resource to be considered ready. The
    /// default readiness check is to have the "Ready" condition to be "True".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessChecks")]
    pub readiness_checks: Option<Vec<CompositionRevisionResourcesReadinessChecks>>,
}

/// ConnectionDetail includes the information about the propagation of the connection
/// information from one secret to another.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesConnectionDetails {
    /// FromConnectionSecretKey is the key that will be used to fetch the value
    /// from the composed resource's connection secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromConnectionSecretKey")]
    pub from_connection_secret_key: Option<String>,
    /// FromFieldPath is the path of the field on the composed resource whose
    /// value to be used as input. Name must be specified if the type is
    /// FromFieldPath.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromFieldPath")]
    pub from_field_path: Option<String>,
    /// Name of the connection secret key that will be propagated to the
    /// connection secret of the composition instance. Leave empty if you'd like
    /// to use the same key name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Type sets the connection detail fetching behaviour to be used. Each
    /// connection detail type may require its own fields to be set on the
    /// ConnectionDetail object. If the type is omitted Crossplane will attempt
    /// to infer it based on which other fields were specified. If multiple
    /// fields are specified the order of precedence is:
    /// 1. FromValue
    /// 2. FromConnectionSecretKey
    /// 3. FromFieldPath
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<CompositionRevisionResourcesConnectionDetailsType>,
    /// Value that will be propagated to the connection secret of the composite
    /// resource. May be set to inject a fixed, non-sensitive connection secret
    /// value, for example a well-known port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// ConnectionDetail includes the information about the propagation of the connection
/// information from one secret to another.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesConnectionDetailsType {
    FromConnectionSecretKey,
    FromFieldPath,
    FromValue,
}

/// Patch objects are applied between composite and composed resources. Their
/// behaviour depends on the Type selected. The default Type,
/// FromCompositeFieldPath, copies a value from the composite resource to
/// the composed resource, applying any defined transformers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatches {
    /// Combine is the patch configuration for a CombineFromComposite or
    /// CombineToComposite patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub combine: Option<CompositionRevisionResourcesPatchesCombine>,
    /// FromFieldPath is the path of the field on the resource whose value is
    /// to be used as input. Required when type is FromCompositeFieldPath or
    /// ToCompositeFieldPath.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromFieldPath")]
    pub from_field_path: Option<String>,
    /// PatchSetName to include patches from. Required when type is PatchSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "patchSetName")]
    pub patch_set_name: Option<String>,
    /// Policy configures the specifics of patching behaviour.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<CompositionRevisionResourcesPatchesPolicy>,
    /// ToFieldPath is the path of the field on the resource whose value will
    /// be changed with the result of transforms. Leave empty if you'd like to
    /// propagate to the same path as fromFieldPath.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toFieldPath")]
    pub to_field_path: Option<String>,
    /// Transforms are the list of functions that are used as a FIFO pipe for the
    /// input to be transformed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transforms: Option<Vec<CompositionRevisionResourcesPatchesTransforms>>,
    /// Type sets the patching behaviour to be used. Each patch type may require
    /// its own fields to be set on the Patch object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<CompositionRevisionResourcesPatchesType>,
}

/// Combine is the patch configuration for a CombineFromComposite or
/// CombineToComposite patch.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionResourcesPatchesCombine {
    /// Strategy defines the strategy to use to combine the input variable values.
    /// Currently only string is supported.
    pub strategy: CompositionRevisionResourcesPatchesCombineStrategy,
    /// String declares that input variables should be combined into a single
    /// string, using the relevant settings for formatting purposes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub string: Option<CompositionRevisionResourcesPatchesCombineString>,
    /// Variables are the list of variables whose values will be retrieved and
    /// combined.
    pub variables: Vec<CompositionRevisionResourcesPatchesCombineVariables>,
}

/// Combine is the patch configuration for a CombineFromComposite or
/// CombineToComposite patch.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesCombineStrategy {
    #[serde(rename = "string")]
    String,
}

/// String declares that input variables should be combined into a single
/// string, using the relevant settings for formatting purposes.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatchesCombineString {
    /// Format the input using a Go format string. See
    /// <https://golang.org/pkg/fmt/> for details.
    pub fmt: String,
}

/// A CombineVariable defines the source of a value that is combined with
/// others to form and patch an output value. Currently, this only supports
/// retrieving values from a field path.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatchesCombineVariables {
    /// FromFieldPath is the path of the field on the source whose value is
    /// to be used as input.
    #[serde(rename = "fromFieldPath")]
    pub from_field_path: String,
}

/// Policy configures the specifics of patching behaviour.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatchesPolicy {
    /// FromFieldPath specifies how to patch from a field path. The default is
    /// 'Optional', which means the patch will be a no-op if the specified
    /// fromFieldPath does not exist. Use 'Required' if the patch should fail if
    /// the specified path does not exist.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromFieldPath")]
    pub from_field_path: Option<CompositionRevisionResourcesPatchesPolicyFromFieldPath>,
    /// MergeOptions Specifies merge options on a field path.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mergeOptions")]
    pub merge_options: Option<CompositionRevisionResourcesPatchesPolicyMergeOptions>,
}

/// Policy configures the specifics of patching behaviour.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesPolicyFromFieldPath {
    Optional,
    Required,
}

/// MergeOptions Specifies merge options on a field path.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatchesPolicyMergeOptions {
    /// Specifies that already existing elements in a merged slice should be preserved
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appendSlice")]
    pub append_slice: Option<bool>,
    /// Specifies that already existing values in a merged map should be preserved
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keepMapValues")]
    pub keep_map_values: Option<bool>,
}

/// Transform is a unit of process whose input is transformed into an output with
/// the supplied configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionResourcesPatchesTransforms {
    /// Convert is used to cast the input into the given output type.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub convert: Option<CompositionRevisionResourcesPatchesTransformsConvert>,
    /// Map uses the input as a key in the given map and returns the value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub map: Option<BTreeMap<String, serde_json::Value>>,
    /// Match is a more complex version of Map that matches a list of patterns.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "match")]
    pub r#match: Option<CompositionRevisionResourcesPatchesTransformsMatch>,
    /// Math is used to transform the input via mathematical operations such as
    /// multiplication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub math: Option<CompositionRevisionResourcesPatchesTransformsMath>,
    /// String is used to transform the input into a string or a different kind
    /// of string. Note that the input does not necessarily need to be a string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub string: Option<CompositionRevisionResourcesPatchesTransformsString>,
    /// Type of the transform to be run.
    #[serde(rename = "type")]
    pub r#type: CompositionRevisionResourcesPatchesTransformsType,
}

/// Convert is used to cast the input into the given output type.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionResourcesPatchesTransformsConvert {
    /// The expected input format.
    /// 
    /// * `quantity` - parses the input as a K8s [`resource.Quantity`](<https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).>
    /// Only used during `string -> float64` conversions.
    /// * `json` - parses the input as a JSON string.
    /// Only used during `string -> object` or `string -> list` conversions.
    /// 
    /// If this property is null, the default conversion is applied.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<CompositionRevisionResourcesPatchesTransformsConvertFormat>,
    /// ToType is the type of the output of this transform.
    #[serde(rename = "toType")]
    pub to_type: CompositionRevisionResourcesPatchesTransformsConvertToType,
}

/// Convert is used to cast the input into the given output type.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesTransformsConvertFormat {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "quantity")]
    Quantity,
    #[serde(rename = "json")]
    Json,
}

/// Convert is used to cast the input into the given output type.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesTransformsConvertToType {
    #[serde(rename = "string")]
    String,
    #[serde(rename = "int")]
    Int,
    #[serde(rename = "int64")]
    Int64,
    #[serde(rename = "bool")]
    Bool,
    #[serde(rename = "float64")]
    Float64,
    #[serde(rename = "object")]
    Object,
    #[serde(rename = "array")]
    Array,
}

/// Match is a more complex version of Map that matches a list of patterns.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatchesTransformsMatch {
    /// Determines to what value the transform should fallback if no pattern matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fallbackTo")]
    pub fallback_to: Option<CompositionRevisionResourcesPatchesTransformsMatchFallbackTo>,
    /// The fallback value that should be returned by the transform if now pattern
    /// matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fallbackValue")]
    pub fallback_value: Option<serde_json::Value>,
    /// The patterns that should be tested against the input string.
    /// Patterns are tested in order. The value of the first match is used as
    /// result of this transform.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patterns: Option<Vec<CompositionRevisionResourcesPatchesTransformsMatchPatterns>>,
}

/// Match is a more complex version of Map that matches a list of patterns.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesTransformsMatchFallbackTo {
    Value,
    Input,
}

/// MatchTransformPattern is a transform that returns the value that matches a
/// pattern.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionResourcesPatchesTransformsMatchPatterns {
    /// Literal exactly matches the input string (case sensitive).
    /// Is required if `type` is `literal`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub literal: Option<String>,
    /// Regexp to match against the input string.
    /// Is required if `type` is `regexp`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regexp: Option<String>,
    /// The value that is used as result of the transform if the pattern matches.
    pub result: serde_json::Value,
    /// Type specifies how the pattern matches the input.
    /// 
    /// * `literal` - the pattern value has to exactly match (case sensitive) the
    /// input string. This is the default.
    /// 
    /// * `regexp` - the pattern treated as a regular expression against
    /// which the input string is tested. Crossplane will throw an error if the
    /// key is not a valid regexp.
    #[serde(rename = "type")]
    pub r#type: CompositionRevisionResourcesPatchesTransformsMatchPatternsType,
}

/// MatchTransformPattern is a transform that returns the value that matches a
/// pattern.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesTransformsMatchPatternsType {
    #[serde(rename = "literal")]
    Literal,
    #[serde(rename = "regexp")]
    Regexp,
}

/// Math is used to transform the input via mathematical operations such as
/// multiplication.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatchesTransformsMath {
    /// ClampMax makes sure that the value is not bigger than the given value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clampMax")]
    pub clamp_max: Option<i64>,
    /// ClampMin makes sure that the value is not smaller than the given value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clampMin")]
    pub clamp_min: Option<i64>,
    /// Multiply the value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub multiply: Option<i64>,
    /// Type of the math transform to be run.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<CompositionRevisionResourcesPatchesTransformsMathType>,
}

/// Math is used to transform the input via mathematical operations such as
/// multiplication.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesTransformsMathType {
    Multiply,
    ClampMin,
    ClampMax,
}

/// String is used to transform the input into a string or a different kind
/// of string. Note that the input does not necessarily need to be a string.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatchesTransformsString {
    /// Optional conversion method to be specified.
    /// `ToUpper` and `ToLower` change the letter case of the input string.
    /// `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
    /// `ToJson` converts any input value into its raw JSON representation.
    /// `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
    /// converted to JSON.
    /// `ToAdler32` generate a addler32 hash based on the input string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub convert: Option<CompositionRevisionResourcesPatchesTransformsStringConvert>,
    /// Format the input using a Go format string. See
    /// <https://golang.org/pkg/fmt/> for details.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fmt: Option<String>,
    /// Join defines parameters to join a slice of values to a string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub join: Option<CompositionRevisionResourcesPatchesTransformsStringJoin>,
    /// Extract a match from the input using a regular expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regexp: Option<CompositionRevisionResourcesPatchesTransformsStringRegexp>,
    /// Trim the prefix or suffix from the input
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trim: Option<String>,
    /// Type of the string transform to be run.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<CompositionRevisionResourcesPatchesTransformsStringType>,
}

/// String is used to transform the input into a string or a different kind
/// of string. Note that the input does not necessarily need to be a string.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesTransformsStringConvert {
    ToUpper,
    ToLower,
    ToBase64,
    FromBase64,
    ToJson,
    ToSha1,
    ToSha256,
    ToSha512,
    ToAdler32,
}

/// Join defines parameters to join a slice of values to a string.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatchesTransformsStringJoin {
    /// Separator defines the character that should separate the values from each
    /// other in the joined string.
    pub separator: String,
}

/// Extract a match from the input using a regular expression.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesPatchesTransformsStringRegexp {
    /// Group number to match. 0 (the default) matches the entire expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<i64>,
    /// Match string. May optionally include submatches, aka capture groups.
    /// See <https://pkg.go.dev/regexp/> for details.
    #[serde(rename = "match")]
    pub r#match: String,
}

/// String is used to transform the input into a string or a different kind
/// of string. Note that the input does not necessarily need to be a string.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesTransformsStringType {
    Format,
    Convert,
    TrimPrefix,
    TrimSuffix,
    Regexp,
    Join,
}

/// Transform is a unit of process whose input is transformed into an output with
/// the supplied configuration.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesTransformsType {
    #[serde(rename = "map")]
    Map,
    #[serde(rename = "match")]
    Match,
    #[serde(rename = "math")]
    Math,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "convert")]
    Convert,
}

/// Patch objects are applied between composite and composed resources. Their
/// behaviour depends on the Type selected. The default Type,
/// FromCompositeFieldPath, copies a value from the composite resource to
/// the composed resource, applying any defined transformers.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesPatchesType {
    FromCompositeFieldPath,
    PatchSet,
    ToCompositeFieldPath,
    CombineFromComposite,
    CombineToComposite,
}

/// ReadinessCheck is used to indicate how to tell whether a resource is ready
/// for consumption.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct CompositionRevisionResourcesReadinessChecks {
    /// FieldPath shows the path of the field whose value will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchCondition")]
    pub match_condition: Option<CompositionRevisionResourcesReadinessChecksMatchCondition>,
    /// MatchInt is the value you'd like to match if you're using "MatchInt" type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchInteger")]
    pub match_integer: Option<i64>,
    /// MatchString is the value you'd like to match if you're using "MatchString" type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchString")]
    pub match_string: Option<String>,
    /// Type indicates the type of probe you'd like to use.
    #[serde(rename = "type")]
    pub r#type: CompositionRevisionResourcesReadinessChecksType,
}

/// MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionResourcesReadinessChecksMatchCondition {
    /// Status is the status of the condition you'd like to match.
    pub status: String,
    /// Type indicates the type of condition you'd like to use.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// ReadinessCheck is used to indicate how to tell whether a resource is ready
/// for consumption.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum CompositionRevisionResourcesReadinessChecksType {
    MatchString,
    MatchInteger,
    NonEmpty,
    MatchCondition,
    MatchTrue,
    MatchFalse,
    None,
}

/// CompositionRevisionStatus shows the observed state of the composition
/// revision.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct CompositionRevisionStatus {
    /// Conditions of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

