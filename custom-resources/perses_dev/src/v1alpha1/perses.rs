// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/perses/perses-operator/perses.dev/v1alpha1/perses.yaml
// kopium version: 0.22.4

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// PersesSpec defines the desired state of Perses
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "perses.dev", version = "v1alpha1", kind = "Perses", plural = "perses")]
#[kube(namespaced)]
#[kube(status = "PersesStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct PersesSpec {
    /// Affinity is a group of affinity scheduling rules.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<PersesAffinity>,
    /// Args extra arguments to pass to perses
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Perses client configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client: Option<PersesClient>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<PersesConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPort")]
    pub container_port: Option<i32>,
    /// Image specifies the container image that should be used for the Perses deployment.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Probe describes a health check to be performed against a container to determine whether it is
    /// alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<PersesLivenessProbe>,
    /// Metadata to add to deployed pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PersesMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Probe describes a health check to be performed against a container to determine whether it is
    /// alive or ready to receive traffic.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<PersesReadinessProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// service specifies the service configuration for the perses instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<PersesService>,
    /// ServiceAccountName is the name of the service account to use for the perses deployment or statefulset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountName")]
    pub service_account_name: Option<String>,
    /// Storage configuration used by the StatefulSet
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<PersesStorage>,
    /// tls specifies the tls configuration for the perses instance
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<PersesTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PersesTolerations>>,
}

/// Affinity is a group of affinity scheduling rules.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinity {
    /// Describes node affinity scheduling rules for the pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<PersesAffinityNodeAffinity>,
    /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<PersesAffinityPodAffinity>,
    /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<PersesAffinityPodAntiAffinity>,
}

/// Describes node affinity scheduling rules for the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityNodeAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node matches the corresponding matchExpressions; the
    /// node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PersesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to an update), the system
    /// may or may not try to eventually evict the pod from its node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PersesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

/// An empty preferred scheduling term matches all objects with implicit weight 0
/// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// A node selector term, associated with the corresponding weight.
    pub preference: PersesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    pub weight: i32,
}

/// A node selector term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /// A list of node selector requirements by node's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    /// A list of node selector requirements by node's fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PersesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// If the affinity requirements specified by this field are not met at
/// scheduling time, the pod will not be scheduled onto the node.
/// If the affinity requirements specified by this field cease to be met
/// at some point during pod execution (e.g. due to an update), the system
/// may or may not try to eventually evict the pod from its node.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// Required. A list of node selector terms. The terms are ORed.
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PersesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

/// A null or empty node selector term matches no objects. The requirements of
/// them are ANDed.
/// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /// A list of node selector requirements by node's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    /// A list of node selector requirements by node's fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PersesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    /// node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to a pod label update), the
    /// system may or may not try to eventually evict the pod from its node.
    /// When there are multiple elements, the lists of nodes corresponding to each
    /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// Required. A pod affinity term, associated with the corresponding weight.
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    /// weight associated with matching the corresponding podAffinityTerm,
    /// in the range 1-100.
    pub weight: i32,
}

/// Required. A pod affinity term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /// A label query over a set of resources, in this case pods.
    /// If it's null, this PodAffinityTerm matches with no Pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    /// Also, matchLabelKeys cannot be set when labelSelector isn't set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MismatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    /// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
/// If it's null, this PodAffinityTerm matches with no Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Defines a set of pods (namely those matching the labelSelector
/// relative to the given namespace(s)) that this pod should be
/// co-located (affinity) or not co-located (anti-affinity) with,
/// where co-located is defined as running on a node whose value of
/// the label with key <topologyKey> matches that of any node on which
/// a pod of the set of pods is running
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// A label query over a set of resources, in this case pods.
    /// If it's null, this PodAffinityTerm matches with no Pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    /// Also, matchLabelKeys cannot be set when labelSelector isn't set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MismatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    /// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
/// If it's null, this PodAffinityTerm matches with no Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the anti-affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling anti-affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    /// node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the anti-affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the anti-affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to a pod label update), the
    /// system may or may not try to eventually evict the pod from its node.
    /// When there are multiple elements, the lists of nodes corresponding to each
    /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// Required. A pod affinity term, associated with the corresponding weight.
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    /// weight associated with matching the corresponding podAffinityTerm,
    /// in the range 1-100.
    pub weight: i32,
}

/// Required. A pod affinity term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /// A label query over a set of resources, in this case pods.
    /// If it's null, this PodAffinityTerm matches with no Pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    /// Also, matchLabelKeys cannot be set when labelSelector isn't set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MismatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    /// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
/// If it's null, this PodAffinityTerm matches with no Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Defines a set of pods (namely those matching the labelSelector
/// relative to the given namespace(s)) that this pod should be
/// co-located (affinity) or not co-located (anti-affinity) with,
/// where co-located is defined as running on a node whose value of
/// the label with key <topologyKey> matches that of any node on which
/// a pod of the set of pods is running
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// A label query over a set of resources, in this case pods.
    /// If it's null, this PodAffinityTerm matches with no Pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    /// Also, matchLabelKeys cannot be set when labelSelector isn't set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MismatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    /// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
/// If it's null, this PodAffinityTerm matches with no Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Perses client configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesClient {
    /// BasicAuth basic auth config for perses client
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<PersesClientBasicAuth>,
    /// KubernetesAuth configuration for perses client
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesAuth")]
    pub kubernetes_auth: Option<PersesClientKubernetesAuth>,
    /// OAuth configuration for perses client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth: Option<PersesClientOauth>,
    /// TLS the equivalent to the tls_config for perses client
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<PersesClientTls>,
}

/// BasicAuth basic auth config for perses client
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PersesClientBasicAuth {
    /// Name of basic auth k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namsespace of certificate k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Path to password
    pub password_path: String,
    /// Type source type of secret
    #[serde(rename = "type")]
    pub r#type: PersesClientBasicAuthType,
    /// Username for basic auth
    pub username: String,
}

/// BasicAuth basic auth config for perses client
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PersesClientBasicAuthType {
    #[serde(rename = "secret")]
    Secret,
    #[serde(rename = "configmap")]
    Configmap,
    #[serde(rename = "file")]
    File,
}

/// KubernetesAuth configuration for perses client
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesClientKubernetesAuth {
    /// Enable kubernetes auth for perses client
    pub enable: bool,
}

/// OAuth configuration for perses client
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PersesClientOauth {
    /// AuthStyle optionally specifies how the endpoint wants the
    /// client ID & client secret sent. The zero value means to
    /// auto-detect.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authStyle")]
    pub auth_style: Option<i64>,
    /// Path to client id
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientIDPath")]
    pub client_id_path: Option<String>,
    /// Path to client secret
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientSecretPath")]
    pub client_secret_path: Option<String>,
    /// EndpointParams specifies additional parameters for requests to the token endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, Vec<String>>>,
    /// Name of basic auth k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namsespace of certificate k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Scope specifies optional requested permissions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// TokenURL is the resource server's token endpoint
    /// URL. This is a constant specific to each server.
    #[serde(rename = "tokenURL")]
    pub token_url: String,
    /// Type source type of secret
    #[serde(rename = "type")]
    pub r#type: PersesClientOauthType,
}

/// OAuth configuration for perses client
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PersesClientOauthType {
    #[serde(rename = "secret")]
    Secret,
    #[serde(rename = "configmap")]
    Configmap,
    #[serde(rename = "file")]
    File,
}

/// TLS the equivalent to the tls_config for perses client
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesClientTls {
    /// CaCert to verify the perses certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCert")]
    pub ca_cert: Option<PersesClientTlsCaCert>,
    /// Enable TLS connection to perses
    pub enable: bool,
    /// InsecureSkipVerify skip verify of perses certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// UserCert client cert/key for mTLS
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userCert")]
    pub user_cert: Option<PersesClientTlsUserCert>,
}

/// CaCert to verify the perses certificate
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PersesClientTlsCaCert {
    /// Path to Certificate
    #[serde(rename = "certPath")]
    pub cert_path: String,
    /// Name of basic auth k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namsespace of certificate k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Path to Private key certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyPath")]
    pub private_key_path: Option<String>,
    /// Type source type of secret
    #[serde(rename = "type")]
    pub r#type: PersesClientTlsCaCertType,
}

/// CaCert to verify the perses certificate
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PersesClientTlsCaCertType {
    #[serde(rename = "secret")]
    Secret,
    #[serde(rename = "configmap")]
    Configmap,
    #[serde(rename = "file")]
    File,
}

/// UserCert client cert/key for mTLS
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PersesClientTlsUserCert {
    /// Path to Certificate
    #[serde(rename = "certPath")]
    pub cert_path: String,
    /// Name of basic auth k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namsespace of certificate k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Path to Private key certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyPath")]
    pub private_key_path: Option<String>,
    /// Type source type of secret
    #[serde(rename = "type")]
    pub r#type: PersesClientTlsUserCertType,
}

/// UserCert client cert/key for mTLS
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PersesClientTlsUserCertType {
    #[serde(rename = "secret")]
    Secret,
    #[serde(rename = "configmap")]
    Configmap,
    #[serde(rename = "file")]
    File,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfig {
    /// Use it in case you want to prefix the API path.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub api_prefix: Option<String>,
    /// Dashboard contains the configuration for the dashboard feature.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dashboard: Option<PersesConfigDashboard>,
    /// Database contains the different configuration depending on the database you want to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub database: Option<PersesConfigDatabase>,
    /// Datasource contains the configuration for the datasource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datasource: Option<PersesConfigDatasource>,
    /// EphemeralDashboard contains the config about the ephemeral dashboard feature
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral_dashboard: Option<PersesConfigEphemeralDashboard>,
    /// EphemeralDashboardsCleanupInterval is the interval at which the ephemeral dashboards are cleaned up
    /// DEPRECATED.
    /// Please use the config EphemeralDashboard instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral_dashboards_cleanup_interval: Option<String>,
    /// Frontend contains any config that will be used by the frontend itself.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub frontend: Option<PersesConfigFrontend>,
    /// Plugin contains the config for runtime plugins.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub plugin: Option<PersesConfigPlugin>,
    /// Provisioning contains the provisioning config that can be used if you want to provide default resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provisioning: Option<PersesConfigProvisioning>,
    /// Schemas contain the configuration to get access to the CUE schemas
    /// DEPRECATED.
    /// Please remove it from your config.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schemas: Option<PersesConfigSchemas>,
    /// Security contains any configuration that changes the API behavior like the endpoints exposed or if the permissions are activated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub security: Option<PersesConfigSecurity>,
    /// Variable contains the configuration for the variable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variable: Option<PersesConfigVariable>,
}

/// Dashboard contains the configuration for the dashboard feature.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDashboard {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_lint_rules: Option<Vec<PersesConfigDashboardCustomLintRules>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDashboardCustomLintRules {
    /// Assertion is a CEL expression that validates the extracted value.
    /// Refer to <https://github.com/google/cel-spec/blob/master/doc/langdef.md> for the syntax.
    pub assertion: String,
    /// Disable is a flag to disable the rule.
    pub disable: bool,
    /// Message is displayed if the assertion fails.
    pub message: String,
    /// Name of the rule
    pub name: String,
    /// Target is a JSONPath expression to extract the relevant portion of the dashboard data.
    /// Refer to <https://goessner.net/articles/JsonPath/> for the syntax.
    pub target: String,
}

/// Database contains the different configuration depending on the database you want to use
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatabase {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub file: Option<PersesConfigDatabaseFile>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sql: Option<PersesConfigDatabaseSql>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatabaseFile {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub case_sensitive: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extension: Option<String>,
    pub folder: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatabaseSql {
    /// Network address (requires Net)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub addr: Option<String>,
    /// Allow all files to be used with LOAD DATA LOCAL INFILE
    pub allow_all_files: bool,
    /// Allows the cleartext client side plugin
    pub allow_cleartext_passwords: bool,
    /// Allows fallback to unencrypted connection if server does not support TLS
    pub allow_fallback_to_plaintext: bool,
    /// Allows the native password authentication method
    pub allow_native_passwords: bool,
    /// Allows the old insecure password method
    pub allow_old_passwords: bool,
    pub case_sensitive: bool,
    /// Check connections for liveness before using them
    pub check_conn_liveness: bool,
    /// Return number of matching rows instead of rows changed
    pub client_found_rows: bool,
    /// Connection collation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub collation: Option<String>,
    /// Prepend table alias to column names
    pub columns_with_alias: bool,
    /// Database name
    pub db_name: String,
    /// Interpolate placeholders into query string
    pub interpolate_params: bool,
    /// Location for time.Time values
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loc: Option<PersesConfigDatabaseSqlLoc>,
    /// Max packet size allowed
    pub max_allowed_packet: i64,
    /// Allow multiple statements in one query
    pub multi_statements: bool,
    /// Network type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub net: Option<String>,
    /// Parse time values to time.Time
    pub parse_time: bool,
    /// Password (requires User)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// PasswordFile is a path to a file that contains a password
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password_file: Option<String>,
    /// I/O read timeout
    pub read_timeout: String,
    /// Reject read-only connections
    pub reject_read_only: bool,
    /// Server public key name
    pub server_pub_key: String,
    /// Dial timeout
    pub timeout: String,
    /// TLS configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<PersesConfigDatabaseSqlTlsConfig>,
    /// Username
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// I/O write timeout
    pub write_timeout: String,
}

/// Location for time.Time values
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatabaseSqlLoc {
}

/// TLS configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatabaseSqlTlsConfig {
    /// Text of the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<String>,
    /// The CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_file: Option<String>,
    /// CARef is the name of the secret within the secret manager to use as the CA cert for the
    /// targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca_ref: Option<String>,
    /// Text of the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<String>,
    /// The client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert_file: Option<String>,
    /// CertRef is the name of the secret within the secret manager to use as the client cert for
    /// the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert_ref: Option<String>,
    /// Disable target certificate validation.
    pub insecure_skip_verify: bool,
    /// Text of the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key_file: Option<String>,
    /// KeyRef is the name of the secret within the secret manager to use as the client key for
    /// the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key_ref: Option<String>,
    /// Maximum TLS version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_version: Option<i64>,
    /// Minimum TLS version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub min_version: Option<i64>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server_name: Option<String>,
}

/// Datasource contains the configuration for the datasource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasource {
    /// DisableLocal when used is preventing the possibility to add a datasource directly in the dashboard spec.
    /// It will also disable the associated proxy.
    pub disable_local: bool,
    pub global: PersesConfigDatasourceGlobal,
    pub project: PersesConfigDatasourceProject,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobal {
    /// Disable is used to disable the global datasource feature.
    /// It will also remove the associated proxy.
    /// Also, since the global variable depends on the global datasource, it will also disable the global variable feature.
    pub disable: bool,
    /// Discovery is the configuration that helps to generate a list of global datasource based on the discovery chosen.
    /// Be careful: the data coming from the discovery will totally override what exists in the database.
    /// Note that this is an experimental feature. Behavior and config may change in the future.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discovery: Option<Vec<PersesConfigDatasourceGlobalDiscovery>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscovery {
    /// HTTP-based service discovery provides a more generic way to generate a set of global datasource and serves as an interface to plug in custom service discovery mechanisms.
    /// It fetches an HTTP endpoint containing a list of zero or more global datasources.
    /// The target must reply with an HTTP 200 response.
    /// The HTTP header Content-Type must be application/json, and the body must be valid array of JSON.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http_sd: Option<PersesConfigDatasourceGlobalDiscoveryHttpSd>,
    /// Kubernetes SD configurations allow retrieving global datasource from Kubernetes' REST API
    /// and always staying synchronized with the cluster state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kubernetes_sd: Option<PersesConfigDatasourceGlobalDiscoveryKubernetesSd>,
    /// The name of the discovery config. It is used for logging purposes only
    pub name: String,
    /// Refresh interval to re-query the endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub refresh_interval: Option<String>,
}

/// HTTP-based service discovery provides a more generic way to generate a set of global datasource and serves as an interface to plug in custom service discovery mechanisms.
/// It fetches an HTTP endpoint containing a list of zero or more global datasources.
/// The target must reply with an HTTP 200 response.
/// The HTTP header Content-Type must be application/json, and the body must be valid array of JSON.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscoveryHttpSd {
    /// The HTTP authorization credentials for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<PersesConfigDatasourceGlobalDiscoveryHttpSdAuthorization>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<PersesConfigDatasourceGlobalDiscoveryHttpSdBasicAuth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub native_auth: Option<PersesConfigDatasourceGlobalDiscoveryHttpSdNativeAuth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth: Option<PersesConfigDatasourceGlobalDiscoveryHttpSdOauth>,
    /// TLSConfig to use to connect to the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<PersesConfigDatasourceGlobalDiscoveryHttpSdTlsConfig>,
    pub url: String,
}

/// The HTTP authorization credentials for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscoveryHttpSdAuthorization {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsFile")]
    pub credentials_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscoveryHttpSdBasicAuth {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// PasswordFile is a path to a file that contains a password
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordFile")]
    pub password_file: Option<String>,
    pub username: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscoveryHttpSdNativeAuth {
    pub login: String,
    pub password: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscoveryHttpSdOauth {
    /// AuthStyle optionally specifies how the endpoint wants the
    /// client ID & client secret sent. The zero value means to
    /// auto-detect.
    #[serde(rename = "authStyle")]
    pub auth_style: i64,
    /// ClientID is the application's ID.
    #[serde(rename = "clientID")]
    pub client_id: String,
    /// ClientSecret is the application's secret.
    #[serde(rename = "clientSecret")]
    pub client_secret: String,
    #[serde(rename = "clientSecretFile")]
    pub client_secret_file: String,
    /// EndpointParams specifies additional parameters for requests to the token endpoint.
    #[serde(rename = "endpointParams")]
    pub endpoint_params: BTreeMap<String, Vec<String>>,
    /// Scope specifies optional requested permissions.
    pub scopes: Vec<String>,
    /// TokenURL is the resource server's token endpoint
    /// URL. This is a constant specific to each server.
    #[serde(rename = "tokenURL")]
    pub token_url: String,
}

/// TLSConfig to use to connect to the targets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscoveryHttpSdTlsConfig {
    /// Text of the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<String>,
    /// The CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Text of the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<String>,
    /// The client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Text of the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Maximum acceptable TLS version. Accepted values: TLS10 (TLS 1.0), TLS11 (TLS 1.1), TLS12 (TLS 1.2), TLS13 (TLS 1.3).
    /// If unset, Perses will use Go default maximum version, which is TLS 1.3.
    /// See MaxVersion in <https://pkg.go.dev/crypto/tls#Config.>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<String>,
    /// Minimum acceptable TLS version. Accepted values: TLS10 (TLS 1.0), TLS11 (TLS 1.1), TLS12 (TLS 1.2), TLS13 (TLS 1.3).
    /// If unset, Perses will use Go default minimum version, which is TLS 1.2.
    /// See MinVersion in <https://pkg.go.dev/crypto/tls#Config.>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<String>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Kubernetes SD configurations allow retrieving global datasource from Kubernetes' REST API
/// and always staying synchronized with the cluster state.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscoveryKubernetesSd {
    /// DatasourcePluginKind is the name of the datasource plugin that should be filled when creating datasources found.
    pub datasource_plugin_kind: String,
    /// The labels used to filter the list of resource when contacting the Kubernetes API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Kubernetes namespace to constraint the query to only one namespace.
    /// Leave empty if you are looking for datasource cross-namespace.
    pub namespace: String,
    /// Configuration when you want to discover the pods in Kubernetes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pod_configuration: Option<PersesConfigDatasourceGlobalDiscoveryKubernetesSdPodConfiguration>,
    /// Configuration when you want to discover the services in Kubernetes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_configuration: Option<PersesConfigDatasourceGlobalDiscoveryKubernetesSdServiceConfiguration>,
}

/// Configuration when you want to discover the pods in Kubernetes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscoveryKubernetesSdPodConfiguration {
    /// Name of the container the target address points to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container_name: Option<String>,
    /// Name of the container port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container_port_name: Option<String>,
    /// Number of the container port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container_port_number: Option<i32>,
    /// If set to true, Perses server will discovery the pod
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
}

/// Configuration when you want to discover the services in Kubernetes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceGlobalDiscoveryKubernetesSdServiceConfiguration {
    /// If set to true, Perses server will discovery the service
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Name of the service port for the target.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port_name: Option<String>,
    /// Number of the service port for the target.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port_number: Option<i32>,
    /// The type of the service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigDatasourceProject {
    /// Disable is used to disable the project datasource feature.
    /// It will also remove the associated proxy.
    pub disable: bool,
}

/// EphemeralDashboard contains the config about the ephemeral dashboard feature
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigEphemeralDashboard {
    /// The interval at which to trigger the cleanup of ephemeral dashboards, based on their TTLs.
    pub cleanup_interval: String,
    /// When true user will be able to use the ephemeral dashboard at project level.
    pub enable: bool,
}

/// Frontend contains any config that will be used by the frontend itself.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigFrontend {
    /// When it is true, Perses won't serve the frontend anymore, and any other config set here will be ignored
    pub disable: bool,
    /// Explorer is activating the different kind of explorer supported.
    /// Be sure you have installed an associated plugin for each explorer type.
    pub explorer: PersesConfigFrontendExplorer,
    /// ImportantDashboards contains important dashboard selectors
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub important_dashboards: Option<Vec<PersesConfigFrontendImportantDashboards>>,
    /// Information contains markdown content to be display on the home page
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub information: Option<String>,
    /// TimeRange contains the time range configuration for the dropdown
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time_range: Option<PersesConfigFrontendTimeRange>,
}

/// Explorer is activating the different kind of explorer supported.
/// Be sure you have installed an associated plugin for each explorer type.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigFrontendExplorer {
    pub enable: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigFrontendImportantDashboards {
    /// Dashboard is the name of the dashboard (dashboard.metadata.name)
    pub dashboard: String,
    /// Project is the name of the project (dashboard.metadata.project)
    pub project: String,
}

/// TimeRange contains the time range configuration for the dropdown
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigFrontendTimeRange {
    pub disable_custom: bool,
    pub disable_zoom: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
}

/// Plugin contains the config for runtime plugins.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigPlugin {
    /// ArchivePath is the path to the directory containing the archived plugins
    /// When Perses is starting, it will extract the content of the archive in the folder specified in the `folder` attribute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archive_path: Option<String>,
    /// DevEnvironment is the configuration to use when developing a plugin
    pub enable_dev: bool,
    /// Path is the path to the directory containing the runtime plugins
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

/// Provisioning contains the provisioning config that can be used if you want to provide default resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigProvisioning {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub folders: Option<Vec<String>>,
    /// Interval is the refresh frequency
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
}

/// Schemas contain the configuration to get access to the CUE schemas
/// DEPRECATED.
/// Please remove it from your config.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSchemas {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub datasources_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub panels_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub queries_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables_path: Option<String>,
}

/// Security contains any configuration that changes the API behavior like the endpoints exposed or if the permissions are activated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurity {
    /// Authentication contains configuration regarding management of access/refresh token
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<PersesConfigSecurityAuthentication>,
    /// Authorization contains all configs around rbac (permissions and roles)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<PersesConfigSecurityAuthorization>,
    /// Cookie configuration
    pub cookie: PersesConfigSecurityCookie,
    /// Configuration for the CORS middleware.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cors: Option<PersesConfigSecurityCors>,
    /// When it is true, the authentication and authorization config are considered.
    /// And you will need a valid JWT token to contact most of the endpoints exposed by the API
    pub enable_auth: bool,
    /// EncryptionKey is the secret key used to encrypt and decrypt sensitive data
    /// stored in the database such as the password of the basic auth for a datasource.
    /// Note that if it is not provided, it will use a default value.
    /// On a production instance, you should set this key.
    /// Also note the key size must be exactly 32 bytes long as we are using AES-256 to encrypt the data.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption_key: Option<String>,
    /// EncryptionKeyFile is the path to file containing the secret key
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption_key_file: Option<String>,
    /// Readonly will deactivate any HTTP POST, PUT, DELETE endpoint
    pub readonly: bool,
}

/// Authentication contains configuration regarding management of access/refresh token
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthentication {
    /// AccessTokenTTL is the time to live of the access token. By default, it is 15 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub access_token_ttl: Option<String>,
    /// DisableSignUp deactivates the Sign-up page in the UI.
    /// It also disables the endpoint that gives the possibility to create a user.
    pub disable_sign_up: bool,
    /// Providers configure the different authentication providers
    pub providers: PersesConfigSecurityAuthenticationProviders,
    /// RefreshTokenTTL is the time to live of the refresh token.
    /// The refresh token is used to get a new access token when it is expired.
    /// By default, it is 24 hours.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub refresh_token_ttl: Option<String>,
}

/// Providers configure the different authentication providers
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProviders {
    pub enable_native: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth: Option<Vec<PersesConfigSecurityAuthenticationProvidersOauth>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oidc: Option<Vec<PersesConfigSecurityAuthenticationProvidersOidc>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOauth {
    pub auth_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_credentials: Option<PersesConfigSecurityAuthenticationProvidersOauthClientCredentials>,
    /// Hidden special type for storing secrets.
    pub client_id: String,
    /// Hidden special type for storing secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub custom_login_property: Option<String>,
    pub device_auth_url: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device_code: Option<PersesConfigSecurityAuthenticationProvidersOauthDeviceCode>,
    pub http: PersesConfigSecurityAuthenticationProvidersOauthHttp,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redirect_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    pub slug_id: String,
    pub token_url: String,
    pub user_infos_url: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOauthClientCredentials {
    /// Hidden special type for storing secrets.
    pub client_id: String,
    /// Hidden special type for storing secrets.
    pub client_secret: String,
    pub scopes: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOauthDeviceCode {
    /// Hidden special type for storing secrets.
    pub client_id: String,
    /// Hidden special type for storing secrets.
    pub client_secret: String,
    pub scopes: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOauthHttp {
    pub timeout: String,
    pub tls_config: PersesConfigSecurityAuthenticationProvidersOauthHttpTlsConfig,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOauthHttpTlsConfig {
    /// Text of the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<String>,
    /// The CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Text of the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<String>,
    /// The client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Text of the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Maximum acceptable TLS version. Accepted values: TLS10 (TLS 1.0), TLS11 (TLS 1.1), TLS12 (TLS 1.2), TLS13 (TLS 1.3).
    /// If unset, Perses will use Go default maximum version, which is TLS 1.3.
    /// See MaxVersion in <https://pkg.go.dev/crypto/tls#Config.>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<String>,
    /// Minimum acceptable TLS version. Accepted values: TLS10 (TLS 1.0), TLS11 (TLS 1.1), TLS12 (TLS 1.2), TLS13 (TLS 1.3).
    /// If unset, Perses will use Go default minimum version, which is TLS 1.2.
    /// See MinVersion in <https://pkg.go.dev/crypto/tls#Config.>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<String>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOidc {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_credentials: Option<PersesConfigSecurityAuthenticationProvidersOidcClientCredentials>,
    /// Hidden special type for storing secrets.
    pub client_id: String,
    /// Hidden special type for storing secrets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub device_code: Option<PersesConfigSecurityAuthenticationProvidersOidcDeviceCode>,
    pub disable_pkce: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discovery_url: Option<String>,
    pub http: PersesConfigSecurityAuthenticationProvidersOidcHttp,
    pub issuer: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub redirect_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    pub slug_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url_params: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOidcClientCredentials {
    /// Hidden special type for storing secrets.
    pub client_id: String,
    /// Hidden special type for storing secrets.
    pub client_secret: String,
    pub scopes: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOidcDeviceCode {
    /// Hidden special type for storing secrets.
    pub client_id: String,
    /// Hidden special type for storing secrets.
    pub client_secret: String,
    pub scopes: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOidcHttp {
    pub timeout: String,
    pub tls_config: PersesConfigSecurityAuthenticationProvidersOidcHttpTlsConfig,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthenticationProvidersOidcHttpTlsConfig {
    /// Text of the CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<String>,
    /// The CA cert to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Text of the client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<String>,
    /// The client cert file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Text of the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Maximum acceptable TLS version. Accepted values: TLS10 (TLS 1.0), TLS11 (TLS 1.1), TLS12 (TLS 1.2), TLS13 (TLS 1.3).
    /// If unset, Perses will use Go default maximum version, which is TLS 1.3.
    /// See MaxVersion in <https://pkg.go.dev/crypto/tls#Config.>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxVersion")]
    pub max_version: Option<String>,
    /// Minimum acceptable TLS version. Accepted values: TLS10 (TLS 1.0), TLS11 (TLS 1.1), TLS12 (TLS 1.2), TLS13 (TLS 1.3).
    /// If unset, Perses will use Go default minimum version, which is TLS 1.2.
    /// See MinVersion in <https://pkg.go.dev/crypto/tls#Config.>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minVersion")]
    pub min_version: Option<String>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Authorization contains all configs around rbac (permissions and roles)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthorization {
    /// CheckLatestUpdateInterval that checks if the RBAC cache needs to be refreshed with db content. Only for SQL database setup.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub check_latest_update_interval: Option<String>,
    /// Default permissions for guest users (logged-in users)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guest_permissions: Option<Vec<PersesConfigSecurityAuthorizationGuestPermissions>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityAuthorizationGuestPermissions {
    /// Actions of the permission (read, create, update, delete, ...)
    pub actions: Vec<String>,
    /// The list of kind targeted by the permission. For example: `Datasource`, `Dashboard`, ...
    /// With Role, you can't target global kinds
    pub scopes: Vec<String>,
}

/// Cookie configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityCookie {
    /// Set the SameSite cookie attribute and prevents the browser from sending the cookie along with cross-site requests.
    /// The main goal is to mitigate the risk of cross-origin information leakage.
    /// This setting also provides some protection against cross-site request forgery attacks (CSRF)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub same_site: Option<i64>,
    /// Set to true if you host Perses behind HTTPS. Default is false
    pub secure: bool,
}

/// Configuration for the CORS middleware.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigSecurityCors {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_credentials: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_methods: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub allow_origins: Option<Vec<String>>,
    pub enable: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expose_headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_age: Option<i64>,
}

/// Variable contains the configuration for the variable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigVariable {
    /// DisableLocal when used is preventing the possibility to add a variable directly in the dashboard spec.
    pub disable_local: bool,
    pub global: PersesConfigVariableGlobal,
    pub project: PersesConfigVariableProject,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigVariableGlobal {
    /// Disable is used to disable the global variable feature.
    /// Note that if the global datasource is disabled, the global variable will also be disabled.
    pub disable: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesConfigVariableProject {
    /// Disable is used to disable the project variable feature.
    /// Note that if the global datasource and the project datasource are disabled,
    /// then the project variable will also be disabled.
    pub disable: bool,
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesLivenessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PersesLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<PersesLivenessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PersesLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PersesLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<PersesLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Metadata to add to deployed pods
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesReadinessProbe {
    /// Exec specifies a command to execute in the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PersesReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies a GRPC HealthCheckRequest.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<PersesReadinessProbeGrpc>,
    /// HTTPGet specifies an HTTP GET request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PersesReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies a connection to a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PersesReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies a command to execute in the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies a GRPC HealthCheckRequest.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies an HTTP GET request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<PersesReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies a connection to a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// service specifies the service configuration for the perses instance
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Storage configuration used by the StatefulSet
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesStorage {
    /// Size of the storage.
    /// cannot be decreased.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<IntOrString>,
    /// StorageClass to use for PVCs.
    /// If not specified, will use the default storage class
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClass")]
    pub storage_class: Option<String>,
}

/// tls specifies the tls configuration for the perses instance
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesTls {
    /// CaCert to verify the perses certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCert")]
    pub ca_cert: Option<PersesTlsCaCert>,
    /// Enable TLS connection to perses
    pub enable: bool,
    /// InsecureSkipVerify skip verify of perses certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// UserCert client cert/key for mTLS
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "userCert")]
    pub user_cert: Option<PersesTlsUserCert>,
}

/// CaCert to verify the perses certificate
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PersesTlsCaCert {
    /// Path to Certificate
    #[serde(rename = "certPath")]
    pub cert_path: String,
    /// Name of basic auth k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namsespace of certificate k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Path to Private key certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyPath")]
    pub private_key_path: Option<String>,
    /// Type source type of secret
    #[serde(rename = "type")]
    pub r#type: PersesTlsCaCertType,
}

/// CaCert to verify the perses certificate
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PersesTlsCaCertType {
    #[serde(rename = "secret")]
    Secret,
    #[serde(rename = "configmap")]
    Configmap,
    #[serde(rename = "file")]
    File,
}

/// UserCert client cert/key for mTLS
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PersesTlsUserCert {
    /// Path to Certificate
    #[serde(rename = "certPath")]
    pub cert_path: String,
    /// Name of basic auth k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namsespace of certificate k8s resource (when type is secret or configmap)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Path to Private key certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyPath")]
    pub private_key_path: Option<String>,
    /// Type source type of secret
    #[serde(rename = "type")]
    pub r#type: PersesTlsUserCertType,
}

/// UserCert client cert/key for mTLS
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PersesTlsUserCertType {
    #[serde(rename = "secret")]
    Secret,
    #[serde(rename = "configmap")]
    Configmap,
    #[serde(rename = "file")]
    File,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// PersesStatus defines the observed state of Perses
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct PersesStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

