// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/apecloud/kubeblocks/apps.kubeblocks.io/v1/sidecardefinitions.yaml
// kopium version: 0.21.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// SidecarDefinitionSpec defines the desired state of SidecarDefinition
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "apps.kubeblocks.io", version = "v1", kind = "SidecarDefinition", plural = "sidecardefinitions")]
#[kube(status = "SidecarDefinitionStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct SidecarDefinitionSpec {
    /// Specifies the configuration file templates used by the Sidecar.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configs: Option<Vec<SidecarDefinitionConfigs>>,
    /// List of containers for the sidecar.
    /// 
    /// 
    /// Cannot be updated.
    pub containers: Vec<SidecarDefinitionContainers>,
    /// Specifies the name of the sidecar.
    pub name: String,
    /// Specifies the component definition that the sidecar belongs to.
    /// 
    /// 
    /// For a specific cluster object, if there is any components provided by the component definition of @owner,
    /// the sidecar will be created and injected into the components which are provided by
    /// the component definition of @selectors automatically.
    /// 
    /// 
    /// This field is immutable.
    pub owner: String,
    /// Specifies the scripts used by the Sidecar.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scripts: Option<Vec<SidecarDefinitionScripts>>,
    /// Specifies the component definition of components that the sidecar along with.
    /// 
    /// 
    /// This field is immutable.
    pub selectors: Vec<String>,
    /// Defines variables which are needed by the sidecar.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vars: Option<Vec<SidecarDefinitionVars>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionConfigs {
    /// The operator attempts to set default file permissions (0444).
    /// 
    /// 
    /// Must be specified as an octal value between 0000 and 0777 (inclusive),
    /// or as a decimal value between 0 and 511 (inclusive).
    /// YAML supports both octal and decimal values for file permissions.
    /// 
    /// 
    /// Please note that this setting only affects the permissions of the files themselves.
    /// Directories within the specified path are not impacted by this setting.
    /// It's important to be aware that this setting might conflict with other options
    /// that influence the file mode, such as fsGroup.
    /// In such cases, the resulting file mode may have additional bits set.
    /// Refers to documents of k8s.ConfigMapVolumeSource.defaultMode for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// ExternalManaged indicates whether the configuration is managed by an external system.
    /// When set to true, the controller will ignore the management of this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalManaged")]
    pub external_managed: Option<bool>,
    /// Specifies the name of the template.
    pub name: String,
    /// Specifies the namespace of the referenced template ConfigMap object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specifies whether to restart the pod when the file changes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartOnFileChange")]
    pub restart_on_file_change: Option<bool>,
    /// Specifies the name of the referenced template ConfigMap object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
    /// Refers to the volume name of PodTemplate. The file produced through the template will be mounted to
    /// the corresponding volume. Must be a DNS_LABEL name.
    /// The volume name must be defined in podSpec.containers[*].volumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainers {
    /// Arguments to the entrypoint.
    /// The container image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The container image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<SidecarDefinitionContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<SidecarDefinitionContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<SidecarDefinitionContainersLifecycle>,
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<SidecarDefinitionContainersLivenessProbe>,
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    pub name: String,
    /// List of ports to expose from the container. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Modifying this array with strategic merge patch may corrupt the data.
    /// For more information See <https://github.com/kubernetes/kubernetes/issues/108255.>
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<SidecarDefinitionContainersPorts>>,
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<SidecarDefinitionContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<SidecarDefinitionContainersResizePolicy>>,
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<SidecarDefinitionContainersResources>,
    /// RestartPolicy defines the restart behavior of individual containers in a pod.
    /// This field may only be set for init containers, and the only allowed value is "Always".
    /// For non-init containers or when this field is not specified,
    /// the restart behavior is defined by the Pod's restart policy and the container type.
    /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
    /// this init container will be continually restarted on
    /// exit until all regular containers have terminated. Once all regular
    /// containers have completed, all init containers with restartPolicy "Always"
    /// will be shut down. This lifecycle differs from normal init containers and
    /// is often referred to as a "sidecar" container. Although this init
    /// container still starts in the init container sequence, it does not wait
    /// for the container to complete before proceeding to the next init
    /// container. Instead, the next init container starts immediately after this
    /// init container is started, or after any startupProbe has successfully
    /// completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<SidecarDefinitionContainersSecurityContext>,
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<SidecarDefinitionContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<SidecarDefinitionContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<SidecarDefinitionContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<SidecarDefinitionContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<SidecarDefinitionContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<SidecarDefinitionContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<SidecarDefinitionContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<SidecarDefinitionContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<SidecarDefinitionContainersEnvFromConfigMapRef>,
    /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<SidecarDefinitionContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersEnvFromSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Actions that the management system should take in response to container lifecycle events.
/// Cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<SidecarDefinitionContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<SidecarDefinitionContainersLifecyclePreStop>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePostStart {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<SidecarDefinitionContainersLifecyclePostStartExec>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<SidecarDefinitionContainersLifecyclePostStartHttpGet>,
    /// Sleep represents the duration that the container should sleep before being terminated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<SidecarDefinitionContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for the backward compatibility. There are no validation of this field and
    /// lifecycle hooks will fail in runtime when tcp handler is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<SidecarDefinitionContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<SidecarDefinitionContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents the duration that the container should sleep before being terminated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for the backward compatibility. There are no validation of this field and
/// lifecycle hooks will fail in runtime when tcp handler is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePreStop {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<SidecarDefinitionContainersLifecyclePreStopExec>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<SidecarDefinitionContainersLifecyclePreStopHttpGet>,
    /// Sleep represents the duration that the container should sleep before being terminated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<SidecarDefinitionContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for the backward compatibility. There are no validation of this field and
    /// lifecycle hooks will fail in runtime when tcp handler is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<SidecarDefinitionContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<SidecarDefinitionContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents the duration that the container should sleep before being terminated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for the backward compatibility. There are no validation of this field and
/// lifecycle hooks will fail in runtime when tcp handler is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Periodic probe of container liveness.
/// Container will be restarted if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLivenessProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<SidecarDefinitionContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<SidecarDefinitionContainersLivenessProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<SidecarDefinitionContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<SidecarDefinitionContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<SidecarDefinitionContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Periodic probe of container service readiness.
/// Container will be removed from service endpoints if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersReadinessProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<SidecarDefinitionContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<SidecarDefinitionContainersReadinessProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<SidecarDefinitionContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<SidecarDefinitionContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<SidecarDefinitionContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Compute Resources required by this container.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<SidecarDefinitionContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// SecurityContext defines the security options the container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
/// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<SidecarDefinitionContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default is DefaultProcMount which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<SidecarDefinitionContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<SidecarDefinitionContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<SidecarDefinitionContainersSecurityContextWindowsOptions>,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// StartupProbe indicates that the Pod has successfully initialized.
/// If specified, no other probes are executed until this completes successfully.
/// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
/// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
/// when it might take a long time to load data or warm a cache, than during steady-state operation.
/// This cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersStartupProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<SidecarDefinitionContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<SidecarDefinitionContainersStartupProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<SidecarDefinitionContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<SidecarDefinitionContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<SidecarDefinitionContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionScripts {
    /// The operator attempts to set default file permissions (0444).
    /// 
    /// 
    /// Must be specified as an octal value between 0000 and 0777 (inclusive),
    /// or as a decimal value between 0 and 511 (inclusive).
    /// YAML supports both octal and decimal values for file permissions.
    /// 
    /// 
    /// Please note that this setting only affects the permissions of the files themselves.
    /// Directories within the specified path are not impacted by this setting.
    /// It's important to be aware that this setting might conflict with other options
    /// that influence the file mode, such as fsGroup.
    /// In such cases, the resulting file mode may have additional bits set.
    /// Refers to documents of k8s.ConfigMapVolumeSource.defaultMode for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// ExternalManaged indicates whether the configuration is managed by an external system.
    /// When set to true, the controller will ignore the management of this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalManaged")]
    pub external_managed: Option<bool>,
    /// Specifies the name of the template.
    pub name: String,
    /// Specifies the namespace of the referenced template ConfigMap object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specifies whether to restart the pod when the file changes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartOnFileChange")]
    pub restart_on_file_change: Option<bool>,
    /// Specifies the name of the referenced template ConfigMap object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
    /// Refers to the volume name of PodTemplate. The file produced through the template will be mounted to
    /// the corresponding volume. Must be a DNS_LABEL name.
    /// The volume name must be defined in podSpec.containers[*].volumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// EnvVar represents a variable present in the env of Pod/Action or the template of config/script.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVars {
    /// A Go template expression that will be applied to the resolved value of the var.
    /// 
    /// 
    /// The expression will only be evaluated if the var is successfully resolved to a non-credential value.
    /// 
    /// 
    /// The resolved value can be accessed by its name within the expression, system vars and other user-defined
    /// non-credential vars can be used within the expression in the same way.
    /// Notice that, when accessing vars by its name, you should replace all the "-" in the name with "_", because of
    /// that "-" is not a valid identifier in Go.
    /// 
    /// 
    /// All expressions are evaluated in the order the vars are defined. If a var depends on any vars that also
    /// have expressions defined, be careful about the evaluation order as it may use intermediate values.
    /// 
    /// 
    /// The result of evaluation will be used as the final value of the var. If the expression fails to evaluate,
    /// the resolving of var will also be considered failed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Name of the variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references `$(VAR_NAME)` are expanded using the previously defined variables in the current context.
    /// 
    /// 
    /// If a variable cannot be resolved, the reference in the input string will be unchanged.
    /// Double `$$` are reduced to a single `$`, which allows for escaping the `$(VAR_NAME)` syntax: i.e.
    /// 
    /// 
    /// - `$$(VAR_NAME)` will produce the string literal `$(VAR_NAME)`.
    /// 
    /// 
    /// Escaped references will never be expanded, regardless of whether the variable exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<SidecarDefinitionVarsValueFrom>,
}

/// Source for the variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFrom {
    /// Selects a defined var of a Cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterVarRef")]
    pub cluster_var_ref: Option<SidecarDefinitionVarsValueFromClusterVarRef>,
    /// Selects a defined var of a Component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentVarRef")]
    pub component_var_ref: Option<SidecarDefinitionVarsValueFromComponentVarRef>,
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<SidecarDefinitionVarsValueFromConfigMapKeyRef>,
    /// Selects a defined var of a Credential (SystemAccount).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialVarRef")]
    pub credential_var_ref: Option<SidecarDefinitionVarsValueFromCredentialVarRef>,
    /// Selects a defined var of host-network resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetworkVarRef")]
    pub host_network_var_ref: Option<SidecarDefinitionVarsValueFromHostNetworkVarRef>,
    /// Selects a defined var of a kind of resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceVarRef")]
    pub resource_var_ref: Option<SidecarDefinitionVarsValueFromResourceVarRef>,
    /// Selects a key of a Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<SidecarDefinitionVarsValueFromSecretKeyRef>,
    /// Selects a defined var of a ServiceRef.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRefVarRef")]
    pub service_ref_var_ref: Option<SidecarDefinitionVarsValueFromServiceRefVarRef>,
    /// Selects a defined var of a Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceVarRef")]
    pub service_var_ref: Option<SidecarDefinitionVarsValueFromServiceVarRef>,
    /// Selects a defined var of the TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVarRef")]
    pub tls_var_ref: Option<SidecarDefinitionVarsValueFromTlsVarRef>,
}

/// Selects a defined var of a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromClusterVarRef {
    /// Reference to the name of the Cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterName")]
    pub cluster_name: Option<SidecarDefinitionVarsValueFromClusterVarRefClusterName>,
    /// Reference to the UID of the Cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterUID")]
    pub cluster_uid: Option<SidecarDefinitionVarsValueFromClusterVarRefClusterUid>,
    /// Reference to the namespace of the Cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<SidecarDefinitionVarsValueFromClusterVarRefNamespace>,
}

/// Selects a defined var of a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromClusterVarRefClusterName {
    Required,
    Optional,
}

/// Selects a defined var of a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromClusterVarRefClusterUid {
    Required,
    Optional,
}

/// Selects a defined var of a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromClusterVarRefNamespace {
    Required,
    Optional,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromComponentVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// Reference to the name of the Component object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentName")]
    pub component_name: Option<SidecarDefinitionVarsValueFromComponentVarRefComponentName>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<SidecarDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Reference to the pod FQDN list of the component.
    /// The value will be presented in the following format: FQDN1,FQDN2,...
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podFQDNs")]
    pub pod_fqd_ns: Option<SidecarDefinitionVarsValueFromComponentVarRefPodFqdNs>,
    /// Reference to the pod FQDN list of the component that have a specific role.
    /// The value will be presented in the following format: FQDN1,FQDN2,...
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podFQDNsForRole")]
    pub pod_fqd_ns_for_role: Option<SidecarDefinitionVarsValueFromComponentVarRefPodFqdNsForRole>,
    /// Reference to the pod name list of the component.
    /// and the value will be presented in the following format: name1,name2,...
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podNames")]
    pub pod_names: Option<SidecarDefinitionVarsValueFromComponentVarRefPodNames>,
    /// Reference to the pod name list of the component that have a specific role.
    /// The value will be presented in the following format: name1,name2,...
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podNamesForRole")]
    pub pod_names_for_role: Option<SidecarDefinitionVarsValueFromComponentVarRefPodNamesForRole>,
    /// Reference to the replicas of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<SidecarDefinitionVarsValueFromComponentVarRefReplicas>,
    /// Reference to the short name of the Component object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shortName")]
    pub short_name: Option<SidecarDefinitionVarsValueFromComponentVarRefShortName>,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromComponentVarRefComponentName {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct SidecarDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<SidecarDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: SidecarDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<SidecarDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromComponentVarRefPodFqdNs {
    Required,
    Optional,
}

/// Reference to the pod FQDN list of the component that have a specific role.
/// The value will be presented in the following format: FQDN1,FQDN2,...
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromComponentVarRefPodFqdNsForRole {
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<SidecarDefinitionVarsValueFromComponentVarRefPodFqdNsForRoleOption>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
}

/// Reference to the pod FQDN list of the component that have a specific role.
/// The value will be presented in the following format: FQDN1,FQDN2,...
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromComponentVarRefPodFqdNsForRoleOption {
    Required,
    Optional,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromComponentVarRefPodNames {
    Required,
    Optional,
}

/// Reference to the pod name list of the component that have a specific role.
/// The value will be presented in the following format: name1,name2,...
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromComponentVarRefPodNamesForRole {
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<SidecarDefinitionVarsValueFromComponentVarRefPodNamesForRoleOption>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
}

/// Reference to the pod name list of the component that have a specific role.
/// The value will be presented in the following format: name1,name2,...
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromComponentVarRefPodNamesForRoleOption {
    Required,
    Optional,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromComponentVarRefReplicas {
    Required,
    Optional,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromComponentVarRefShortName {
    Required,
    Optional,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a defined var of a Credential (SystemAccount).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromCredentialVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<SidecarDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<SidecarDefinitionVarsValueFromCredentialVarRefPassword>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<SidecarDefinitionVarsValueFromCredentialVarRefUsername>,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct SidecarDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<SidecarDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: SidecarDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<SidecarDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Selects a defined var of a Credential (SystemAccount).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromCredentialVarRefPassword {
    Required,
    Optional,
}

/// Selects a defined var of a Credential (SystemAccount).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromCredentialVarRefUsername {
    Required,
    Optional,
}

/// Selects a defined var of host-network resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromHostNetworkVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// ContainerVars defines the vars that can be referenced from a Container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<SidecarDefinitionVarsValueFromHostNetworkVarRefContainer>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<SidecarDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ContainerVars defines the vars that can be referenced from a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromHostNetworkVarRefContainer {
    /// The name of the container.
    pub name: String,
    /// Container port to reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<SidecarDefinitionVarsValueFromHostNetworkVarRefContainerPort>,
}

/// Container port to reference.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromHostNetworkVarRefContainerPort {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<SidecarDefinitionVarsValueFromHostNetworkVarRefContainerPortOption>,
}

/// Container port to reference.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromHostNetworkVarRefContainerPortOption {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct SidecarDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<SidecarDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: SidecarDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<SidecarDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromResourceVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<SidecarDefinitionVarsValueFromResourceVarRefCpu>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuLimit")]
    pub cpu_limit: Option<SidecarDefinitionVarsValueFromResourceVarRefCpuLimit>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<SidecarDefinitionVarsValueFromResourceVarRefMemory>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryLimit")]
    pub memory_limit: Option<SidecarDefinitionVarsValueFromResourceVarRefMemoryLimit>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<SidecarDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<SidecarDefinitionVarsValueFromResourceVarRefStorage>,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromResourceVarRefCpu {
    Required,
    Optional,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromResourceVarRefCpuLimit {
    Required,
    Optional,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromResourceVarRefMemory {
    Required,
    Optional,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromResourceVarRefMemoryLimit {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct SidecarDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<SidecarDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: SidecarDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<SidecarDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromResourceVarRefStorage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<SidecarDefinitionVarsValueFromResourceVarRefStorageOption>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromResourceVarRefStorageOption {
    Required,
    Optional,
}

/// Selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromServiceRefVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<SidecarDefinitionVarsValueFromServiceRefVarRefEndpoint>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<SidecarDefinitionVarsValueFromServiceRefVarRefHost>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<SidecarDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<SidecarDefinitionVarsValueFromServiceRefVarRefPassword>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podFQDNs")]
    pub pod_fqd_ns: Option<SidecarDefinitionVarsValueFromServiceRefVarRefPodFqdNs>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<SidecarDefinitionVarsValueFromServiceRefVarRefPort>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<SidecarDefinitionVarsValueFromServiceRefVarRefUsername>,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceRefVarRefEndpoint {
    Required,
    Optional,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceRefVarRefHost {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct SidecarDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<SidecarDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: SidecarDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<SidecarDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceRefVarRefPassword {
    Required,
    Optional,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceRefVarRefPodFqdNs {
    Required,
    Optional,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceRefVarRefPort {
    Required,
    Optional,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceRefVarRefUsername {
    Required,
    Optional,
}

/// Selects a defined var of a Service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromServiceVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<SidecarDefinitionVarsValueFromServiceVarRefHost>,
    /// LoadBalancer represents the LoadBalancer ingress point of the service.
    /// 
    /// 
    /// If multiple ingress points are available, the first one will be used automatically, choosing between IP and Hostname.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<SidecarDefinitionVarsValueFromServiceVarRefLoadBalancer>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<SidecarDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Port references a port or node-port defined in the service.
    /// 
    /// 
    /// If the referenced service is a pod-service, there will be multiple service objects matched,
    /// and the value will be presented in the following format: service1.name:port1,service2.name:port2...
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<SidecarDefinitionVarsValueFromServiceVarRefPort>,
    /// ServiceType references the type of the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<SidecarDefinitionVarsValueFromServiceVarRefServiceType>,
}

/// Selects a defined var of a Service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceVarRefHost {
    Required,
    Optional,
}

/// Selects a defined var of a Service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceVarRefLoadBalancer {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct SidecarDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<SidecarDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: SidecarDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<SidecarDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Port references a port or node-port defined in the service.
/// 
/// 
/// If the referenced service is a pod-service, there will be multiple service objects matched,
/// and the value will be presented in the following format: service1.name:port1,service2.name:port2...
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromServiceVarRefPort {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<SidecarDefinitionVarsValueFromServiceVarRefPortOption>,
}

/// Port references a port or node-port defined in the service.
/// 
/// 
/// If the referenced service is a pod-service, there will be multiple service objects matched,
/// and the value will be presented in the following format: service1.name:port1,service2.name:port2...
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceVarRefPortOption {
    Required,
    Optional,
}

/// Selects a defined var of a Service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromServiceVarRefServiceType {
    Required,
    Optional,
}

/// Selects a defined var of the TLS.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromTlsVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<SidecarDefinitionVarsValueFromTlsVarRefEnabled>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<SidecarDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a defined var of the TLS.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromTlsVarRefEnabled {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct SidecarDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<SidecarDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: SidecarDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<SidecarDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// SidecarDefinitionStatus defines the observed state of SidecarDefinition
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct SidecarDefinitionStatus {
    /// Provides additional information about the current phase.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Refers to the most recent generation that has been observed for the SidecarDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// Resolved owners of the SidecarDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owners: Option<String>,
    /// Represents the current status of the SidecarDefinition. Valid values include ``, `Available`, and `Unavailable`.
    /// When the status is `Available`, the SidecarDefinition is ready and can be utilized by related objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<SidecarDefinitionStatusPhase>,
    /// Resolved selectors of the SidecarDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selectors: Option<String>,
}

/// SidecarDefinitionStatus defines the observed state of SidecarDefinition
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum SidecarDefinitionStatusPhase {
    Available,
    Unavailable,
}

