// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/apecloud/kubeblocks/apps.kubeblocks.io/v1/componentdefinitions.yaml
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "apps.kubeblocks.io", version = "v1", kind = "ComponentDefinition", plural = "componentdefinitions")]
#[kube(status = "ComponentDefinitionStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ComponentDefinitionSpec {
    /// Specifies static annotations that will be patched to all Kubernetes resources created for the Component.
    /// 
    /// 
    /// Note: If an annotation key in the `annotations` field conflicts with any system annotations
    /// or user-specified annotations, it will be silently ignored to avoid overriding higher-priority annotations.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Specifies the strategies for determining the available status of the Component.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub available: Option<ComponentDefinitionAvailable>,
    /// Specifies the config file templates and volume mount parameters used by the Component.
    /// 
    /// 
    /// This field specifies a list of templates that will be rendered into Component containers' config files.
    /// Each template is represented as a ConfigMap and may contain multiple config files, with each file being a key in the ConfigMap.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configs: Option<Vec<ComponentDefinitionConfigs>>,
    /// Provides a brief and concise explanation of the Component's purpose, functionality, and any relevant details.
    /// It serves as a quick reference for users to understand the Component's role and characteristics.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Specifies whether to create the default headless service.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableDefaultHeadlessService")]
    pub disable_default_headless_service: Option<bool>,
    /// Defines the built-in metrics exporter container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exporter: Option<ComponentDefinitionExporter>,
    /// Specifies the host network configuration for the Component.
    /// 
    /// 
    /// When `hostNetwork` option is enabled, the Pods share the host's network namespace and can directly access
    /// the host's network interfaces.
    /// This means that if multiple Pods need to use the same port, they cannot run on the same host simultaneously
    /// due to port conflicts.
    /// 
    /// 
    /// The DNSPolicy field in the Pod spec determines how containers within the Pod perform DNS resolution.
    /// When using hostNetwork, the operator will set the DNSPolicy to 'ClusterFirstWithHostNet'.
    /// With this policy, DNS queries will first go through the K8s cluster's DNS service.
    /// If the query fails, it will fall back to the host's DNS settings.
    /// 
    /// 
    /// If set, the DNS policy will be automatically set to "ClusterFirstWithHostNet".
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<ComponentDefinitionHostNetwork>,
    /// Specifies static labels that will be patched to all Kubernetes resources created for the Component.
    /// 
    /// 
    /// Note: If a label key in the `labels` field conflicts with any system labels or user-specified labels,
    /// it will be silently ignored to avoid overriding higher-priority labels.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Defines a set of hooks and procedures that customize the behavior of a Component throughout its lifecycle.
    /// Actions are triggered at specific lifecycle stages:
    /// 
    /// 
    ///   - `postProvision`: Defines the hook to be executed after the creation of a Component,
    ///     with `preCondition` specifying when the action should be fired relative to the Component's lifecycle stages:
    ///     `Immediately`, `RuntimeReady`, `ComponentReady`, and `ClusterReady`.
    ///   - `preTerminate`: Defines the hook to be executed before terminating a Component.
    ///   - `roleProbe`: Defines the procedure which is invoked regularly to assess the role of replicas.
    ///   - `availableProbe`: Defines the procedure which is invoked regularly to assess the availability of the component.
    ///   - `switchover`: Defines the procedure for a controlled transition of a role to a new replica.
    ///     This approach aims to minimize downtime and maintain availability in systems with a leader-follower topology,
    ///     such as before planned maintenance or upgrades on the current leader node.
    ///   - `memberJoin`: Defines the procedure to add a new replica to the replication group.
    ///   - `memberLeave`: Defines the method to remove a replica from the replication group.
    ///   - `readOnly`: Defines the procedure to switch a replica into the read-only state.
    ///   - `readWrite`: transition a replica from the read-only state back to the read-write state.
    ///   - `dataDump`: Defines the procedure to export the data from a replica.
    ///   - `dataLoad`: Defines the procedure to import data into a replica.
    ///   - `reconfigure`: Defines the procedure that update a replica with new configuration file.
    ///   - `accountProvision`: Defines the procedure to generate a new database account.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lifecycleActions")]
    pub lifecycle_actions: Option<ComponentDefinitionLifecycleActions>,
    /// Defines the types of logs generated by instances of the Component and their corresponding file paths.
    /// These logs can be collected for further analysis and monitoring.
    /// 
    /// 
    /// The `logConfigs` field is an optional list of LogConfig objects, where each object represents
    /// a specific log type and its configuration.
    /// It allows you to specify multiple log types and their respective file paths for the Component.
    /// 
    /// 
    /// Examples:
    /// 
    /// 
    /// ```text
    ///  logConfigs:
    ///  - filePathPattern: /data/mysql/log/mysqld-error.log
    ///    name: error
    ///  - filePathPattern: /data/mysql/log/mysqld.log
    ///    name: general
    ///  - filePathPattern: /data/mysql/log/mysqld-slowquery.log
    ///    name: slow
    /// ```
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logConfigs")]
    pub log_configs: Option<Vec<ComponentDefinitionLogConfigs>>,
    /// `minReadySeconds` is the minimum duration in seconds that a new Pod should remain in the ready
    /// state without any of its containers crashing to be considered available.
    /// This ensures the Pod's stability and readiness to serve requests.
    /// 
    /// 
    /// A default value of 0 seconds means the Pod is considered available as soon as it enters the ready state.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// InstanceSet controls the creation of pods during initial scale up, replacement of pods on nodes, and scaling down.
    /// 
    /// 
    /// - `OrderedReady`: Creates pods in increasing order (pod-0, then pod-1, etc). The controller waits until each pod
    /// is ready before continuing. Pods are removed in reverse order when scaling down.
    /// - `Parallel`: Creates pods in parallel to match the desired scale without waiting. All pods are deleted at once
    /// when scaling down.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podManagementPolicy")]
    pub pod_management_policy: Option<String>,
    /// Specifies the default update policy for pods when the Component is updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podUpdatePolicy")]
    pub pod_update_policy: Option<ComponentDefinitionPodUpdatePolicy>,
    /// Specifies the default update policy for pods when the Component is upgraded (the service version changes).
    /// 
    /// 
    /// If not specified, the default behavior is the same as `podUpdatePolicy`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podUpgradePolicy")]
    pub pod_upgrade_policy: Option<ComponentDefinitionPodUpgradePolicy>,
    /// Defines the namespaced policy rules required by the Component.
    /// 
    /// 
    /// The `policyRules` field is an array of `rbacv1.PolicyRule` objects that define the policy rules
    /// needed by the Component to operate within a namespace.
    /// These policy rules determine the permissions and verbs the Component is allowed to perform on
    /// Kubernetes resources within the namespace.
    /// 
    /// 
    /// The purpose of this field is to automatically generate the necessary RBAC roles
    /// for the Component based on the specified policy rules.
    /// This ensures that the Pods in the Component has appropriate permissions to function.
    /// 
    /// 
    /// To prevent privilege escalation, only permissions already owned by KubeBlocks can be added here.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "policyRules")]
    pub policy_rules: Option<Vec<ComponentDefinitionPolicyRules>>,
    /// Specifies the name of the Component provider, typically the vendor or developer name.
    /// It identifies the entity responsible for creating and maintaining the Component.
    /// 
    /// 
    /// When specifying the provider name, consider the following guidelines:
    /// 
    /// 
    /// - Keep the name concise and relevant to the Component.
    /// - Use a consistent naming convention across Components from the same provider.
    /// - Avoid using trademarked or copyrighted names without proper permission.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    /// Defines the upper limit of the number of replicas supported by the Component.
    /// 
    /// 
    /// It defines the maximum number of replicas that can be created for the Component.
    /// This field allows you to set a limit on the scalability of the Component, preventing it from exceeding a certain number of replicas.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasLimit")]
    pub replicas_limit: Option<ComponentDefinitionReplicasLimit>,
    /// Enumerate all possible roles assigned to each replica of the Component, influencing its behavior.
    /// 
    /// 
    /// A replica can have zero or one role.
    /// KubeBlocks operator determines the role of each replica by invoking the `lifecycleActions.roleProbe` method.
    /// This action returns the role for each replica, and the returned role must be predefined here.
    /// 
    /// 
    /// The roles assigned to a replica can influence various aspects of the Component's behavior, such as:
    /// 
    /// 
    /// - Service selection: The Component's exposed Services may target replicas based on their roles using `roleSelector`.
    /// - Update order: The roles can determine the order in which replicas are updated during a Component update.
    ///   For instance, replicas with a "follower" role can be updated first, while the replica with the "leader"
    ///   role is updated last. This helps minimize the number of leader changes during the update process.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<ComponentDefinitionRoles>>,
    /// Specifies the PodSpec template used in the Component.
    /// It includes the following elements:
    /// 
    /// 
    /// - Init containers
    /// - Containers
    ///     - Image
    ///     - Commands
    ///     - Args
    ///     - Envs
    ///     - Mounts
    ///     - Ports
    ///     - Security context
    ///     - Probes
    ///     - Lifecycle
    /// - Volumes
    /// 
    /// 
    /// This field is intended to define static settings that remain consistent across all instantiated Components.
    /// Dynamic settings such as CPU and memory resource limits, as well as scheduling settings (affinity,
    /// toleration, priority), may vary among different instantiated Components.
    /// They should be specified in the `cluster.spec.componentSpecs` (ClusterComponentSpec).
    /// 
    /// 
    /// Specific instances of a Component may override settings defined here, such as using a different container image
    /// or modifying environment variable values.
    /// These instance-specific overrides can be specified in `cluster.spec.componentSpecs[*].instances`.
    /// 
    /// 
    /// This field is immutable and cannot be updated once set.
    pub runtime: ComponentDefinitionRuntime,
    /// Specifies groups of scripts, each provided via a ConfigMap, to be mounted as volumes in the container.
    /// These scripts can be executed during container startup or via specific actions.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scripts: Option<Vec<ComponentDefinitionScripts>>,
    /// Defines the type of well-known service protocol that the Component provides.
    /// It specifies the standard or widely recognized protocol used by the Component to offer its Services.
    /// 
    /// 
    /// The `serviceKind` field allows users to quickly identify the type of Service provided by the Component
    /// based on common protocols or service types. This information helps in understanding the compatibility,
    /// interoperability, and usage of the Component within a system.
    /// 
    /// 
    /// Some examples of well-known service protocols include:
    /// 
    /// 
    /// - "MySQL": Indicates that the Component provides a MySQL database service.
    /// - "PostgreSQL": Indicates that the Component offers a PostgreSQL database service.
    /// - "Redis": Signifies that the Component functions as a Redis key-value store.
    /// - "ETCD": Denotes that the Component serves as an ETCD distributed key-value store.
    /// 
    /// 
    /// The `serviceKind` value is case-insensitive, allowing for flexibility in specifying the protocol name.
    /// 
    /// 
    /// When specifying the `serviceKind`, consider the following guidelines:
    /// 
    /// 
    /// - Use well-established and widely recognized protocol names or service types.
    /// - Ensure that the `serviceKind` accurately represents the primary service type offered by the Component.
    /// - If the Component provides multiple services, choose the most prominent or commonly used protocol.
    /// - Limit the `serviceKind` to a maximum of 32 characters for conciseness and readability.
    /// 
    /// 
    /// Note: The `serviceKind` field is optional and can be left empty if the Component does not fit into a well-known
    /// service category or if the protocol is not widely recognized. It is primarily used to convey information about
    /// the Component's service type to users and facilitate discovery and integration.
    /// 
    /// 
    /// The `serviceKind` field is immutable and cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceKind")]
    pub service_kind: Option<String>,
    /// Lists external service dependencies of the Component, including services from other Clusters or outside the K8s environment.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRefDeclarations")]
    pub service_ref_declarations: Option<Vec<ComponentDefinitionServiceRefDeclarations>>,
    /// Specifies the version of the Service provided by the Component.
    /// It follows the syntax and semantics of the "Semantic Versioning" specification (<http://semver.org/).>
    /// 
    /// 
    /// The Semantic Versioning specification defines a version number format of X.Y.Z (MAJOR.MINOR.PATCH), where:
    /// 
    /// 
    /// - X represents the major version and indicates incompatible API changes.
    /// - Y represents the minor version and indicates added functionality in a backward-compatible manner.
    /// - Z represents the patch version and indicates backward-compatible bug fixes.
    /// 
    /// 
    /// Additional labels for pre-release and build metadata are available as extensions to the X.Y.Z format:
    /// 
    /// 
    /// - Use pre-release labels (e.g., -alpha, -beta) for versions that are not yet stable or ready for production use.
    /// - Use build metadata (e.g., +build.1) for additional version information if needed.
    /// 
    /// 
    /// Examples of valid ServiceVersion values:
    /// 
    /// 
    /// - "1.0.0"
    /// - "2.3.1"
    /// - "3.0.0-alpha.1"
    /// - "4.5.2+build.1"
    /// 
    /// 
    /// The `serviceVersion` field is immutable and cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceVersion")]
    pub service_version: Option<String>,
    /// Defines additional Services to expose the Component's endpoints.
    /// 
    /// 
    /// A default headless Service, named `{cluster.name}-{component.name}-headless`, is automatically created
    /// for internal Cluster communication.
    /// 
    /// 
    /// This field enables customization of additional Services to expose the Component's endpoints to
    /// other Components within the same or different Clusters, and to external applications.
    /// Each Service entry in this list can include properties such as ports, type, and selectors.
    /// 
    /// 
    /// - For intra-Cluster access, Components can reference Services using variables declared in
    ///   `componentDefinition.spec.vars[*].valueFrom.serviceVarRef`.
    /// - For inter-Cluster access, reference Services use variables declared in
    ///   `componentDefinition.spec.vars[*].valueFrom.serviceRefVarRef`,
    ///   and bind Services at Cluster creation time with `clusterComponentSpec.ServiceRef[*].clusterServiceSelector`.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<ComponentDefinitionServices>>,
    /// An array of `SystemAccount` objects that define the system accounts needed
    /// for the management operations of the Component.
    /// 
    /// 
    /// Each `SystemAccount` includes:
    /// 
    /// 
    /// - Account name.
    /// - The SQL statement template: Used to create the system account.
    /// - Password Source: Either generated based on certain rules or retrieved from a Secret.
    /// 
    /// 
    ///  Use cases for system accounts typically involve tasks like system initialization, backups, monitoring,
    ///  health checks, replication, and other system-level operations.
    /// 
    /// 
    /// System accounts are distinct from user accounts, although both are database accounts.
    /// 
    /// 
    /// - **System Accounts**: Created during Cluster setup by the KubeBlocks operator,
    ///   these accounts have higher privileges for system management and are fully managed
    ///   through a declarative API by the operator.
    /// - **User Accounts**: Managed by users or administrator.
    ///   User account permissions should follow the principle of least privilege,
    ///   granting only the necessary access rights to complete their required tasks.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "systemAccounts")]
    pub system_accounts: Option<Vec<ComponentDefinitionSystemAccounts>>,
    /// Specifies the TLS configuration for the Component.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ComponentDefinitionTls>,
    /// Specifies the concurrency strategy for updating multiple instances of the Component.
    /// Available strategies:
    /// 
    /// 
    /// - `Serial`: Updates replicas one at a time, ensuring minimal downtime by waiting for each replica to become ready
    ///   before updating the next.
    /// - `Parallel`: Updates all replicas simultaneously, optimizing for speed but potentially reducing availability
    ///   during the update.
    /// - `BestEffortParallel`: Updates replicas concurrently with a limit on simultaneous updates to ensure a minimum
    ///   number of operational replicas for maintaining quorum.
    /// 	 For example, in a 5-replica component, updating a maximum of 2 replicas simultaneously keeps
    /// 	 at least 3 operational for quorum.
    /// 
    /// 
    /// This field is immutable and defaults to 'Serial'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<ComponentDefinitionUpdateStrategy>,
    /// Defines variables which are determined after Cluster instantiation and reflect
    /// dynamic or runtime attributes of instantiated Clusters.
    /// These variables serve as placeholders for setting environment variables in Pods and Actions,
    /// or for rendering configuration and script templates before actual values are finalized.
    /// 
    /// 
    /// These variables are placed in front of the environment variables declared in the Pod if used as
    /// environment variables.
    /// 
    /// 
    /// Variable values can be sourced from:
    /// 
    /// 
    /// - ConfigMap: Select and extract a value from a specific key within a ConfigMap.
    /// - Secret: Select and extract a value from a specific key within a Secret.
    /// - HostNetwork: Retrieves values (including ports) from host-network resources.
    /// - Service: Retrieves values (including address, port, NodePort) from a selected Service.
    ///   Intended to obtain the address of a ComponentService within the same Cluster.
    /// - Credential: Retrieves account name and password from a SystemAccount variable.
    /// - ServiceRef: Retrieves address, port, account name and password from a selected ServiceRefDeclaration.
    ///   Designed to obtain the address bound to a ServiceRef, such as a ClusterService or
    ///   ComponentService of another cluster or an external service.
    /// - Component: Retrieves values from a selected Component, including replicas and instance name list.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vars: Option<Vec<ComponentDefinitionVars>>,
    /// Defines the volumes used by the Component and some static attributes of the volumes.
    /// After defining the volumes here, user can reference them in the
    /// `cluster.spec.componentSpecs[*].volumeClaimTemplates` field to configure dynamic properties such as
    /// volume capacity and storage class.
    /// 
    /// 
    /// This field allows you to specify the following:
    /// 
    /// 
    /// - Snapshot behavior: Determines whether a snapshot of the volume should be taken when performing
    ///   a snapshot backup of the Component.
    /// - Disk high watermark: Sets the high watermark for the volume's disk usage.
    ///   When the disk usage reaches the specified threshold, it triggers an alert or action.
    /// 
    /// 
    /// By configuring these volume behaviors, you can control how the volumes are managed and monitored within the Component.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<ComponentDefinitionVolumes>>,
}

/// Specifies the strategies for determining the available status of the Component.
/// 
/// 
/// This field is immutable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailable {
    /// Specifies the phases that the component will go through to be considered available.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withPhases")]
    pub with_phases: Option<String>,
    /// Specifies the strategies for determining whether the component is available based on the available probe.
    /// 
    /// 
    /// If specified, it will take precedence over the WithPhases and WithRole fields.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withProbe")]
    pub with_probe: Option<ComponentDefinitionAvailableWithProbe>,
    /// Specifies the role that the component will go through to be considered available.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "withRole")]
    pub with_role: Option<String>,
}

/// Specifies the strategies for determining whether the component is available based on the available probe.
/// 
/// 
/// If specified, it will take precedence over the WithPhases and WithRole fields.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbe {
    /// Specifies the conditions that the component will go through to be considered available.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub condition: Option<ComponentDefinitionAvailableWithProbeCondition>,
    /// A brief description for the condition when the component is available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeWindowSeconds")]
    pub time_window_seconds: Option<i32>,
}

/// Specifies the conditions that the component will go through to be considered available.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeCondition {
    /// All replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<ComponentDefinitionAvailableWithProbeConditionAll>,
    /// Logical And to combine multiple expressions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAnd>>,
    /// At least one replica must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<ComponentDefinitionAvailableWithProbeConditionAny>,
    /// Majority replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub majority: Option<ComponentDefinitionAvailableWithProbeConditionMajority>,
    /// None of the replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub none: Option<ComponentDefinitionAvailableWithProbeConditionNone>,
    /// Logical Not to negate the expression.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionNot>,
    /// Logical Or to combine multiple expressions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionOr>>,
}

/// All replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAll {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAllAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionAllNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAllOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAllStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAllStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAllAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAllAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAllNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAllNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAllOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAllOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAllStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnd {
    /// All replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<ComponentDefinitionAvailableWithProbeConditionAndAll>,
    /// At least one replica must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<ComponentDefinitionAvailableWithProbeConditionAndAny>,
    /// Majority replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub majority: Option<ComponentDefinitionAvailableWithProbeConditionAndMajority>,
    /// None of the replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub none: Option<ComponentDefinitionAvailableWithProbeConditionAndNone>,
}

/// All replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAll {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAndAllAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionAndAllNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAndAllOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndAllStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndAllStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndAllAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndAllAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndAllNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndAllNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndAllOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndAllOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAllStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// At least one replica must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAny {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAndAnyAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionAndAnyNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAndAnyOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndAnyStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndAnyStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndAnyAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndAnyAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndAnyNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndAnyNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndAnyOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndAnyOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndAnyStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Majority replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajority {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAndMajorityAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionAndMajorityNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAndMajorityOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndMajorityStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndMajorityStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndMajorityAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndMajorityAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndMajorityNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndMajorityNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndMajorityOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndMajorityOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndMajorityStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// None of the replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNone {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAndNoneAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionAndNoneNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAndNoneOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndNoneStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndNoneStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndNoneAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndNoneAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndNoneNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndNoneNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAndNoneOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAndNoneOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAndNoneStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// At least one replica must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAny {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAnyAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionAnyNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionAnyOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAnyStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAnyStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAnyAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAnyAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAnyNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAnyNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionAnyOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionAnyOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionAnyStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Majority replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajority {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionMajorityAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionMajorityNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionMajorityOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionMajorityStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionMajorityStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionMajorityAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionMajorityAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionMajorityNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionMajorityNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionMajorityOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionMajorityOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionMajorityStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// None of the replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNone {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNoneAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionNoneNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNoneOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNoneStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNoneStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNoneAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNoneAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNoneNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNoneNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNoneOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNoneOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNoneStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the expression.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNot {
    /// All replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<ComponentDefinitionAvailableWithProbeConditionNotAll>,
    /// At least one replica must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<ComponentDefinitionAvailableWithProbeConditionNotAny>,
    /// Majority replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub majority: Option<ComponentDefinitionAvailableWithProbeConditionNotMajority>,
    /// None of the replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub none: Option<ComponentDefinitionAvailableWithProbeConditionNotNone>,
}

/// All replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAll {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNotAllAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionNotAllNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNotAllOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotAllStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotAllStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotAllAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotAllAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotAllNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotAllNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotAllOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotAllOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAllStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// At least one replica must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAny {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNotAnyAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionNotAnyNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNotAnyOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotAnyStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotAnyStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotAnyAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotAnyAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotAnyNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotAnyNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotAnyOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotAnyOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotAnyStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Majority replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajority {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNotMajorityAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionNotMajorityNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNotMajorityOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotMajorityStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotMajorityStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotMajorityAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotMajorityAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotMajorityNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotMajorityNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotMajorityOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotMajorityOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotMajorityStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// None of the replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNone {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNotNoneAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionNotNoneNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionNotNoneOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotNoneStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotNoneStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotNoneAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotNoneAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotNoneNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotNoneNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionNotNoneOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionNotNoneOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionNotNoneStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOr {
    /// All replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub all: Option<ComponentDefinitionAvailableWithProbeConditionOrAll>,
    /// At least one replica must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<ComponentDefinitionAvailableWithProbeConditionOrAny>,
    /// Majority replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub majority: Option<ComponentDefinitionAvailableWithProbeConditionOrMajority>,
    /// None of the replicas must satisfy the assertion.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub none: Option<ComponentDefinitionAvailableWithProbeConditionOrNone>,
}

/// All replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAll {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionOrAllAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionOrAllNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionOrAllOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrAllStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrAllStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrAllAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrAllAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrAllNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrAllNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrAllOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrAllOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAllStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// At least one replica must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAny {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionOrAnyAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionOrAnyNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionOrAnyOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrAnyStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrAnyStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrAnyAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrAnyAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrAnyNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrAnyNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrAnyOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrAnyOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrAnyStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Majority replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajority {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionOrMajorityAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionOrMajorityNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionOrMajorityOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrMajorityStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrMajorityStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrMajorityAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrMajorityAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrMajorityNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrMajorityNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrMajorityOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrMajorityOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrMajorityStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// None of the replicas must satisfy the assertion.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNone {
    /// Logical And to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<ComponentDefinitionAvailableWithProbeConditionOrNoneAnd>>,
    /// Logical Not to negate the assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<ComponentDefinitionAvailableWithProbeConditionOrNoneNot>,
    /// Logical Or to combine multiple assertions.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<ComponentDefinitionAvailableWithProbeConditionOrNoneOr>>,
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrNoneStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrNoneStdout>,
    /// Specifies whether apply the assertions strictly to all replicas.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneAnd {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrNoneAndStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrNoneAndStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneAndStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneAndStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Logical Not to negate the assertions.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneNot {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrNoneNotStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrNoneNotStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneNotStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneNotStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// ActionAssertion defines the custom assertions for evaluating the success or failure of an action.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneOr {
    /// Specifies the stderr matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stderr: Option<ComponentDefinitionAvailableWithProbeConditionOrNoneOrStderr>,
    /// Specifies the stdout matcher for the action.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdout: Option<ComponentDefinitionAvailableWithProbeConditionOrNoneOrStdout>,
    /// Whether the action should succeed or fail.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeed: Option<bool>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneOrStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneOrStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stderr matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneStderr {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

/// Specifies the stdout matcher for the action.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionAvailableWithProbeConditionOrNoneStdout {
    /// The output of the action should contain the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub contains: Option<String>,
    /// The output of the action should be equal to the specified value.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "equalTo")]
    pub equal_to: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionConfigs {
    /// The operator attempts to set default file permissions (0444).
    /// 
    /// 
    /// Must be specified as an octal value between 0000 and 0777 (inclusive),
    /// or as a decimal value between 0 and 511 (inclusive).
    /// YAML supports both octal and decimal values for file permissions.
    /// 
    /// 
    /// Please note that this setting only affects the permissions of the files themselves.
    /// Directories within the specified path are not impacted by this setting.
    /// It's important to be aware that this setting might conflict with other options
    /// that influence the file mode, such as fsGroup.
    /// In such cases, the resulting file mode may have additional bits set.
    /// Refers to documents of k8s.ConfigMapVolumeSource.defaultMode for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// ExternalManaged indicates whether the configuration is managed by an external system.
    /// When set to true, the controller will ignore the management of this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalManaged")]
    pub external_managed: Option<bool>,
    /// Specifies the name of the template.
    pub name: String,
    /// Specifies the namespace of the referenced template ConfigMap object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specifies whether to restart the pod when the file changes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartOnFileChange")]
    pub restart_on_file_change: Option<bool>,
    /// Specifies the name of the referenced template ConfigMap object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
    /// Refers to the volume name of PodTemplate. The file produced through the template will be mounted to
    /// the corresponding volume. Must be a DNS_LABEL name.
    /// The volume name must be defined in podSpec.containers[*].volumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// Defines the built-in metrics exporter container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionExporter {
    /// Specifies the name of the built-in metrics exporter container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the http/https url path to scrape for metrics.
    /// If empty, Prometheus uses the default value (e.g. `/metrics`).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapePath")]
    pub scrape_path: Option<String>,
    /// Specifies the port name to scrape for metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapePort")]
    pub scrape_port: Option<String>,
    /// Specifies the schema to use for scraping.
    /// `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling.
    /// If empty, Prometheus uses the default value `http`.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeScheme")]
    pub scrape_scheme: Option<ComponentDefinitionExporterScrapeScheme>,
}

/// Defines the built-in metrics exporter container.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionExporterScrapeScheme {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

/// Specifies the host network configuration for the Component.
/// 
/// 
/// When `hostNetwork` option is enabled, the Pods share the host's network namespace and can directly access
/// the host's network interfaces.
/// This means that if multiple Pods need to use the same port, they cannot run on the same host simultaneously
/// due to port conflicts.
/// 
/// 
/// The DNSPolicy field in the Pod spec determines how containers within the Pod perform DNS resolution.
/// When using hostNetwork, the operator will set the DNSPolicy to 'ClusterFirstWithHostNet'.
/// With this policy, DNS queries will first go through the K8s cluster's DNS service.
/// If the query fails, it will fall back to the host's DNS settings.
/// 
/// 
/// If set, the DNS policy will be automatically set to "ClusterFirstWithHostNet".
/// 
/// 
/// This field is immutable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionHostNetwork {
    /// The list of container ports that are required by the component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerPorts")]
    pub container_ports: Option<Vec<ComponentDefinitionHostNetworkContainerPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionHostNetworkContainerPorts {
    /// Container specifies the target container within the Pod.
    pub container: String,
    /// Ports are named container ports within the specified container.
    /// These container ports must be defined in the container for proper port allocation.
    pub ports: Vec<String>,
}

/// Defines a set of hooks and procedures that customize the behavior of a Component throughout its lifecycle.
/// Actions are triggered at specific lifecycle stages:
/// 
/// 
///   - `postProvision`: Defines the hook to be executed after the creation of a Component,
///     with `preCondition` specifying when the action should be fired relative to the Component's lifecycle stages:
///     `Immediately`, `RuntimeReady`, `ComponentReady`, and `ClusterReady`.
///   - `preTerminate`: Defines the hook to be executed before terminating a Component.
///   - `roleProbe`: Defines the procedure which is invoked regularly to assess the role of replicas.
///   - `availableProbe`: Defines the procedure which is invoked regularly to assess the availability of the component.
///   - `switchover`: Defines the procedure for a controlled transition of a role to a new replica.
///     This approach aims to minimize downtime and maintain availability in systems with a leader-follower topology,
///     such as before planned maintenance or upgrades on the current leader node.
///   - `memberJoin`: Defines the procedure to add a new replica to the replication group.
///   - `memberLeave`: Defines the method to remove a replica from the replication group.
///   - `readOnly`: Defines the procedure to switch a replica into the read-only state.
///   - `readWrite`: transition a replica from the read-only state back to the read-write state.
///   - `dataDump`: Defines the procedure to export the data from a replica.
///   - `dataLoad`: Defines the procedure to import data into a replica.
///   - `reconfigure`: Defines the procedure that update a replica with new configuration file.
///   - `accountProvision`: Defines the procedure to generate a new database account.
/// 
/// 
/// This field is immutable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActions {
    /// Defines the procedure to generate a new database account.
    /// 
    /// 
    /// Use Case:
    /// This action is designed to create system accounts that are utilized for replication, monitoring, backup,
    /// and other administrative tasks.
    /// 
    /// 
    /// The container executing this action has access to following variables:
    /// 
    /// 
    /// - KB_ACCOUNT_NAME: The name of the system account to be manipulated.
    /// - KB_ACCOUNT_PASSWORD: The password for the system account.
    /// - KB_ACCOUNT_STATEMENT: The statement used to manipulate the system account.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accountProvision")]
    pub account_provision: Option<ComponentDefinitionLifecycleActionsAccountProvision>,
    /// Defines the procedure which is invoked regularly to assess the availability of the component.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableProbe")]
    pub available_probe: Option<ComponentDefinitionLifecycleActionsAvailableProbe>,
    /// Defines the procedure for exporting the data from a replica.
    /// 
    /// 
    /// Use Case:
    /// This action is intended for initializing a newly created replica with data. It involves exporting data
    /// from an existing replica and importing it into the new, empty replica. This is essential for synchronizing
    /// the state of replicas across the system.
    /// 
    /// 
    /// Applicability:
    /// Some database engines or associated sidecar applications (e.g., Patroni) may already provide this functionality.
    /// In such cases, this action may not be required.
    /// 
    /// 
    /// The output should be a valid data dump streamed to stdout. It must exclude any irrelevant information to ensure
    /// that only the necessary data is exported for import into the new replica.
    /// 
    /// 
    /// The container executing this action has access to following environment variables:
    /// 
    /// 
    /// - KB_TARGET_POD_NAME: The name of the replica pod into which the data will be loaded.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataDump")]
    pub data_dump: Option<ComponentDefinitionLifecycleActionsDataDump>,
    /// Defines the procedure for importing data into a replica.
    /// 
    /// 
    /// Use Case:
    /// This action is intended for initializing a newly created replica with data. It involves exporting data
    /// from an existing replica and importing it into the new, empty replica. This is essential for synchronizing
    /// the state of replicas across the system.
    /// 
    /// 
    /// Some database engines or associated sidecar applications (e.g., Patroni) may already provide this functionality.
    /// In such cases, this action may not be required.
    /// 
    /// 
    /// Data should be received through stdin. If any error occurs during the process,
    /// the action must be able to guarantee idempotence to allow for retries from the beginning.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataLoad")]
    pub data_load: Option<ComponentDefinitionLifecycleActionsDataLoad>,
    /// Defines the procedure to add a new replica to the replication group.
    /// 
    /// 
    /// This action is initiated after a replica pod becomes ready.
    /// 
    /// 
    /// The role of the replica (e.g., primary, secondary) will be determined and assigned as part of the action command
    /// implementation, or automatically by the database kernel or a sidecar utility like Patroni that implements
    /// a consensus algorithm.
    /// 
    /// 
    /// The container executing this action has access to following variables:
    /// 
    /// 
    /// - KB_JOIN_MEMBER_POD_FQDN: The pod FQDN of the replica being added to the group.
    /// - KB_JOIN_MEMBER_POD_NAME: The pod name of the replica being added to the group.
    /// 
    /// 
    /// Expected action output:
    /// - On Failure: An error message detailing the reason for any failure encountered
    ///   during the addition of the new member.
    /// 
    /// 
    /// For example, to add a new OBServer to an OceanBase Cluster in 'zone1', the following command may be used:
    /// 
    /// 
    /// ```text
    /// command:
    /// - bash
    /// - -c
    /// - |
    ///    CLIENT="mysql -u $SERVICE_USER -p$SERVICE_PASSWORD -P $SERVICE_PORT -h $SERVICE_HOST -e"
    /// 	  $CLIENT "ALTER SYSTEM ADD SERVER '$POD_FQDN:$SERVICE_PORT' ZONE 'zone1'"
    /// ```
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memberJoin")]
    pub member_join: Option<ComponentDefinitionLifecycleActionsMemberJoin>,
    /// Defines the procedure to remove a replica from the replication group.
    /// 
    /// 
    /// This action is initiated before remove a replica from the group.
    /// The operator will wait for MemberLeave to complete successfully before releasing the replica and cleaning up
    /// related Kubernetes resources.
    /// 
    /// 
    /// The process typically includes updating configurations and informing other group members about the removal.
    /// Data migration is generally not part of this action and should be handled separately if needed.
    /// 
    /// 
    /// The container executing this action has access to following variables:
    /// 
    /// 
    /// - KB_LEAVE_MEMBER_POD_FQDN: The pod name of the replica being removed from the group.
    /// - KB_LEAVE_MEMBER_POD_NAME: The pod name of the replica being removed from the group.
    /// 
    /// 
    /// Expected action output:
    /// - On Failure: An error message, if applicable, indicating why the action failed.
    /// 
    /// 
    /// For example, to remove an OBServer from an OceanBase Cluster in 'zone1', the following command can be executed:
    /// 
    /// 
    /// ```text
    /// command:
    /// - bash
    /// - -c
    /// - |
    ///    CLIENT="mysql -u $SERVICE_USER -p$SERVICE_PASSWORD -P $SERVICE_PORT -h $SERVICE_HOST -e"
    /// 	  $CLIENT "ALTER SYSTEM DELETE SERVER '$POD_FQDN:$SERVICE_PORT' ZONE 'zone1'"
    /// ```
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memberLeave")]
    pub member_leave: Option<ComponentDefinitionLifecycleActionsMemberLeave>,
    /// Specifies the hook to be executed after a component's creation.
    /// 
    /// 
    /// By setting `postProvision.customHandler.preCondition`, you can determine the specific lifecycle stage
    /// at which the action should trigger: `Immediately`, `RuntimeReady`, `ComponentReady`, and `ClusterReady`.
    /// with `ComponentReady` being the default.
    /// 
    /// 
    /// The PostProvision Action is intended to run only once.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postProvision")]
    pub post_provision: Option<ComponentDefinitionLifecycleActionsPostProvision>,
    /// Specifies the hook to be executed prior to terminating a component.
    /// 
    /// 
    /// The PreTerminate Action is intended to run only once.
    /// 
    /// 
    /// This action is executed immediately when a scale-down operation for the Component is initiated.
    /// The actual termination and cleanup of the Component and its associated resources will not proceed
    /// until the PreTerminate action has completed successfully.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preTerminate")]
    pub pre_terminate: Option<ComponentDefinitionLifecycleActionsPreTerminate>,
    /// Defines the procedure to switch a replica into the read-only state.
    /// 
    /// 
    /// Use Case:
    /// This action is invoked when the database's volume capacity nears its upper limit and space is about to be exhausted.
    /// 
    /// 
    /// Expected action output:
    /// - On Failure: An error message, if applicable, indicating why the action failed.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub readonly: Option<ComponentDefinitionLifecycleActionsReadonly>,
    /// Defines the procedure to transition a replica from the read-only state back to the read-write state.
    /// 
    /// 
    /// Use Case:
    /// This action is used to bring back a replica that was previously in a read-only state,
    /// which restricted write operations, to its normal operational state where it can handle
    /// both read and write operations.
    /// 
    /// 
    /// Expected action output:
    /// - On Failure: An error message, if applicable, indicating why the action failed.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub readwrite: Option<ComponentDefinitionLifecycleActionsReadwrite>,
    /// Defines the procedure that update a replica with new configuration.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    /// 
    /// 
    /// This Action is reserved for future versions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconfigure: Option<ComponentDefinitionLifecycleActionsReconfigure>,
    /// Defines the procedure which is invoked regularly to assess the role of replicas.
    /// 
    /// 
    /// This action is periodically triggered at the specified interval to determine the role of each replica.
    /// Upon successful execution, the action's output designates the role of the replica,
    /// which should match one of the predefined role names within `componentDefinition.spec.roles`.
    /// The output is then compared with the previous successful execution result.
    /// If a role change is detected, an event is generated to inform the controller,
    /// which initiates an update of the replica's role.
    /// 
    /// 
    /// Defining a RoleProbe Action for a Component is required if roles are defined for the Component.
    /// It ensures replicas are correctly labeled with their respective roles.
    /// Without this, services that rely on roleSelectors might improperly direct traffic to wrong replicas.
    /// 
    /// 
    /// Expected output of this action:
    /// - On Success: The determined role of the replica, which must align with one of the roles specified
    ///   in the component definition.
    /// - On Failure: An error message, if applicable, indicating why the action failed.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleProbe")]
    pub role_probe: Option<ComponentDefinitionLifecycleActionsRoleProbe>,
    /// Defines the procedure for a controlled transition of a role to a new replica.
    /// This approach aims to minimize downtime and maintain availability
    /// during events such as planned maintenance or when performing stop, shutdown, restart, or upgrade operations.
    /// In a typical consensus system, this action is used to transfer leader role to another replica.
    /// 
    /// 
    /// The container executing this action has access to following variables:
    /// 
    /// 
    /// - KB_SWITCHOVER_CANDIDATE_NAME: The name of the pod of the new role's candidate, which may not be specified (empty).
    /// - KB_SWITCHOVER_CANDIDATE_FQDN: The FQDN of the pod of the new role's candidate, which may not be specified (empty).
    /// - KB_SWITCHOVER_CURRENT_NAME: The name of the pod of the current role.
    /// - KB_SWITCHOVER_CURRENT_FQDN: The FQDN of the pod of the current role.
    /// - KB_SWITCHOVER_ROLE: The role that will be transferred to another replica.
    ///   This variable can be empty if, for example, role probe does not succeed.
    ///   It depends on the addon implementation what to do under such cases.
    /// 
    /// 
    /// Note: This field is immutable once it has been set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub switchover: Option<ComponentDefinitionLifecycleActionsSwitchover>,
}

/// Defines the procedure to generate a new database account.
/// 
/// 
/// Use Case:
/// This action is designed to create system accounts that are utilized for replication, monitoring, backup,
/// and other administrative tasks.
/// 
/// 
/// The container executing this action has access to following variables:
/// 
/// 
/// - KB_ACCOUNT_NAME: The name of the system account to be manipulated.
/// - KB_ACCOUNT_PASSWORD: The password for the system account.
/// - KB_ACCOUNT_STATEMENT: The statement used to manipulate the system account.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvision {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsAccountProvisionExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsAccountProvisionGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsAccountProvisionHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsAccountProvisionRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsAccountProvisionTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsAccountProvisionExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsAccountProvisionExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsAccountProvisionExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsAccountProvisionGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsAccountProvisionHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsAccountProvisionHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsAccountProvisionHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsAccountProvisionHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsAccountProvisionHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAccountProvisionRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure to generate a new database account.
/// 
/// 
/// Use Case:
/// This action is designed to create system accounts that are utilized for replication, monitoring, backup,
/// and other administrative tasks.
/// 
/// 
/// The container executing this action has access to following variables:
/// 
/// 
/// - KB_ACCOUNT_NAME: The name of the system account to be manipulated.
/// - KB_ACCOUNT_PASSWORD: The password for the system account.
/// - KB_ACCOUNT_STATEMENT: The statement used to manipulate the system account.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsAccountProvisionTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure which is invoked regularly to assess the availability of the component.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbe {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsAvailableProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsAvailableProbeGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsAvailableProbeHttp>,
    /// Specifies the number of seconds to wait after the container has started before the RoleProbe
    /// begins to detect the container's role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the frequency at which the probe is conducted. This value is expressed in seconds.
    /// Default to 60 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsAvailableProbeRetryPolicy>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsAvailableProbeTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsAvailableProbeExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsAvailableProbeExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsAvailableProbeExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsAvailableProbeGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsAvailableProbeHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsAvailableProbeHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsAvailableProbeHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsAvailableProbeHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsAvailableProbeHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsAvailableProbeRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure which is invoked regularly to assess the availability of the component.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsAvailableProbeTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure for exporting the data from a replica.
/// 
/// 
/// Use Case:
/// This action is intended for initializing a newly created replica with data. It involves exporting data
/// from an existing replica and importing it into the new, empty replica. This is essential for synchronizing
/// the state of replicas across the system.
/// 
/// 
/// Applicability:
/// Some database engines or associated sidecar applications (e.g., Patroni) may already provide this functionality.
/// In such cases, this action may not be required.
/// 
/// 
/// The output should be a valid data dump streamed to stdout. It must exclude any irrelevant information to ensure
/// that only the necessary data is exported for import into the new replica.
/// 
/// 
/// The container executing this action has access to following environment variables:
/// 
/// 
/// - KB_TARGET_POD_NAME: The name of the replica pod into which the data will be loaded.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDump {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsDataDumpExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsDataDumpGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsDataDumpHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsDataDumpRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsDataDumpTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsDataDumpExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsDataDumpExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsDataDumpExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsDataDumpGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsDataDumpHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsDataDumpHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsDataDumpHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsDataDumpHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsDataDumpHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataDumpRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure for exporting the data from a replica.
/// 
/// 
/// Use Case:
/// This action is intended for initializing a newly created replica with data. It involves exporting data
/// from an existing replica and importing it into the new, empty replica. This is essential for synchronizing
/// the state of replicas across the system.
/// 
/// 
/// Applicability:
/// Some database engines or associated sidecar applications (e.g., Patroni) may already provide this functionality.
/// In such cases, this action may not be required.
/// 
/// 
/// The output should be a valid data dump streamed to stdout. It must exclude any irrelevant information to ensure
/// that only the necessary data is exported for import into the new replica.
/// 
/// 
/// The container executing this action has access to following environment variables:
/// 
/// 
/// - KB_TARGET_POD_NAME: The name of the replica pod into which the data will be loaded.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsDataDumpTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure for importing data into a replica.
/// 
/// 
/// Use Case:
/// This action is intended for initializing a newly created replica with data. It involves exporting data
/// from an existing replica and importing it into the new, empty replica. This is essential for synchronizing
/// the state of replicas across the system.
/// 
/// 
/// Some database engines or associated sidecar applications (e.g., Patroni) may already provide this functionality.
/// In such cases, this action may not be required.
/// 
/// 
/// Data should be received through stdin. If any error occurs during the process,
/// the action must be able to guarantee idempotence to allow for retries from the beginning.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoad {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsDataLoadExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsDataLoadGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsDataLoadHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsDataLoadRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsDataLoadTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsDataLoadExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsDataLoadExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsDataLoadExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsDataLoadGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsDataLoadHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsDataLoadHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsDataLoadHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsDataLoadHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsDataLoadHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsDataLoadRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure for importing data into a replica.
/// 
/// 
/// Use Case:
/// This action is intended for initializing a newly created replica with data. It involves exporting data
/// from an existing replica and importing it into the new, empty replica. This is essential for synchronizing
/// the state of replicas across the system.
/// 
/// 
/// Some database engines or associated sidecar applications (e.g., Patroni) may already provide this functionality.
/// In such cases, this action may not be required.
/// 
/// 
/// Data should be received through stdin. If any error occurs during the process,
/// the action must be able to guarantee idempotence to allow for retries from the beginning.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsDataLoadTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure to add a new replica to the replication group.
/// 
/// 
/// This action is initiated after a replica pod becomes ready.
/// 
/// 
/// The role of the replica (e.g., primary, secondary) will be determined and assigned as part of the action command
/// implementation, or automatically by the database kernel or a sidecar utility like Patroni that implements
/// a consensus algorithm.
/// 
/// 
/// The container executing this action has access to following variables:
/// 
/// 
/// - KB_JOIN_MEMBER_POD_FQDN: The pod FQDN of the replica being added to the group.
/// - KB_JOIN_MEMBER_POD_NAME: The pod name of the replica being added to the group.
/// 
/// 
/// Expected action output:
/// - On Failure: An error message detailing the reason for any failure encountered
///   during the addition of the new member.
/// 
/// 
/// For example, to add a new OBServer to an OceanBase Cluster in 'zone1', the following command may be used:
/// 
/// 
/// ```text
/// command:
/// - bash
/// - -c
/// - |
///    CLIENT="mysql -u $SERVICE_USER -p$SERVICE_PASSWORD -P $SERVICE_PORT -h $SERVICE_HOST -e"
/// 	  $CLIENT "ALTER SYSTEM ADD SERVER '$POD_FQDN:$SERVICE_PORT' ZONE 'zone1'"
/// ```
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoin {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsMemberJoinExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsMemberJoinGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsMemberJoinHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsMemberJoinRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsMemberJoinTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsMemberJoinExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsMemberJoinExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsMemberJoinExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsMemberJoinGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsMemberJoinHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsMemberJoinHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsMemberJoinHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsMemberJoinHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsMemberJoinHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberJoinRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure to add a new replica to the replication group.
/// 
/// 
/// This action is initiated after a replica pod becomes ready.
/// 
/// 
/// The role of the replica (e.g., primary, secondary) will be determined and assigned as part of the action command
/// implementation, or automatically by the database kernel or a sidecar utility like Patroni that implements
/// a consensus algorithm.
/// 
/// 
/// The container executing this action has access to following variables:
/// 
/// 
/// - KB_JOIN_MEMBER_POD_FQDN: The pod FQDN of the replica being added to the group.
/// - KB_JOIN_MEMBER_POD_NAME: The pod name of the replica being added to the group.
/// 
/// 
/// Expected action output:
/// - On Failure: An error message detailing the reason for any failure encountered
///   during the addition of the new member.
/// 
/// 
/// For example, to add a new OBServer to an OceanBase Cluster in 'zone1', the following command may be used:
/// 
/// 
/// ```text
/// command:
/// - bash
/// - -c
/// - |
///    CLIENT="mysql -u $SERVICE_USER -p$SERVICE_PASSWORD -P $SERVICE_PORT -h $SERVICE_HOST -e"
/// 	  $CLIENT "ALTER SYSTEM ADD SERVER '$POD_FQDN:$SERVICE_PORT' ZONE 'zone1'"
/// ```
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsMemberJoinTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure to remove a replica from the replication group.
/// 
/// 
/// This action is initiated before remove a replica from the group.
/// The operator will wait for MemberLeave to complete successfully before releasing the replica and cleaning up
/// related Kubernetes resources.
/// 
/// 
/// The process typically includes updating configurations and informing other group members about the removal.
/// Data migration is generally not part of this action and should be handled separately if needed.
/// 
/// 
/// The container executing this action has access to following variables:
/// 
/// 
/// - KB_LEAVE_MEMBER_POD_FQDN: The pod name of the replica being removed from the group.
/// - KB_LEAVE_MEMBER_POD_NAME: The pod name of the replica being removed from the group.
/// 
/// 
/// Expected action output:
/// - On Failure: An error message, if applicable, indicating why the action failed.
/// 
/// 
/// For example, to remove an OBServer from an OceanBase Cluster in 'zone1', the following command can be executed:
/// 
/// 
/// ```text
/// command:
/// - bash
/// - -c
/// - |
///    CLIENT="mysql -u $SERVICE_USER -p$SERVICE_PASSWORD -P $SERVICE_PORT -h $SERVICE_HOST -e"
/// 	  $CLIENT "ALTER SYSTEM DELETE SERVER '$POD_FQDN:$SERVICE_PORT' ZONE 'zone1'"
/// ```
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeave {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsMemberLeaveExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsMemberLeaveGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsMemberLeaveHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsMemberLeaveRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsMemberLeaveTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsMemberLeaveExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsMemberLeaveExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsMemberLeaveExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsMemberLeaveGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsMemberLeaveHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsMemberLeaveHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsMemberLeaveHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsMemberLeaveHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsMemberLeaveHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsMemberLeaveRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure to remove a replica from the replication group.
/// 
/// 
/// This action is initiated before remove a replica from the group.
/// The operator will wait for MemberLeave to complete successfully before releasing the replica and cleaning up
/// related Kubernetes resources.
/// 
/// 
/// The process typically includes updating configurations and informing other group members about the removal.
/// Data migration is generally not part of this action and should be handled separately if needed.
/// 
/// 
/// The container executing this action has access to following variables:
/// 
/// 
/// - KB_LEAVE_MEMBER_POD_FQDN: The pod name of the replica being removed from the group.
/// - KB_LEAVE_MEMBER_POD_NAME: The pod name of the replica being removed from the group.
/// 
/// 
/// Expected action output:
/// - On Failure: An error message, if applicable, indicating why the action failed.
/// 
/// 
/// For example, to remove an OBServer from an OceanBase Cluster in 'zone1', the following command can be executed:
/// 
/// 
/// ```text
/// command:
/// - bash
/// - -c
/// - |
///    CLIENT="mysql -u $SERVICE_USER -p$SERVICE_PASSWORD -P $SERVICE_PORT -h $SERVICE_HOST -e"
/// 	  $CLIENT "ALTER SYSTEM DELETE SERVER '$POD_FQDN:$SERVICE_PORT' ZONE 'zone1'"
/// ```
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsMemberLeaveTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Specifies the hook to be executed after a component's creation.
/// 
/// 
/// By setting `postProvision.customHandler.preCondition`, you can determine the specific lifecycle stage
/// at which the action should trigger: `Immediately`, `RuntimeReady`, `ComponentReady`, and `ClusterReady`.
/// with `ComponentReady` being the default.
/// 
/// 
/// The PostProvision Action is intended to run only once.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvision {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsPostProvisionExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsPostProvisionGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsPostProvisionHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsPostProvisionRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsPostProvisionTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsPostProvisionExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsPostProvisionExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsPostProvisionExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsPostProvisionGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsPostProvisionHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsPostProvisionHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsPostProvisionHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsPostProvisionHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsPostProvisionHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPostProvisionRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Specifies the hook to be executed after a component's creation.
/// 
/// 
/// By setting `postProvision.customHandler.preCondition`, you can determine the specific lifecycle stage
/// at which the action should trigger: `Immediately`, `RuntimeReady`, `ComponentReady`, and `ClusterReady`.
/// with `ComponentReady` being the default.
/// 
/// 
/// The PostProvision Action is intended to run only once.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsPostProvisionTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Specifies the hook to be executed prior to terminating a component.
/// 
/// 
/// The PreTerminate Action is intended to run only once.
/// 
/// 
/// This action is executed immediately when a scale-down operation for the Component is initiated.
/// The actual termination and cleanup of the Component and its associated resources will not proceed
/// until the PreTerminate action has completed successfully.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminate {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsPreTerminateExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsPreTerminateGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsPreTerminateHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsPreTerminateRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsPreTerminateTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsPreTerminateExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsPreTerminateExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsPreTerminateExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsPreTerminateGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsPreTerminateHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsPreTerminateHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsPreTerminateHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsPreTerminateHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsPreTerminateHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsPreTerminateRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Specifies the hook to be executed prior to terminating a component.
/// 
/// 
/// The PreTerminate Action is intended to run only once.
/// 
/// 
/// This action is executed immediately when a scale-down operation for the Component is initiated.
/// The actual termination and cleanup of the Component and its associated resources will not proceed
/// until the PreTerminate action has completed successfully.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsPreTerminateTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure to switch a replica into the read-only state.
/// 
/// 
/// Use Case:
/// This action is invoked when the database's volume capacity nears its upper limit and space is about to be exhausted.
/// 
/// 
/// Expected action output:
/// - On Failure: An error message, if applicable, indicating why the action failed.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonly {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsReadonlyExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsReadonlyGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsReadonlyHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsReadonlyRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsReadonlyTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsReadonlyExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsReadonlyExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReadonlyExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsReadonlyGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsReadonlyHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsReadonlyHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsReadonlyHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReadonlyHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReadonlyHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadonlyRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure to switch a replica into the read-only state.
/// 
/// 
/// Use Case:
/// This action is invoked when the database's volume capacity nears its upper limit and space is about to be exhausted.
/// 
/// 
/// Expected action output:
/// - On Failure: An error message, if applicable, indicating why the action failed.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReadonlyTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure to transition a replica from the read-only state back to the read-write state.
/// 
/// 
/// Use Case:
/// This action is used to bring back a replica that was previously in a read-only state,
/// which restricted write operations, to its normal operational state where it can handle
/// both read and write operations.
/// 
/// 
/// Expected action output:
/// - On Failure: An error message, if applicable, indicating why the action failed.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwrite {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsReadwriteExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsReadwriteGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsReadwriteHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsReadwriteRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsReadwriteTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsReadwriteExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsReadwriteExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReadwriteExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsReadwriteGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsReadwriteHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsReadwriteHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsReadwriteHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReadwriteHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReadwriteHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReadwriteRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure to transition a replica from the read-only state back to the read-write state.
/// 
/// 
/// Use Case:
/// This action is used to bring back a replica that was previously in a read-only state,
/// which restricted write operations, to its normal operational state where it can handle
/// both read and write operations.
/// 
/// 
/// Expected action output:
/// - On Failure: An error message, if applicable, indicating why the action failed.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReadwriteTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure that update a replica with new configuration.
/// 
/// 
/// Note: This field is immutable once it has been set.
/// 
/// 
/// This Action is reserved for future versions.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigure {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsReconfigureExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsReconfigureGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsReconfigureHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsReconfigureRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsReconfigureTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsReconfigureExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsReconfigureExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReconfigureExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsReconfigureGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsReconfigureHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsReconfigureHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsReconfigureHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReconfigureHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReconfigureHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsReconfigureRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure that update a replica with new configuration.
/// 
/// 
/// Note: This field is immutable once it has been set.
/// 
/// 
/// This Action is reserved for future versions.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsReconfigureTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure which is invoked regularly to assess the role of replicas.
/// 
/// 
/// This action is periodically triggered at the specified interval to determine the role of each replica.
/// Upon successful execution, the action's output designates the role of the replica,
/// which should match one of the predefined role names within `componentDefinition.spec.roles`.
/// The output is then compared with the previous successful execution result.
/// If a role change is detected, an event is generated to inform the controller,
/// which initiates an update of the replica's role.
/// 
/// 
/// Defining a RoleProbe Action for a Component is required if roles are defined for the Component.
/// It ensures replicas are correctly labeled with their respective roles.
/// Without this, services that rely on roleSelectors might improperly direct traffic to wrong replicas.
/// 
/// 
/// Expected output of this action:
/// - On Success: The determined role of the replica, which must align with one of the roles specified
///   in the component definition.
/// - On Failure: An error message, if applicable, indicating why the action failed.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbe {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsRoleProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsRoleProbeGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsRoleProbeHttp>,
    /// Specifies the number of seconds to wait after the container has started before the RoleProbe
    /// begins to detect the container's role.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the frequency at which the probe is conducted. This value is expressed in seconds.
    /// Default to 60 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsRoleProbeRetryPolicy>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsRoleProbeTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsRoleProbeExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsRoleProbeExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsRoleProbeExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsRoleProbeGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsRoleProbeHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsRoleProbeHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsRoleProbeHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsRoleProbeHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsRoleProbeHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsRoleProbeRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure which is invoked regularly to assess the role of replicas.
/// 
/// 
/// This action is periodically triggered at the specified interval to determine the role of each replica.
/// Upon successful execution, the action's output designates the role of the replica,
/// which should match one of the predefined role names within `componentDefinition.spec.roles`.
/// The output is then compared with the previous successful execution result.
/// If a role change is detected, an event is generated to inform the controller,
/// which initiates an update of the replica's role.
/// 
/// 
/// Defining a RoleProbe Action for a Component is required if roles are defined for the Component.
/// It ensures replicas are correctly labeled with their respective roles.
/// Without this, services that rely on roleSelectors might improperly direct traffic to wrong replicas.
/// 
/// 
/// Expected output of this action:
/// - On Success: The determined role of the replica, which must align with one of the roles specified
///   in the component definition.
/// - On Failure: An error message, if applicable, indicating why the action failed.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsRoleProbeTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the procedure for a controlled transition of a role to a new replica.
/// This approach aims to minimize downtime and maintain availability
/// during events such as planned maintenance or when performing stop, shutdown, restart, or upgrade operations.
/// In a typical consensus system, this action is used to transfer leader role to another replica.
/// 
/// 
/// The container executing this action has access to following variables:
/// 
/// 
/// - KB_SWITCHOVER_CANDIDATE_NAME: The name of the pod of the new role's candidate, which may not be specified (empty).
/// - KB_SWITCHOVER_CANDIDATE_FQDN: The FQDN of the pod of the new role's candidate, which may not be specified (empty).
/// - KB_SWITCHOVER_CURRENT_NAME: The name of the pod of the current role.
/// - KB_SWITCHOVER_CURRENT_FQDN: The FQDN of the pod of the current role.
/// - KB_SWITCHOVER_ROLE: The role that will be transferred to another replica.
///   This variable can be empty if, for example, role probe does not succeed.
///   It depends on the addon implementation what to do under such cases.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchover {
    /// Defines the command to run.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionLifecycleActionsSwitchoverExec>,
    /// Defines the gRPC call to issue.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionLifecycleActionsSwitchoverGrpc>,
    /// Defines the HTTP request to perform.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<ComponentDefinitionLifecycleActionsSwitchoverHttp>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Specifies the state that the cluster must reach before the Action is executed.
    /// Currently, this is only applicable to the `postProvision` action.
    /// 
    /// 
    /// The conditions are as follows:
    /// 
    /// 
    /// - `Immediately`: Executed right after the Component object is created.
    ///   The readiness of the Component and its resources is not guaranteed at this stage.
    /// - `RuntimeReady`: The Action is triggered after the Component object has been created and all associated
    ///   runtime resources (e.g. Pods) are in a ready state.
    /// - `ComponentReady`: The Action is triggered after the Component itself is in a ready state.
    ///   This process does not affect the readiness state of the Component or the Cluster.
    /// - `ClusterReady`: The Action is executed after the Cluster is in a ready state.
    ///   This execution does not alter the Component or the Cluster's state of readiness.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preCondition")]
    pub pre_condition: Option<String>,
    /// Defines the strategy to be taken when retrying the Action after a failure.
    /// 
    /// 
    /// It specifies the conditions under which the Action should be retried and the limits to apply,
    /// such as the maximum number of retries and backoff strategy.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPolicy")]
    pub retry_policy: Option<ComponentDefinitionLifecycleActionsSwitchoverRetryPolicy>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsSwitchoverTargetPodSelector>,
    /// Specifies the maximum duration in seconds that the Action is allowed to run.
    /// 
    /// 
    /// If the Action does not complete within this time frame, it will be terminated.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverExec {
    /// Args represents the arguments that are passed to the `command` for execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Specifies the command to be executed inside the container.
    /// The working directory for this command is the container's root directory('/').
    /// Commands are executed directly without a shell environment, meaning shell-specific syntax ('|', etc.) is not supported.
    /// If the shell is required, it must be explicitly invoked in the command.
    /// 
    /// 
    /// A successful execution is indicated by an exit status of 0; any non-zero status signifies a failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// Specifies the name of the container within the same pod whose resources will be shared with the action.
    /// This allows the action to utilize the specified container's resources without executing within it.
    /// 
    /// 
    /// The name must match one of the containers defined in `componentDefinition.spec.runtime`.
    /// 
    /// 
    /// The resources that can be shared are included:
    /// 
    /// 
    /// - volume mounts
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<String>,
    /// Represents a list of environment variables that will be injected into the container.
    /// These variables enable the container to adapt its behavior based on the environment it's running in.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionLifecycleActionsSwitchoverExecEnv>>,
    /// Specifies the container image to be used for running the Action.
    /// 
    /// 
    /// When specified, a dedicated container will be created using this image to execute the Action.
    /// All actions with same image will share the same container.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Used in conjunction with the `targetPodSelector` field to refine the selection of target pod(s) for Action execution.
    /// The impact of this field depends on the `targetPodSelector` value:
    /// 
    /// 
    /// - When `targetPodSelector` is set to `Any` or `All`, this field will be ignored.
    /// - When `targetPodSelector` is set to `Role`, only those replicas whose role matches the `matchingKey`
    ///   will be selected for the Action.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchingKey")]
    pub matching_key: Option<String>,
    /// Defines the criteria used to select the target Pod(s) for executing the Action.
    /// This is useful when there is no default target replica identified.
    /// It allows for precise control over which Pod(s) the Action should run in.
    /// 
    /// 
    /// If not specified, the Action will be executed in the pod where the Action is triggered, such as the pod
    /// to be removed or added; or a random pod if the Action is triggered at the component level, such as
    /// post-provision or pre-terminate of the component.
    /// 
    /// 
    /// This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPodSelector")]
    pub target_pod_selector: Option<ComponentDefinitionLifecycleActionsSwitchoverExecTargetPodSelector>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverExecEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverExecEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Defines the command to run.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsSwitchoverExecTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

/// Defines the gRPC call to issue.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverGrpc {
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Name of the method to invoke on the gRPC service.
    pub method: String,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "50051") or a named port defined in the container spec.
    pub port: String,
    /// Request payload for the gRPC method.
    /// 
    /// 
    /// Keys are proto field names (lowerCamelCase); values are strings that can include Go templates.
    /// Templates are rendered with predefined action variables before the request is sent.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub request: Option<BTreeMap<String, String>>,
    /// Required response schema for the gRPC method.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub response: Option<ComponentDefinitionLifecycleActionsSwitchoverGrpcResponse>,
    /// Fully-qualified name of the gRPC service to call.
    pub service: String,
}

/// Required response schema for the gRPC method.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverGrpcResponse {
    /// Name of the field in the response whose value should be output.
    /// Printed to stdout on success, or stderr on failure.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Name of the string field in the response that carries status information.
    /// If non-empty, the action fails.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverHttp {
    /// Optional HTTP request body.
    /// 
    /// 
    /// Supports Go text/template syntax; rendered with predefined variables before sending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Custom headers to set in the request.
    /// Header values may use Go text/template syntax, rendered with predefined variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<ComponentDefinitionLifecycleActionsSwitchoverHttpHeaders>>,
    /// The target host to connect to.
    /// Defaults to "127.0.0.1" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// The HTTP method to use.
    /// Defaults to "GET".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<ComponentDefinitionLifecycleActionsSwitchoverHttpMethod>,
    /// The path to request on the HTTP server.
    /// Defaults to "/" if not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The port to access on the host.
    /// It may be a numeric string (e.g., "8080") or a named port defined in the container spec.
    pub port: String,
    /// The scheme to use for connecting to the host.
    /// Defaults to "HTTP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<ComponentDefinitionLifecycleActionsSwitchoverHttpScheme>,
}

/// HTTPHeader represents a single HTTP header key/value pair.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverHttpHeaders {
    /// Name of the header field.
    pub name: String,
    /// Value of the header field.
    pub value: String,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsSwitchoverHttpMethod {
    #[serde(rename = "GET")]
    Get,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "PUT")]
    Put,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "HEAD")]
    Head,
    #[serde(rename = "PATCH")]
    Patch,
}

/// Defines the HTTP request to perform.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsSwitchoverHttpScheme {
    #[serde(rename = "HTTP")]
    Http,
    #[serde(rename = "HTTPS")]
    Https,
}

/// Defines the strategy to be taken when retrying the Action after a failure.
/// 
/// 
/// It specifies the conditions under which the Action should be retried and the limits to apply,
/// such as the maximum number of retries and backoff strategy.
/// 
/// 
/// This field cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLifecycleActionsSwitchoverRetryPolicy {
    /// Defines the maximum number of retry attempts that should be made for a given Action.
    /// This value is set to 0 by default, indicating that no retries will be made.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetries")]
    pub max_retries: Option<i64>,
    /// Indicates the duration of time to wait between each retry attempt.
    /// This value is set to 0 by default, indicating that there will be no delay between retry attempts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryInterval")]
    pub retry_interval: Option<i64>,
}

/// Defines the procedure for a controlled transition of a role to a new replica.
/// This approach aims to minimize downtime and maintain availability
/// during events such as planned maintenance or when performing stop, shutdown, restart, or upgrade operations.
/// In a typical consensus system, this action is used to transfer leader role to another replica.
/// 
/// 
/// The container executing this action has access to following variables:
/// 
/// 
/// - KB_SWITCHOVER_CANDIDATE_NAME: The name of the pod of the new role's candidate, which may not be specified (empty).
/// - KB_SWITCHOVER_CANDIDATE_FQDN: The FQDN of the pod of the new role's candidate, which may not be specified (empty).
/// - KB_SWITCHOVER_CURRENT_NAME: The name of the pod of the current role.
/// - KB_SWITCHOVER_CURRENT_FQDN: The FQDN of the pod of the current role.
/// - KB_SWITCHOVER_ROLE: The role that will be transferred to another replica.
///   This variable can be empty if, for example, role probe does not succeed.
///   It depends on the addon implementation what to do under such cases.
/// 
/// 
/// Note: This field is immutable once it has been set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionLifecycleActionsSwitchoverTargetPodSelector {
    Any,
    All,
    Role,
    Ordinal,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionLogConfigs {
    /// Specifies the paths or patterns identifying where the log files are stored.
    /// This field allows the system to locate and manage log files effectively.
    /// 
    /// 
    /// Examples:
    /// 
    /// 
    /// - /home/postgres/pgdata/pgroot/data/log/postgresql-*
    /// - /data/mysql/log/mysqld-error.log
    #[serde(rename = "filePathPattern")]
    pub file_path_pattern: String,
    /// Specifies a descriptive label for the log type, such as 'slow' for a MySQL slow log file.
    /// It provides a clear identification of the log's purpose and content.
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionPodUpdatePolicy {
    PreferInPlace,
    ReCreate,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionPodUpgradePolicy {
    PreferInPlace,
    ReCreate,
}

/// PolicyRule holds information that describes a policy rule, but does not contain information
/// about who the rule applies to or which namespace the rule applies to.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionPolicyRules {
    /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
    /// the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroups")]
    pub api_groups: Option<Vec<String>>,
    /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
    /// Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
    /// Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nonResourceURLs")]
    pub non_resource_ur_ls: Option<Vec<String>>,
    /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceNames")]
    pub resource_names: Option<Vec<String>>,
    /// Resources is a list of resources this rule applies to. '*' represents all resources.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
    /// Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
    pub verbs: Vec<String>,
}

/// Defines the upper limit of the number of replicas supported by the Component.
/// 
/// 
/// It defines the maximum number of replicas that can be created for the Component.
/// This field allows you to set a limit on the scalability of the Component, preventing it from exceeding a certain number of replicas.
/// 
/// 
/// This field is immutable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionReplicasLimit {
    /// The maximum limit of replicas.
    #[serde(rename = "maxReplicas")]
    pub max_replicas: i32,
    /// The minimum limit of replicas.
    #[serde(rename = "minReplicas")]
    pub min_replicas: i32,
}

/// ReplicaRole represents a role that can be assigned to a component instance, defining its behavior and responsibilities.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRoles {
    /// Name defines the role's unique identifier. This value is used to set the "apps.kubeblocks.io/role" label
    /// on the corresponding object to identify its role.
    /// 
    /// 
    /// For example, common role names include:
    /// - "leader": The primary/master instance that handles write operations
    /// - "follower": Secondary/replica instances that replicate data from the leader
    /// - "learner": Read-only instances that don't participate in elections
    /// 
    /// 
    /// This field is immutable once set.
    pub name: String,
    /// ParticipatesInQuorum indicates if pods with this role are counted when determining quorum.
    /// This affects update strategies that need to maintain quorum for availability. Roles participate
    /// in quorum should have higher update priority than roles do not participate in quorum.
    /// The default value is false.
    /// 
    /// 
    /// For example, in a 5-pod component where:
    /// - 2 learner pods (participatesInQuorum=false)
    /// - 2 follower pods (participatesInQuorum=true)
    /// - 1 leader pod (participatesInQuorum=true)
    /// The quorum size would be 3 (based on the 3 participating pods), allowing parallel updates
    /// of 2 learners and 1 follower while maintaining quorum.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "participatesInQuorum")]
    pub participates_in_quorum: Option<bool>,
    /// UpdatePriority determines the order in which pods with different roles are updated.
    /// Pods are sorted by this priority (higher numbers = higher priority) and updated accordingly.
    /// Roles with the highest priority will be updated last.
    /// The default priority is 0.
    /// 
    /// 
    /// For example:
    /// - Leader role may have priority 2 (updated last)
    /// - Follower role may have priority 1 (updated before leader)
    /// - Learner role may have priority 0 (updated first)
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatePriority")]
    pub update_priority: Option<i64>,
}

/// Specifies the PodSpec template used in the Component.
/// It includes the following elements:
/// 
/// 
/// - Init containers
/// - Containers
///     - Image
///     - Commands
///     - Args
///     - Envs
///     - Mounts
///     - Ports
///     - Security context
///     - Probes
///     - Lifecycle
/// - Volumes
/// 
/// 
/// This field is intended to define static settings that remain consistent across all instantiated Components.
/// Dynamic settings such as CPU and memory resource limits, as well as scheduling settings (affinity,
/// toleration, priority), may vary among different instantiated Components.
/// They should be specified in the `cluster.spec.componentSpecs` (ClusterComponentSpec).
/// 
/// 
/// Specific instances of a Component may override settings defined here, such as using a different container image
/// or modifying environment variable values.
/// These instance-specific overrides can be specified in `cluster.spec.componentSpecs[*].instances`.
/// 
/// 
/// This field is immutable and cannot be updated once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntime {
    /// Optional duration in seconds the pod may be active on the node relative to
    /// StartTime before the system will actively try to mark it failed and kill associated containers.
    /// Value must be a positive integer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "activeDeadlineSeconds")]
    pub active_deadline_seconds: Option<i64>,
    /// If specified, the pod's scheduling constraints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<ComponentDefinitionRuntimeAffinity>,
    /// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "automountServiceAccountToken")]
    pub automount_service_account_token: Option<bool>,
    /// List of containers belonging to the pod.
    /// Containers cannot currently be added or removed.
    /// There must be at least one container in a Pod.
    /// Cannot be updated.
    pub containers: Vec<ComponentDefinitionRuntimeContainers>,
    /// Specifies the DNS parameters of a pod.
    /// Parameters specified here will be merged to the generated DNS
    /// configuration based on DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsConfig")]
    pub dns_config: Option<ComponentDefinitionRuntimeDnsConfig>,
    /// Set DNS policy for the pod.
    /// Defaults to "ClusterFirst".
    /// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
    /// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
    /// To have DNS options set along with hostNetwork, you have to specify DNS policy
    /// explicitly to 'ClusterFirstWithHostNet'.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsPolicy")]
    pub dns_policy: Option<String>,
    /// EnableServiceLinks indicates whether information about services should be injected into pod's
    /// environment variables, matching the syntax of Docker links.
    /// Optional: Defaults to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableServiceLinks")]
    pub enable_service_links: Option<bool>,
    /// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
    /// pod to perform user-initiated actions such as debugging. This list cannot be specified when
    /// creating a pod, and it cannot be modified by updating the pod spec. In order to add an
    /// ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ephemeralContainers")]
    pub ephemeral_containers: Option<Vec<ComponentDefinitionRuntimeEphemeralContainers>>,
    /// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
    /// file if specified. This is only valid for non-hostNetwork pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostAliases")]
    pub host_aliases: Option<Vec<ComponentDefinitionRuntimeHostAliases>>,
    /// Use the host's ipc namespace.
    /// Optional: Default to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIPC")]
    pub host_ipc: Option<bool>,
    /// Host networking requested for this pod. Use the host's network namespace.
    /// If this option is set, the ports that will be used must be specified.
    /// Default to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetwork")]
    pub host_network: Option<bool>,
    /// Use the host's pid namespace.
    /// Optional: Default to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPID")]
    pub host_pid: Option<bool>,
    /// Use the host's user namespace.
    /// Optional: Default to true.
    /// If set to true or not present, the pod will be run in the host user namespace, useful
    /// for when the pod needs a feature only available to the host user namespace, such as
    /// loading a kernel module with CAP_SYS_MODULE.
    /// When set to false, a new userns is created for the pod. Setting false is useful for
    /// mitigating container breakout vulnerabilities even allowing users to run their
    /// containers as root without actually having root privileges on the host.
    /// This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostUsers")]
    pub host_users: Option<bool>,
    /// Specifies the hostname of the Pod
    /// If not specified, the pod's hostname will be set to a system-defined value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostname: Option<String>,
    /// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
    /// If specified, these secrets will be passed to individual puller implementations for them to use.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSecrets")]
    pub image_pull_secrets: Option<Vec<ComponentDefinitionRuntimeImagePullSecrets>>,
    /// List of initialization containers belonging to the pod.
    /// Init containers are executed in order prior to containers being started. If any
    /// init container fails, the pod is considered to have failed and is handled according
    /// to its restartPolicy. The name for an init container or normal container must be
    /// unique among all containers.
    /// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
    /// The resourceRequirements of an init container are taken into account during scheduling
    /// by finding the highest request/limit for each resource type, and then using the max of
    /// of that value or the sum of the normal containers. Limits are applied to init containers
    /// in a similar fashion.
    /// Init containers cannot currently be added or removed.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/init-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<ComponentDefinitionRuntimeInitContainers>>,
    /// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
    /// the scheduler simply schedules this pod onto that node, assuming that it fits resource
    /// requirements.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeName")]
    pub node_name: Option<String>,
    /// NodeSelector is a selector which must be true for the pod to fit on a node.
    /// Selector which must match a node's labels for the pod to be scheduled on that node.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/assign-pod-node/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<BTreeMap<String, String>>,
    /// Specifies the OS of the containers in the pod.
    /// Some pod and container fields are restricted if this is set.
    /// 
    /// 
    /// If the OS field is set to linux, the following fields must be unset:
    /// -securityContext.windowsOptions
    /// 
    /// 
    /// If the OS field is set to windows, following fields must be unset:
    /// - spec.hostPID
    /// - spec.hostIPC
    /// - spec.hostUsers
    /// - spec.securityContext.seLinuxOptions
    /// - spec.securityContext.seccompProfile
    /// - spec.securityContext.fsGroup
    /// - spec.securityContext.fsGroupChangePolicy
    /// - spec.securityContext.sysctls
    /// - spec.shareProcessNamespace
    /// - spec.securityContext.runAsUser
    /// - spec.securityContext.runAsGroup
    /// - spec.securityContext.supplementalGroups
    /// - spec.containers[*].securityContext.seLinuxOptions
    /// - spec.containers[*].securityContext.seccompProfile
    /// - spec.containers[*].securityContext.capabilities
    /// - spec.containers[*].securityContext.readOnlyRootFilesystem
    /// - spec.containers[*].securityContext.privileged
    /// - spec.containers[*].securityContext.allowPrivilegeEscalation
    /// - spec.containers[*].securityContext.procMount
    /// - spec.containers[*].securityContext.runAsUser
    /// - spec.containers[*].securityContext.runAsGroup
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub os: Option<ComponentDefinitionRuntimeOs>,
    /// Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
    /// This field will be autopopulated at admission time by the RuntimeClass admission controller. If
    /// the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
    /// The RuntimeClass admission controller will reject Pod create requests which have the overhead already
    /// set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
    /// defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
    /// More info: <https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overhead: Option<BTreeMap<String, IntOrString>>,
    /// PreemptionPolicy is the Policy for preempting pods with lower priority.
    /// One of Never, PreemptLowerPriority.
    /// Defaults to PreemptLowerPriority if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preemptionPolicy")]
    pub preemption_policy: Option<String>,
    /// The priority value. Various system components use this field to find the
    /// priority of the pod. When Priority Admission Controller is enabled, it
    /// prevents users from setting this field. The admission controller populates
    /// this field from PriorityClassName.
    /// The higher the value, the higher the priority.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
    /// If specified, indicates the pod's priority. "system-node-critical" and
    /// "system-cluster-critical" are two special keywords which indicate the
    /// highest priorities with the former being the highest priority. Any other
    /// name must be defined by creating a PriorityClass object with that name.
    /// If not specified, the pod priority will be default or zero if there is no
    /// default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityClassName")]
    pub priority_class_name: Option<String>,
    /// If specified, all readiness gates will be evaluated for pod readiness.
    /// A pod is ready when all its containers are ready AND
    /// all conditions specified in the readiness gates have status equal to "True"
    /// More info: <https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<ComponentDefinitionRuntimeReadinessGates>>,
    /// ResourceClaims defines which ResourceClaims must be allocated
    /// and reserved before the Pod is allowed to start. The resources
    /// will be made available to those containers which consume them
    /// by name.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceClaims")]
    pub resource_claims: Option<Vec<ComponentDefinitionRuntimeResourceClaims>>,
    /// Restart policy for all containers within the pod.
    /// One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
    /// Default to Always.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
    /// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
    /// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
    /// empty definition that uses the default runtime handler.
    /// More info: <https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runtimeClassName")]
    pub runtime_class_name: Option<String>,
    /// If specified, the pod will be dispatched by specified scheduler.
    /// If not specified, the pod will be dispatched by default scheduler.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    /// SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
    /// If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the
    /// scheduler will not attempt to schedule the pod.
    /// 
    /// 
    /// SchedulingGates can only be set at pod creation time, and be removed only afterwards.
    /// 
    /// 
    /// This is a beta feature enabled by the PodSchedulingReadiness feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulingGates")]
    pub scheduling_gates: Option<Vec<ComponentDefinitionRuntimeSchedulingGates>>,
    /// SecurityContext holds pod-level security attributes and common container settings.
    /// Optional: Defaults to empty.  See type description for default values of each field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ComponentDefinitionRuntimeSecurityContext>,
    /// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
    /// Deprecated: Use serviceAccountName instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccount")]
    pub service_account: Option<String>,
    /// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountName")]
    pub service_account_name: Option<String>,
    /// If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
    /// In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
    /// In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
    /// If a pod does not have FQDN, this has no effect.
    /// Default to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "setHostnameAsFQDN")]
    pub set_hostname_as_fqdn: Option<bool>,
    /// Share a single process namespace between all of the containers in a pod.
    /// When this is set containers will be able to view and signal processes from other containers
    /// in the same pod, and the first process in each container will not be assigned PID 1.
    /// HostPID and ShareProcessNamespace cannot both be set.
    /// Optional: Default to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shareProcessNamespace")]
    pub share_process_namespace: Option<bool>,
    /// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
    /// If not specified, the pod will not have a domainname at all.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subdomain: Option<String>,
    /// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// If this value is nil, the default grace period will be used instead.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// Defaults to 30 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// If specified, the pod's tolerations.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<ComponentDefinitionRuntimeTolerations>>,
    /// TopologySpreadConstraints describes how a group of pods ought to spread across topology
    /// domains. Scheduler will schedule pods in a way which abides by the constraints.
    /// All topologySpreadConstraints are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologySpreadConstraints")]
    pub topology_spread_constraints: Option<Vec<ComponentDefinitionRuntimeTopologySpreadConstraints>>,
    /// List of volumes that can be mounted by containers belonging to the pod.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<ComponentDefinitionRuntimeVolumes>>,
}

/// If specified, the pod's scheduling constraints
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinity {
    /// Describes node affinity scheduling rules for the pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<ComponentDefinitionRuntimeAffinityNodeAffinity>,
    /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAffinity")]
    pub pod_affinity: Option<ComponentDefinitionRuntimeAffinityPodAffinity>,
    /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAntiAffinity")]
    pub pod_anti_affinity: Option<ComponentDefinitionRuntimeAffinityPodAntiAffinity>,
}

/// Describes node affinity scheduling rules for the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityNodeAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node matches the corresponding matchExpressions; the
    /// node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<ComponentDefinitionRuntimeAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to an update), the system
    /// may or may not try to eventually evict the pod from its node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<ComponentDefinitionRuntimeAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

/// An empty preferred scheduling term matches all objects with implicit weight 0
/// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// A node selector term, associated with the corresponding weight.
    pub preference: ComponentDefinitionRuntimeAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    pub weight: i32,
}

/// A node selector term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /// A list of node selector requirements by node's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    /// A list of node selector requirements by node's fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<ComponentDefinitionRuntimeAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// If the affinity requirements specified by this field are not met at
/// scheduling time, the pod will not be scheduled onto the node.
/// If the affinity requirements specified by this field cease to be met
/// at some point during pod execution (e.g. due to an update), the system
/// may or may not try to eventually evict the pod from its node.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// Required. A list of node selector terms. The terms are ORed.
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<ComponentDefinitionRuntimeAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

/// A null or empty node selector term matches no objects. The requirements of
/// them are ANDed.
/// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /// A list of node selector requirements by node's labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    /// A list of node selector requirements by node's fields.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<ComponentDefinitionRuntimeAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /// The label key that the selector applies to.
    pub key: String,
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    pub operator: String,
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    /// node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to a pod label update), the
    /// system may or may not try to eventually evict the pod from its node.
    /// When there are multiple elements, the lists of nodes corresponding to each
    /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// Required. A pod affinity term, associated with the corresponding weight.
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    /// weight associated with matching the corresponding podAffinityTerm,
    /// in the range 1-100.
    pub weight: i32,
}

/// Required. A pod affinity term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /// A label query over a set of resources, in this case pods.
    /// If it's null, this PodAffinityTerm matches with no Pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
    /// Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
    /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MismatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
    /// Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
    /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
/// If it's null, this PodAffinityTerm matches with no Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Defines a set of pods (namely those matching the labelSelector
/// relative to the given namespace(s)) that this pod should be
/// co-located (affinity) or not co-located (anti-affinity) with,
/// where co-located is defined as running on a node whose value of
/// the label with key <topologyKey> matches that of any node on which
/// a pod of the set of pods is running
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// A label query over a set of resources, in this case pods.
    /// If it's null, this PodAffinityTerm matches with no Pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
    /// Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
    /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MismatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
    /// Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
    /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
/// If it's null, this PodAffinityTerm matches with no Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinity {
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the anti-affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling anti-affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    /// node(s) with the highest sum are the most preferred.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    /// If the anti-affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the anti-affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to a pod label update), the
    /// system may or may not try to eventually evict the pod from its node.
    /// When there are multiple elements, the lists of nodes corresponding to each
    /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /// Required. A pod affinity term, associated with the corresponding weight.
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    /// weight associated with matching the corresponding podAffinityTerm,
    /// in the range 1-100.
    pub weight: i32,
}

/// Required. A pod affinity term, associated with the corresponding weight.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /// A label query over a set of resources, in this case pods.
    /// If it's null, this PodAffinityTerm matches with no Pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
    /// Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
    /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MismatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
    /// Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
    /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
/// If it's null, this PodAffinityTerm matches with no Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Defines a set of pods (namely those matching the labelSelector
/// relative to the given namespace(s)) that this pod should be
/// co-located (affinity) or not co-located (anti-affinity) with,
/// where co-located is defined as running on a node whose value of
/// the label with key <topologyKey> matches that of any node on which
/// a pod of the set of pods is running
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /// A label query over a set of resources, in this case pods.
    /// If it's null, this PodAffinityTerm matches with no Pods.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
    /// Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
    /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MismatchLabelKeys is a set of pod label keys to select which pods will
    /// be taken into consideration. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
    /// to select the group of existing pods which pods will be taken into consideration
    /// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    /// pod labels will be ignored. The default value is empty.
    /// The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
    /// Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
    /// This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mismatchLabelKeys")]
    pub mismatch_label_keys: Option<Vec<String>>,
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

/// A label query over a set of resources, in this case pods.
/// If it's null, this PodAffinityTerm matches with no Pods.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A label query over the set of namespaces that the term applies to.
/// The term is applied to the union of the namespaces selected by this field
/// and the ones listed in the namespaces field.
/// null selector and null or empty namespaces list means "this pod's namespace".
/// An empty selector ({}) matches all namespaces.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainers {
    /// Arguments to the entrypoint.
    /// The container image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The container image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionRuntimeContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ComponentDefinitionRuntimeContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ComponentDefinitionRuntimeContainersLifecycle>,
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ComponentDefinitionRuntimeContainersLivenessProbe>,
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    pub name: String,
    /// List of ports to expose from the container. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Modifying this array with strategic merge patch may corrupt the data.
    /// For more information See <https://github.com/kubernetes/kubernetes/issues/108255.>
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ComponentDefinitionRuntimeContainersPorts>>,
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ComponentDefinitionRuntimeContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<ComponentDefinitionRuntimeContainersResizePolicy>>,
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ComponentDefinitionRuntimeContainersResources>,
    /// RestartPolicy defines the restart behavior of individual containers in a pod.
    /// This field may only be set for init containers, and the only allowed value is "Always".
    /// For non-init containers or when this field is not specified,
    /// the restart behavior is defined by the Pod's restart policy and the container type.
    /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
    /// this init container will be continually restarted on
    /// exit until all regular containers have terminated. Once all regular
    /// containers have completed, all init containers with restartPolicy "Always"
    /// will be shut down. This lifecycle differs from normal init containers and
    /// is often referred to as a "sidecar" container. Although this init
    /// container still starts in the init container sequence, it does not wait
    /// for the container to complete before proceeding to the next init
    /// container. Instead, the next init container starts immediately after this
    /// init container is started, or after any startupProbe has successfully
    /// completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ComponentDefinitionRuntimeContainersSecurityContext>,
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ComponentDefinitionRuntimeContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ComponentDefinitionRuntimeContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ComponentDefinitionRuntimeContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionRuntimeContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionRuntimeContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionRuntimeContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionRuntimeContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionRuntimeContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ComponentDefinitionRuntimeContainersEnvFromConfigMapRef>,
    /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ComponentDefinitionRuntimeContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersEnvFromSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Actions that the management system should take in response to container lifecycle events.
/// Cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ComponentDefinitionRuntimeContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ComponentDefinitionRuntimeContainersLifecyclePreStop>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePostStart {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeContainersLifecyclePostStartExec>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeContainersLifecyclePostStartHttpGet>,
    /// Sleep represents the duration that the container should sleep before being terminated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ComponentDefinitionRuntimeContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for the backward compatibility. There are no validation of this field and
    /// lifecycle hooks will fail in runtime when tcp handler is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents the duration that the container should sleep before being terminated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for the backward compatibility. There are no validation of this field and
/// lifecycle hooks will fail in runtime when tcp handler is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePreStop {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeContainersLifecyclePreStopExec>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeContainersLifecyclePreStopHttpGet>,
    /// Sleep represents the duration that the container should sleep before being terminated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ComponentDefinitionRuntimeContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for the backward compatibility. There are no validation of this field and
    /// lifecycle hooks will fail in runtime when tcp handler is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents the duration that the container should sleep before being terminated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for the backward compatibility. There are no validation of this field and
/// lifecycle hooks will fail in runtime when tcp handler is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Periodic probe of container liveness.
/// Container will be restarted if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLivenessProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionRuntimeContainersLivenessProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Periodic probe of container service readiness.
/// Container will be removed from service endpoints if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersReadinessProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionRuntimeContainersReadinessProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Compute Resources required by this container.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ComponentDefinitionRuntimeContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// SecurityContext defines the security options the container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
/// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ComponentDefinitionRuntimeContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default is DefaultProcMount which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ComponentDefinitionRuntimeContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ComponentDefinitionRuntimeContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ComponentDefinitionRuntimeContainersSecurityContextWindowsOptions>,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// StartupProbe indicates that the Pod has successfully initialized.
/// If specified, no other probes are executed until this completes successfully.
/// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
/// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
/// when it might take a long time to load data or warm a cache, than during steady-state operation.
/// This cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersStartupProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionRuntimeContainersStartupProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Specifies the DNS parameters of a pod.
/// Parameters specified here will be merged to the generated DNS
/// configuration based on DNSPolicy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeDnsConfig {
    /// A list of DNS name server IP addresses.
    /// This will be appended to the base nameservers generated from DNSPolicy.
    /// Duplicated nameservers will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nameservers: Option<Vec<String>>,
    /// A list of DNS resolver options.
    /// This will be merged with the base options generated from DNSPolicy.
    /// Duplicated entries will be removed. Resolution options given in Options
    /// will override those that appear in the base DNSPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<ComponentDefinitionRuntimeDnsConfigOptions>>,
    /// A list of DNS search domains for host-name lookup.
    /// This will be appended to the base search paths generated from DNSPolicy.
    /// Duplicated search paths will be removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub searches: Option<Vec<String>>,
}

/// PodDNSConfigOption defines DNS resolver options of a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeDnsConfigOptions {
    /// Required.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// An EphemeralContainer is a temporary container that you may add to an existing Pod for
/// user-initiated activities such as debugging. Ephemeral containers have no resource or
/// scheduling guarantees, and they will not be restarted when they exit or when a Pod is
/// removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
/// Pod to exceed its resource allocation.
/// 
/// 
/// To add an ephemeral container, use the ephemeralcontainers subresource of an existing
/// Pod. Ephemeral containers may not be removed or restarted.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainers {
    /// Arguments to the entrypoint.
    /// The image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Lifecycle is not allowed for ephemeral containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ComponentDefinitionRuntimeEphemeralContainersLifecycle>,
    /// Probes are not allowed for ephemeral containers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ComponentDefinitionRuntimeEphemeralContainersLivenessProbe>,
    /// Name of the ephemeral container specified as a DNS_LABEL.
    /// This name must be unique among all containers, init containers and ephemeral containers.
    pub name: String,
    /// Ports are not allowed for ephemeral containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersPorts>>,
    /// Probes are not allowed for ephemeral containers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ComponentDefinitionRuntimeEphemeralContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersResizePolicy>>,
    /// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
    /// already allocated to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ComponentDefinitionRuntimeEphemeralContainersResources>,
    /// Restart policy for the container to manage the restart behavior of each
    /// container within a pod.
    /// This may only be set for init containers. You cannot set this field on
    /// ephemeral containers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// Optional: SecurityContext defines the security options the ephemeral container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ComponentDefinitionRuntimeEphemeralContainersSecurityContext>,
    /// Probes are not allowed for ephemeral containers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ComponentDefinitionRuntimeEphemeralContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// If set, the name of the container from PodSpec that this ephemeral container targets.
    /// The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
    /// If not set then the ephemeral container uses the namespaces configured in the Pod spec.
    /// 
    /// 
    /// The container runtime must implement support for this feature. If the runtime does not
    /// support namespace targeting then the result of setting this field is undefined.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetContainerName")]
    pub target_container_name: Option<String>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionRuntimeEphemeralContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionRuntimeEphemeralContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionRuntimeEphemeralContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionRuntimeEphemeralContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionRuntimeEphemeralContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ComponentDefinitionRuntimeEphemeralContainersEnvFromConfigMapRef>,
    /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ComponentDefinitionRuntimeEphemeralContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersEnvFromSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Lifecycle is not allowed for ephemeral containers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStop>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStart {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartExec>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartHttpGet>,
    /// Sleep represents the duration that the container should sleep before being terminated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for the backward compatibility. There are no validation of this field and
    /// lifecycle hooks will fail in runtime when tcp handler is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents the duration that the container should sleep before being terminated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for the backward compatibility. There are no validation of this field and
/// lifecycle hooks will fail in runtime when tcp handler is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStop {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopExec>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopHttpGet>,
    /// Sleep represents the duration that the container should sleep before being terminated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for the backward compatibility. There are no validation of this field and
    /// lifecycle hooks will fail in runtime when tcp handler is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents the duration that the container should sleep before being terminated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for the backward compatibility. There are no validation of this field and
/// lifecycle hooks will fail in runtime when tcp handler is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Probes are not allowed for ephemeral containers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLivenessProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeEphemeralContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionRuntimeEphemeralContainersLivenessProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeEphemeralContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeEphemeralContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Probes are not allowed for ephemeral containers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersReadinessProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeEphemeralContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionRuntimeEphemeralContainersReadinessProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeEphemeralContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeEphemeralContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
/// already allocated to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// Optional: SecurityContext defines the security options the ephemeral container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ComponentDefinitionRuntimeEphemeralContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default is DefaultProcMount which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ComponentDefinitionRuntimeEphemeralContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ComponentDefinitionRuntimeEphemeralContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ComponentDefinitionRuntimeEphemeralContainersSecurityContextWindowsOptions>,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// Probes are not allowed for ephemeral containers.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersStartupProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeEphemeralContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionRuntimeEphemeralContainersStartupProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeEphemeralContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeEphemeralContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeEphemeralContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeEphemeralContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeHostAliases {
    /// Hostnames for the above IP address.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hostnames: Option<Vec<String>>,
    /// IP address of the host file entry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeImagePullSecrets {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainers {
    /// Arguments to the entrypoint.
    /// The container image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// Entrypoint array. Not executed within a shell.
    /// The container image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: <https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ComponentDefinitionRuntimeInitContainersEnv>>,
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<ComponentDefinitionRuntimeInitContainersEnvFrom>>,
    /// Container image name.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images>
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/containers/images#updating-images>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<String>,
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<ComponentDefinitionRuntimeInitContainersLifecycle>,
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "livenessProbe")]
    pub liveness_probe: Option<ComponentDefinitionRuntimeInitContainersLivenessProbe>,
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    pub name: String,
    /// List of ports to expose from the container. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Modifying this array with strategic merge patch may corrupt the data.
    /// For more information See <https://github.com/kubernetes/kubernetes/issues/108255.>
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ComponentDefinitionRuntimeInitContainersPorts>>,
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessProbe")]
    pub readiness_probe: Option<ComponentDefinitionRuntimeInitContainersReadinessProbe>,
    /// Resources resize policy for the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resizePolicy")]
    pub resize_policy: Option<Vec<ComponentDefinitionRuntimeInitContainersResizePolicy>>,
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ComponentDefinitionRuntimeInitContainersResources>,
    /// RestartPolicy defines the restart behavior of individual containers in a pod.
    /// This field may only be set for init containers, and the only allowed value is "Always".
    /// For non-init containers or when this field is not specified,
    /// the restart behavior is defined by the Pod's restart policy and the container type.
    /// Setting the RestartPolicy as "Always" for the init container will have the following effect:
    /// this init container will be continually restarted on
    /// exit until all regular containers have terminated. Once all regular
    /// containers have completed, all init containers with restartPolicy "Always"
    /// will be shut down. This lifecycle differs from normal init containers and
    /// is often referred to as a "sidecar" container. Although this init
    /// container still starts in the init container sequence, it does not wait
    /// for the container to complete before proceeding to the next init
    /// container. Instead, the next init container starts immediately after this
    /// init container is started, or after any startupProbe has successfully
    /// completed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartPolicy")]
    pub restart_policy: Option<String>,
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityContext")]
    pub security_context: Option<ComponentDefinitionRuntimeInitContainersSecurityContext>,
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startupProbe")]
    pub startup_probe: Option<ComponentDefinitionRuntimeInitContainersStartupProbe>,
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePath")]
    pub termination_message_path: Option<String>,
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationMessagePolicy")]
    pub termination_message_policy: Option<String>,
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    /// volumeDevices is the list of block devices to be used by the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeDevices")]
    pub volume_devices: Option<Vec<ComponentDefinitionRuntimeInitContainersVolumeDevices>>,
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMounts")]
    pub volume_mounts: Option<Vec<ComponentDefinitionRuntimeInitContainersVolumeMounts>>,
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workingDir")]
    pub working_dir: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionRuntimeInitContainersEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionRuntimeInitContainersEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionRuntimeInitContainersEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionRuntimeInitContainersEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionRuntimeInitContainersEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// EnvFromSource represents the source of a set of ConfigMaps
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersEnvFrom {
    /// The ConfigMap to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapRef")]
    pub config_map_ref: Option<ComponentDefinitionRuntimeInitContainersEnvFromConfigMapRef>,
    /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    /// The Secret to select from
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ComponentDefinitionRuntimeInitContainersEnvFromSecretRef>,
}

/// The ConfigMap to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersEnvFromConfigMapRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The Secret to select from
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersEnvFromSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Actions that the management system should take in response to container lifecycle events.
/// Cannot be updated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecycle {
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<ComponentDefinitionRuntimeInitContainersLifecyclePostStart>,
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The Pod's termination grace period countdown begins before the
    /// PreStop hook is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<ComponentDefinitionRuntimeInitContainersLifecyclePreStop>,
}

/// PostStart is called immediately after a container is created. If the handler fails,
/// the container is terminated and restarted according to its restart policy.
/// Other management of the container blocks until the hook completes.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePostStart {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeInitContainersLifecyclePostStartExec>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeInitContainersLifecyclePostStartHttpGet>,
    /// Sleep represents the duration that the container should sleep before being terminated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ComponentDefinitionRuntimeInitContainersLifecyclePostStartSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for the backward compatibility. There are no validation of this field and
    /// lifecycle hooks will fail in runtime when tcp handler is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeInitContainersLifecyclePostStartTcpSocket>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePostStartExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePostStartHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeInitContainersLifecyclePostStartHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePostStartHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents the duration that the container should sleep before being terminated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePostStartSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for the backward compatibility. There are no validation of this field and
/// lifecycle hooks will fail in runtime when tcp handler is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePostStartTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// PreStop is called immediately before a container is terminated due to an
/// API request or management event such as liveness/startup probe failure,
/// preemption, resource contention, etc. The handler is not called if the
/// container crashes or exits. The Pod's termination grace period countdown begins before the
/// PreStop hook is executed. Regardless of the outcome of the handler, the
/// container will eventually terminate within the Pod's termination grace
/// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
/// or until the termination grace period is reached.
/// More info: <https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePreStop {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeInitContainersLifecyclePreStopExec>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeInitContainersLifecyclePreStopHttpGet>,
    /// Sleep represents the duration that the container should sleep before being terminated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sleep: Option<ComponentDefinitionRuntimeInitContainersLifecyclePreStopSleep>,
    /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    /// for the backward compatibility. There are no validation of this field and
    /// lifecycle hooks will fail in runtime when tcp handler is specified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeInitContainersLifecyclePreStopTcpSocket>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePreStopExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePreStopHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeInitContainersLifecyclePreStopHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePreStopHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// Sleep represents the duration that the container should sleep before being terminated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePreStopSleep {
    /// Seconds is the number of seconds to sleep.
    pub seconds: i64,
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
/// for the backward compatibility. There are no validation of this field and
/// lifecycle hooks will fail in runtime when tcp handler is specified.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLifecyclePreStopTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// Periodic probe of container liveness.
/// Container will be restarted if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLivenessProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeInitContainersLivenessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionRuntimeInitContainersLivenessProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeInitContainersLivenessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeInitContainersLivenessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLivenessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLivenessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLivenessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeInitContainersLivenessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLivenessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersLivenessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerPort represents a network port in a single container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersPorts {
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 < x < 65536.
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    /// What host IP to bind the external port to.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 < x < 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

/// Periodic probe of container service readiness.
/// Container will be removed from service endpoints if the probe fails.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersReadinessProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeInitContainersReadinessProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionRuntimeInitContainersReadinessProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeInitContainersReadinessProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeInitContainersReadinessProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersReadinessProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersReadinessProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersReadinessProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeInitContainersReadinessProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersReadinessProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersReadinessProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// ContainerResizePolicy represents resource resize policy for the container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersResizePolicy {
    /// Name of the resource to which this resource resize policy applies.
    /// Supported values: cpu, memory.
    #[serde(rename = "resourceName")]
    pub resource_name: String,
    /// Restart policy to apply when specified resource is resized.
    /// If not specified, it defaults to NotRequired.
    #[serde(rename = "restartPolicy")]
    pub restart_policy: String,
}

/// Compute Resources required by this container.
/// Cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims,
    /// that are used by this container.
    /// 
    /// 
    /// This is an alpha field and requires enabling the
    /// DynamicResourceAllocation feature gate.
    /// 
    /// 
    /// This field is immutable. It can only be set for containers.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<ComponentDefinitionRuntimeInitContainersResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of
    /// the Pod where this field is used. It makes that resource available
    /// inside a container.
    pub name: String,
}

/// SecurityContext defines the security options the container should be run with.
/// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
/// More info: <https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersSecurityContext {
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowPrivilegeEscalation")]
    pub allow_privilege_escalation: Option<bool>,
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<ComponentDefinitionRuntimeInitContainersSecurityContextCapabilities>,
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default is DefaultProcMount which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnlyRootFilesystem")]
    pub read_only_root_filesystem: Option<bool>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ComponentDefinitionRuntimeInitContainersSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod & container level, the container options
    /// override the pod options.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ComponentDefinitionRuntimeInitContainersSecurityContextSeccompProfile>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ComponentDefinitionRuntimeInitContainersSecurityContextWindowsOptions>,
}

/// The capabilities to add/drop when running containers.
/// Defaults to the default set of capabilities granted by the container runtime.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersSecurityContextCapabilities {
    /// Added capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    /// Removed capabilities
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

/// The SELinux context to be applied to the container.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
/// PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by this container. If seccomp options are
/// provided at both the pod & container level, the container options
/// override the pod options.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options from the PodSecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// StartupProbe indicates that the Pod has successfully initialized.
/// If specified, no other probes are executed until this completes successfully.
/// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
/// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
/// when it might take a long time to load data or warm a cache, than during steady-state operation.
/// This cannot be updated.
/// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersStartupProbe {
    /// Exec specifies the action to take.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<ComponentDefinitionRuntimeInitContainersStartupProbeExec>,
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureThreshold")]
    pub failure_threshold: Option<i32>,
    /// GRPC specifies an action involving a GRPC port.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<ComponentDefinitionRuntimeInitContainersStartupProbeGrpc>,
    /// HTTPGet specifies the http request to perform.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<ComponentDefinitionRuntimeInitContainersStartupProbeHttpGet>,
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initialDelaySeconds")]
    pub initial_delay_seconds: Option<i32>,
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "periodSeconds")]
    pub period_seconds: Option<i32>,
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "successThreshold")]
    pub success_threshold: Option<i32>,
    /// TCPSocket specifies an action involving a TCP port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<ComponentDefinitionRuntimeInitContainersStartupProbeTcpSocket>,
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminationGracePeriodSeconds")]
    pub termination_grace_period_seconds: Option<i64>,
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: <https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

/// Exec specifies the action to take.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersStartupProbeExec {
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

/// GRPC specifies an action involving a GRPC port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersStartupProbeGrpc {
    /// Port number of the gRPC service. Number must be in the range 1 to 65535.
    pub port: i32,
    /// Service is the name of the service to place in the gRPC HealthCheckRequest
    /// (see <https://github.com/grpc/grpc/blob/master/doc/health-checking.md).>
    /// 
    /// 
    /// If this is not specified, the default behavior is defined by gRPC.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

/// HTTPGet specifies the http request to perform.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersStartupProbeHttpGet {
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Custom headers to set in the request. HTTP allows repeated headers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpHeaders")]
    pub http_headers: Option<Vec<ComponentDefinitionRuntimeInitContainersStartupProbeHttpGetHttpHeaders>>,
    /// Path to access on the HTTP server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersStartupProbeHttpGetHttpHeaders {
    /// The header field name.
    /// This will be canonicalized upon output, so case-variant names will be understood as the same header.
    pub name: String,
    /// The header field value
    pub value: String,
}

/// TCPSocket specifies an action involving a TCP port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersStartupProbeTcpSocket {
    /// Optional: Host name to connect to, defaults to the pod IP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    pub port: IntOrString,
}

/// volumeDevice describes a mapping of a raw block device within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersVolumeDevices {
    /// devicePath is the path inside of the container that the device will be mapped to.
    #[serde(rename = "devicePath")]
    pub device_path: String,
    /// name must match the name of a persistentVolumeClaim in the pod
    pub name: String,
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeInitContainersVolumeMounts {
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "mountPropagation")]
    pub mount_propagation: Option<String>,
    /// This must match the Name of a Volume.
    pub name: String,
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPathExpr")]
    pub sub_path_expr: Option<String>,
}

/// Specifies the OS of the containers in the pod.
/// Some pod and container fields are restricted if this is set.
/// 
/// 
/// If the OS field is set to linux, the following fields must be unset:
/// -securityContext.windowsOptions
/// 
/// 
/// If the OS field is set to windows, following fields must be unset:
/// - spec.hostPID
/// - spec.hostIPC
/// - spec.hostUsers
/// - spec.securityContext.seLinuxOptions
/// - spec.securityContext.seccompProfile
/// - spec.securityContext.fsGroup
/// - spec.securityContext.fsGroupChangePolicy
/// - spec.securityContext.sysctls
/// - spec.shareProcessNamespace
/// - spec.securityContext.runAsUser
/// - spec.securityContext.runAsGroup
/// - spec.securityContext.supplementalGroups
/// - spec.containers[*].securityContext.seLinuxOptions
/// - spec.containers[*].securityContext.seccompProfile
/// - spec.containers[*].securityContext.capabilities
/// - spec.containers[*].securityContext.readOnlyRootFilesystem
/// - spec.containers[*].securityContext.privileged
/// - spec.containers[*].securityContext.allowPrivilegeEscalation
/// - spec.containers[*].securityContext.procMount
/// - spec.containers[*].securityContext.runAsUser
/// - spec.containers[*].securityContext.runAsGroup
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeOs {
    /// Name is the name of the operating system. The currently supported values are linux and windows.
    /// Additional value may be defined in future and can be one of:
    /// <https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration>
    /// Clients should expect to handle additional values and treat unrecognized values in this field as os: null
    pub name: String,
}

/// PodReadinessGate contains the reference to a pod condition
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeReadinessGates {
    /// ConditionType refers to a condition in the pod's condition list with matching type.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
}

/// PodResourceClaim references exactly one ResourceClaim through a ClaimSource.
/// It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
/// Containers that need access to the ResourceClaim reference it with this name.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeResourceClaims {
    /// Name uniquely identifies this resource claim inside the pod.
    /// This must be a DNS_LABEL.
    pub name: String,
    /// Source describes where to find the ResourceClaim.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<ComponentDefinitionRuntimeResourceClaimsSource>,
}

/// Source describes where to find the ResourceClaim.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeResourceClaimsSource {
    /// ResourceClaimName is the name of a ResourceClaim object in the same
    /// namespace as this pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceClaimName")]
    pub resource_claim_name: Option<String>,
    /// ResourceClaimTemplateName is the name of a ResourceClaimTemplate
    /// object in the same namespace as this pod.
    /// 
    /// 
    /// The template will be used to create a new ResourceClaim, which will
    /// be bound to this pod. When this pod is deleted, the ResourceClaim
    /// will also be deleted. The pod name and resource name, along with a
    /// generated component, will be used to form a unique name for the
    /// ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
    /// 
    /// 
    /// This field is immutable and no changes will be made to the
    /// corresponding ResourceClaim by the control plane after creating the
    /// ResourceClaim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceClaimTemplateName")]
    pub resource_claim_template_name: Option<String>,
}

/// PodSchedulingGate is associated to a Pod to guard its scheduling.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeSchedulingGates {
    /// Name of the scheduling gate.
    /// Each scheduling gate must have a unique name field.
    pub name: String,
}

/// SecurityContext holds pod-level security attributes and common container settings.
/// Optional: Defaults to empty.  See type description for default values of each field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeSecurityContext {
    /// A special supplemental group that applies to all containers in a pod.
    /// Some volume types allow the Kubelet to change the ownership of that volume
    /// to be owned by the pod:
    /// 
    /// 
    /// 1. The owning GID will be the FSGroup
    /// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
    /// 3. The permission bits are OR'd with rw-rw----
    /// 
    /// 
    /// If unset, the Kubelet will not modify the ownership and permissions of any volume.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsGroup")]
    pub fs_group: Option<i64>,
    /// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
    /// before being exposed inside Pod. This field will only apply to
    /// volume types which support fsGroup based ownership(and permissions).
    /// It will have no effect on ephemeral volume types such as: secret, configmaps
    /// and emptydir.
    /// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsGroupChangePolicy")]
    pub fs_group_change_policy: Option<String>,
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in SecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence
    /// for that container.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsGroup")]
    pub run_as_group: Option<i64>,
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in SecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsNonRoot")]
    pub run_as_non_root: Option<bool>,
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in SecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence
    /// for that container.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    /// The SELinux context to be applied to all containers.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in SecurityContext.  If set in
    /// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
    /// takes precedence for that container.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seLinuxOptions")]
    pub se_linux_options: Option<ComponentDefinitionRuntimeSecurityContextSeLinuxOptions>,
    /// The seccomp options to use by the containers in this pod.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "seccompProfile")]
    pub seccomp_profile: Option<ComponentDefinitionRuntimeSecurityContextSeccompProfile>,
    /// A list of groups applied to the first process run in each container, in addition
    /// to the container's primary GID, the fsGroup (if specified), and group memberships
    /// defined in the container image for the uid of the container process. If unspecified,
    /// no additional groups are added to any container. Note that group memberships
    /// defined in the container image for the uid of the container process are still effective,
    /// even if they are not included in this list.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "supplementalGroups")]
    pub supplemental_groups: Option<Vec<i64>>,
    /// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
    /// sysctls (by the container runtime) might fail to launch.
    /// Note that this field cannot be set when spec.os.name is windows.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sysctls: Option<Vec<ComponentDefinitionRuntimeSecurityContextSysctls>>,
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options within a container's SecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// Note that this field cannot be set when spec.os.name is linux.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "windowsOptions")]
    pub windows_options: Option<ComponentDefinitionRuntimeSecurityContextWindowsOptions>,
}

/// The SELinux context to be applied to all containers.
/// If unspecified, the container runtime will allocate a random SELinux context for each
/// container.  May also be set in SecurityContext.  If set in
/// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
/// takes precedence for that container.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeSecurityContextSeLinuxOptions {
    /// Level is SELinux level label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    /// Role is a SELinux role label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// Type is a SELinux type label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    /// User is a SELinux user label that applies to the container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// The seccomp options to use by the containers in this pod.
/// Note that this field cannot be set when spec.os.name is windows.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeSecurityContextSeccompProfile {
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must be set if type is "Localhost". Must NOT be set for any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localhostProfile")]
    pub localhost_profile: Option<String>,
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    /// 
    /// 
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Sysctl defines a kernel parameter to be set
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeSecurityContextSysctls {
    /// Name of a property to set
    pub name: String,
    /// Value of a property to set
    pub value: String,
}

/// The Windows specific settings applied to all containers.
/// If unspecified, the options within a container's SecurityContext will be used.
/// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
/// Note that this field cannot be set when spec.os.name is linux.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeSecurityContextWindowsOptions {
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (<https://github.com/kubernetes-sigs/windows-gmsa)> inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpec")]
    pub gmsa_credential_spec: Option<String>,
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gmsaCredentialSpecName")]
    pub gmsa_credential_spec_name: Option<String>,
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// All of a Pod's containers must have the same effective HostProcess value
    /// (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    /// In addition, if HostProcess is true then HostNetwork must also be set to true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostProcess")]
    pub host_process: Option<bool>,
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUserName")]
    pub run_as_user_name: Option<String>,
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeTolerations {
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeTopologySpreadConstraints {
    /// LabelSelector is used to find matching pods.
    /// Pods that match this label selector are counted to determine the number of pods
    /// in their corresponding topology domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ComponentDefinitionRuntimeTopologySpreadConstraintsLabelSelector>,
    /// MatchLabelKeys is a set of pod label keys to select the pods over which
    /// spreading will be calculated. The keys are used to lookup values from the
    /// incoming pod labels, those key-value labels are ANDed with labelSelector
    /// to select the group of existing pods over which spreading will be calculated
    /// for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
    /// MatchLabelKeys cannot be set when LabelSelector isn't set.
    /// Keys that don't exist in the incoming pod labels will
    /// be ignored. A null or empty list means only match against labelSelector.
    /// 
    /// 
    /// This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabelKeys")]
    pub match_label_keys: Option<Vec<String>>,
    /// MaxSkew describes the degree to which pods may be unevenly distributed.
    /// When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
    /// between the number of matching pods in the target topology and the global minimum.
    /// The global minimum is the minimum number of matching pods in an eligible domain
    /// or zero if the number of eligible domains is less than MinDomains.
    /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    /// labelSelector spread as 2/2/1:
    /// In this case, the global minimum is 1.
    /// | zone1 | zone2 | zone3 |
    /// |  P P  |  P P  |   P   |
    /// - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
    /// scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
    /// violate MaxSkew(1).
    /// - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
    /// When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
    /// to topologies that satisfy it.
    /// It's a required field. Default value is 1 and 0 is not allowed.
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    /// MinDomains indicates a minimum number of eligible domains.
    /// When the number of eligible domains with matching topology keys is less than minDomains,
    /// Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
    /// And when the number of eligible domains with matching topology keys equals or greater than minDomains,
    /// this value has no effect on scheduling.
    /// As a result, when the number of eligible domains is less than minDomains,
    /// scheduler won't schedule more than maxSkew Pods to those domains.
    /// If value is nil, the constraint behaves as if MinDomains is equal to 1.
    /// Valid values are integers greater than 0.
    /// When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
    /// 
    /// 
    /// For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
    /// labelSelector spread as 2/2/2:
    /// | zone1 | zone2 | zone3 |
    /// |  P P  |  P P  |  P P  |
    /// The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
    /// In this situation, new pod with the same labelSelector cannot be scheduled,
    /// because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
    /// it will violate MaxSkew.
    /// 
    /// 
    /// This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minDomains")]
    pub min_domains: Option<i32>,
    /// NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
    /// when calculating pod topology spread skew. Options are:
    /// - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
    /// - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
    /// 
    /// 
    /// If this value is nil, the behavior is equivalent to the Honor policy.
    /// This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinityPolicy")]
    pub node_affinity_policy: Option<String>,
    /// NodeTaintsPolicy indicates how we will treat node taints when calculating
    /// pod topology spread skew. Options are:
    /// - Honor: nodes without taints, along with tainted nodes for which the incoming pod
    /// has a toleration, are included.
    /// - Ignore: node taints are ignored. All nodes are included.
    /// 
    /// 
    /// If this value is nil, the behavior is equivalent to the Ignore policy.
    /// This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeTaintsPolicy")]
    pub node_taints_policy: Option<String>,
    /// TopologyKey is the key of node labels. Nodes that have a label with this key
    /// and identical values are considered to be in the same topology.
    /// We consider each <key, value> as a "bucket", and try to put balanced number
    /// of pods into each bucket.
    /// We define a domain as a particular instance of a topology.
    /// Also, we define an eligible domain as a domain whose nodes meet the requirements of
    /// nodeAffinityPolicy and nodeTaintsPolicy.
    /// e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
    /// And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
    /// It's a required field.
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    /// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
    /// the spread constraint.
    /// - DoNotSchedule (default) tells the scheduler not to schedule it.
    /// - ScheduleAnyway tells the scheduler to schedule the pod in any location,
    ///   but giving higher precedence to topologies that would help reduce the
    ///   skew.
    /// A constraint is considered "Unsatisfiable" for an incoming pod
    /// if and only if every possible node assignment for that pod would violate
    /// "MaxSkew" on some topology.
    /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    /// labelSelector spread as 3/1/1:
    /// | zone1 | zone2 | zone3 |
    /// | P P P |   P   |   P   |
    /// If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
    /// to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
    /// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
    /// won't make it *more* imbalanced.
    /// It's a required field.
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

/// LabelSelector is used to find matching pods.
/// Pods that match this label selector are counted to determine the number of pods
/// in their corresponding topology domain.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeTopologySpreadConstraintsLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeTopologySpreadConstraintsLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumes {
    /// awsElasticBlockStore represents an AWS Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "awsElasticBlockStore")]
    pub aws_elastic_block_store: Option<ComponentDefinitionRuntimeVolumesAwsElasticBlockStore>,
    /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureDisk")]
    pub azure_disk: Option<ComponentDefinitionRuntimeVolumesAzureDisk>,
    /// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "azureFile")]
    pub azure_file: Option<ComponentDefinitionRuntimeVolumesAzureFile>,
    /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cephfs: Option<ComponentDefinitionRuntimeVolumesCephfs>,
    /// cinder represents a cinder volume attached and mounted on kubelets host machine.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cinder: Option<ComponentDefinitionRuntimeVolumesCinder>,
    /// configMap represents a configMap that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ComponentDefinitionRuntimeVolumesConfigMap>,
    /// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub csi: Option<ComponentDefinitionRuntimeVolumesCsi>,
    /// downwardAPI represents downward API about the pod that should populate this volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ComponentDefinitionRuntimeVolumesDownwardApi>,
    /// emptyDir represents a temporary directory that shares a pod's lifetime.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "emptyDir")]
    pub empty_dir: Option<ComponentDefinitionRuntimeVolumesEmptyDir>,
    /// ephemeral represents a volume that is handled by a cluster storage driver.
    /// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    /// and deleted when the pod is removed.
    /// 
    /// 
    /// Use this if:
    /// a) the volume is only needed while the pod runs,
    /// b) features of normal volumes like restoring from snapshot or capacity
    ///    tracking are needed,
    /// c) the storage driver is specified through a storage class, and
    /// d) the storage driver supports dynamic volume provisioning through
    ///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
    ///    information on the connection between this volume type
    ///    and PersistentVolumeClaim).
    /// 
    /// 
    /// Use PersistentVolumeClaim or one of the vendor-specific
    /// APIs for volumes that persist for longer than the lifecycle
    /// of an individual pod.
    /// 
    /// 
    /// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    /// be used that way - see the documentation of the driver for
    /// more information.
    /// 
    /// 
    /// A pod can use both types of ephemeral volumes and
    /// persistent volumes at the same time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<ComponentDefinitionRuntimeVolumesEphemeral>,
    /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fc: Option<ComponentDefinitionRuntimeVolumesFc>,
    /// flexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flexVolume")]
    pub flex_volume: Option<ComponentDefinitionRuntimeVolumesFlexVolume>,
    /// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub flocker: Option<ComponentDefinitionRuntimeVolumesFlocker>,
    /// gcePersistentDisk represents a GCE Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gcePersistentDisk")]
    pub gce_persistent_disk: Option<ComponentDefinitionRuntimeVolumesGcePersistentDisk>,
    /// gitRepo represents a git repository at a particular revision.
    /// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    /// into the Pod's container.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gitRepo")]
    pub git_repo: Option<ComponentDefinitionRuntimeVolumesGitRepo>,
    /// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub glusterfs: Option<ComponentDefinitionRuntimeVolumesGlusterfs>,
    /// hostPath represents a pre-existing file or directory on the host
    /// machine that is directly exposed to the container. This is generally
    /// used for system agents or other privileged things that are allowed
    /// to see the host machine. Most containers will NOT need this.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    /// ---
    /// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
    /// mount host directories as read/write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPath")]
    pub host_path: Option<ComponentDefinitionRuntimeVolumesHostPath>,
    /// iscsi represents an ISCSI Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iscsi: Option<ComponentDefinitionRuntimeVolumesIscsi>,
    /// name of the volume.
    /// Must be a DNS_LABEL and unique within the pod.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    pub name: String,
    /// nfs represents an NFS mount on the host that shares a pod's lifetime
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nfs: Option<ComponentDefinitionRuntimeVolumesNfs>,
    /// persistentVolumeClaimVolumeSource represents a reference to a
    /// PersistentVolumeClaim in the same namespace.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaim")]
    pub persistent_volume_claim: Option<ComponentDefinitionRuntimeVolumesPersistentVolumeClaim>,
    /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "photonPersistentDisk")]
    pub photon_persistent_disk: Option<ComponentDefinitionRuntimeVolumesPhotonPersistentDisk>,
    /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portworxVolume")]
    pub portworx_volume: Option<ComponentDefinitionRuntimeVolumesPortworxVolume>,
    /// projected items for all in one resources secrets, configmaps, and downward API
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projected: Option<ComponentDefinitionRuntimeVolumesProjected>,
    /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quobyte: Option<ComponentDefinitionRuntimeVolumesQuobyte>,
    /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rbd: Option<ComponentDefinitionRuntimeVolumesRbd>,
    /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scaleIO")]
    pub scale_io: Option<ComponentDefinitionRuntimeVolumesScaleIo>,
    /// secret represents a secret that should populate this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ComponentDefinitionRuntimeVolumesSecret>,
    /// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storageos: Option<ComponentDefinitionRuntimeVolumesStorageos>,
    /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vsphereVolume")]
    pub vsphere_volume: Option<ComponentDefinitionRuntimeVolumesVsphereVolume>,
}

/// awsElasticBlockStore represents an AWS Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesAwsElasticBlockStore {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// readOnly value true will force the readOnly setting in VolumeMounts.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesAzureDisk {
    /// cachingMode is the Host Caching mode: None, Read Only, Read Write.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cachingMode")]
    pub caching_mode: Option<String>,
    /// diskName is the Name of the data disk in the blob storage
    #[serde(rename = "diskName")]
    pub disk_name: String,
    /// diskURI is the URI of data disk in the blob storage
    #[serde(rename = "diskURI")]
    pub disk_uri: String,
    /// fsType is Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// azureFile represents an Azure File Service mount on the host and bind mount to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesAzureFile {
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretName is the  name of secret that contains Azure Storage Account Name and Key
    #[serde(rename = "secretName")]
    pub secret_name: String,
    /// shareName is the azure share Name
    #[serde(rename = "shareName")]
    pub share_name: String,
}

/// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesCephfs {
    /// monitors is Required: Monitors is a collection of Ceph monitors
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretFile")]
    pub secret_file: Option<String>,
    /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ComponentDefinitionRuntimeVolumesCephfsSecretRef>,
    /// user is optional: User is the rados user name, default is admin
    /// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
/// More info: <https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesCephfsSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// cinder represents a cinder volume attached and mounted on kubelets host machine.
/// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesCinder {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is optional: points to a secret object containing parameters used to connect
    /// to OpenStack.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ComponentDefinitionRuntimeVolumesCinderSecretRef>,
    /// volumeID used to identify the volume in cinder.
    /// More info: <https://examples.k8s.io/mysql-cinder-pd/README.md>
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// secretRef is optional: points to a secret object containing parameters used to connect
/// to OpenStack.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesCinderSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// configMap represents a configMap that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesConfigMap {
    /// defaultMode is optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ComponentDefinitionRuntimeVolumesConfigMapItems>>,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesCsi {
    /// driver is the name of the CSI driver that handles this volume.
    /// Consult with your admin for the correct name as registered in the cluster.
    pub driver: String,
    /// fsType to mount. Ex. "ext4", "xfs", "ntfs".
    /// If not provided, the empty value is passed to the associated CSI driver
    /// which will determine the default filesystem to apply.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// nodePublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// NodePublishVolume and NodeUnpublishVolume calls.
    /// This field is optional, and  may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secret references are passed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePublishSecretRef")]
    pub node_publish_secret_ref: Option<ComponentDefinitionRuntimeVolumesCsiNodePublishSecretRef>,
    /// readOnly specifies a read-only configuration for the volume.
    /// Defaults to false (read/write).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeAttributes stores driver-specific properties that are passed to the CSI
    /// driver. Consult your driver's documentation for supported values.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributes")]
    pub volume_attributes: Option<BTreeMap<String, String>>,
}

/// nodePublishSecretRef is a reference to the secret object containing
/// sensitive information to pass to the CSI driver to complete the CSI
/// NodePublishVolume and NodeUnpublishVolume calls.
/// This field is optional, and  may be empty if no secret is required. If the
/// secret object contains more than one secret, all secret references are passed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesCsiNodePublishSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// downwardAPI represents downward API about the pod that should populate this volume
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesDownwardApi {
    /// Optional: mode bits to use on created files by default. Must be a
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// Items is a list of downward API volume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ComponentDefinitionRuntimeVolumesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionRuntimeVolumesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionRuntimeVolumesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// emptyDir represents a temporary directory that shares a pod's lifetime.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEmptyDir {
    /// medium represents what type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub medium: Option<String>,
    /// sizeLimit is the total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#emptydir>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizeLimit")]
    pub size_limit: Option<IntOrString>,
}

/// ephemeral represents a volume that is handled by a cluster storage driver.
/// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
/// and deleted when the pod is removed.
/// 
/// 
/// Use this if:
/// a) the volume is only needed while the pod runs,
/// b) features of normal volumes like restoring from snapshot or capacity
///    tracking are needed,
/// c) the storage driver is specified through a storage class, and
/// d) the storage driver supports dynamic volume provisioning through
///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
///    information on the connection between this volume type
///    and PersistentVolumeClaim).
/// 
/// 
/// Use PersistentVolumeClaim or one of the vendor-specific
/// APIs for volumes that persist for longer than the lifecycle
/// of an individual pod.
/// 
/// 
/// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
/// be used that way - see the documentation of the driver for
/// more information.
/// 
/// 
/// A pod can use both types of ephemeral volumes and
/// persistent volumes at the same time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEphemeral {
    /// Will be used to create a stand-alone PVC to provision the volume.
    /// The pod in which this EphemeralVolumeSource is embedded will be the
    /// owner of the PVC, i.e. the PVC will be deleted together with the
    /// pod.  The name of the PVC will be `<pod name>-<volume name>` where
    /// `<volume name>` is the name from the `PodSpec.Volumes` array
    /// entry. Pod validation will reject the pod if the concatenated name
    /// is not valid for a PVC (for example, too long).
    /// 
    /// 
    /// An existing PVC with that name that is not owned by the pod
    /// will *not* be used for the pod to avoid using an unrelated
    /// volume by mistake. Starting the pod is then blocked until
    /// the unrelated PVC is removed. If such a pre-created PVC is
    /// meant to be used by the pod, the PVC has to updated with an
    /// owner reference to the pod once the pod exists. Normally
    /// this should not be necessary, but it may be useful when
    /// manually reconstructing a broken cluster.
    /// 
    /// 
    /// This field is read-only and no changes will be made by Kubernetes
    /// to the PVC after it has been created.
    /// 
    /// 
    /// Required, must not be nil.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplate>,
}

/// Will be used to create a stand-alone PVC to provision the volume.
/// The pod in which this EphemeralVolumeSource is embedded will be the
/// owner of the PVC, i.e. the PVC will be deleted together with the
/// pod.  The name of the PVC will be `<pod name>-<volume name>` where
/// `<volume name>` is the name from the `PodSpec.Volumes` array
/// entry. Pod validation will reject the pod if the concatenated name
/// is not valid for a PVC (for example, too long).
/// 
/// 
/// An existing PVC with that name that is not owned by the pod
/// will *not* be used for the pod to avoid using an unrelated
/// volume by mistake. Starting the pod is then blocked until
/// the unrelated PVC is removed. If such a pre-created PVC is
/// meant to be used by the pod, the PVC has to updated with an
/// owner reference to the pod once the pod exists. Normally
/// this should not be necessary, but it may be useful when
/// manually reconstructing a broken cluster.
/// 
/// 
/// This field is read-only and no changes will be made by Kubernetes
/// to the PVC after it has been created.
/// 
/// 
/// Required, must not be nil.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplate {
    /// May contain labels and annotations that will be copied into the PVC
    /// when creating it. No other fields are allowed and will be rejected during
    /// validation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateMetadata>,
    /// The specification for the PersistentVolumeClaim. The entire content is
    /// copied unchanged into the PVC that gets created from this
    /// template. The same fields as in a PersistentVolumeClaim
    /// are also valid here.
    pub spec: ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpec,
}

/// May contain labels and annotations that will be copied into the PVC
/// when creating it. No other fields are allowed and will be rejected during
/// validation.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub finalizers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// The specification for the PersistentVolumeClaim. The entire content is
/// copied unchanged into the PVC that gets created from this
/// template. The same fields as in a PersistentVolumeClaim
/// are also valid here.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpec {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass>
    /// (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesFc {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// lun is Optional: FC target lun number
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lun: Option<i32>,
    /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// targetWWNs is Optional: FC target worldwide names (WWNs)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetWWNs")]
    pub target_ww_ns: Option<Vec<String>>,
    /// wwids Optional: FC volume world wide identifiers (wwids)
    /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wwids: Option<Vec<String>>,
}

/// flexVolume represents a generic volume resource that is
/// provisioned/attached using an exec based plugin.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesFlexVolume {
    /// driver is the name of the driver to use for this volume.
    pub driver: String,
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// options is Optional: this field holds extra command options if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<BTreeMap<String, String>>,
    /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is Optional: secretRef is reference to the secret object containing
    /// sensitive information to pass to the plugin scripts. This may be
    /// empty if no secret object is specified. If the secret object
    /// contains more than one secret, all secrets are passed to the plugin
    /// scripts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ComponentDefinitionRuntimeVolumesFlexVolumeSecretRef>,
}

/// secretRef is Optional: secretRef is reference to the secret object containing
/// sensitive information to pass to the plugin scripts. This may be
/// empty if no secret object is specified. If the secret object
/// contains more than one secret, all secrets are passed to the plugin
/// scripts.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesFlexVolumeSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesFlocker {
    /// datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
    /// should be considered as deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetName")]
    pub dataset_name: Option<String>,
    /// datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "datasetUUID")]
    pub dataset_uuid: Option<String>,
}

/// gcePersistentDisk represents a GCE Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesGcePersistentDisk {
    /// fsType is filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// partition is the partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(rename = "pdName")]
    pub pd_name: String,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// gitRepo represents a git repository at a particular revision.
/// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
/// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
/// into the Pod's container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesGitRepo {
    /// directory is the target directory name.
    /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    /// git repository.  Otherwise, if specified, the volume will contain the git repository in
    /// the subdirectory with the given name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    /// repository is the URL
    pub repository: String,
    /// revision is the commit hash for the specified revision.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub revision: Option<String>,
}

/// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
/// More info: <https://examples.k8s.io/volumes/glusterfs/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesGlusterfs {
    /// endpoints is the endpoint name that details Glusterfs topology.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub endpoints: String,
    /// path is the Glusterfs volume path.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    pub path: String,
    /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// hostPath represents a pre-existing file or directory on the host
/// machine that is directly exposed to the container. This is generally
/// used for system agents or other privileged things that are allowed
/// to see the host machine. Most containers will NOT need this.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
/// ---
/// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
/// mount host directories as read/write.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesHostPath {
    /// path of the directory on the host.
    /// If the path is a symlink, it will follow the link to the real path.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    pub path: String,
    /// type for HostPath Volume
    /// Defaults to ""
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#hostpath>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// iscsi represents an ISCSI Disk resource that is attached to a
/// kubelet's host machine and then exposed to the pod.
/// More info: <https://examples.k8s.io/volumes/iscsi/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesIscsi {
    /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthDiscovery")]
    pub chap_auth_discovery: Option<bool>,
    /// chapAuthSession defines whether support iSCSI Session CHAP authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chapAuthSession")]
    pub chap_auth_session: Option<bool>,
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#iscsi>
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// initiatorName is the custom iSCSI Initiator Name.
    /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    /// <target portal>:<volume name> will be created for the connection.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initiatorName")]
    pub initiator_name: Option<String>,
    /// iqn is the target iSCSI Qualified Name.
    pub iqn: String,
    /// iscsiInterface is the interface Name that uses an iSCSI transport.
    /// Defaults to 'default' (tcp).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "iscsiInterface")]
    pub iscsi_interface: Option<String>,
    /// lun represents iSCSI Target Lun number.
    pub lun: i32,
    /// portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub portals: Option<Vec<String>>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ComponentDefinitionRuntimeVolumesIscsiSecretRef>,
    /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    #[serde(rename = "targetPortal")]
    pub target_portal: String,
}

/// secretRef is the CHAP Secret for iSCSI target and initiator authentication
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesIscsiSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// nfs represents an NFS mount on the host that shares a pod's lifetime
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesNfs {
    /// path that is exported by the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub path: String,
    /// readOnly here will force the NFS export to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// server is the hostname or IP address of the NFS server.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#nfs>
    pub server: String,
}

/// persistentVolumeClaimVolumeSource represents a reference to a
/// PersistentVolumeClaim in the same namespace.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesPersistentVolumeClaim {
    /// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims>
    #[serde(rename = "claimName")]
    pub claim_name: String,
    /// readOnly Will force the ReadOnly setting in VolumeMounts.
    /// Default false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesPhotonPersistentDisk {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// pdID is the ID that identifies Photon Controller persistent disk
    #[serde(rename = "pdID")]
    pub pd_id: String,
}

/// portworxVolume represents a portworx volume attached and mounted on kubelets host machine
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesPortworxVolume {
    /// fSType represents the filesystem type to mount
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// volumeID uniquely identifies a Portworx volume
    #[serde(rename = "volumeID")]
    pub volume_id: String,
}

/// projected items for all in one resources secrets, configmaps, and downward API
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjected {
    /// defaultMode are the mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// sources is the list of volume projections
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sources: Option<Vec<ComponentDefinitionRuntimeVolumesProjectedSources>>,
}

/// Projection that may be projected along with other supported volume types
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSources {
    /// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
    /// of ClusterTrustBundle objects in an auto-updating file.
    /// 
    /// 
    /// Alpha, gated by the ClusterTrustBundleProjection feature gate.
    /// 
    /// 
    /// ClusterTrustBundle objects can either be selected by name, or by the
    /// combination of signer name and a label selector.
    /// 
    /// 
    /// Kubelet performs aggressive normalization of the PEM contents written
    /// into the pod filesystem.  Esoteric PEM features such as inter-block
    /// comments and block headers are stripped.  Certificates are deduplicated.
    /// The ordering of certificates within the file is arbitrary, and Kubelet
    /// may change the order over time.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterTrustBundle")]
    pub cluster_trust_bundle: Option<ComponentDefinitionRuntimeVolumesProjectedSourcesClusterTrustBundle>,
    /// configMap information about the configMap data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ComponentDefinitionRuntimeVolumesProjectedSourcesConfigMap>,
    /// downwardAPI information about the downwardAPI data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "downwardAPI")]
    pub downward_api: Option<ComponentDefinitionRuntimeVolumesProjectedSourcesDownwardApi>,
    /// secret information about the secret data to project
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ComponentDefinitionRuntimeVolumesProjectedSourcesSecret>,
    /// serviceAccountToken is information about the serviceAccountToken data to project
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAccountToken")]
    pub service_account_token: Option<ComponentDefinitionRuntimeVolumesProjectedSourcesServiceAccountToken>,
}

/// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
/// of ClusterTrustBundle objects in an auto-updating file.
/// 
/// 
/// Alpha, gated by the ClusterTrustBundleProjection feature gate.
/// 
/// 
/// ClusterTrustBundle objects can either be selected by name, or by the
/// combination of signer name and a label selector.
/// 
/// 
/// Kubelet performs aggressive normalization of the PEM contents written
/// into the pod filesystem.  Esoteric PEM features such as inter-block
/// comments and block headers are stripped.  Certificates are deduplicated.
/// The ordering of certificates within the file is arbitrary, and Kubelet
/// may change the order over time.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesClusterTrustBundle {
    /// Select all ClusterTrustBundles that match this label selector.  Only has
    /// effect if signerName is set.  Mutually-exclusive with name.  If unset,
    /// interpreted as "match nothing".  If set but empty, interpreted as "match
    /// everything".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<ComponentDefinitionRuntimeVolumesProjectedSourcesClusterTrustBundleLabelSelector>,
    /// Select a single ClusterTrustBundle by object name.  Mutually-exclusive
    /// with signerName and labelSelector.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// If true, don't block pod startup if the referenced ClusterTrustBundle(s)
    /// aren't available.  If using name, then the named ClusterTrustBundle is
    /// allowed not to exist.  If using signerName, then the combination of
    /// signerName and labelSelector is allowed to match zero
    /// ClusterTrustBundles.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Relative path from the volume root to write the bundle.
    pub path: String,
    /// Select all ClusterTrustBundles that match this signer name.
    /// Mutually-exclusive with name.  The contents of all selected
    /// ClusterTrustBundles will be unified and deduplicated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "signerName")]
    pub signer_name: Option<String>,
}

/// Select all ClusterTrustBundles that match this label selector.  Only has
/// effect if signerName is set.  Mutually-exclusive with name.  If unset,
/// interpreted as "match nothing".  If set but empty, interpreted as "match
/// everything".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesClusterTrustBundleLabelSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ComponentDefinitionRuntimeVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// configMap information about the configMap data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesConfigMap {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ComponentDefinitionRuntimeVolumesProjectedSourcesConfigMapItems>>,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional specify whether the ConfigMap or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesConfigMapItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// downwardAPI information about the downwardAPI data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesDownwardApi {
    /// Items is a list of DownwardAPIVolume file
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ComponentDefinitionRuntimeVolumesProjectedSourcesDownwardApiItems>>,
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesDownwardApiItems {
    /// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ComponentDefinitionRuntimeVolumesProjectedSourcesDownwardApiItemsFieldRef>,
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    pub path: String,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<ComponentDefinitionRuntimeVolumesProjectedSourcesDownwardApiItemsResourceFieldRef>,
}

/// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesDownwardApiItemsFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// secret information about the secret data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesSecret {
    /// items if unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ComponentDefinitionRuntimeVolumesProjectedSourcesSecretItems>>,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional field specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// serviceAccountToken is information about the serviceAccountToken data to project
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesProjectedSourcesServiceAccountToken {
    /// audience is the intended audience of the token. A recipient of a token
    /// must identify itself with an identifier specified in the audience of the
    /// token, and otherwise should reject the token. The audience defaults to the
    /// identifier of the apiserver.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    /// expirationSeconds is the requested duration of validity of the service
    /// account token. As the token approaches expiration, the kubelet volume
    /// plugin will proactively rotate the service account token. The kubelet will
    /// start trying to rotate the token if the token is older than 80 percent of
    /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
    /// and must be at least 10 minutes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "expirationSeconds")]
    pub expiration_seconds: Option<i64>,
    /// path is the path relative to the mount point of the file to project the
    /// token into.
    pub path: String,
}

/// quobyte represents a Quobyte mount on the host that shares a pod's lifetime
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesQuobyte {
    /// group to map volume access to
    /// Default is no group
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// readOnly here will force the Quobyte volume to be mounted with read-only permissions.
    /// Defaults to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// registry represents a single or multiple Quobyte Registry services
    /// specified as a string as host:port pair (multiple entries are separated with commas)
    /// which acts as the central registry for volumes
    pub registry: String,
    /// tenant owning the given Quobyte volume in the Backend
    /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tenant: Option<String>,
    /// user to map volume access to
    /// Defaults to serivceaccount user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// volume is a string that references an already created Quobyte volume by name.
    pub volume: String,
}

/// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesRbd {
    /// fsType is the filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#rbd>
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// image is the rados image name.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub image: String,
    /// keyring is the path to key ring for RBDUser.
    /// Default is /etc/ceph/keyring.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyring: Option<String>,
    /// monitors is a collection of Ceph monitors.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    pub monitors: Vec<String>,
    /// pool is the rados pool name.
    /// Default is rbd.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    /// readOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef is name of the authentication secret for RBDUser. If provided
    /// overrides keyring.
    /// Default is nil.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ComponentDefinitionRuntimeVolumesRbdSecretRef>,
    /// user is the rados user name.
    /// Default is admin.
    /// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

/// secretRef is name of the authentication secret for RBDUser. If provided
/// overrides keyring.
/// Default is nil.
/// More info: <https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesRbdSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesScaleIo {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// Default is "xfs".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// gateway is the host address of the ScaleIO API Gateway.
    pub gateway: String,
    /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protectionDomain")]
    pub protection_domain: Option<String>,
    /// readOnly Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef references to the secret for ScaleIO user and other
    /// sensitive information. If this is not provided, Login operation will fail.
    #[serde(rename = "secretRef")]
    pub secret_ref: ComponentDefinitionRuntimeVolumesScaleIoSecretRef,
    /// sslEnabled Flag enable/disable SSL communication with Gateway, default false
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sslEnabled")]
    pub ssl_enabled: Option<bool>,
    /// storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    /// Default is ThinProvisioned.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageMode")]
    pub storage_mode: Option<String>,
    /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePool")]
    pub storage_pool: Option<String>,
    /// system is the name of the storage system as configured in ScaleIO.
    pub system: String,
    /// volumeName is the name of a volume already created in the ScaleIO system
    /// that is associated with this volume source.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// secretRef references to the secret for ScaleIO user and other
/// sensitive information. If this is not provided, Login operation will fail.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesScaleIoSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// secret represents a secret that should populate this volume.
/// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesSecret {
    /// defaultMode is Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values
    /// for mode bits. Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// items If unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ComponentDefinitionRuntimeVolumesSecretItems>>,
    /// optional field specify whether the Secret or its keys must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// secretName is the name of the secret in the pod's namespace to use.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volumes#secret>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// Maps a string key to a path within a volume.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesSecretItems {
    /// key is the key to project.
    pub key: String,
    /// mode is Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    /// path is the relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    pub path: String,
}

/// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesStorageos {
    /// fsType is the filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// readOnly defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    /// secretRef specifies the secret to use for obtaining the StorageOS API
    /// credentials.  If not specified, default values will be attempted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<ComponentDefinitionRuntimeVolumesStorageosSecretRef>,
    /// volumeName is the human-readable name of the StorageOS volume.  Volume
    /// names are only unique within a namespace.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
    /// volumeNamespace specifies the scope of the volume within StorageOS.  If no
    /// namespace is specified then the Pod's namespace will be used.  This allows the
    /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    /// Set VolumeName to any name to override the default behaviour.
    /// Set to "default" if you are not using namespaces within StorageOS.
    /// Namespaces that do not pre-exist within StorageOS will be created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeNamespace")]
    pub volume_namespace: Option<String>,
}

/// secretRef specifies the secret to use for obtaining the StorageOS API
/// credentials.  If not specified, default values will be attempted.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesStorageosSecretRef {
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionRuntimeVolumesVsphereVolume {
    /// fsType is filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fsType")]
    pub fs_type: Option<String>,
    /// storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyID")]
    pub storage_policy_id: Option<String>,
    /// storagePolicyName is the storage Policy Based Management (SPBM) profile name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storagePolicyName")]
    pub storage_policy_name: Option<String>,
    /// volumePath is the path that identifies vSphere volume vmdk
    #[serde(rename = "volumePath")]
    pub volume_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionScripts {
    /// The operator attempts to set default file permissions (0444).
    /// 
    /// 
    /// Must be specified as an octal value between 0000 and 0777 (inclusive),
    /// or as a decimal value between 0 and 511 (inclusive).
    /// YAML supports both octal and decimal values for file permissions.
    /// 
    /// 
    /// Please note that this setting only affects the permissions of the files themselves.
    /// Directories within the specified path are not impacted by this setting.
    /// It's important to be aware that this setting might conflict with other options
    /// that influence the file mode, such as fsGroup.
    /// In such cases, the resulting file mode may have additional bits set.
    /// Refers to documents of k8s.ConfigMapVolumeSource.defaultMode for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// ExternalManaged indicates whether the configuration is managed by an external system.
    /// When set to true, the controller will ignore the management of this configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalManaged")]
    pub external_managed: Option<bool>,
    /// Specifies the name of the template.
    pub name: String,
    /// Specifies the namespace of the referenced template ConfigMap object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specifies whether to restart the pod when the file changes.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartOnFileChange")]
    pub restart_on_file_change: Option<bool>,
    /// Specifies the name of the referenced template ConfigMap object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
    /// Refers to the volume name of PodTemplate. The file produced through the template will be mounted to
    /// the corresponding volume. Must be a DNS_LABEL name.
    /// The volume name must be defined in podSpec.containers[*].volumeMounts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// ServiceRefDeclaration represents a reference to a service that can be either provided by a KubeBlocks Cluster
/// or an external service.
/// It acts as a placeholder for the actual service reference, which is determined later when a Cluster is created.
/// 
/// 
/// The purpose of ServiceRefDeclaration is to declare a service dependency without specifying the concrete details
/// of the service.
/// It allows for flexibility and abstraction in defining service references within a Component.
/// By using ServiceRefDeclaration, you can define service dependencies in a declarative manner, enabling loose coupling
/// and easier management of service references across different components and clusters.
/// 
/// 
/// Upon Cluster creation, the ServiceRefDeclaration is bound to an actual service through the ServiceRef field,
/// effectively resolving and connecting to the specified service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionServiceRefDeclarations {
    /// Specifies the name of the ServiceRefDeclaration.
    pub name: String,
    /// Specifies whether the service reference can be optional.
    /// 
    /// 
    /// For an optional service-ref, the component can still be created even if the service-ref is not provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Defines a list of constraints and requirements for services that can be bound to this ServiceRefDeclaration
    /// upon Cluster creation.
    /// Each ServiceRefDeclarationSpec defines a ServiceKind and ServiceVersion,
    /// outlining the acceptable service types and versions that are compatible.
    /// 
    /// 
    /// This flexibility allows a ServiceRefDeclaration to be fulfilled by any one of the provided specs.
    /// For example, if it requires an OLTP database, specs for both MySQL and PostgreSQL are listed,
    /// either MySQL or PostgreSQL services can be used when binding.
    #[serde(rename = "serviceRefDeclarationSpecs")]
    pub service_ref_declaration_specs: Vec<ComponentDefinitionServiceRefDeclarationsServiceRefDeclarationSpecs>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionServiceRefDeclarationsServiceRefDeclarationSpecs {
    /// Specifies the type or nature of the service. This should be a well-known application cluster type, such as
    /// {mysql, redis, mongodb}.
    /// The field is case-insensitive and supports abbreviations for some well-known databases.
    /// For instance, both `zk` and `zookeeper` are considered as a ZooKeeper cluster, while `pg`, `postgres`, `postgresql`
    /// are all recognized as a PostgreSQL cluster.
    #[serde(rename = "serviceKind")]
    pub service_kind: String,
    /// Defines the service version of the service reference. This is a regular expression that matches a version number pattern.
    /// For instance, `^8.0.8$`, `8.0.\d{1,2}$`, `^[v\-]*?(\d{1,2}\.){0,3}\d{1,2}$` are all valid patterns.
    #[serde(rename = "serviceVersion")]
    pub service_version: String,
}

/// ComponentService defines a service that would be exposed as an inter-component service within a Cluster.
/// A Service defined in the ComponentService is expected to be accessed by other Components within the same Cluster.
/// 
/// 
/// When a Component needs to use a ComponentService provided by another Component within the same Cluster,
/// it can declare a variable in the `componentDefinition.spec.vars` section and bind it to the specific exposed address
/// of the ComponentService using the `serviceVarRef` field.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionServices {
    /// If ServiceType is LoadBalancer, cloud provider related parameters can be put here
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Indicates whether the automatic provisioning of the service should be disabled.
    /// 
    /// 
    /// If set to true, the service will not be automatically created at the component provisioning.
    /// Instead, you can enable the creation of this service by specifying it explicitly in the cluster API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableAutoProvision")]
    pub disable_auto_provision: Option<bool>,
    /// Name defines the name of the service.
    /// otherwise, it indicates the name of the service.
    /// Others can refer to this service by its name. (e.g., connection credential)
    /// Cannot be updated.
    pub name: String,
    /// Indicates whether to create a corresponding Service for each Pod of the selected Component.
    /// When set to true, a set of Services will be automatically generated for each Pod,
    /// and the `roleSelector` field will be ignored.
    /// 
    /// 
    /// The names of the generated Services will follow the same suffix naming pattern: `$(serviceName)-$(podOrdinal)`.
    /// The total number of generated Services will be equal to the number of replicas specified for the Component.
    /// 
    /// 
    /// Example usage:
    /// 
    /// 
    /// ```text
    /// name: my-service
    /// serviceName: my-service
    /// podService: true
    /// disableAutoProvision: true
    /// spec:
    ///   type: NodePort
    ///   ports:
    ///   - name: http
    ///     port: 80
    ///     targetPort: 8080
    /// ```
    /// 
    /// 
    /// In this example, if the Component has 3 replicas, three Services will be generated:
    /// - my-service-0: Points to the first Pod (podOrdinal: 0)
    /// - my-service-1: Points to the second Pod (podOrdinal: 1)
    /// - my-service-2: Points to the third Pod (podOrdinal: 2)
    /// 
    /// 
    /// Each generated Service will have the specified spec configuration and will target its respective Pod.
    /// 
    /// 
    /// This feature is useful when you need to expose each Pod of a Component individually, allowing external access
    /// to specific instances of the Component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podService")]
    pub pod_service: Option<bool>,
    /// Extends the above `serviceSpec.selector` by allowing you to specify defined role as selector for the service.
    /// When `roleSelector` is set, it adds a label selector "kubeblocks.io/role: {roleSelector}"
    /// to the `serviceSpec.selector`.
    /// Example usage:
    /// 
    /// 
    /// 	  roleSelector: "leader"
    /// 
    /// 
    /// In this example, setting `roleSelector` to "leader" will add a label selector
    /// "kubeblocks.io/role: leader" to the `serviceSpec.selector`.
    /// This means that the service will select and route traffic to Pods with the label
    /// "kubeblocks.io/role" set to "leader".
    /// 
    /// 
    /// Note that if `podService` sets to true, RoleSelector will be ignored.
    /// The `podService` flag takes precedence over `roleSelector` and generates a service for each Pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "roleSelector")]
    pub role_selector: Option<String>,
    /// ServiceName defines the name of the underlying service object.
    /// If not specified, the default service name with different patterns will be used:
    /// 
    /// 
    /// - CLUSTER_NAME: for cluster-level services
    /// - CLUSTER_NAME-COMPONENT_NAME: for component-level services
    /// 
    /// 
    /// Only one default service name is allowed.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
    /// Spec defines the behavior of a service.
    /// <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ComponentDefinitionServicesSpec>,
}

/// Spec defines the behavior of a service.
/// <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionServicesSpec {
    /// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
    /// allocated for services with type LoadBalancer.  Default is "true". It
    /// may be set to "false" if the cluster load-balancer does not rely on
    /// NodePorts.  If the caller requests specific NodePorts (by specifying a
    /// value), those requests will be respected, regardless of this field.
    /// This field may only be set for services with type LoadBalancer and will
    /// be cleared if the type is changed to any other type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allocateLoadBalancerNodePorts")]
    pub allocate_load_balancer_node_ports: Option<bool>,
    /// clusterIP is the IP address of the service and is usually assigned
    /// randomly. If an address is specified manually, is in-range (as per
    /// system configuration), and is not in use, it will be allocated to the
    /// service; otherwise creation of the service will fail. This field may not
    /// be changed through updates unless the type field is also being changed
    /// to ExternalName (which requires this field to be blank) or the type
    /// field is being changed from ExternalName (in which case this field may
    /// optionally be specified, as describe above).  Valid values are "None",
    /// empty string (""), or a valid IP address. Setting this to "None" makes a
    /// "headless service" (no virtual IP), which is useful when direct endpoint
    /// connections are preferred and proxying is not required.  Only applies to
    /// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
    /// when creating a Service of type ExternalName, creation will fail. This
    /// field will be wiped when updating a Service to type ExternalName.
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIP")]
    pub cluster_ip: Option<String>,
    /// ClusterIPs is a list of IP addresses assigned to this service, and are
    /// usually assigned randomly.  If an address is specified manually, is
    /// in-range (as per system configuration), and is not in use, it will be
    /// allocated to the service; otherwise creation of the service will fail.
    /// This field may not be changed through updates unless the type field is
    /// also being changed to ExternalName (which requires this field to be
    /// empty) or the type field is being changed from ExternalName (in which
    /// case this field may optionally be specified, as describe above).  Valid
    /// values are "None", empty string (""), or a valid IP address.  Setting
    /// this to "None" makes a "headless service" (no virtual IP), which is
    /// useful when direct endpoint connections are preferred and proxying is
    /// not required.  Only applies to types ClusterIP, NodePort, and
    /// LoadBalancer. If this field is specified when creating a Service of type
    /// ExternalName, creation will fail. This field will be wiped when updating
    /// a Service to type ExternalName.  If this field is not specified, it will
    /// be initialized from the clusterIP field.  If this field is specified,
    /// clients must ensure that clusterIPs[0] and clusterIP have the same
    /// value.
    /// 
    /// 
    /// This field may hold a maximum of two entries (dual-stack IPs, in either order).
    /// These IPs must correspond to the values of the ipFamilies field. Both
    /// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterIPs")]
    pub cluster_i_ps: Option<Vec<String>>,
    /// externalIPs is a list of IP addresses for which nodes in the cluster
    /// will also accept traffic for this service.  These IPs are not managed by
    /// Kubernetes.  The user is responsible for ensuring that traffic arrives
    /// at a node with this IP.  A common example is external load-balancers
    /// that are not part of the Kubernetes system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalIPs")]
    pub external_i_ps: Option<Vec<String>>,
    /// externalName is the external reference that discovery mechanisms will
    /// return as an alias for this service (e.g. a DNS CNAME record). No
    /// proxying will be involved.  Must be a lowercase RFC-1123 hostname
    /// (<https://tools.ietf.org/html/rfc1123)> and requires `type` to be "ExternalName".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalName")]
    pub external_name: Option<String>,
    /// externalTrafficPolicy describes how nodes distribute service traffic they
    /// receive on one of the Service's "externally-facing" addresses (NodePorts,
    /// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
    /// the service in a way that assumes that external load balancers will take care
    /// of balancing the service traffic between nodes, and so each node will deliver
    /// traffic only to the node-local endpoints of the service, without masquerading
    /// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
    /// be dropped.) The default value, "Cluster", uses the standard behavior of
    /// routing to all endpoints evenly (possibly modified by topology and other
    /// features). Note that traffic sent to an External IP or LoadBalancer IP from
    /// within the cluster will always get "Cluster" semantics, but clients sending to
    /// a NodePort from within the cluster may need to take traffic policy into account
    /// when picking a node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "externalTrafficPolicy")]
    pub external_traffic_policy: Option<String>,
    /// healthCheckNodePort specifies the healthcheck nodePort for the service.
    /// This only applies when type is set to LoadBalancer and
    /// externalTrafficPolicy is set to Local. If a value is specified, is
    /// in-range, and is not in use, it will be used.  If not specified, a value
    /// will be automatically allocated.  External systems (e.g. load-balancers)
    /// can use this port to determine if a given node holds endpoints for this
    /// service or not.  If this field is specified when creating a Service
    /// which does not need it, creation will fail. This field will be wiped
    /// when updating a Service to no longer need it (e.g. changing type).
    /// This field cannot be updated once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "healthCheckNodePort")]
    pub health_check_node_port: Option<i32>,
    /// InternalTrafficPolicy describes how nodes distribute service traffic they
    /// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
    /// only want to talk to endpoints of the service on the same node as the pod,
    /// dropping the traffic if there are no local endpoints. The default value,
    /// "Cluster", uses the standard behavior of routing to all endpoints evenly
    /// (possibly modified by topology and other features).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalTrafficPolicy")]
    pub internal_traffic_policy: Option<String>,
    /// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
    /// service. This field is usually assigned automatically based on cluster
    /// configuration and the ipFamilyPolicy field. If this field is specified
    /// manually, the requested family is available in the cluster,
    /// and ipFamilyPolicy allows it, it will be used; otherwise creation of
    /// the service will fail. This field is conditionally mutable: it allows
    /// for adding or removing a secondary IP family, but it does not allow
    /// changing the primary IP family of the Service. Valid values are "IPv4"
    /// and "IPv6".  This field only applies to Services of types ClusterIP,
    /// NodePort, and LoadBalancer, and does apply to "headless" services.
    /// This field will be wiped when updating a Service to type ExternalName.
    /// 
    /// 
    /// This field may hold a maximum of two entries (dual-stack families, in
    /// either order).  These families must correspond to the values of the
    /// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
    /// governed by the ipFamilyPolicy field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipFamilies")]
    pub ip_families: Option<Vec<String>>,
    /// IPFamilyPolicy represents the dual-stack-ness requested or required by
    /// this Service. If there is no value provided, then this field will be set
    /// to SingleStack. Services can be "SingleStack" (a single IP family),
    /// "PreferDualStack" (two IP families on dual-stack configured clusters or
    /// a single IP family on single-stack clusters), or "RequireDualStack"
    /// (two IP families on dual-stack configured clusters, otherwise fail). The
    /// ipFamilies and clusterIPs fields depend on the value of this field. This
    /// field will be wiped when updating a service to type ExternalName.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipFamilyPolicy")]
    pub ip_family_policy: Option<String>,
    /// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
    /// If specified, the value of this field must be a label-style identifier, with an optional prefix,
    /// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
    /// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
    /// balancer implementation is used, today this is typically done through the cloud provider integration,
    /// but should apply for any default implementation. If set, it is assumed that a load balancer
    /// implementation is watching for Services with a matching class. Any default load balancer
    /// implementation (e.g. cloud providers) should ignore Services that set this field.
    /// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
    /// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerClass")]
    pub load_balancer_class: Option<String>,
    /// Only applies to Service Type: LoadBalancer.
    /// This feature depends on whether the underlying cloud-provider supports specifying
    /// the loadBalancerIP when a load balancer is created.
    /// This field will be ignored if the cloud-provider does not support the feature.
    /// Deprecated: This field was under-specified and its meaning varies across implementations.
    /// Using it is non-portable and it may not support dual-stack.
    /// Users are encouraged to use implementation-specific annotations when available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerIP")]
    pub load_balancer_ip: Option<String>,
    /// If specified and supported by the platform, this will restrict traffic through the cloud-provider
    /// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
    /// cloud-provider does not support the feature."
    /// More info: <https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancerSourceRanges")]
    pub load_balancer_source_ranges: Option<Vec<String>>,
    /// The list of ports that are exposed by this service.
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<ComponentDefinitionServicesSpecPorts>>,
    /// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
    /// Service should disregard any indications of ready/not-ready.
    /// The primary use case for setting this field is for a StatefulSet's Headless Service to
    /// propagate SRV DNS records for its Pods for the purpose of peer discovery.
    /// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
    /// Services interpret this to mean that all endpoints are considered "ready" even if the
    /// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
    /// through the Endpoints or EndpointSlice resources can safely assume this behavior.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "publishNotReadyAddresses")]
    pub publish_not_ready_addresses: Option<bool>,
    /// Route service traffic to pods with label keys and values matching this
    /// selector. If empty or not present, the service is assumed to have an
    /// external process managing its endpoints, which Kubernetes will not
    /// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
    /// Ignored if type is ExternalName.
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<BTreeMap<String, String>>,
    /// Supports "ClientIP" and "None". Used to maintain session affinity.
    /// Enable client IP based session affinity.
    /// Must be ClientIP or None.
    /// Defaults to None.
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionAffinity")]
    pub session_affinity: Option<String>,
    /// sessionAffinityConfig contains the configurations of session affinity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionAffinityConfig")]
    pub session_affinity_config: Option<ComponentDefinitionServicesSpecSessionAffinityConfig>,
    /// type determines how the Service is exposed. Defaults to ClusterIP. Valid
    /// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
    /// "ClusterIP" allocates a cluster-internal IP address for load-balancing
    /// to endpoints. Endpoints are determined by the selector or if that is not
    /// specified, by manual construction of an Endpoints object or
    /// EndpointSlice objects. If clusterIP is "None", no virtual IP is
    /// allocated and the endpoints are published as a set of endpoints rather
    /// than a virtual IP.
    /// "NodePort" builds on ClusterIP and allocates a port on every node which
    /// routes to the same endpoints as the clusterIP.
    /// "LoadBalancer" builds on NodePort and creates an external load-balancer
    /// (if supported in the current cloud) which routes to the same endpoints
    /// as the clusterIP.
    /// "ExternalName" aliases this service to the specified externalName.
    /// Several other fields do not apply to ExternalName services.
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// ServicePort contains information on service's port.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionServicesSpecPorts {
    /// The application protocol for this port.
    /// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
    /// This field follows standard Kubernetes label syntax.
    /// Valid values are either:
    /// 
    /// 
    /// * Un-prefixed protocol names - reserved for IANA standard service names (as per
    /// RFC-6335 and <https://www.iana.org/assignments/service-names).>
    /// 
    /// 
    /// * Kubernetes-defined prefixed names:
    ///   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in <https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior->
    ///   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in <https://www.rfc-editor.org/rfc/rfc6455>
    ///   * 'kubernetes.io/wss' - WebSocket over TLS as described in <https://www.rfc-editor.org/rfc/rfc6455>
    /// 
    /// 
    /// * Other protocols should use implementation-defined prefixed names such as
    /// mycompany.com/my-custom-protocol.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "appProtocol")]
    pub app_protocol: Option<String>,
    /// The name of this port within the service. This must be a DNS_LABEL.
    /// All ports within a ServiceSpec must have unique names. When considering
    /// the endpoints for a Service, this must match the 'name' field in the
    /// EndpointPort.
    /// Optional if only one ServicePort is defined on this service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The port on each node on which this service is exposed when type is
    /// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
    /// specified, in-range, and not in use it will be used, otherwise the
    /// operation will fail.  If not specified, a port will be allocated if this
    /// Service requires one.  If this field is specified when creating a
    /// Service which does not need it, creation will fail. This field will be
    /// wiped when updating a Service to no longer need it (e.g. changing type
    /// from NodePort to ClusterIP).
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i32>,
    /// The port that will be exposed by this service.
    pub port: i32,
    /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
    /// Default is TCP.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    /// Number or name of the port to access on the pods targeted by the service.
    /// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    /// If this is a string, it will be looked up as a named port in the
    /// target Pod's container ports. If this is not specified, the value
    /// of the 'port' field is used (an identity map).
    /// This field is ignored for services with clusterIP=None, and should be
    /// omitted or set equal to the 'port' field.
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPort")]
    pub target_port: Option<IntOrString>,
}

/// sessionAffinityConfig contains the configurations of session affinity.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionServicesSpecSessionAffinityConfig {
    /// clientIP contains the configurations of Client IP based session affinity.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientIP")]
    pub client_ip: Option<ComponentDefinitionServicesSpecSessionAffinityConfigClientIp>,
}

/// clientIP contains the configurations of Client IP based session affinity.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionServicesSpecSessionAffinityConfigClientIp {
    /// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
    /// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
    /// Default value is 10800(for 3 hours).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutSeconds")]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionSystemAccounts {
    /// Indicates if this account is a system initialization account (e.g., MySQL root).
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initAccount")]
    pub init_account: Option<bool>,
    /// Specifies the unique identifier for the account. This name is used by other entities to reference the account.
    /// 
    /// 
    /// This field is immutable once set.
    pub name: String,
    /// Specifies the policy for generating the account's password.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwordGenerationPolicy")]
    pub password_generation_policy: Option<ComponentDefinitionSystemAccountsPasswordGenerationPolicy>,
    /// Defines the statements used to create, delete, and update the account.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub statement: Option<ComponentDefinitionSystemAccountsStatement>,
}

/// Specifies the policy for generating the account's password.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionSystemAccountsPasswordGenerationPolicy {
    /// The length of the password.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub length: Option<i32>,
    /// The case of the letters in the password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "letterCase")]
    pub letter_case: Option<ComponentDefinitionSystemAccountsPasswordGenerationPolicyLetterCase>,
    /// The number of digits in the password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numDigits")]
    pub num_digits: Option<i32>,
    /// The number of symbols in the password.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numSymbols")]
    pub num_symbols: Option<i32>,
    /// Seed to generate the account's password.
    /// Cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub seed: Option<String>,
    /// The set of symbols allowed when generating password. If empty, kubeblocks will
    /// use a default symbol set, which is "!@#&*".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "symbolCharacters")]
    pub symbol_characters: Option<String>,
}

/// Specifies the policy for generating the account's password.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionSystemAccountsPasswordGenerationPolicyLetterCase {
    LowerCases,
    UpperCases,
    MixedCases,
}

/// Defines the statements used to create, delete, and update the account.
/// 
/// 
/// This field is immutable once set.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionSystemAccountsStatement {
    /// The statement to create a new account with the necessary privileges.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create: Option<String>,
    /// The statement to delete a account.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub delete: Option<String>,
    /// The statement to update an existing account.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub update: Option<String>,
}

/// Specifies the TLS configuration for the Component.
/// 
/// 
/// This field is immutable.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionTls {
    /// The CA file of the TLS.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// The certificate file of the TLS.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// The permissions for the mounted path. Defaults to 0600.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultMode")]
    pub default_mode: Option<i32>,
    /// The key file of the TLS.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Specifies the mount path for the TLS secret to be mounted.
    /// Similar to the volume, the controller will mount the created volume to the specified path within containers when the TLS is enabled.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// Specifies the volume name for the TLS secret.
    /// The controller will create a volume object with the specified name and add it to the pod when the TLS is enabled.
    /// 
    /// 
    /// This field is immutable once set.
    #[serde(rename = "volumeName")]
    pub volume_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionUpdateStrategy {
    Serial,
    BestEffortParallel,
    Parallel,
}

/// EnvVar represents a variable present in the env of Pod/Action or the template of config/script.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVars {
    /// A Go template expression that will be applied to the resolved value of the var.
    /// 
    /// 
    /// The expression will only be evaluated if the var is successfully resolved to a non-credential value.
    /// 
    /// 
    /// The resolved value can be accessed by its name within the expression, system vars and other user-defined
    /// non-credential vars can be used within the expression in the same way.
    /// Notice that, when accessing vars by its name, you should replace all the "-" in the name with "_", because of
    /// that "-" is not a valid identifier in Go.
    /// 
    /// 
    /// All expressions are evaluated in the order the vars are defined. If a var depends on any vars that also
    /// have expressions defined, be careful about the evaluation order as it may use intermediate values.
    /// 
    /// 
    /// The result of evaluation will be used as the final value of the var. If the expression fails to evaluate,
    /// the resolving of var will also be considered failed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Name of the variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references `$(VAR_NAME)` are expanded using the previously defined variables in the current context.
    /// 
    /// 
    /// If a variable cannot be resolved, the reference in the input string will be unchanged.
    /// Double `$$` are reduced to a single `$`, which allows for escaping the `$(VAR_NAME)` syntax: i.e.
    /// 
    /// 
    /// - `$$(VAR_NAME)` will produce the string literal `$(VAR_NAME)`.
    /// 
    /// 
    /// Escaped references will never be expanded, regardless of whether the variable exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ComponentDefinitionVarsValueFrom>,
}

/// Source for the variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFrom {
    /// Selects a defined var of a Cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterVarRef")]
    pub cluster_var_ref: Option<ComponentDefinitionVarsValueFromClusterVarRef>,
    /// Selects a defined var of a Component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentVarRef")]
    pub component_var_ref: Option<ComponentDefinitionVarsValueFromComponentVarRef>,
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<ComponentDefinitionVarsValueFromConfigMapKeyRef>,
    /// Selects a defined var of a Credential (SystemAccount).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialVarRef")]
    pub credential_var_ref: Option<ComponentDefinitionVarsValueFromCredentialVarRef>,
    /// Selects a defined var of host-network resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostNetworkVarRef")]
    pub host_network_var_ref: Option<ComponentDefinitionVarsValueFromHostNetworkVarRef>,
    /// Selects a defined var of a kind of resource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceVarRef")]
    pub resource_var_ref: Option<ComponentDefinitionVarsValueFromResourceVarRef>,
    /// Selects a key of a Secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ComponentDefinitionVarsValueFromSecretKeyRef>,
    /// Selects a defined var of a ServiceRef.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceRefVarRef")]
    pub service_ref_var_ref: Option<ComponentDefinitionVarsValueFromServiceRefVarRef>,
    /// Selects a defined var of a Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceVarRef")]
    pub service_var_ref: Option<ComponentDefinitionVarsValueFromServiceVarRef>,
    /// Selects a defined var of the TLS.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsVarRef")]
    pub tls_var_ref: Option<ComponentDefinitionVarsValueFromTlsVarRef>,
}

/// Selects a defined var of a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromClusterVarRef {
    /// Reference to the name of the Cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterName")]
    pub cluster_name: Option<ComponentDefinitionVarsValueFromClusterVarRefClusterName>,
    /// Reference to the UID of the Cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterUID")]
    pub cluster_uid: Option<ComponentDefinitionVarsValueFromClusterVarRefClusterUid>,
    /// Reference to the namespace of the Cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<ComponentDefinitionVarsValueFromClusterVarRefNamespace>,
}

/// Selects a defined var of a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromClusterVarRefClusterName {
    Required,
    Optional,
}

/// Selects a defined var of a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromClusterVarRefClusterUid {
    Required,
    Optional,
}

/// Selects a defined var of a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromClusterVarRefNamespace {
    Required,
    Optional,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromComponentVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// Reference to the name of the Component object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentName")]
    pub component_name: Option<ComponentDefinitionVarsValueFromComponentVarRefComponentName>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<ComponentDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Reference to the pod FQDN list of the component.
    /// The value will be presented in the following format: FQDN1,FQDN2,...
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podFQDNs")]
    pub pod_fqd_ns: Option<ComponentDefinitionVarsValueFromComponentVarRefPodFqdNs>,
    /// Reference to the pod FQDN list of the component that have a specific role.
    /// The value will be presented in the following format: FQDN1,FQDN2,...
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podFQDNsForRole")]
    pub pod_fqd_ns_for_role: Option<ComponentDefinitionVarsValueFromComponentVarRefPodFqdNsForRole>,
    /// Reference to the pod name list of the component.
    /// and the value will be presented in the following format: name1,name2,...
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podNames")]
    pub pod_names: Option<ComponentDefinitionVarsValueFromComponentVarRefPodNames>,
    /// Reference to the pod name list of the component that have a specific role.
    /// The value will be presented in the following format: name1,name2,...
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podNamesForRole")]
    pub pod_names_for_role: Option<ComponentDefinitionVarsValueFromComponentVarRefPodNamesForRole>,
    /// Reference to the replicas of the component.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<ComponentDefinitionVarsValueFromComponentVarRefReplicas>,
    /// Reference to the service version of the component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceVersion")]
    pub service_version: Option<ComponentDefinitionVarsValueFromComponentVarRefServiceVersion>,
    /// Reference to the short name of the Component object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shortName")]
    pub short_name: Option<ComponentDefinitionVarsValueFromComponentVarRefShortName>,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromComponentVarRefComponentName {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ComponentDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<ComponentDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: ComponentDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<ComponentDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromComponentVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromComponentVarRefPodFqdNs {
    Required,
    Optional,
}

/// Reference to the pod FQDN list of the component that have a specific role.
/// The value will be presented in the following format: FQDN1,FQDN2,...
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromComponentVarRefPodFqdNsForRole {
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<ComponentDefinitionVarsValueFromComponentVarRefPodFqdNsForRoleOption>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
}

/// Reference to the pod FQDN list of the component that have a specific role.
/// The value will be presented in the following format: FQDN1,FQDN2,...
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromComponentVarRefPodFqdNsForRoleOption {
    Required,
    Optional,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromComponentVarRefPodNames {
    Required,
    Optional,
}

/// Reference to the pod name list of the component that have a specific role.
/// The value will be presented in the following format: name1,name2,...
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromComponentVarRefPodNamesForRole {
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<ComponentDefinitionVarsValueFromComponentVarRefPodNamesForRoleOption>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
}

/// Reference to the pod name list of the component that have a specific role.
/// The value will be presented in the following format: name1,name2,...
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromComponentVarRefPodNamesForRoleOption {
    Required,
    Optional,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromComponentVarRefReplicas {
    Required,
    Optional,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromComponentVarRefServiceVersion {
    Required,
    Optional,
}

/// Selects a defined var of a Component.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromComponentVarRefShortName {
    Required,
    Optional,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a defined var of a Credential (SystemAccount).
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromCredentialVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<ComponentDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ComponentDefinitionVarsValueFromCredentialVarRefPassword>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ComponentDefinitionVarsValueFromCredentialVarRefUsername>,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ComponentDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<ComponentDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: ComponentDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<ComponentDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromCredentialVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Selects a defined var of a Credential (SystemAccount).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromCredentialVarRefPassword {
    Required,
    Optional,
}

/// Selects a defined var of a Credential (SystemAccount).
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromCredentialVarRefUsername {
    Required,
    Optional,
}

/// Selects a defined var of host-network resources.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromHostNetworkVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// ContainerVars defines the vars that can be referenced from a Container.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub container: Option<ComponentDefinitionVarsValueFromHostNetworkVarRefContainer>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<ComponentDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// ContainerVars defines the vars that can be referenced from a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromHostNetworkVarRefContainer {
    /// The name of the container.
    pub name: String,
    /// Container port to reference.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<ComponentDefinitionVarsValueFromHostNetworkVarRefContainerPort>,
}

/// Container port to reference.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromHostNetworkVarRefContainerPort {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<ComponentDefinitionVarsValueFromHostNetworkVarRefContainerPortOption>,
}

/// Container port to reference.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromHostNetworkVarRefContainerPortOption {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ComponentDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<ComponentDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: ComponentDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<ComponentDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromHostNetworkVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromResourceVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<ComponentDefinitionVarsValueFromResourceVarRefCpu>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cpuLimit")]
    pub cpu_limit: Option<ComponentDefinitionVarsValueFromResourceVarRefCpuLimit>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<ComponentDefinitionVarsValueFromResourceVarRefMemory>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "memoryLimit")]
    pub memory_limit: Option<ComponentDefinitionVarsValueFromResourceVarRefMemoryLimit>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<ComponentDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<ComponentDefinitionVarsValueFromResourceVarRefStorage>,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromResourceVarRefCpu {
    Required,
    Optional,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromResourceVarRefCpuLimit {
    Required,
    Optional,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromResourceVarRefMemory {
    Required,
    Optional,
}

/// Selects a defined var of a kind of resource.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromResourceVarRefMemoryLimit {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ComponentDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<ComponentDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: ComponentDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<ComponentDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromResourceVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromResourceVarRefStorage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<ComponentDefinitionVarsValueFromResourceVarRefStorageOption>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromResourceVarRefStorageOption {
    Required,
    Optional,
}

/// Selects a key of a Secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// More info: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromServiceRefVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<ComponentDefinitionVarsValueFromServiceRefVarRefEndpoint>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<ComponentDefinitionVarsValueFromServiceRefVarRefHost>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<ComponentDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ComponentDefinitionVarsValueFromServiceRefVarRefPassword>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podFQDNs")]
    pub pod_fqd_ns: Option<ComponentDefinitionVarsValueFromServiceRefVarRefPodFqdNs>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<ComponentDefinitionVarsValueFromServiceRefVarRefPort>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ComponentDefinitionVarsValueFromServiceRefVarRefUsername>,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceRefVarRefEndpoint {
    Required,
    Optional,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceRefVarRefHost {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ComponentDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<ComponentDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: ComponentDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<ComponentDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceRefVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceRefVarRefPassword {
    Required,
    Optional,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceRefVarRefPodFqdNs {
    Required,
    Optional,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceRefVarRefPort {
    Required,
    Optional,
}

/// Selects a defined var of a ServiceRef.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceRefVarRefUsername {
    Required,
    Optional,
}

/// Selects a defined var of a Service.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromServiceVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<ComponentDefinitionVarsValueFromServiceVarRefHost>,
    /// LoadBalancer represents the LoadBalancer ingress point of the service.
    /// 
    /// 
    /// If multiple ingress points are available, the first one will be used automatically, choosing between IP and Hostname.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "loadBalancer")]
    pub load_balancer: Option<ComponentDefinitionVarsValueFromServiceVarRefLoadBalancer>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<ComponentDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Port references a port or node-port defined in the service.
    /// 
    /// 
    /// If the referenced service is a pod-service, there will be multiple service objects matched,
    /// and the value will be presented in the following format: service1.name:port1,service2.name:port2...
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<ComponentDefinitionVarsValueFromServiceVarRefPort>,
    /// ServiceType references the type of the service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceType")]
    pub service_type: Option<ComponentDefinitionVarsValueFromServiceVarRefServiceType>,
}

/// Selects a defined var of a Service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceVarRefHost {
    Required,
    Optional,
}

/// Selects a defined var of a Service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceVarRefLoadBalancer {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ComponentDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<ComponentDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: ComponentDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<ComponentDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

/// Port references a port or node-port defined in the service.
/// 
/// 
/// If the referenced service is a pod-service, there will be multiple service objects matched,
/// and the value will be presented in the following format: service1.name:port1,service2.name:port2...
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromServiceVarRefPort {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub option: Option<ComponentDefinitionVarsValueFromServiceVarRefPortOption>,
}

/// Port references a port or node-port defined in the service.
/// 
/// 
/// If the referenced service is a pod-service, there will be multiple service objects matched,
/// and the value will be presented in the following format: service1.name:port1,service2.name:port2...
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceVarRefPortOption {
    Required,
    Optional,
}

/// Selects a defined var of a Service.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromServiceVarRefServiceType {
    Required,
    Optional,
}

/// Selects a defined var of the TLS.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromTlsVarRef {
    /// Specifies the exact name, name prefix, or regular expression pattern for matching the name of the ComponentDefinition
    /// custom resource (CR) used by the component that the referent object resident in.
    /// 
    /// 
    /// If not specified, the component itself will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "compDef")]
    pub comp_def: Option<String>,
    /// VarOption defines whether a variable is required or optional.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<ComponentDefinitionVarsValueFromTlsVarRefEnabled>,
    /// This option defines the behavior when multiple component objects match the specified @CompDef.
    /// If not provided, an error will be raised when handling multiple matches.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "multipleClusterObjectOption")]
    pub multiple_cluster_object_option: Option<ComponentDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOption>,
    /// Name of the referent object.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the object must be defined.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a defined var of the TLS.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromTlsVarRefEnabled {
    Required,
    Optional,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct ComponentDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOption {
    /// Define the options for handling combined variables.
    /// Valid only when the strategy is set to "combined".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "combinedOption")]
    pub combined_option: Option<ComponentDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionCombinedOption>,
    /// RequireAllComponentObjects controls whether all component objects must exist before resolving.
    /// If set to true, resolving will only proceed if all component objects are present.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requireAllComponentObjects")]
    pub require_all_component_objects: Option<bool>,
    /// Define the strategy for handling multiple cluster objects.
    pub strategy: ComponentDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionStrategy,
}

/// Define the options for handling combined variables.
/// Valid only when the strategy is set to "combined".
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionCombinedOption {
    /// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flattenFormat")]
    pub flatten_format: Option<ComponentDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat>,
    /// If set, the existing variable will be kept, and a new variable will be defined with the specified suffix
    /// in pattern: $(var.name)_$(suffix).
    /// The new variable will be auto-created and placed behind the existing one.
    /// If not set, the existing variable will be reused with the value format defined below.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "newVarSuffix")]
    pub new_var_suffix: Option<String>,
    /// The format of the value that the operator will use to compose values from multiple components.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFormat")]
    pub value_format: Option<String>,
}

/// The flatten format, default is: $(comp-name-1):value,$(comp-name-2):value.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionCombinedOptionFlattenFormat {
    /// Pair delimiter.
    pub delimiter: String,
    /// Key-value delimiter.
    #[serde(rename = "keyValueDelimiter")]
    pub key_value_delimiter: String,
}

/// This option defines the behavior when multiple component objects match the specified @CompDef.
/// If not provided, an error will be raised when handling multiple matches.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionVarsValueFromTlsVarRefMultipleClusterObjectOptionStrategy {
    #[serde(rename = "individual")]
    Individual,
    #[serde(rename = "combined")]
    Combined,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionVolumes {
    /// Sets the critical threshold for volume space utilization as a percentage (0-100).
    /// 
    /// 
    /// Exceeding this percentage triggers the system to switch the volume to read-only mode as specified in
    /// `componentDefinition.spec.lifecycleActions.readOnly`.
    /// This precaution helps prevent space depletion while maintaining read-only access.
    /// If the space utilization later falls below this threshold, the system reverts the volume to read-write mode
    /// as defined in `componentDefinition.spec.lifecycleActions.readWrite`, restoring full functionality.
    /// 
    /// 
    /// Note: This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "highWatermark")]
    pub high_watermark: Option<i64>,
    /// Specifies the name of the volume.
    /// It must be a DNS_LABEL and unique within the pod.
    /// More info can be found at: <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// Note: This field cannot be updated.
    pub name: String,
    /// Specifies whether the creation of a snapshot of this volume is necessary when performing a backup of the Component.
    /// 
    /// 
    /// Note: This field cannot be updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "needSnapshot")]
    pub need_snapshot: Option<bool>,
}

/// ComponentDefinitionStatus defines the observed state of ComponentDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentDefinitionStatus {
    /// Provides additional information about the current phase.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Refers to the most recent generation that has been observed for the ComponentDefinition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// Represents the current status of the ComponentDefinition. Valid values include ``, `Available`, and `Unavailable`.
    /// When the status is `Available`, the ComponentDefinition is ready and can be utilized by related objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<ComponentDefinitionStatusPhase>,
}

/// ComponentDefinitionStatus defines the observed state of ComponentDefinition.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ComponentDefinitionStatusPhase {
    Available,
    Unavailable,
}

