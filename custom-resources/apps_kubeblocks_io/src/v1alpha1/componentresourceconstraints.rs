// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/apecloud/kubeblocks/apps.kubeblocks.io/v1alpha1/componentresourceconstraints.yaml
// kopium version: 0.22.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// ComponentResourceConstraintSpec defines the desired state of ComponentResourceConstraint
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "apps.kubeblocks.io", version = "v1alpha1", kind = "ComponentResourceConstraint", plural = "componentresourceconstraints")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ComponentResourceConstraintSpec {
    /// componentSelector is used to bind the resource constraint to components based on ComponentDefinition API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "componentSelector")]
    pub component_selector: Option<Vec<ComponentResourceConstraintComponentSelector>>,
    /// Component resource constraint rules.
    pub rules: Vec<ComponentResourceConstraintRules>,
    /// selector is used to bind the resource constraint to cluster definitions based on ClusterDefinition API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<Vec<ComponentResourceConstraintSelector>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentResourceConstraintComponentSelector {
    /// In versions prior to KB 0.8.0, ComponentDefRef is the name of the component definition in the ClusterDefinition. In KB 0.8.0 and later versions, ComponentDefRef is the name of ComponentDefinition.
    #[serde(rename = "componentDefRef")]
    pub component_def_ref: String,
    /// rules are the constraint rules that will be applied to the component.
    pub rules: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentResourceConstraintRules {
    /// The constraint for vcpu cores.
    pub cpu: ComponentResourceConstraintRulesCpu,
    /// The constraint for memory size.
    pub memory: ComponentResourceConstraintRulesMemory,
    /// The name of the constraint.
    pub name: String,
    /// The constraint for storage size.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<ComponentResourceConstraintRulesStorage>,
}

/// The constraint for vcpu cores.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentResourceConstraintRulesCpu {
    /// The maximum count of vcpu cores, [Min, Max] defines a range for valid vcpu cores, and the value in this range must be multiple times of Step. It's useful to define a large number of valid values without defining them one by one. Please see the documentation for Step for some examples. If Slots is specified, Max, Min, and Step are ignored
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max: Option<IntOrString>,
    /// The minimum count of vcpu cores, [Min, Max] defines a range for valid vcpu cores, and the value in this range must be multiple times of Step. It's useful to define a large number of valid values without defining them one by one. Please see the documentation for Step for some examples. If Slots is specified, Max, Min, and Step are ignored
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub min: Option<IntOrString>,
    /// The valid vcpu cores, it's useful if you want to define valid vcpu cores explicitly. If Slots is specified, Max, Min, and Step are ignored
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slots: Option<Vec<IntOrString>>,
    /// The minimum granularity of vcpu cores, [Min, Max] defines a range for valid vcpu cores and the value in this range must be multiple times of Step. For example: 1. Min is 2, Max is 8, Step is 2, and the valid vcpu core is {2, 4, 6, 8}. 2. Min is 0.5, Max is 2, Step is 0.5, and the valid vcpu core is {0.5, 1, 1.5, 2}.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<IntOrString>,
}

/// The constraint for memory size.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentResourceConstraintRulesMemory {
    /// The maximum size of memory per vcpu core, [MinPerCPU, MaxPerCPU] defines a range for valid memory size per vcpu core. It is useful on GCP as the ratio between the CPU and memory may be a range. If SizePerCPU is specified, MinPerCPU and MaxPerCPU are ignored. Reference: <https://cloud.google.com/compute/docs/general-purpose-machines#custom_machine_types>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxPerCPU")]
    pub max_per_cpu: Option<IntOrString>,
    /// The minimum size of memory per vcpu core, [MinPerCPU, MaxPerCPU] defines a range for valid memory size per vcpu core. It is useful on GCP as the ratio between the CPU and memory may be a range. If SizePerCPU is specified, MinPerCPU and MaxPerCPU are ignored. Reference: <https://cloud.google.com/compute/docs/general-purpose-machines#custom_machine_types>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minPerCPU")]
    pub min_per_cpu: Option<IntOrString>,
    /// The size of memory per vcpu core. For example: 1Gi, 200Mi. If SizePerCPU is specified, MinPerCPU and MaxPerCPU are ignore.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sizePerCPU")]
    pub size_per_cpu: Option<IntOrString>,
}

/// The constraint for storage size.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentResourceConstraintRulesStorage {
    /// The maximum size of storage.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max: Option<IntOrString>,
    /// The minimum size of storage.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub min: Option<IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentResourceConstraintSelector {
    /// clusterDefRef is the name of the cluster definition.
    #[serde(rename = "clusterDefRef")]
    pub cluster_def_ref: String,
    /// selector is used to bind the resource constraint to components.
    pub components: Vec<ComponentResourceConstraintSelectorComponents>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ComponentResourceConstraintSelectorComponents {
    /// In versions prior to KB 0.8.0, ComponentDefRef is the name of the component definition in the ClusterDefinition. In KB 0.8.0 and later versions, ComponentDefRef is the name of ComponentDefinition.
    #[serde(rename = "componentDefRef")]
    pub component_def_ref: String,
    /// rules are the constraint rules that will be applied to the component.
    pub rules: Vec<String>,
}

