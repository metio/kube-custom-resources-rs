// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --derive=Default --derive=PartialEq --smart-derive-elision --filename crd-catalog/Altinity/clickhouse-operator/clickhouse.altinity.com/v1/clickhouseinstallationtemplates.yaml
// kopium version: 0.22.3

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// Specification of the desired behavior of one or more ClickHouse clusters
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md>
/// 
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
#[kube(group = "clickhouse.altinity.com", version = "v1", kind = "ClickHouseInstallationTemplate", plural = "clickhouseinstallationtemplates")]
#[kube(namespaced)]
#[kube(status = "ClickHouseInstallationTemplateStatus")]
#[kube(schema = "disabled")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClickHouseInstallationTemplateSpec {
    /// allows configure multiple aspects and behavior for `clickhouse-server` instance and also allows describe multiple `clickhouse-server` clusters inside one `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<ClickHouseInstallationTemplateConfiguration>,
    /// define default behavior for whole ClickHouseInstallation, some behavior can be re-define on cluster, shard and replica level
    /// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specdefaults>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defaults: Option<ClickHouseInstallationTemplateDefaults>,
    /// Custom domain pattern which will be used for DNS names of `Service` or `Pod`.
    /// Typical use scenario - custom cluster domain in Kubernetes cluster
    /// Example: %s.svc.my.test
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceDomainPattern")]
    pub namespace_domain_pattern: Option<String>,
    /// Optional, allows tuning reconciling cycle for ClickhouseInstallation from clickhouse-operator side
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconciling: Option<ClickHouseInstallationTemplateReconciling>,
    /// In case 'RollingUpdate' specified, the operator will always restart ClickHouse pods during reconcile.
    /// This options is used in rare cases when force restart is required and is typically removed after the use in order to avoid unneeded restarts.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restart: Option<ClickHouseInstallationTemplateRestart>,
    /// Allows to stop all ClickHouse clusters defined in a CHI.
    /// Works as the following:
    ///  - When `stop` is `1` operator sets `Replicas: 0` in each StatefulSet. Thie leads to having all `Pods` and `Service` deleted. All PVCs are kept intact.
    ///  - When `stop` is `0` operator sets `Replicas: 1` and `Pod`s and `Service`s will created again and all retained PVCs will be attached to `Pod`s.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stop: Option<ClickHouseInstallationTemplateStop>,
    /// Suspend reconciliation of resources managed by a ClickHouse Installation.
    /// Works as the following:
    ///  - When `suspend` is `true` operator stops reconciling all resources.
    ///  - When `suspend` is `false` or not set, operator reconciles all resources.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suspend: Option<ClickHouseInstallationTemplateSuspend>,
    /// Allows to define custom taskID for CHI update and watch status of this update execution.
    /// Displayed in all .status.taskID* fields.
    /// By default (if not filled) every update of CHI manifest will generate random taskID
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskID")]
    pub task_id: Option<String>,
    /// allows define templates which will use for render Kubernetes resources like StatefulSet, ConfigMap, Service, PVC, by default, clickhouse-operator have own templates, but you can override it
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseInstallationTemplateTemplates>,
    /// Optional, applicable inside ClickHouseInstallationTemplate only.
    /// Defines current ClickHouseInstallationTemplate application options to target ClickHouseInstallation(s)."
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templating: Option<ClickHouseInstallationTemplateTemplating>,
    /// Allows to troubleshoot Pods during CrashLoopBack state.
    /// This may happen when wrong configuration applied, in this case `clickhouse-server` wouldn't start.
    /// Command within ClickHouse container is modified with `sleep` in order to avoid quick restarts
    /// and give time to troubleshoot via CLI.
    /// Liveness and Readiness probes are disabled as well.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub troubleshoot: Option<ClickHouseInstallationTemplateTroubleshoot>,
    /// list of `ClickHouseInstallationTemplate` (chit) resource names which will merge with current `CHI`
    /// manifest during render Kubernetes resources to create related ClickHouse clusters"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useTemplates")]
    pub use_templates: Option<Vec<ClickHouseInstallationTemplateUseTemplates>>,
}

/// allows configure multiple aspects and behavior for `clickhouse-server` instance and also allows describe multiple `clickhouse-server` clusters inside one `chi` resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfiguration {
    /// describes clusters layout and allows change settings on cluster-level, shard-level and replica-level
    /// every cluster is a set of StatefulSet, one StatefulSet contains only one Pod with `clickhouse-server`
    /// all Pods will rendered in <remote_server> part of ClickHouse configs, mounted from ConfigMap as `/etc/clickhouse-server/config.d/chop-generated-remote_servers.xml`
    /// Clusters will use for Distributed table engine, more details: <https://clickhouse.tech/docs/en/engines/table-engines/special/distributed/>
    /// If `cluster` contains zookeeper settings (could be inherited from top `chi` level), when you can create *ReplicatedMergeTree tables
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clusters: Option<Vec<ClickHouseInstallationTemplateConfigurationClusters>>,
    /// allows define content of any setting file inside each `Pod` during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// every key in this object is the file name
    /// every value in this object is the file content
    /// you can use `!!binary |` and base64 for binary files, see details here <https://yaml.org/type/binary.html>
    /// each key could contains prefix like {common}, {users}, {hosts} or config.d, users.d, conf.d, wrong prefixes will be ignored, subfolders also will be ignored
    /// More details: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/chi-examples/05-settings-05-files-nested.yaml>
    /// 
    /// any key could contains `valueFrom` with `secretKeyRef` which allow pass values from kubernetes secrets
    /// secrets will mounted into pod as separate volume in /etc/clickhouse-server/secrets.d/
    /// and will automatically update when update secret
    /// it useful for pass SSL certificates from cert-manager or similar tool
    /// look into <https://github.com/Altinity/clickhouse-operator/blob/master/docs/chi-examples/05-settings-01-overview.yaml> for examples
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// allows configure <yandex><profiles>..</profiles></yandex> section in each `Pod` during generate `ConfigMap` which will mount in `/etc/clickhouse-server/users.d/`
    /// you can configure any aspect of settings profile
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings-profiles/>
    /// Your yaml code will convert to XML, see examples <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specconfigurationprofiles>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profiles: Option<BTreeMap<String, serde_json::Value>>,
    /// allows configure <yandex><quotas>..</quotas></yandex> section in each `Pod` during generate `ConfigMap` which will mount in `/etc/clickhouse-server/users.d/`
    /// you can configure any aspect of resource quotas
    /// More details: <https://clickhouse.tech/docs/en/operations/quotas/>
    /// Your yaml code will convert to XML, see examples <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specconfigurationquotas>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quotas: Option<BTreeMap<String, serde_json::Value>>,
    /// allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in each `Pod` during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/`
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// Your yaml code will convert to XML, see examples <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specconfigurationsettings>
    /// 
    /// any key could contains `valueFrom` with `secretKeyRef` which allow pass password from kubernetes secrets
    /// look into <https://github.com/Altinity/clickhouse-operator/blob/master/docs/chi-examples/05-settings-01-overview.yaml> for examples
    /// 
    /// secret value will pass in `pod.spec.env`, and generate with from_env=XXX in XML in /etc/clickhouse-server/config.d/chop-generated-settings.xml
    /// it not allow automatically updates when updates `secret`, change spec.taskID for manually trigger reconcile cycle
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// allows configure <yandex><users>..</users></yandex> section in each `Pod` during generate `ConfigMap` which will mount in `/etc/clickhouse-server/users.d/`
    /// you can configure password hashed, authorization restrictions, database level security row filters etc.
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings-users/>
    /// Your yaml code will convert to XML, see examples <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specconfigurationusers>
    /// 
    /// any key could contains `valueFrom` with `secretKeyRef` which allow pass password from kubernetes secrets
    /// secret value will pass in `pod.spec.containers.evn`, and generate with from_env=XXX in XML in /etc/clickhouse-server/users.d/chop-generated-users.xml
    /// it not allow automatically updates when updates `secret`, change spec.taskID for manually trigger reconcile cycle
    /// 
    /// look into <https://github.com/Altinity/clickhouse-operator/blob/master/docs/chi-examples/05-settings-01-overview.yaml> for examples
    /// 
    /// any key with prefix `k8s_secret_` shall has value with format namespace/secret/key or secret/key
    /// in this case value from secret will write directly into XML tag during render *-usersd ConfigMap
    /// 
    /// any key with prefix `k8s_secret_env` shall has value with format namespace/secret/key or secret/key
    /// in this case value from secret will write into environment variable and write to XML tag via from_env=XXX
    /// 
    /// look into <https://github.com/Altinity/clickhouse-operator/blob/master/docs/chi-examples/05-settings-01-overview.yaml> for examples
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<BTreeMap<String, serde_json::Value>>,
    /// allows configure <yandex><zookeeper>..</zookeeper></yandex> section in each `Pod` during generate `ConfigMap` which will mounted in `/etc/clickhouse-server/config.d/`
    /// `clickhouse-operator` itself doesn't manage Zookeeper, please install Zookeeper separatelly look examples on <https://github.com/Altinity/clickhouse-operator/tree/master/deploy/zookeeper/>
    /// currently, zookeeper (or clickhouse-keeper replacement) used for *ReplicatedMergeTree table engines and for `distributed_ddl`
    /// More details: <https://clickhouse.tech/docs/en/operations/server-configuration-parameters/settings/#server-settings_zookeeper>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zookeeper: Option<ClickHouseInstallationTemplateConfigurationZookeeper>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClusters {
    /// optional, allows define content of any setting file inside each `Pod` on current cluster during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// override top-level `chi.spec.configuration.files`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, open insecure ports for cluster, defaults to "yes"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<ClickHouseInstallationTemplateConfigurationClustersInsecure>,
    /// describe current cluster layout, how much shards in cluster, how much replica in shard
    /// allows override settings on each shard and replica separatelly
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub layout: Option<ClickHouseInstallationTemplateConfigurationClustersLayout>,
    /// cluster name, used to identify set of servers and wide used during generate names of related Kubernetes resources
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specifies whether the Pod Disruption Budget (PDB) should be managed.
    /// During the next installation, if PDB management is enabled, the operator will
    /// attempt to retrieve any existing PDB. If none is found, it will create a new one
    /// and initiate a reconciliation loop. If PDB management is disabled, the existing PDB
    /// will remain intact, and the reconciliation loop will not be executed. By default,
    /// PDB management is enabled.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pdbManaged")]
    pub pdb_managed: Option<ClickHouseInstallationTemplateConfigurationClustersPdbManaged>,
    /// Pod eviction is allowed if at most "pdbMaxUnavailable" pods are unavailable after the eviction,
    /// i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions
    /// by specifying 0. This is a mutually exclusive setting with "minAvailable".
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pdbMaxUnavailable")]
    pub pdb_max_unavailable: Option<i64>,
    /// allow tuning reconciling process
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reconcile: Option<ClickHouseInstallationTemplateConfigurationClustersReconcile>,
    /// describes how schema is propagated within replicas and shards
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schemaPolicy")]
    pub schema_policy: Option<ClickHouseInstallationTemplateConfigurationClustersSchemaPolicy>,
    /// optional, shared secret value to secure cluster communications
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ClickHouseInstallationTemplateConfigurationClustersSecret>,
    /// optional, open secure ports for cluster
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<ClickHouseInstallationTemplateConfigurationClustersSecure>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in each `Pod` only in one cluster during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/`
    /// override top-level `chi.spec.configuration.settings`
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected cluster
    /// override top-level `chi.spec.configuration.templates`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseInstallationTemplateConfigurationClustersTemplates>,
    /// optional, allows configure <yandex><zookeeper>..</zookeeper></yandex> section in each `Pod` only in current ClickHouse cluster, during generate `ConfigMap` which will mounted in `/etc/clickhouse-server/config.d/`
    /// override top-level `chi.spec.configuration.zookeeper` settings
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zookeeper: Option<ClickHouseInstallationTemplateConfigurationClustersZookeeper>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersInsecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// describe current cluster layout, how much shards in cluster, how much replica in shard
/// allows override settings on each shard and replica separatelly
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersLayout {
    /// optional, allows override top-level `chi.spec.configuration` and cluster-level `chi.spec.configuration.clusters` configuration for each replica and each shard relates to selected replica, use it only if you fully understand what you do
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<Vec<ClickHouseInstallationTemplateConfigurationClustersLayoutReplicas>>,
    /// how much replicas in each shards for current cluster will run in Kubernetes,
    /// each replica is a separate `StatefulSet` which contains only one `Pod` with `clickhouse-server` instance,
    /// every shard contains 1 replica by default"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasCount")]
    pub replicas_count: Option<i64>,
    /// optional, allows override top-level `chi.spec.configuration`, cluster-level
    /// `chi.spec.configuration.clusters` settings for each shard separately,
    /// use it only if you fully understand what you do"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shards: Option<Vec<ClickHouseInstallationTemplateConfigurationClustersLayoutShards>>,
    /// how much shards for current ClickHouse cluster will run in Kubernetes,
    /// each shard contains shared-nothing part of data and contains set of replicas,
    /// cluster contains 1 shard by default"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardsCount")]
    pub shards_count: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersLayoutReplicas {
    /// optional, allows define content of any setting file inside each `Pod` only in one replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// override top-level `chi.spec.configuration.files` and cluster-level `chi.spec.configuration.clusters.files`, will ignore if `chi.spec.configuration.clusters.layout.shards` presents
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, by default replica name is generated, but you can override it and setup custom name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in `Pod` only in one replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/conf.d/`
    /// override top-level `chi.spec.configuration.settings`, cluster-level `chi.spec.configuration.clusters.settings` and will ignore if shard-level `chi.spec.configuration.clusters.layout.shards` present
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, list of shards related to current replica, will ignore if `chi.spec.configuration.clusters.layout.shards` presents
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shards: Option<Vec<ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasShards>>,
    /// optional, count of shards related to current replica, you can override each shard behavior on low-level `chi.spec.configuration.clusters.layout.replicas.shards`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardsCount")]
    pub shards_count: Option<i64>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
    /// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasTemplates>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasShards {
    /// optional, allows define content of any setting file inside each `Pod` only in one shard related to current replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// override top-level `chi.spec.configuration.files` and cluster-level `chi.spec.configuration.clusters.files`, will ignore if `chi.spec.configuration.clusters.layout.shards` presents
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, setup `Pod.spec.containers.ports` with name `http` for selected shard, override `chi.spec.templates.hostTemplates.spec.httpPort`
    /// allows connect to `clickhouse-server` via HTTP protocol via kubernetes `Service`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsPort")]
    pub https_port: Option<i64>,
    /// optional, open insecure ports for cluster, defaults to "yes"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasShardsInsecure>,
    /// optional, setup `Pod.spec.containers.ports` with name `interserver` for selected shard, override `chi.spec.templates.hostTemplates.spec.interserverHTTPPort`
    /// allows connect between replicas inside same shard during fetch replicated data parts HTTP protocol
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interserverHTTPPort")]
    pub interserver_http_port: Option<i64>,
    /// optional, by default shard name is generated, but you can override it and setup custom name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional, open secure ports
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasShardsSecure>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in `Pod` only in one shard related to current replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/conf.d/`
    /// override top-level `chi.spec.configuration.settings`, cluster-level `chi.spec.configuration.clusters.settings` and replica-level `chi.spec.configuration.clusters.layout.replicas.settings`
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, setup `Pod.spec.containers.ports` with name `tcp` for selected shard, override `chi.spec.templates.hostTemplates.spec.tcpPort`
    /// allows connect to `clickhouse-server` via TCP Native protocol via kubernetes `Service`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpPort")]
    pub tcp_port: Option<i64>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
    /// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates`, replica-level `chi.spec.configuration.clusters.layout.replicas.templates`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasShardsTemplates>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPort")]
    pub tls_port: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasShardsInsecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasShardsSecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
/// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates`, replica-level `chi.spec.configuration.clusters.layout.replicas.templates`
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasShardsTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
/// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates`
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersLayoutReplicasTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersLayoutShards {
    /// DEPRECATED - to be removed soon
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "definitionType")]
    pub definition_type: Option<String>,
    /// optional, allows define content of any setting file inside each `Pod` only in one shard during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// override top-level `chi.spec.configuration.files` and cluster-level `chi.spec.configuration.clusters.files`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, `true` by default when `chi.spec.configuration.clusters[].layout.ReplicaCount` > 1 and 0 otherwise
    /// allows setup <internal_replication> setting which will use during insert into tables with `Distributed` engine for insert only in one live replica and other replicas will download inserted data during replication,
    /// will apply in <remote_servers> inside ConfigMap which will mount in /etc/clickhouse-server/config.d/chop-generated-remote_servers.xml
    /// More details: <https://clickhouse.tech/docs/en/engines/table-engines/special/distributed/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalReplication")]
    pub internal_replication: Option<ClickHouseInstallationTemplateConfigurationClustersLayoutShardsInternalReplication>,
    /// optional, by default shard name is generated, but you can override it and setup custom name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional, allows override behavior for selected replicas from cluster-level `chi.spec.configuration.clusters` and shard-level `chi.spec.configuration.clusters.layout.shards`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<Vec<ClickHouseInstallationTemplateConfigurationClustersLayoutShardsReplicas>>,
    /// optional, how much replicas in selected shard for selected ClickHouse cluster will run in Kubernetes, each replica is a separate `StatefulSet` which contains only one `Pod` with `clickhouse-server` instance,
    /// shard contains 1 replica by default
    /// override cluster-level `chi.spec.configuration.clusters.layout.replicasCount`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasCount")]
    pub replicas_count: Option<i64>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in each `Pod` only in one shard during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/`
    /// override top-level `chi.spec.configuration.settings` and cluster-level `chi.spec.configuration.clusters.settings`
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected shard
    /// override top-level `chi.spec.configuration.templates` and cluster-level `chi.spec.configuration.clusters.templates`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseInstallationTemplateConfigurationClustersLayoutShardsTemplates>,
    /// optional, 1 by default, allows setup shard <weight> setting which will use during insert into tables with `Distributed` engine,
    /// will apply in <remote_servers> inside ConfigMap which will mount in /etc/clickhouse-server/config.d/chop-generated-remote_servers.xml
    /// More details: <https://clickhouse.tech/docs/en/engines/table-engines/special/distributed/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersLayoutShardsInternalReplication {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersLayoutShardsReplicas {
    /// optional, allows define content of any setting file inside `Pod` only in one replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// override top-level `chi.spec.configuration.files`, cluster-level `chi.spec.configuration.clusters.files` and shard-level `chi.spec.configuration.clusters.layout.shards.files`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, setup `Pod.spec.containers.ports` with name `http` for selected replica, override `chi.spec.templates.hostTemplates.spec.httpPort`
    /// allows connect to `clickhouse-server` via HTTP protocol via kubernetes `Service`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsPort")]
    pub https_port: Option<i64>,
    /// optional, open insecure ports for cluster, defaults to "yes"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<ClickHouseInstallationTemplateConfigurationClustersLayoutShardsReplicasInsecure>,
    /// optional, setup `Pod.spec.containers.ports` with name `interserver` for selected replica, override `chi.spec.templates.hostTemplates.spec.interserverHTTPPort`
    /// allows connect between replicas inside same shard during fetch replicated data parts HTTP protocol
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interserverHTTPPort")]
    pub interserver_http_port: Option<i64>,
    /// optional, by default replica name is generated, but you can override it and setup custom name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional, open secure ports
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<ClickHouseInstallationTemplateConfigurationClustersLayoutShardsReplicasSecure>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in `Pod` only in one replica during generate `ConfigMap` which will mount in `/etc/clickhouse-server/conf.d/`
    /// override top-level `chi.spec.configuration.settings`, cluster-level `chi.spec.configuration.clusters.settings` and shard-level `chi.spec.configuration.clusters.layout.shards.settings`
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, setup `Pod.spec.containers.ports` with name `tcp` for selected replica, override `chi.spec.templates.hostTemplates.spec.tcpPort`
    /// allows connect to `clickhouse-server` via TCP Native protocol via kubernetes `Service`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpPort")]
    pub tcp_port: Option<i64>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
    /// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates` and shard-level `chi.spec.configuration.clusters.layout.shards.templates`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseInstallationTemplateConfigurationClustersLayoutShardsReplicasTemplates>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPort")]
    pub tls_port: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersLayoutShardsReplicasInsecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersLayoutShardsReplicasSecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected replica
/// override top-level `chi.spec.configuration.templates`, cluster-level `chi.spec.configuration.clusters.templates` and shard-level `chi.spec.configuration.clusters.layout.shards.templates`
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersLayoutShardsReplicasTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected shard
/// override top-level `chi.spec.configuration.templates` and cluster-level `chi.spec.configuration.clusters.templates`
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersLayoutShardsTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersPdbManaged {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// allow tuning reconciling process
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersReconcile {
    /// runtime parameters for clickhouse-operator process which are used during reconcile cycle
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub runtime: Option<ClickHouseInstallationTemplateConfigurationClustersReconcileRuntime>,
}

/// runtime parameters for clickhouse-operator process which are used during reconcile cycle
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersReconcileRuntime {
    /// The maximum percentage of cluster shards that may be reconciled in parallel, 50 percent by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconcileShardsMaxConcurrencyPercent")]
    pub reconcile_shards_max_concurrency_percent: Option<i64>,
    /// How many goroutines will be used to reconcile shards of a cluster in parallel, 1 by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconcileShardsThreadsNumber")]
    pub reconcile_shards_threads_number: Option<i64>,
}

/// describes how schema is propagated within replicas and shards
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersSchemaPolicy {
    /// how schema is propagated within a replica
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replica: Option<ClickHouseInstallationTemplateConfigurationClustersSchemaPolicyReplica>,
    /// how schema is propagated between shards
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shard: Option<ClickHouseInstallationTemplateConfigurationClustersSchemaPolicyShard>,
}

/// describes how schema is propagated within replicas and shards
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersSchemaPolicyReplica {
    #[serde(rename = "")]
    KopiumEmpty,
    None,
    All,
}

/// describes how schema is propagated within replicas and shards
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersSchemaPolicyShard {
    #[serde(rename = "")]
    KopiumEmpty,
    None,
    All,
    DistributedTablesOnly,
}

/// optional, shared secret value to secure cluster communications
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersSecret {
    /// Auto-generate shared secret value to secure cluster communications
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auto: Option<ClickHouseInstallationTemplateConfigurationClustersSecretAuto>,
    /// Cluster shared secret value in plain text
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Cluster shared secret source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ClickHouseInstallationTemplateConfigurationClustersSecretValueFrom>,
}

/// optional, shared secret value to secure cluster communications
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersSecretAuto {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// Cluster shared secret source
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersSecretValueFrom {
    /// Selects a key of a secret in the clickhouse installation namespace.
    /// Should not be used if value is not empty.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<ClickHouseInstallationTemplateConfigurationClustersSecretValueFromSecretKeyRef>,
}

/// Selects a key of a secret in the clickhouse installation namespace.
/// Should not be used if value is not empty.
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersSecretValueFromSecretKeyRef {
    /// The key of the secret to select from. Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info:
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names>
    /// 
    pub name: String,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersSecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to selected cluster
/// override top-level `chi.spec.configuration.templates`
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

/// optional, allows configure <yandex><zookeeper>..</zookeeper></yandex> section in each `Pod` only in current ClickHouse cluster, during generate `ConfigMap` which will mounted in `/etc/clickhouse-server/config.d/`
/// override top-level `chi.spec.configuration.zookeeper` settings
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersZookeeper {
    /// optional access credentials string with `user:password` format used when use digest authorization in Zookeeper
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<String>,
    /// describe every available zookeeper cluster node for interaction
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nodes: Option<Vec<ClickHouseInstallationTemplateConfigurationClustersZookeeperNodes>>,
    /// one operation timeout during Zookeeper transactions
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation_timeout_ms: Option<i64>,
    /// optional root znode path inside zookeeper to store ClickHouse related data (replication queue or distributed DDL)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub root: Option<String>,
    /// session timeout during connect to Zookeeper
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_timeout_ms: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationClustersZookeeperNodes {
    /// availability zone for Zookeeper node
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZone")]
    pub availability_zone: Option<String>,
    /// dns name or ip address for Zookeeper node
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// TCP port which used to connect to Zookeeper node
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// if a secure connection to Zookeeper is required
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<ClickHouseInstallationTemplateConfigurationClustersZookeeperNodesSecure>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationClustersZookeeperNodesSecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// allows configure <yandex><zookeeper>..</zookeeper></yandex> section in each `Pod` during generate `ConfigMap` which will mounted in `/etc/clickhouse-server/config.d/`
/// `clickhouse-operator` itself doesn't manage Zookeeper, please install Zookeeper separatelly look examples on <https://github.com/Altinity/clickhouse-operator/tree/master/deploy/zookeeper/>
/// currently, zookeeper (or clickhouse-keeper replacement) used for *ReplicatedMergeTree table engines and for `distributed_ddl`
/// More details: <https://clickhouse.tech/docs/en/operations/server-configuration-parameters/settings/#server-settings_zookeeper>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationZookeeper {
    /// optional access credentials string with `user:password` format used when use digest authorization in Zookeeper
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub identity: Option<String>,
    /// describe every available zookeeper cluster node for interaction
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nodes: Option<Vec<ClickHouseInstallationTemplateConfigurationZookeeperNodes>>,
    /// one operation timeout during Zookeeper transactions
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operation_timeout_ms: Option<i64>,
    /// optional root znode path inside zookeeper to store ClickHouse related data (replication queue or distributed DDL)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub root: Option<String>,
    /// session timeout during connect to Zookeeper
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub session_timeout_ms: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateConfigurationZookeeperNodes {
    /// availability zone for Zookeeper node
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availabilityZone")]
    pub availability_zone: Option<String>,
    /// dns name or ip address for Zookeeper node
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    /// TCP port which used to connect to Zookeeper node
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i64>,
    /// if a secure connection to Zookeeper is required
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<ClickHouseInstallationTemplateConfigurationZookeeperNodesSecure>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateConfigurationZookeeperNodesSecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// define default behavior for whole ClickHouseInstallation, some behavior can be re-define on cluster, shard and replica level
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specdefaults>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateDefaults {
    /// allows change `<yandex><distributed_ddl></distributed_ddl></yandex>` settings
    /// More info: <https://clickhouse.tech/docs/en/operations/server-configuration-parameters/settings/#server-settings-distributed_ddl>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "distributedDDL")]
    pub distributed_ddl: Option<ClickHouseInstallationTemplateDefaultsDistributedDdl>,
    /// define should replicas be specified by FQDN in `<host></host>`.
    /// In case of "no" will use short hostname and clickhouse-server will use kubernetes default suffixes for DNS lookup
    /// "no" by default
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicasUseFQDN")]
    pub replicas_use_fqdn: Option<ClickHouseInstallationTemplateDefaultsReplicasUseFqdn>,
    /// default storage management options
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageManagement")]
    pub storage_management: Option<ClickHouseInstallationTemplateDefaultsStorageManagement>,
    /// optional, configuration of the templates names which will use for generate Kubernetes resources according to one or more ClickHouse clusters described in current ClickHouseInstallation (chi) resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseInstallationTemplateDefaultsTemplates>,
}

/// allows change `<yandex><distributed_ddl></distributed_ddl></yandex>` settings
/// More info: <https://clickhouse.tech/docs/en/operations/server-configuration-parameters/settings/#server-settings-distributed_ddl>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateDefaultsDistributedDdl {
    /// Settings from this profile will be used to execute DDL queries
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profile: Option<String>,
}

/// define default behavior for whole ClickHouseInstallation, some behavior can be re-define on cluster, shard and replica level
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#specdefaults>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateDefaultsReplicasUseFqdn {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// default storage management options
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateDefaultsStorageManagement {
    /// defines `PVC` provisioner - be it StatefulSet or the Operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provisioner: Option<ClickHouseInstallationTemplateDefaultsStorageManagementProvisioner>,
    /// defines behavior of `PVC` deletion.
    /// `Delete` by default, if `Retain` specified then `PVC` will be kept when deleting StatefulSet
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reclaimPolicy")]
    pub reclaim_policy: Option<ClickHouseInstallationTemplateDefaultsStorageManagementReclaimPolicy>,
}

/// default storage management options
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateDefaultsStorageManagementProvisioner {
    #[serde(rename = "")]
    KopiumEmpty,
    StatefulSet,
    Operator,
}

/// default storage management options
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateDefaultsStorageManagementReclaimPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// optional, configuration of the templates names which will use for generate Kubernetes resources according to one or more ClickHouse clusters described in current ClickHouseInstallation (chi) resource
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateDefaultsTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

/// Optional, allows tuning reconciling cycle for ClickhouseInstallation from clickhouse-operator side
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconciling {
    /// Optional, defines behavior for cleanup Kubernetes resources during reconcile cycle
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cleanup: Option<ClickHouseInstallationTemplateReconcilingCleanup>,
    /// Timeout in seconds for `clickhouse-operator` to wait for modified `ConfigMap` to propagate into the `Pod`
    /// More details: <https://kubernetes.io/docs/concepts/configuration/configmap/#mounted-configmaps-are-updated-automatically>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapPropagationTimeout")]
    pub config_map_propagation_timeout: Option<i64>,
    /// macros parameters
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub macros: Option<ClickHouseInstallationTemplateReconcilingMacros>,
    /// DISCUSSED TO BE DEPRECATED
    /// Syntax sugar
    /// Overrides all three 'reconcile.host.wait.{exclude, queries, include}' values from the operator's config
    /// Possible values:
    ///  - wait - should wait to exclude host, complete queries and include host back into the cluster
    ///  - nowait - should NOT wait to exclude host, complete queries and include host back into the cluster
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClickHouseInstallationTemplateReconcilingPolicy>,
    /// runtime parameters for clickhouse-operator process which are used during reconcile cycle
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub runtime: Option<ClickHouseInstallationTemplateReconcilingRuntime>,
}

/// Optional, defines behavior for cleanup Kubernetes resources during reconcile cycle
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingCleanup {
    /// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
    /// Default behavior is `Retain`"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconcileFailedObjects")]
    pub reconcile_failed_objects: Option<ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjects>,
    /// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
    /// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
    /// Default behavior is `Delete`"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unknownObjects")]
    pub unknown_objects: Option<ClickHouseInstallationTemplateReconcilingCleanupUnknownObjects>,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjects {
    /// Behavior policy for failed ConfigMap, `Retain` by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjectsConfigMap>,
    /// Behavior policy for failed PVC, `Retain` by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pvc: Option<ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjectsPvc>,
    /// Behavior policy for failed Service, `Retain` by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjectsService>,
    /// Behavior policy for failed StatefulSet, `Retain` by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulSet")]
    pub stateful_set: Option<ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjectsStatefulSet>,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjectsConfigMap {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjectsPvc {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjectsService {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with Kubernetes resources which are failed during reconcile.
/// Default behavior is `Retain`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingCleanupReconcileFailedObjectsStatefulSet {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingCleanupUnknownObjects {
    /// Behavior policy for unknown ConfigMap, `Delete` by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ClickHouseInstallationTemplateReconcilingCleanupUnknownObjectsConfigMap>,
    /// Behavior policy for unknown PVC, `Delete` by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pvc: Option<ClickHouseInstallationTemplateReconcilingCleanupUnknownObjectsPvc>,
    /// Behavior policy for unknown Service, `Delete` by default
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<ClickHouseInstallationTemplateReconcilingCleanupUnknownObjectsService>,
    /// Behavior policy for unknown StatefulSet, `Delete` by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "statefulSet")]
    pub stateful_set: Option<ClickHouseInstallationTemplateReconcilingCleanupUnknownObjectsStatefulSet>,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingCleanupUnknownObjectsConfigMap {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingCleanupUnknownObjectsPvc {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingCleanupUnknownObjectsService {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Describes what clickhouse-operator should do with found Kubernetes resources which should be managed by clickhouse-operator,
/// but do not have `ownerReference` to any currently managed `ClickHouseInstallation` resource.
/// Default behavior is `Delete`"
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingCleanupUnknownObjectsStatefulSet {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// macros parameters
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingMacros {
    /// sections behaviour for macros
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sections: Option<ClickHouseInstallationTemplateReconcilingMacrosSections>,
}

/// sections behaviour for macros
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingMacrosSections {
    /// sections behaviour for macros on files
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsFiles>,
    /// sections behaviour for macros on profiles
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profiles: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsProfiles>,
    /// sections behaviour for macros on quotas
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub quotas: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsQuotas>,
    /// sections behaviour for macros on settings
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsSettings>,
    /// sections behaviour for macros on users
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsUsers>,
}

/// sections behaviour for macros on files
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingMacrosSectionsFiles {
    /// enabled or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsFilesEnabled>,
}

/// sections behaviour for macros on files
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingMacrosSectionsFilesEnabled {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// sections behaviour for macros on profiles
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingMacrosSectionsProfiles {
    /// enabled or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsProfilesEnabled>,
}

/// sections behaviour for macros on profiles
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingMacrosSectionsProfilesEnabled {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// sections behaviour for macros on quotas
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingMacrosSectionsQuotas {
    /// enabled or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsQuotasEnabled>,
}

/// sections behaviour for macros on quotas
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingMacrosSectionsQuotasEnabled {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// sections behaviour for macros on settings
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingMacrosSectionsSettings {
    /// enabled or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsSettingsEnabled>,
}

/// sections behaviour for macros on settings
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingMacrosSectionsSettingsEnabled {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// sections behaviour for macros on users
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingMacrosSectionsUsers {
    /// enabled or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<ClickHouseInstallationTemplateReconcilingMacrosSectionsUsersEnabled>,
}

/// sections behaviour for macros on users
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingMacrosSectionsUsersEnabled {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// Optional, allows tuning reconciling cycle for ClickhouseInstallation from clickhouse-operator side
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateReconcilingPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "wait")]
    Wait,
    #[serde(rename = "nowait")]
    Nowait,
}

/// runtime parameters for clickhouse-operator process which are used during reconcile cycle
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateReconcilingRuntime {
    /// The maximum percentage of cluster shards that may be reconciled in parallel, 50 percent by default.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconcileShardsMaxConcurrencyPercent")]
    pub reconcile_shards_max_concurrency_percent: Option<i64>,
    /// How many goroutines will be used to reconcile shards of a cluster in parallel, 1 by default
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reconcileShardsThreadsNumber")]
    pub reconcile_shards_threads_number: Option<i64>,
}

/// Specification of the desired behavior of one or more ClickHouse clusters
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateRestart {
    #[serde(rename = "")]
    KopiumEmpty,
    RollingUpdate,
}

/// Specification of the desired behavior of one or more ClickHouse clusters
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateStop {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// Specification of the desired behavior of one or more ClickHouse clusters
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateSuspend {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// allows define templates which will use for render Kubernetes resources like StatefulSet, ConfigMap, Service, PVC, by default, clickhouse-operator have own templates, but you can override it
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplates {
    /// hostTemplate will use during apply to generate `clickhose-server` config files
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplates")]
    pub host_templates: Option<Vec<ClickHouseInstallationTemplateTemplatesHostTemplates>>,
    /// podTemplate will use during render `Pod` inside `StatefulSet.spec` and allows define rendered `Pod.spec`, pod scheduling distribution and pod zone
    /// More information: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#spectemplatespodtemplates>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplates")]
    pub pod_templates: Option<Vec<ClickHouseInstallationTemplateTemplatesPodTemplates>>,
    /// allows define template for rendering `Service` which would get endpoint from Pods which scoped chi-wide, cluster-wide, shard-wide, replica-wide level
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<ClickHouseInstallationTemplateTemplatesServiceTemplates>>,
    /// allows define template for rendering `PVC` kubernetes resource, which would use inside `Pod` for mount clickhouse `data`, clickhouse `logs` or something else
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Option<Vec<ClickHouseInstallationTemplateTemplatesVolumeClaimTemplates>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplatesHostTemplates {
    /// template name, could use to link inside top-level `chi.spec.defaults.templates.hostTemplate`, cluster-level `chi.spec.configuration.clusters.templates.hostTemplate`, shard-level `chi.spec.configuration.clusters.layout.shards.temlates.hostTemplate`, replica-level `chi.spec.configuration.clusters.layout.replicas.templates.hostTemplate`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// define how will distribute numeric values of named ports in `Pod.spec.containers.ports` and clickhouse-server configs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "portDistribution")]
    pub port_distribution: Option<Vec<ClickHouseInstallationTemplateTemplatesHostTemplatesPortDistribution>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<ClickHouseInstallationTemplateTemplatesHostTemplatesSpec>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplatesHostTemplatesPortDistribution {
    /// type of distribution, when `Unspecified` (default value) then all listen ports on clickhouse-server configuration in all Pods will have the same value, when `ClusterScopeIndex` then ports will increment to offset from base value depends on shard and replica index inside cluster with combination of `chi.spec.templates.podTemlates.spec.HostNetwork` it allows setup ClickHouse cluster inside Kubernetes and provide access via external network bypass Kubernetes internal network
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ClickHouseInstallationTemplateTemplatesHostTemplatesPortDistributionType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTemplatesHostTemplatesPortDistributionType {
    #[serde(rename = "")]
    KopiumEmpty,
    Unspecified,
    ClusterScopeIndex,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplatesHostTemplatesSpec {
    /// optional, allows define content of any setting file inside each `Pod` where this template will apply during generate `ConfigMap` which will mount in `/etc/clickhouse-server/config.d/` or `/etc/clickhouse-server/conf.d/` or `/etc/clickhouse-server/users.d/`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, setup `http_port` inside `clickhouse-server` settings for each Pod where current template will apply
    /// if specified, should have equal value with `chi.spec.templates.podTemplates.spec.containers.ports[name=http]`
    /// More info: <https://clickhouse.tech/docs/en/interfaces/http/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpPort")]
    pub http_port: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpsPort")]
    pub https_port: Option<i64>,
    /// optional, open insecure ports for cluster, defaults to "yes"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insecure: Option<ClickHouseInstallationTemplateTemplatesHostTemplatesSpecInsecure>,
    /// optional, setup `interserver_http_port` inside `clickhouse-server` settings for each Pod where current template will apply
    /// if specified, should have equal value with `chi.spec.templates.podTemplates.spec.containers.ports[name=interserver]`
    /// More info: <https://clickhouse.tech/docs/en/operations/server-configuration-parameters/settings/#interserver-http-port>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "interserverHTTPPort")]
    pub interserver_http_port: Option<i64>,
    /// by default, hostname will generate, but this allows define custom name for each `clickhuse-server`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// optional, open secure ports
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<ClickHouseInstallationTemplateTemplatesHostTemplatesSpecSecure>,
    /// optional, allows configure `clickhouse-server` settings inside <yandex>...</yandex> tag in each `Pod` where this template will apply during generate `ConfigMap` which will mount in `/etc/clickhouse-server/conf.d/`
    /// More details: <https://clickhouse.tech/docs/en/operations/settings/settings/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
    /// optional, setup `tcp_port` inside `clickhouse-server` settings for each Pod where current template will apply
    /// if specified, should have equal value with `chi.spec.templates.podTemplates.spec.containers.ports[name=tcp]`
    /// More info: <https://clickhouse.tech/docs/en/interfaces/tcp/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpPort")]
    pub tcp_port: Option<i64>,
    /// be careful, this part of CRD allows override template inside template, don't use it if you don't understand what you do
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub templates: Option<ClickHouseInstallationTemplateTemplatesHostTemplatesSpecTemplates>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsPort")]
    pub tls_port: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTemplatesHostTemplatesSpecInsecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTemplatesHostTemplatesSpecSecure {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

/// be careful, this part of CRD allows override template inside template, don't use it if you don't understand what you do
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplatesHostTemplatesSpecTemplates {
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterServiceTemplate")]
    pub cluster_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataVolumeClaimTemplate")]
    pub data_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.hostTemplates, which will apply to configure every `clickhouse-server` instance during render ConfigMap resources which will mount into `Pod`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostTemplate")]
    pub host_template: Option<String>,
    /// optional, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse log directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logVolumeClaimTemplate")]
    pub log_volume_claim_template: Option<String>,
    /// optional, template name from chi.spec.templates.podTemplates, allows customization each `Pod` resource during render and reconcile each StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTemplate")]
    pub pod_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each replica inside each shard inside each clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceTemplate")]
    pub replica_service_template: Option<String>,
    /// optional, template name from chi.spec.templates.serviceTemplates. used for customization of the `Service` resource, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplate")]
    pub service_template: Option<String>,
    /// optional, template names from chi.spec.templates.serviceTemplates. used for customization of the `Service` resources, created by `clickhouse-operator` to cover all clusters in whole `chi` resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceTemplates")]
    pub service_templates: Option<Vec<String>>,
    /// optional, template name from chi.spec.templates.serviceTemplates, allows customization for each `Service` resource which will created by `clickhouse-operator` which cover each shard inside clickhouse cluster described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "shardServiceTemplate")]
    pub shard_service_template: Option<String>,
    /// optional, alias for dataVolumeClaimTemplate, template name from chi.spec.templates.volumeClaimTemplates, allows customization each `PVC` which will mount for clickhouse data directory in each `Pod` during render and reconcile every StatefulSet.spec resource described in `chi.spec.configuration.clusters`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplate")]
    pub volume_claim_template: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplatesPodTemplates {
    /// DEPRECATED, shortcut for `chi.spec.templates.podTemplates.spec.affinity.podAntiAffinity`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribution: Option<ClickHouseInstallationTemplateTemplatesPodTemplatesDistribution>,
    /// allows define format for generated `Pod` name, look to <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#spectemplatesservicetemplates> for details about available template variables
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generateName")]
    pub generate_name: Option<String>,
    /// allows pass standard object's metadata from template to Pod
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, serde_json::Value>>,
    /// template name, could use to link inside top-level `chi.spec.defaults.templates.podTemplate`, cluster-level `chi.spec.configuration.clusters.templates.podTemplate`, shard-level `chi.spec.configuration.clusters.layout.shards.temlates.podTemplate`, replica-level `chi.spec.configuration.clusters.layout.replicas.templates.podTemplate`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// define ClickHouse Pod distribution policy between Kubernetes Nodes inside Shard, Replica, Namespace, CHI, another ClickHouse cluster
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podDistribution")]
    pub pod_distribution: Option<Vec<ClickHouseInstallationTemplateTemplatesPodTemplatesPodDistribution>>,
    /// allows define whole Pod.spec inside StaefulSet.spec, look to <https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates> for details
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
    /// allows define custom zone name and will separate ClickHouse `Pods` between nodes, shortcut for `chi.spec.templates.podTemplates.spec.affinity.podAntiAffinity`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zone: Option<ClickHouseInstallationTemplateTemplatesPodTemplatesZone>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTemplatesPodTemplatesDistribution {
    #[serde(rename = "")]
    KopiumEmpty,
    Unspecified,
    OnePerHost,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplatesPodTemplatesPodDistribution {
    /// define, how much ClickHouse Pods could be inside selected scope with selected distribution type
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub number: Option<i64>,
    /// scope for apply each podDistribution
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<ClickHouseInstallationTemplateTemplatesPodTemplatesPodDistributionScope>,
    /// use for inter-pod affinity look to `pod.spec.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution.podAffinityTerm.topologyKey`,
    /// more info: <https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity">
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "topologyKey")]
    pub topology_key: Option<String>,
    /// you can define multiple affinity policy types
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ClickHouseInstallationTemplateTemplatesPodTemplatesPodDistributionType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTemplatesPodTemplatesPodDistributionScope {
    #[serde(rename = "")]
    KopiumEmpty,
    Unspecified,
    Shard,
    Replica,
    Cluster,
    ClickHouseInstallation,
    Namespace,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTemplatesPodTemplatesPodDistributionType {
    #[serde(rename = "")]
    KopiumEmpty,
    Unspecified,
    ClickHouseAntiAffinity,
    ShardAntiAffinity,
    ReplicaAntiAffinity,
    AnotherNamespaceAntiAffinity,
    AnotherClickHouseInstallationAntiAffinity,
    AnotherClusterAntiAffinity,
    MaxNumberPerNode,
    NamespaceAffinity,
    ClickHouseInstallationAffinity,
    ClusterAffinity,
    ShardAffinity,
    ReplicaAffinity,
    PreviousTailAffinity,
    CircularReplication,
}

/// allows define custom zone name and will separate ClickHouse `Pods` between nodes, shortcut for `chi.spec.templates.podTemplates.spec.affinity.podAntiAffinity`
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplatesPodTemplatesZone {
    /// optional, if defined, allows select kubernetes nodes by label with `name` equal `key`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// optional, if defined, allows select kubernetes nodes by label with `value` in `values`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplatesServiceTemplates {
    /// allows define format for generated `Service` name,
    /// look to <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md#spectemplatesservicetemplates>
    /// for details about available template variables"
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "generateName")]
    pub generate_name: Option<String>,
    /// allows pass standard object's metadata from template to Service
    /// Could be use for define specificly for Cloud Provider metadata which impact to behavior of service
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, serde_json::Value>>,
    /// template name, could use to link inside
    /// chi-level `chi.spec.defaults.templates.serviceTemplate`
    /// cluster-level `chi.spec.configuration.clusters.templates.clusterServiceTemplate`
    /// shard-level `chi.spec.configuration.clusters.layout.shards.temlates.shardServiceTemplate`
    /// replica-level `chi.spec.configuration.clusters.layout.replicas.templates.replicaServiceTemplate` or `chi.spec.configuration.clusters.layout.shards.replicas.replicaServiceTemplate`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// describe behavior of generated Service
    /// More info: <https://kubernetes.io/docs/concepts/services-networking/service/>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplatesVolumeClaimTemplates {
    /// allows to pass standard object's metadata from template to PVC
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BTreeMap<String, serde_json::Value>>,
    /// template name, could use to link inside
    /// top-level `chi.spec.defaults.templates.dataVolumeClaimTemplate` or `chi.spec.defaults.templates.logVolumeClaimTemplate`,
    /// cluster-level `chi.spec.configuration.clusters.templates.dataVolumeClaimTemplate` or `chi.spec.configuration.clusters.templates.logVolumeClaimTemplate`,
    /// shard-level `chi.spec.configuration.clusters.layout.shards.temlates.dataVolumeClaimTemplate` or `chi.spec.configuration.clusters.layout.shards.temlates.logVolumeClaimTemplate`
    /// replica-level `chi.spec.configuration.clusters.layout.replicas.templates.dataVolumeClaimTemplate` or `chi.spec.configuration.clusters.layout.replicas.templates.logVolumeClaimTemplate`
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// defines `PVC` provisioner - be it StatefulSet or the Operator
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub provisioner: Option<ClickHouseInstallationTemplateTemplatesVolumeClaimTemplatesProvisioner>,
    /// defines behavior of `PVC` deletion.
    /// `Delete` by default, if `Retain` specified then `PVC` will be kept when deleting StatefulSet
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reclaimPolicy")]
    pub reclaim_policy: Option<ClickHouseInstallationTemplateTemplatesVolumeClaimTemplatesReclaimPolicy>,
    /// allows define all aspects of `PVC` resource
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spec: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTemplatesVolumeClaimTemplatesProvisioner {
    #[serde(rename = "")]
    KopiumEmpty,
    StatefulSet,
    Operator,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTemplatesVolumeClaimTemplatesReclaimPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    Retain,
    Delete,
}

/// Optional, applicable inside ClickHouseInstallationTemplate only.
/// Defines current ClickHouseInstallationTemplate application options to target ClickHouseInstallation(s)."
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateTemplating {
    /// Optional, defines selector for ClickHouseInstallation(s) to be templated with ClickhouseInstallationTemplate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chiSelector")]
    pub chi_selector: Option<BTreeMap<String, serde_json::Value>>,
    /// When defined as `auto` inside ClickhouseInstallationTemplate, this ClickhouseInstallationTemplate
    /// will be auto-added into ClickHouseInstallation, selectable by `chiSelector`.
    /// Default value is `manual`, meaning ClickHouseInstallation should request this ClickhouseInstallationTemplate explicitly.
    /// 
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub policy: Option<ClickHouseInstallationTemplateTemplatingPolicy>,
}

/// Optional, applicable inside ClickHouseInstallationTemplate only.
/// Defines current ClickHouseInstallationTemplate application options to target ClickHouseInstallation(s)."
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTemplatingPolicy {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "auto")]
    Auto,
    #[serde(rename = "manual")]
    Manual,
}

/// Specification of the desired behavior of one or more ClickHouse clusters
/// More info: <https://github.com/Altinity/clickhouse-operator/blob/master/docs/custom_resource_explained.md>
/// 
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateTroubleshoot {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "0")]
    r#_0,
    #[serde(rename = "1")]
    r#_1,
    False,
    #[serde(rename = "false")]
    FalseX,
    True,
    #[serde(rename = "true")]
    TrueX,
    No,
    #[serde(rename = "no")]
    NoX,
    Yes,
    #[serde(rename = "yes")]
    YesX,
    Off,
    #[serde(rename = "off")]
    OffX,
    On,
    #[serde(rename = "on")]
    OnX,
    Disable,
    #[serde(rename = "disable")]
    DisableX,
    Enable,
    #[serde(rename = "enable")]
    EnableX,
    Disabled,
    #[serde(rename = "disabled")]
    DisabledX,
    Enabled,
    #[serde(rename = "enabled")]
    EnabledX,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateUseTemplates {
    /// name of `ClickHouseInstallationTemplate` (chit) resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Kubernetes namespace where need search `chit` resource, depending on `watchNamespaces` settings in `clichouse-operator`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// optional, current strategy is only merge, and current `chi` settings have more priority than merged template `chit`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useType")]
    pub use_type: Option<ClickHouseInstallationTemplateUseTemplatesUseType>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum ClickHouseInstallationTemplateUseTemplatesUseType {
    #[serde(rename = "")]
    KopiumEmpty,
    #[serde(rename = "merge")]
    Merge,
}

/// Status contains many fields like a normalized configuration, clickhouse-operator version, current action and all applied action list, current taskID and all applied taskIDs and other
/// 
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq)]
pub struct ClickHouseInstallationTemplateStatus {
    /// Action
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<String>,
    /// Actions
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<String>>,
    /// Operator git commit SHA
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chop-commit")]
    pub chop_commit: Option<String>,
    /// Operator build date
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chop-date")]
    pub chop_date: Option<String>,
    /// IP address of the operator's pod which managed this resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chop-ip")]
    pub chop_ip: Option<String>,
    /// Operator version
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "chop-version")]
    pub chop_version: Option<String>,
    /// Clusters count
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clusters: Option<i64>,
    /// Endpoint
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoint: Option<String>,
    /// All endpoints
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub endpoints: Option<Vec<String>>,
    /// Last error
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    /// Errors
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<String>>,
    /// Pods FQDNs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fqdns: Option<Vec<String>>,
    /// Generation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generation: Option<i64>,
    /// Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub hosts: Option<i64>,
    /// Added Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsAdded")]
    pub hosts_added: Option<i64>,
    /// Completed Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsCompleted")]
    pub hosts_completed: Option<i64>,
    /// About to delete Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsDelete")]
    pub hosts_delete: Option<i64>,
    /// Deleted Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsDeleted")]
    pub hosts_deleted: Option<i64>,
    /// Unchanged Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsUnchanged")]
    pub hosts_unchanged: Option<i64>,
    /// Updated Hosts count
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsUpdated")]
    pub hosts_updated: Option<i64>,
    /// List of hosts with replica caught up
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsWithReplicaCaughtUp")]
    pub hosts_with_replica_caught_up: Option<Vec<String>>,
    /// List of hosts with tables created by the operator
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostsWithTablesCreated")]
    pub hosts_with_tables_created: Option<Vec<String>>,
    /// Normalized resource requested
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub normalized: Option<BTreeMap<String, serde_json::Value>>,
    /// Normalized resource completed
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "normalizedCompleted")]
    pub normalized_completed: Option<BTreeMap<String, serde_json::Value>>,
    /// Pod IPs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pod-ips")]
    pub pod_ips: Option<Vec<String>>,
    /// Pods
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pods: Option<Vec<String>>,
    /// Replicas count
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i64>,
    /// Shards count
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shards: Option<i64>,
    /// Status
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// Current task id
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskID")]
    pub task_id: Option<String>,
    /// Completed task ids
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskIDsCompleted")]
    pub task_i_ds_completed: Option<Vec<String>>,
    /// Started task ids
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "taskIDsStarted")]
    pub task_i_ds_started: Option<Vec<String>>,
    /// List of templates used to build this CHI
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usedTemplates")]
    pub used_templates: Option<Vec<BTreeMap<String, serde_json::Value>>>,
}

